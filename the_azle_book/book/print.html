<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Azle Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Azle Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-azle-book-release-candidate"><a class="header" href="#the-azle-book-release-candidate">The Azle Book (Release Candidate)</a></h1>
<div style="display: flex; justify-content: center">
    <img src="logo.svg" alt="The Azle Logo" height="250px" />
</div>
<p>Welcome to The Azle Book! This is a guide for building secure decentralized/replicated servers in TypeScript or JavaScript on <a href="https://internetcomputer.org" target="_blank">ICP</a>. The current replication factor is <a href="https://dashboard.internetcomputer.org/subnets">13-40 times</a>.</p>
<p>Please remember that Azle stable mode is continuously subjected to <a href="https://github.com/demergent-labs/azle/actions">intense scrutiny and testing</a>, however it does not yet have multiple independent security reviews/audits.</p>
<p>The Azle Book is subject to the following license and Azle's <a href="https://github.com/demergent-labs/azle/blob/main/LICENSE_EXTENSION.md">License Extension</a>:</p>
<pre><code>MIT License

Copyright (c) 2025 AZLE token holders (nlhft-2iaaa-aaaae-qaaua-cai)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-rpc-or-http-server"><a class="header" href="#candid-rpc-or-http-server">Candid RPC or HTTP Server</a></h1>
<p>Azle applications (<a href="https://internetcomputer.org/docs/current/concepts/canisters-code">canisters</a>) can be developed using two main methodologies: <a href="./candid_rpc.html">Candid RPC</a> and <a href="./http_server.html">HTTP Server</a>.</p>
<p>Candid RPC embraces ICP's <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/candid/">Candid language</a>, exposing canister methods directly to Candid-speaking clients, and using Candid for serialization and deserialization purposes.</p>
<p>HTTP Server embraces traditional web server techniques, allowing you to write HTTP servers using popular libraries such as <a href="https://expressjs.com/">Express</a>, and using <a href="https://www.json.org/json-en.html">JSON</a> for simple serialization and deserialization purposes.</p>
<p>Candid RPC is heading towards 1.0 and production-readiness in 2025.</p>
<p>HTTP Server will remain experimental for an unknown length of time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-rpc"><a class="header" href="#candid-rpc">Candid RPC</a></h1>
<p>This section documents the Candid RPC methodology for developing Azle applications. This methodology embraces ICP's Candid language, exposing canister methods directly to Candid-speaking clients, and using Candid for serialization and deserialization purposes.</p>
<p>Candid RPC is heading towards 1.0 and production-readiness in 2025.</p>
<h2 id="quick-navigation"><a class="header" href="#quick-navigation">Quick Navigation</a></h2>
<ul>
<li><a href="./candid_rpc/get_started.html">Get Started</a> - Installation and deployment guide</li>
<li><a href="./candid_rpc/examples.html">Examples</a> - Working examples and best practices</li>
<li><a href="./candid_rpc/canister_class.html">Canister Class</a> - How to structure your canister</li>
<li><a href="./candid_rpc/dfinity_candid_idl.html">@dfinity/candid IDL</a> - Type definitions and serialization</li>
<li><a href="./candid_rpc/decorators.html">Decorators</a> - Method decorators for canister entry points</li>
<li><a href="./candid_rpc/ic_api.html">IC API</a> - Internet Computer platform APIs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-started"><a class="header" href="#get-started">Get Started</a></h1>
<p>Azle helps you to build secure decentralized/replicated servers in TypeScript or JavaScript on <a href="https://internetcomputer.org/">ICP</a>. The current replication factor is <a href="https://dashboard.internetcomputer.org/subnets">13-40 times</a>.</p>
<p>Please remember that Azle stable mode is continuously subjected to <a href="https://github.com/demergent-labs/azle/actions">intense scrutiny and testing</a>, however it does not yet have multiple independent security reviews/audits.</p>
<p>Azle runs in stable mode by default.</p>
<p>This mode is intended for production use after Azle's 1.0 release. Its focus is on API and runtime stability, security, performance, TypeScript and JavaScript language support, the ICP APIs, and Candid remote procedure calls (RPC). There is minimal support for the Node.js standard library, npm ecosystem, and HTTP server functionality.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<blockquote>
<p>Windows is only supported through a Linux virtual environment of some kind, such as <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a></p>
</blockquote>
<p>You will need <a href="candid_rpc/get_started.html#nodejs-22">Node.js 22</a> and <a href="candid_rpc/get_started.html#dfx">dfx</a> to develop ICP applications with Azle:</p>
<h3 id="nodejs-22"><a class="header" href="#nodejs-22">Node.js 22</a></h3>
<p>It's recommended to use nvm to install Node.js 22:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>Restart your terminal and then run:</p>
<pre><code class="language-bash">nvm install 22
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">node --version
</code></pre>
<h3 id="dfx"><a class="header" href="#dfx">dfx</a></h3>
<p>Install the dfx command line tools for managing ICP applications:</p>
<pre><code class="language-bash">DFX_VERSION=0.24.3 sh -ci "$(curl -fsSL https://internetcomputer.org/install.sh)"
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">dfx --version
</code></pre>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>To create and deploy a simple sample application called <code>hello_world</code>:</p>
<pre><code class="language-bash"># create a new default project called hello_world
npx azle new hello_world
cd hello_world
</code></pre>
<pre><code class="language-bash"># install all npm dependencies including azle
npm install
</code></pre>
<pre><code class="language-bash"># start up a local ICP replica
dfx start --clean
</code></pre>
<p>In a separate terminal in the <code>hello_world</code> directory:</p>
<pre><code class="language-bash"># deploy your canister
dfx deploy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Some of the best documentation for creating Candid RPC canisters is currently in <a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc">the examples directory</a>.</p>
<h2 id="basic-hello-world"><a class="header" href="#basic-hello-world">Basic Hello World</a></h2>
<pre><code class="language-typescript">import { IDL, query } from 'azle';

export default class {
    @query([], IDL.Text)
    hello(): string {
        return 'Hello World!';
    }
}
</code></pre>
<h2 id="counter-with-state"><a class="header" href="#counter-with-state">Counter with State</a></h2>
<pre><code class="language-typescript">import { IDL, query, update } from 'azle';

export default class {
    counter: number = 0;

    @query([], IDL.Nat)
    get(): number {
        return this.counter;
    }

    @update([], IDL.Nat)
    increment(): number {
        this.counter += 1;
        return this.counter;
    }

    @update([IDL.Nat], IDL.Nat)
    set(value: number): number {
        this.counter = value;
        return this.counter;
    }
}
</code></pre>
<h2 id="user-management"><a class="header" href="#user-management">User Management</a></h2>
<pre><code class="language-typescript">import { IDL, Principal, query, update, msgCaller } from 'azle';

type User = {
    id: Principal;
    name: string;
    age: number;
};

const UserRecord = IDL.Record({
    id: IDL.Principal,
    name: IDL.Text,
    age: IDL.Nat8
});

export default class {
    users: Map&lt;string, User&gt; = new Map();

    @update([IDL.Text, IDL.Nat8], UserRecord)
    createUser(name: string, age: number): User {
        const caller = msgCaller();
        const user: User = {
            id: caller,
            name,
            age
        };

        this.users.set(caller.toText(), user);
        return user;
    }

    @query([], IDL.Vec(UserRecord))
    getUsers(): User[] {
        return Array.from(this.users.values());
    }

    @query([IDL.Principal], IDL.Opt(UserRecord))
    getUser(id: Principal): [User] | [] {
        const user = this.users.get(id.toText());
        return user ? [user] : [];
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-class"><a class="header" href="#canister-class">Canister Class</a></h1>
<p>Your canister's functionality must be encapsulated in a class exported using the default export:</p>
<pre><code class="language-typescript">import { IDL, query } from 'azle';

export default class {
    @query([], IDL.Text)
    hello(): string {
        return 'world!';
    }
}
</code></pre>
<h2 id="required-structure"><a class="header" href="#required-structure">Required Structure</a></h2>
<ul>
<li>Must use <code>export default class</code></li>
<li>Methods must use decorators to be exposed</li>
<li>TypeScript types are optional but recommended</li>
</ul>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<p>Class properties become canister state:</p>
<pre><code class="language-typescript">import { IDL, query, update } from 'azle';

export default class {
    // This becomes persistent canister state
    counter: number = 0;
    users: Map&lt;string, string&gt; = new Map();

    @query([], IDL.Nat)
    getCounter(): number {
        return this.counter;
    }

    @update([], IDL.Nat)
    increment(): number {
        this.counter += 1;
        return this.counter;
    }
}
</code></pre>
<h2 id="available-decorators"><a class="header" href="#available-decorators">Available Decorators</a></h2>
<p>You must use these decorators to expose your canister's methods:</p>
<ul>
<li><code>@query</code> - Read-only methods</li>
<li><code>@update</code> - Read-write methods</li>
<li><code>@init</code> - Initialization method</li>
<li><code>@postUpgrade</code> - Post-upgrade method</li>
<li><code>@preUpgrade</code> - Pre-upgrade method</li>
<li><code>@inspectMessage</code> - Message inspection method</li>
<li><code>@heartbeat</code> - Periodic execution method</li>
</ul>
<h2 id="method-visibility"><a class="header" href="#method-visibility">Method Visibility</a></h2>
<p>Only decorated methods are exposed in the canister's Candid interface:</p>
<pre><code class="language-typescript">import { IDL, query } from 'azle';

export default class {
    // This method is exposed
    @query([], IDL.Text)
    publicMethod(): string {
        return this.privateHelper();
    }

    // This method is private (not exposed)
    privateHelper(): string {
        return 'Hello from private method';
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dfinitycandid-idl"><a class="header" href="#dfinitycandid-idl">@dfinity/candid IDL</a></h1>
<p>For each of your canister's methods, deserialization of incoming arguments and serialization of return values is handled with a combination of decorators and the <a href="https://agent-js.icp.xyz/candid/modules/IDL.html">IDL</a> object from the <a href="https://agent-js.icp.xyz/candid/index.html">@dfinity/candid</a> library.</p>
<p><code>IDL</code> is re-exported by Azle, and has properties that correspond to <a href="https://internetcomputer.org/docs/current/references/candid-ref">Candid's supported types</a>.</p>
<h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<pre><code class="language-typescript">import { IDL } from 'azle';

// Text
IDL.Text;

// Numbers
IDL.Nat; // Unlimited precision unsigned integer
IDL.Nat64; // 64-bit unsigned integer
IDL.Nat32; // 32-bit unsigned integer
IDL.Nat16; // 16-bit unsigned integer
IDL.Nat8; // 8-bit unsigned integer

IDL.Int; // Unlimited precision signed integer
IDL.Int64; // 64-bit signed integer
IDL.Int32; // 32-bit signed integer
IDL.Int16; // 16-bit signed integer
IDL.Int8; // 8-bit signed integer

// Floating point
IDL.Float64; // 64-bit floating point
IDL.Float32; // 32-bit floating point

// Boolean and null
IDL.Bool;
IDL.Null;
</code></pre>
<h2 id="complex-types"><a class="header" href="#complex-types">Complex Types</a></h2>
<pre><code class="language-typescript">import { IDL } from 'azle';

// Vector (array)
IDL.Vec(IDL.Text); // Array of text
IDL.Vec(IDL.Nat8); // Blob (array of bytes)

// Optional
IDL.Opt(IDL.Text); // Optional text

// Record (object)
IDL.Record({
    name: IDL.Text,
    age: IDL.Nat8,
    active: IDL.Bool
});

// Variant (union type)
IDL.Variant({
    Success: IDL.Text,
    Error: IDL.Text,
    Loading: IDL.Null
});
</code></pre>
<h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h2>
<pre><code class="language-typescript">import { IDL } from 'azle';

// Function reference
IDL.Func([IDL.Text], [IDL.Bool], ['query']);

// Service reference
IDL.Service({
    getName: IDL.Func([], [IDL.Text], ['query']),
    setName: IDL.Func([IDL.Text], [], ['update'])
});

// Principal
IDL.Principal;

// Reserved and Empty
IDL.Reserved;
IDL.Empty;
</code></pre>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<pre><code class="language-typescript">import { IDL, query, update } from 'azle';

type User = {
    name: string;
    email: string;
    age: number;
};

const UserRecord = IDL.Record({
    name: IDL.Text,
    email: IDL.Text,
    age: IDL.Nat8
});

export default class {
    @query([IDL.Text], IDL.Opt(UserRecord))
    getUser(id: string): [User] | [] {
        // Implementation here
        return [];
    }

    @update([UserRecord], IDL.Bool)
    createUser(user: User): boolean {
        // Implementation here
        return true;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorators"><a class="header" href="#decorators">Decorators</a></h1>
<p>Decorators expose your class methods as canister entry points. Each decorator specifies how the method should be called and what permissions it has.</p>
<h2 id="available-decorators-1"><a class="header" href="#available-decorators-1">Available Decorators</a></h2>
<h3 id="query"><a class="header" href="#query"><a href="candid_rpc/./decorators/query.html">@query</a></a></h3>
<p>Read-only methods that cannot modify state. Fast execution with optional cross-canister calls.</p>
<h3 id="update"><a class="header" href="#update"><a href="candid_rpc/./decorators/update.html">@update</a></a></h3>
<p>Read-write methods that can modify canister state. Full async support with cross-canister calls.</p>
<h3 id="init"><a class="header" href="#init"><a href="candid_rpc/./decorators/init.html">@init</a></a></h3>
<p>Initialization method called once during canister deployment. Sets up initial state.</p>
<h3 id="postupgrade"><a class="header" href="#postupgrade"><a href="candid_rpc/./decorators/post_upgrade.html">@postUpgrade</a></a></h3>
<p>Called after canister upgrade. Used for state migration and restoration.</p>
<h3 id="preupgrade"><a class="header" href="#preupgrade"><a href="candid_rpc/./decorators/pre_upgrade.html">@preUpgrade</a></a></h3>
<p>Called before canister upgrade. Used for cleanup and state validation.</p>
<h3 id="inspectmessage"><a class="header" href="#inspectmessage"><a href="candid_rpc/./decorators/inspect_message.html">@inspectMessage</a></a></h3>
<p>Called before every <code>@update</code> method. Provides access control and validation.</p>
<h3 id="heartbeat"><a class="header" href="#heartbeat"><a href="candid_rpc/./decorators/heartbeat.html">@heartbeat</a></a></h3>
<p>Called periodically (~every second). Not recommended - use timers instead.</p>
<h2 id="quick-comparison"><a class="header" href="#quick-comparison">Quick Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Decorator</th><th>State Access</th><th>Async</th><th>Replication</th><th>Instruction Limit</th></tr></thead><tbody>
<tr><td><code>@query</code></td><td>read-only</td><td>yes*</td><td>possible</td><td>5B</td></tr>
<tr><td><code>@update</code></td><td>read-write</td><td>yes</td><td>yes</td><td>40B</td></tr>
<tr><td><code>@init</code></td><td>read-write</td><td>no</td><td>yes</td><td>300B</td></tr>
<tr><td><code>@postUpgrade</code></td><td>read-write</td><td>no</td><td>yes</td><td>300B</td></tr>
<tr><td><code>@preUpgrade</code></td><td>read-only</td><td>no</td><td>yes</td><td>300B</td></tr>
<tr><td><code>@inspectMessage</code></td><td>read-only</td><td>no</td><td>none</td><td>200M</td></tr>
<tr><td><code>@heartbeat</code></td><td>read-write</td><td>yes</td><td>yes</td><td>40B</td></tr>
</tbody></table>
</div>
<p>*Only with <code>composite: true</code> option</p>
<h2 id="common-options"><a class="header" href="#common-options">Common Options</a></h2>
<p>All decorators support these common options:</p>
<ul>
<li><code>manual</code>: Manual argument/return handling</li>
<li><code>hidden</code>: Hide from Candid interface (except <code>@preUpgrade</code>, <code>@inspectMessage</code>, <code>@heartbeat</code>)</li>
</ul>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h2>
<pre><code class="language-typescript">import { IDL, query, update, init } from 'azle';

export default class {
    counter: number = 0;
    owner: string = '';

    @init([IDL.Text])
    initialize(ownerName: string): void {
        this.owner = ownerName;
    }

    @query([], IDL.Nat)
    getCounter(): number {
        return this.counter;
    }

    @update([], IDL.Nat)
    increment(): number {
        this.counter += 1;
        return this.counter;
    }
}
</code></pre>
<h2 id="query-1"><a class="header" href="#query-1">@query</a></h2>
<p>Read-only canister method. Cannot modify state.</p>
<ul>
<li><strong>State</strong>: read-only</li>
<li><strong>Replication</strong>: possible</li>
<li><strong>Async</strong>: yes with <code>composite</code> set to true</li>
<li><strong>Instruction limit</strong>: 5_000_000_000</li>
</ul>
<pre><code class="language-typescript">import { IDL, query } from 'azle';

export default class {
    counter: number = 0;

    @query([], IDL.Nat)
    getCounter(): number {
        return this.counter;
    }

    @query([IDL.Text], IDL.Text)
    echo(message: string): string {
        return `Echo: ${message}`;
    }
}
</code></pre>
<h3 id="composite-queries"><a class="header" href="#composite-queries">Composite Queries</a></h3>
<pre><code class="language-typescript">import { IDL, query, call } from 'azle';

export default class {
    @query([], IDL.Text, { composite: true })
    async crossCanisterQuery(): Promise&lt;string&gt; {
        const result = await call('canister-id', 'method_name', {
            returnIdlType: IDL.Text
        });
        return result;
    }
}
</code></pre>
<h2 id="update-1"><a class="header" href="#update-1">@update</a></h2>
<p>Read-write canister method. Can modify state.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: yes</li>
<li><strong>Instruction limit</strong>: 40_000_000_000</li>
</ul>
<pre><code class="language-typescript">import { IDL, update } from 'azle';

export default class {
    counter: number = 0;

    @update([], IDL.Nat)
    increment(): number {
        this.counter += 1;
        return this.counter;
    }

    @update([IDL.Nat], IDL.Nat)
    setCounter(value: number): number {
        this.counter = value;
        return this.counter;
    }
}
</code></pre>
<h2 id="init-1"><a class="header" href="#init-1">@init</a></h2>
<p>Canister initialization method. Called once during deployment.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 300_000_000_000</li>
</ul>
<pre><code class="language-typescript">import { IDL, init } from 'azle';

export default class {
    owner: string = '';
    initialized: boolean = false;

    @init([IDL.Text])
    initialize(ownerName: string): void {
        this.owner = ownerName;
        this.initialized = true;
    }
}
</code></pre>
<h2 id="postupgrade-1"><a class="header" href="#postupgrade-1">@postUpgrade</a></h2>
<p>Called after canister upgrade. Used to restore state.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 300_000_000_000 (shared with preUpgrade)</li>
</ul>
<pre><code class="language-typescript">import { IDL, postUpgrade } from 'azle';

export default class {
    version: string = '1.0.0';

    @postUpgrade([IDL.Text])
    upgrade(newVersion: string): void {
        this.version = newVersion;
        console.log(`Upgraded to version ${newVersion}`);
    }
}
</code></pre>
<h2 id="preupgrade-1"><a class="header" href="#preupgrade-1">@preUpgrade</a></h2>
<p>Called before canister upgrade. Used to save state.</p>
<ul>
<li><strong>State</strong>: read-only</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 300_000_000_000 (shared with postUpgrade)</li>
</ul>
<pre><code class="language-typescript">import { IDL, preUpgrade } from 'azle';

export default class {
    counter: number = 0;

    @preUpgrade()
    saveState(): void {
        // Save critical state before upgrade
        console.log(`Current counter: ${this.counter}`);
    }
}
</code></pre>
<h2 id="inspectmessage-1"><a class="header" href="#inspectmessage-1">@inspectMessage</a></h2>
<p>Called before every <code>@update</code> method. Can reject calls.</p>
<ul>
<li><strong>State</strong>: read-only</li>
<li><strong>Replication</strong>: none</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 200_000_000</li>
</ul>
<pre><code class="language-typescript">import { IDL, inspectMessage, msgCaller } from 'azle';

export default class {
    owner: string = 'owner-principal-id';

    @inspectMessage()
    inspect(methodName: string): boolean {
        const caller = msgCaller();

        // Only allow owner to call sensitive methods
        if (methodName === 'sensitiveMethod') {
            return caller.toText() === this.owner;
        }

        return true; // Allow all other methods
    }

    @update([], IDL.Text)
    sensitiveMethod(): string {
        return 'Secret data';
    }
}
</code></pre>
<h2 id="heartbeat-1"><a class="header" href="#heartbeat-1">@heartbeat</a></h2>
<p>Called periodically (~every second). Not recommended for most use cases.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: yes</li>
<li><strong>Instruction limit</strong>: 40_000_000_000</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Use <code>setTimer</code> and <code>setTimerInterval</code> instead of <code>@heartbeat</code> for most periodic tasks.</p>
</blockquote>
<pre><code class="language-typescript">import { IDL, heartbeat } from 'azle';

export default class {
    heartbeatCount: number = 0;

    @heartbeat()
    periodicTask(): void {
        this.heartbeatCount += 1;
        console.log(`Heartbeat ${this.heartbeatCount}`);
    }
}
</code></pre>
<h2 id="manual-mode"><a class="header" href="#manual-mode">Manual Mode</a></h2>
<p>All decorators support manual mode for advanced use cases:</p>
<pre><code class="language-typescript">import { IDL, query, msgArgData, msgReply, IDL as CandidIDL } from 'azle';

export default class {
    @query([], IDL.Text, { manual: true })
    manualQuery(): void {
        const args = msgArgData();
        const decodedArgs = CandidIDL.decode([IDL.Text], args);

        const result = `Processed: ${decodedArgs[0]}`;
        const encodedResult = CandidIDL.encode([IDL.Text], [result]);

        msgReply(encodedResult);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-2"><a class="header" href="#query-2">@query</a></h1>
<p>Read-only canister method. Cannot modify state.</p>
<ul>
<li><strong>State</strong>: read-only</li>
<li><strong>Replication</strong>: possible</li>
<li><strong>Async</strong>: yes with <code>composite</code> set to true</li>
<li><strong>Instruction limit</strong>: 5_000_000_000</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, query } from 'azle';

export default class {
    counter: number = 0;

    @query([], IDL.Nat)
    getCounter(): number {
        return this.counter;
    }

    @query([IDL.Text], IDL.Text)
    echo(message: string): string {
        return `Echo: ${message}`;
    }
}
</code></pre>
<h2 id="composite-queries-1"><a class="header" href="#composite-queries-1">Composite Queries</a></h2>
<p>Enable cross-canister calls within query methods:</p>
<pre><code class="language-typescript">import { IDL, query, call } from 'azle';

export default class {
    @query([], IDL.Text, { composite: true })
    async crossCanisterQuery(): Promise&lt;string&gt; {
        const result = await call('canister-id', 'method_name', {
            returnIdlType: IDL.Text
        });
        return result;
    }
}
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<ul>
<li><code>composite</code>: Enable async cross-canister calls</li>
<li><code>manual</code>: Manual argument/return handling</li>
<li><code>hidden</code>: Hide from Candid interface</li>
</ul>
<pre><code class="language-typescript">import { IDL, query, msgArgData, msgReply } from 'azle';

export default class {
    @query([], IDL.Text, { manual: true })
    manualQuery(): void {
        const args = msgArgData();
        // Process manually
        msgReply(new Uint8Array([1, 2, 3]));
    }

    @query([], IDL.Text, { hidden: true })
    hiddenQuery(): string {
        return 'This method is hidden from Candid interface';
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-2"><a class="header" href="#update-2">@update</a></h1>
<p>Read-write canister method. Can modify state.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: yes</li>
<li><strong>Instruction limit</strong>: 40_000_000_000</li>
</ul>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, update } from 'azle';

export default class {
    counter: number = 0;

    @update([], IDL.Nat)
    increment(): number {
        this.counter += 1;
        return this.counter;
    }

    @update([IDL.Nat], IDL.Nat)
    setCounter(value: number): number {
        this.counter = value;
        return this.counter;
    }
}
</code></pre>
<h2 id="async-operations"><a class="header" href="#async-operations">Async Operations</a></h2>
<pre><code class="language-typescript">import { IDL, update, call } from 'azle';

export default class {
    @update([IDL.Text], IDL.Text)
    async processData(data: string): Promise&lt;string&gt; {
        // Async processing
        await new Promise((resolve) =&gt; setTimeout(resolve, 1000));

        return `Processed: ${data}`;
    }

    @update([IDL.Principal, IDL.Text], IDL.Text)
    async callOtherCanister(
        canisterId: Principal,
        message: string
    ): Promise&lt;string&gt; {
        const result = await call(canisterId, 'process', {
            args: [message],
            paramIdlTypes: [IDL.Text],
            returnIdlType: IDL.Text
        });
        return result;
    }
}
</code></pre>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<ul>
<li><code>manual</code>: Manual argument/return handling</li>
<li><code>hidden</code>: Hide from Candid interface</li>
</ul>
<pre><code class="language-typescript">import { IDL, update, msgArgData, msgReply, msgReject } from 'azle';

export default class {
    @update([], IDL.Text, { manual: true })
    manualUpdate(): void {
        try {
            const args = msgArgData();
            // Process manually
            const result = 'Success!';
            msgReply(new TextEncoder().encode(result));
        } catch (error) {
            msgReject(`Error: ${error}`);
        }
    }

    @update([IDL.Text], IDL.Text, { hidden: true })
    hiddenUpdate(secret: string): string {
        return `Hidden processing of: ${secret}`;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init-2"><a class="header" href="#init-2">@init</a></h1>
<p>Canister initialization method. Called once during deployment.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 300_000_000_000</li>
</ul>
<p>Only one <code>@init</code> method is allowed per canister.</p>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, init } from 'azle';

export default class {
    owner: string = '';
    initialized: boolean = false;

    @init([IDL.Text])
    initialize(ownerName: string): void {
        this.owner = ownerName;
        this.initialized = true;
        console.log(`Canister initialized with owner: ${ownerName}`);
    }
}
</code></pre>
<h2 id="complex-initialization"><a class="header" href="#complex-initialization">Complex Initialization</a></h2>
<pre><code class="language-typescript">import { IDL, init, msgCaller } from 'azle';

type Config = {
    name: string;
    maxUsers: number;
    features: string[];
};

const ConfigRecord = IDL.Record({
    name: IDL.Text,
    maxUsers: IDL.Nat32,
    features: IDL.Vec(IDL.Text)
});

export default class {
    config: Config = { name: '', maxUsers: 0, features: [] };
    owner: Principal | null = null;
    users: Map&lt;string, string&gt; = new Map();

    @init([ConfigRecord])
    initialize(config: Config): void {
        this.config = config;
        this.owner = msgCaller();

        console.log(`Initialized canister "${config.name}"`);
        console.log(`Max users: ${config.maxUsers}`);
        console.log(`Features: ${config.features.join(', ')}`);
    }
}
</code></pre>
<h2 id="no-arguments"><a class="header" href="#no-arguments">No Arguments</a></h2>
<pre><code class="language-typescript">import { IDL, init } from 'azle';

export default class {
    startTime: bigint = 0n;

    @init()
    initialize(): void {
        this.startTime = time();
        console.log('Canister initialized at:', this.startTime);
    }
}
</code></pre>
<h2 id="options-2"><a class="header" href="#options-2">Options</a></h2>
<ul>
<li><code>manual</code>: Manual argument handling</li>
</ul>
<pre><code class="language-typescript">import { IDL, init, msgArgData, candidDecode } from 'azle';

export default class {
    @init([], { manual: true })
    initialize(): void {
        const args = msgArgData();
        const decodedArgs = candidDecode([IDL.Text], args);

        console.log('Manual init with args:', decodedArgs);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postupgrade-2"><a class="header" href="#postupgrade-2">@postUpgrade</a></h1>
<p>Called after canister upgrade. Used to restore state.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 300_000_000_000 (shared with preUpgrade)</li>
</ul>
<p>Only one <code>@postUpgrade</code> method is allowed per canister.</p>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, postUpgrade } from 'azle';

export default class {
    version: string = '1.0.0';

    @postUpgrade([IDL.Text])
    upgrade(newVersion: string): void {
        this.version = newVersion;
        console.log(`Upgraded to version ${newVersion}`);
    }
}
</code></pre>
<h2 id="state-migration"><a class="header" href="#state-migration">State Migration</a></h2>
<pre><code class="language-typescript">import { IDL, postUpgrade } from 'azle';

type UserV1 = {
    name: string;
    age: number;
};

type UserV2 = {
    name: string;
    age: number;
    email: string; // New field
    active: boolean; // New field
};

export default class {
    users: Map&lt;string, UserV2&gt; = new Map();
    version: string = '2.0.0';

    @postUpgrade([IDL.Text])
    migrateToV2(previousVersion: string): void {
        console.log(`Migrating from ${previousVersion} to ${this.version}`);

        // Migrate existing users to new format
        for (const [id, user] of this.users.entries()) {
            const userV1 = user as any;
            if (!userV1.email) {
                const migratedUser: UserV2 = {
                    ...userV1,
                    email: `${userV1.name.toLowerCase()}@example.com`,
                    active: true
                };
                this.users.set(id, migratedUser);
            }
        }

        console.log(`Migration complete. ${this.users.size} users migrated.`);
    }
}
</code></pre>
<h2 id="no-arguments-1"><a class="header" href="#no-arguments-1">No Arguments</a></h2>
<pre><code class="language-typescript">import { IDL, postUpgrade, time } from 'azle';

export default class {
    lastUpgrade: bigint = 0n;
    upgradeCount: number = 0;

    @postUpgrade()
    handleUpgrade(): void {
        this.lastUpgrade = time();
        this.upgradeCount += 1;

        console.log(
            `Upgrade #${this.upgradeCount} completed at ${this.lastUpgrade}`
        );
    }
}
</code></pre>
<h2 id="options-3"><a class="header" href="#options-3">Options</a></h2>
<ul>
<li><code>manual</code>: Manual argument handling</li>
</ul>
<pre><code class="language-typescript">import { IDL, postUpgrade, msgArgData, candidDecode } from 'azle';

export default class {
    @postUpgrade([], { manual: true })
    manualUpgrade(): void {
        const args = msgArgData();
        const decodedArgs = candidDecode([IDL.Text, IDL.Nat], args);

        console.log('Manual upgrade with args:', decodedArgs);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preupgrade-2"><a class="header" href="#preupgrade-2">@preUpgrade</a></h1>
<p>Called before canister upgrade. Used to save state.</p>
<ul>
<li><strong>State</strong>: read-only</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 300_000_000_000 (shared with postUpgrade)</li>
</ul>
<p>Only one <code>@preUpgrade</code> method is allowed per canister.</p>
<h2 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, preUpgrade } from 'azle';

export default class {
    counter: number = 0;

    @preUpgrade()
    saveState(): void {
        // Save critical state before upgrade
        console.log(`Current counter: ${this.counter}`);

        // State is automatically preserved
        // This is mainly for logging/cleanup
    }
}
</code></pre>
<h2 id="state-validation"><a class="header" href="#state-validation">State Validation</a></h2>
<pre><code class="language-typescript">import { IDL, preUpgrade } from 'azle';

export default class {
    users: Map&lt;string, any&gt; = new Map();
    orders: Map&lt;string, any&gt; = new Map();

    @preUpgrade()
    validateState(): void {
        console.log(`Pre-upgrade validation:`);
        console.log(`- Users: ${this.users.size}`);
        console.log(`- Orders: ${this.orders.size}`);

        // Validate critical state
        if (this.users.size === 0) {
            console.warn('Warning: No users in system');
        }

        // Log important metrics
        const activeUsers = Array.from(this.users.values()).filter(
            (user) =&gt; user.active
        ).length;
        console.log(`- Active users: ${activeUsers}`);
    }
}
</code></pre>
<h2 id="cleanup-operations"><a class="header" href="#cleanup-operations">Cleanup Operations</a></h2>
<pre><code class="language-typescript">import { IDL, preUpgrade, clearTimer } from 'azle';

export default class {
    activeTimers: Set&lt;bigint&gt; = new Set();

    @preUpgrade()
    cleanup(): void {
        console.log('Cleaning up before upgrade...');

        // Cancel all active timers
        for (const timerId of this.activeTimers) {
            clearTimer(timerId);
        }

        console.log(`Cleared ${this.activeTimers.size} timers`);

        // Other cleanup operations
        console.log('Cleanup complete');
    }
}
</code></pre>
<h2 id="backup-state"><a class="header" href="#backup-state">Backup State</a></h2>
<pre><code class="language-typescript">import { IDL, preUpgrade } from 'azle';

export default class {
    criticalData: Map&lt;string, string&gt; = new Map();

    @preUpgrade()
    backupCriticalData(): void {
        const backup = {
            timestamp: Date.now(),
            dataCount: this.criticalData.size,
            keys: Array.from(this.criticalData.keys())
        };

        console.log('Backup info:', JSON.stringify(backup));

        // In a real scenario, you might want to store
        // backup data in stable storage
    }
}
</code></pre>
<h2 id="no-manual-mode"><a class="header" href="#no-manual-mode">No Manual Mode</a></h2>
<blockquote>
<p><strong>Note</strong>: <code>@preUpgrade</code> does not support manual mode as it takes no arguments.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspectmessage-2"><a class="header" href="#inspectmessage-2">@inspectMessage</a></h1>
<p>Called before every <code>@update</code> method. Can reject calls.</p>
<ul>
<li><strong>State</strong>: read-only</li>
<li><strong>Replication</strong>: none</li>
<li><strong>Async</strong>: no</li>
<li><strong>Instruction limit</strong>: 200_000_000</li>
</ul>
<p>Only one <code>@inspectMessage</code> method is allowed per canister.</p>
<h2 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, inspectMessage, msgCaller, update } from 'azle';

export default class {
    owner: string = 'owner-principal-id';

    @inspectMessage()
    inspect(methodName: string): boolean {
        const caller = msgCaller();

        // Only allow owner to call sensitive methods
        if (methodName === 'sensitiveMethod') {
            return caller.toText() === this.owner;
        }

        return true; // Allow all other methods
    }

    @update([], IDL.Text)
    sensitiveMethod(): string {
        return 'Secret data';
    }

    @update([IDL.Text], IDL.Text)
    publicMethod(message: string): string {
        return `Public: ${message}`;
    }
}
</code></pre>
<h2 id="role-based-access-control"><a class="header" href="#role-based-access-control">Role-Based Access Control</a></h2>
<pre><code class="language-typescript">import { IDL, inspectMessage, msgCaller, update } from 'azle';

export default class {
    admins: Set&lt;string&gt; = new Set(['admin-principal-1', 'admin-principal-2']);
    moderators: Set&lt;string&gt; = new Set(['mod-principal-1']);

    @inspectMessage()
    checkPermissions(methodName: string): boolean {
        const caller = msgCaller().toText();

        // Admin-only methods
        if (['deleteUser', 'systemReset'].includes(methodName)) {
            return this.admins.has(caller);
        }

        // Moderator or admin methods
        if (['banUser', 'deletePost'].includes(methodName)) {
            return this.admins.has(caller) || this.moderators.has(caller);
        }

        // Public methods - all users allowed
        return true;
    }

    @update([IDL.Text], IDL.Bool)
    deleteUser(userId: string): boolean {
        // Admin only - checked in inspectMessage
        return true;
    }

    @update([IDL.Text], IDL.Bool)
    banUser(userId: string): boolean {
        // Admin or moderator - checked in inspectMessage
        return true;
    }

    @update([IDL.Text], IDL.Text)
    createPost(content: string): string {
        // Public method - all users allowed
        return `Post created: ${content}`;
    }
}
</code></pre>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<pre><code class="language-typescript">import { IDL, inspectMessage, msgCaller, update, time } from 'azle';

export default class {
    lastCallTime: Map&lt;string, bigint&gt; = new Map();
    rateLimitSeconds: bigint = 60n * 1_000_000_000n; // 60 seconds in nanoseconds

    @inspectMessage()
    rateLimit(methodName: string): boolean {
        const caller = msgCaller().toText();
        const now = time();

        // Only rate limit certain methods
        if (['expensiveOperation', 'sendEmail'].includes(methodName)) {
            const lastCall = this.lastCallTime.get(caller);

            if (lastCall &amp;&amp; now - lastCall &lt; this.rateLimitSeconds) {
                console.log(`Rate limit exceeded for ${caller}`);
                return false; // Reject the call
            }

            this.lastCallTime.set(caller, now);
        }

        return true;
    }

    @update([IDL.Text], IDL.Text)
    expensiveOperation(data: string): string {
        // Rate limited operation
        return `Processed: ${data}`;
    }

    @update([IDL.Text], IDL.Bool)
    sendEmail(recipient: string): boolean {
        // Rate limited operation
        return true;
    }
}
</code></pre>
<h2 id="method-arguments-access"><a class="header" href="#method-arguments-access">Method Arguments Access</a></h2>
<pre><code class="language-typescript">import { IDL, inspectMessage, update } from 'azle';

export default class {
    @inspectMessage()
    validateArguments(methodName: string, ...args: unknown[]): boolean {
        console.log(`Method: ${methodName}, Args:`, args);

        // Validate specific method arguments
        if (methodName === 'transfer') {
            const [amount] = args as [number];
            if (amount &lt;= 0 || amount &gt; 1000000) {
                console.log('Invalid transfer amount');
                return false;
            }
        }

        if (methodName === 'setUsername') {
            const [username] = args as [string];
            if (username.length &lt; 3 || username.length &gt; 20) {
                console.log('Invalid username length');
                return false;
            }
        }

        return true;
    }

    @update([IDL.Nat], IDL.Bool)
    transfer(amount: number): boolean {
        return true;
    }

    @update([IDL.Text], IDL.Bool)
    setUsername(username: string): boolean {
        return true;
    }
}
</code></pre>
<h2 id="options-4"><a class="header" href="#options-4">Options</a></h2>
<ul>
<li><code>manual</code>: Manual argument handling</li>
</ul>
<pre><code class="language-typescript">import { IDL, inspectMessage, msgArgData, candidDecode } from 'azle';

export default class {
    @inspectMessage([], { manual: true })
    manualInspect(): boolean {
        const args = msgArgData();
        const decoded = candidDecode([IDL.Text], args);

        console.log('Manual inspect with args:', decoded);
        return true;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heartbeat-2"><a class="header" href="#heartbeat-2">@heartbeat</a></h1>
<p>Called periodically (~every second). Not recommended for most use cases.</p>
<ul>
<li><strong>State</strong>: read-write</li>
<li><strong>Replication</strong>: yes</li>
<li><strong>Async</strong>: yes</li>
<li><strong>Instruction limit</strong>: 40_000_000_000</li>
</ul>
<p>Only one <code>@heartbeat</code> method is allowed per canister.</p>
<blockquote>
<p><strong>Note</strong>: Use <code>setTimer</code> and <code>setTimerInterval</code> instead of <code>@heartbeat</code> for most periodic tasks.</p>
</blockquote>
<h2 id="basic-usage-6"><a class="header" href="#basic-usage-6">Basic Usage</a></h2>
<pre><code class="language-typescript">import { IDL, heartbeat } from 'azle';

export default class {
    heartbeatCount: number = 0;

    @heartbeat()
    periodicTask(): void {
        this.heartbeatCount += 1;
        console.log(`Heartbeat ${this.heartbeatCount}`);
    }
}
</code></pre>
<h2 id="periodic-cleanup"><a class="header" href="#periodic-cleanup">Periodic Cleanup</a></h2>
<pre><code class="language-typescript">import { IDL, heartbeat, time } from 'azle';

export default class {
    sessions: Map&lt;string, { userId: string; lastActive: bigint }&gt; = new Map();
    lastCleanup: bigint = 0n;

    @heartbeat()
    cleanup(): void {
        const now = time();
        const oneHour = 60n * 60n * 1_000_000_000n; // 1 hour in nanoseconds

        // Only run cleanup every hour
        if (now - this.lastCleanup &lt; oneHour) {
            return;
        }

        // Clean up expired sessions
        const expiredSessions: string[] = [];
        for (const [sessionId, session] of this.sessions.entries()) {
            if (now - session.lastActive &gt; oneHour * 24n) {
                // 24 hours
                expiredSessions.push(sessionId);
            }
        }

        for (const sessionId of expiredSessions) {
            this.sessions.delete(sessionId);
        }

        console.log(`Cleaned up ${expiredSessions.length} expired sessions`);
        this.lastCleanup = now;
    }
}
</code></pre>
<h2 id="async-operations-1"><a class="header" href="#async-operations-1">Async Operations</a></h2>
<pre><code class="language-typescript">import { IDL, heartbeat, call } from 'azle';

export default class {
    lastHealthCheck: bigint = 0n;
    isHealthy: boolean = true;

    @heartbeat()
    async healthCheck(): Promise&lt;void&gt; {
        const now = time();
        const fiveMinutes = 5n * 60n * 1_000_000_000n;

        // Only check every 5 minutes
        if (now - this.lastHealthCheck &lt; fiveMinutes) {
            return;
        }

        try {
            // Check external service
            const response = await call('external-service-canister', 'ping', {
                returnIdlType: IDL.Bool
            });

            this.isHealthy = response;
            console.log(`Health check: ${this.isHealthy ? 'OK' : 'FAILED'}`);
        } catch (error) {
            this.isHealthy = false;
            console.log(`Health check failed: ${error}`);
        }

        this.lastCleanup = now;
    }
}
</code></pre>
<h2 id="why-use-timers-instead"><a class="header" href="#why-use-timers-instead">Why Use Timers Instead</a></h2>
<p>Timers are more flexible and efficient:</p>
<pre><code class="language-typescript">import { IDL, init, setTimerInterval, clearTimer } from 'azle';

export default class {
    cleanupTimerId: bigint | null = null;

    @init()
    initialize(): void {
        // Set up periodic cleanup with timer instead of heartbeat
        this.cleanupTimerId = setTimerInterval(3600, () =&gt; {
            // Every hour
            this.performCleanup();
        });
    }

    performCleanup(): void {
        console.log('Performing scheduled cleanup...');
        // Cleanup logic here
    }

    stopCleanup(): void {
        if (this.cleanupTimerId) {
            clearTimer(this.cleanupTimerId);
            this.cleanupTimerId = null;
        }
    }
}
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Cannot guarantee exact timing</li>
<li>Runs on all replicas (waste of resources)</li>
<li>May not execute during high load</li>
<li>Cannot pass arguments</li>
<li>Limited to ~1 second intervals</li>
</ul>
<h2 id="when-to-use-heartbeat"><a class="header" href="#when-to-use-heartbeat">When to Use Heartbeat</a></h2>
<p>Only use <code>@heartbeat</code> when you need:</p>
<ul>
<li>Guaranteed periodic execution across all replicas</li>
<li>System-level maintenance tasks</li>
<li>Monitoring that must run even when canister is idle</li>
</ul>
<p>For most use cases, prefer <code>setTimer</code> and <code>setTimerInterval</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ic-api"><a class="header" href="#ic-api">IC API</a></h1>
<p>The IC API is exposed as functions exported from <code>azle</code>. These functions provide access to Internet Computer platform capabilities.</p>
<h2 id="message-information"><a class="header" href="#message-information">Message Information</a></h2>
<h3 id="msgcaller"><a class="header" href="#msgcaller">msgCaller</a></h3>
<p>Get the principal of the identity that initiated the current call:</p>
<pre><code class="language-typescript">import { msgCaller, IDL, query } from 'azle';

export default class {
    @query([], IDL.Text)
    whoAmI(): string {
        return msgCaller().toText();
    }

    @query([], IDL.Bool)
    isAnonymous(): boolean {
        return msgCaller().toText() === '2vxsx-fae';
    }
}
</code></pre>
<h3 id="msgmethodname"><a class="header" href="#msgmethodname">msgMethodName</a></h3>
<p>Get the name of the currently executing method:</p>
<pre><code class="language-typescript">import { msgMethodName, IDL, update } from 'azle';

export default class {
    @update([], IDL.Text)
    currentMethod(): string {
        return msgMethodName(); // Returns "currentMethod"
    }
}
</code></pre>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<h3 id="time-1"><a class="header" href="#time-1">time</a></h3>
<p>Get the current ICP system time in nanoseconds:</p>
<pre><code class="language-typescript">import { time, IDL, query } from 'azle';

export default class {
    @query([], IDL.Nat64)
    getCurrentTime(): bigint {
        return time();
    }

    @query([], IDL.Text)
    getFormattedTime(): string {
        const nanos = time();
        const date = new Date(Number(nanos / 1_000_000n));
        return date.toISOString();
    }
}
</code></pre>
<h2 id="timers"><a class="header" href="#timers">Timers</a></h2>
<h3 id="settimer"><a class="header" href="#settimer">setTimer</a></h3>
<p>Execute a callback after a delay:</p>
<pre><code class="language-typescript">import { setTimer, IDL, update } from 'azle';

export default class {
    @update([IDL.Nat], IDL.Nat64)
    scheduleTask(delaySeconds: number): bigint {
        const timerId = setTimer(delaySeconds, () =&gt; {
            console.log('Timer executed!');
        });

        return timerId;
    }
}
</code></pre>
<h3 id="settimerinterval"><a class="header" href="#settimerinterval">setTimerInterval</a></h3>
<p>Execute a callback repeatedly:</p>
<pre><code class="language-typescript">import { setTimerInterval, IDL, update } from 'azle';

export default class {
    counter: number = 0;

    @update([IDL.Nat], IDL.Nat64)
    startPeriodicTask(intervalSeconds: number): bigint {
        const timerId = setTimerInterval(intervalSeconds, () =&gt; {
            this.counter += 1;
            console.log(`Periodic task executed ${this.counter} times`);
        });

        return timerId;
    }
}
</code></pre>
<h3 id="cleartimer"><a class="header" href="#cleartimer">clearTimer</a></h3>
<p>Cancel a scheduled timer:</p>
<pre><code class="language-typescript">import { setTimer, clearTimer, IDL, update } from 'azle';

export default class {
    activeTimers: Set&lt;bigint&gt; = new Set();

    @update([IDL.Nat], IDL.Nat64)
    scheduleTask(delaySeconds: number): bigint {
        const timerId = setTimer(delaySeconds, () =&gt; {
            console.log('Task executed!');
            this.activeTimers.delete(timerId);
        });

        this.activeTimers.add(timerId);
        return timerId;
    }

    @update([IDL.Nat64], IDL.Bool)
    cancelTask(timerId: bigint): boolean {
        if (this.activeTimers.has(timerId)) {
            clearTimer(timerId);
            this.activeTimers.delete(timerId);
            return true;
        }
        return false;
    }
}
</code></pre>
<h2 id="cycles"><a class="header" href="#cycles">Cycles</a></h2>
<h3 id="canistercyclebalance"><a class="header" href="#canistercyclebalance">canisterCycleBalance</a></h3>
<p>Get the canister's current cycle balance:</p>
<pre><code class="language-typescript">import { canisterCycleBalance, IDL, query } from 'azle';

export default class {
    @query([], IDL.Nat)
    getBalance(): bigint {
        return canisterCycleBalance();
    }

    @query([], IDL.Bool)
    hasEnoughCycles(): boolean {
        const balance = canisterCycleBalance();
        const minimumRequired = 1_000_000_000n; // 1 billion cycles
        return balance &gt;= minimumRequired;
    }
}
</code></pre>
<h3 id="msgcyclesaccept"><a class="header" href="#msgcyclesaccept">msgCyclesAccept</a></h3>
<p>Accept cycles sent with the current call:</p>
<pre><code class="language-typescript">import { msgCyclesAccept, msgCyclesAvailable, IDL, update } from 'azle';

export default class {
    @update([], IDL.Nat)
    acceptPayment(): bigint {
        const available = msgCyclesAvailable();
        const accepted = msgCyclesAccept(available);
        return accepted;
    }
}
</code></pre>
<h2 id="inter-canister-calls"><a class="header" href="#inter-canister-calls">Inter-Canister Calls</a></h2>
<h3 id="call"><a class="header" href="#call">call</a></h3>
<p>Make calls to other canisters:</p>
<pre><code class="language-typescript">import { call, IDL, update, Principal } from 'azle';

export default class {
    @update([IDL.Principal, IDL.Text], IDL.Text)
    async callOtherCanister(
        canisterId: Principal,
        message: string
    ): Promise&lt;string&gt; {
        const result = await call(canisterId, 'process_message', {
            args: [message],
            paramIdlTypes: [IDL.Text],
            returnIdlType: IDL.Text
        });

        return result;
    }

    @update([IDL.Principal], IDL.Nat)
    async transferCycles(recipient: Principal): Promise&lt;bigint&gt; {
        const cyclesToSend = 1_000_000n;

        await call(recipient, 'receive_cycles', {
            cycles: cyclesToSend
        });

        return cyclesToSend;
    }
}
</code></pre>
<h2 id="canister-information"><a class="header" href="#canister-information">Canister Information</a></h2>
<h3 id="canisterself"><a class="header" href="#canisterself">canisterSelf</a></h3>
<p>Get the current canister's principal:</p>
<pre><code class="language-typescript">import { canisterSelf, IDL, query } from 'azle';

export default class {
    @query([], IDL.Principal)
    myId(): Principal {
        return canisterSelf();
    }
}
</code></pre>
<h3 id="canisterversion"><a class="header" href="#canisterversion">canisterVersion</a></h3>
<p>Get the current canister version:</p>
<pre><code class="language-typescript">import { canisterVersion, IDL, query } from 'azle';

export default class {
    @query([], IDL.Nat64)
    getVersion(): bigint {
        return canisterVersion();
    }
}
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="trap"><a class="header" href="#trap">trap</a></h3>
<p>Terminate execution with an error:</p>
<pre><code class="language-typescript">import { trap, IDL, update } from 'azle';

export default class {
    @update([IDL.Text], IDL.Text)
    processInput(input: string): string {
        if (input === '') {
            trap('Input cannot be empty');
        }

        return `Processed: ${input}`;
    }
}
</code></pre>
<h2 id="manual-response-handling"><a class="header" href="#manual-response-handling">Manual Response Handling</a></h2>
<h3 id="msgreply--msgreject"><a class="header" href="#msgreply--msgreject">msgReply / msgReject</a></h3>
<p>For manual response handling in decorators with <code>manual: true</code>:</p>
<pre><code class="language-typescript">import {
    msgReply,
    msgReject,
    msgArgData,
    IDL,
    update,
    candidDecode,
    candidEncode
} from 'azle';

export default class {
    @update([], IDL.Text, { manual: true })
    manualResponse(): void {
        try {
            const result = 'Success!';
            const encoded = candidEncode([IDL.Text], [result]);
            msgReply(encoded);
        } catch (error) {
            msgReject(`Error: ${error}`);
        }
    }
}
</code></pre>
<h2 id="random-numbers"><a class="header" href="#random-numbers">Random Numbers</a></h2>
<h3 id="randseed"><a class="header" href="#randseed">randSeed</a></h3>
<p>Get a random seed for pseudorandom number generation:</p>
<pre><code class="language-typescript">import { randSeed, IDL, query } from 'azle';

export default class {
    @query([], IDL.Nat)
    getRandomNumber(): number {
        const seed = randSeed();
        // Use seed for pseudorandom number generation
        return Math.abs(seed.reduce((a, b) =&gt; a + b, 0));
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-experimental"><a class="header" href="#http-server-experimental">HTTP Server (Experimental)</a></h1>
<p>This section documents the HTTP Server methodology for developing Azle applications. This methodology embraces traditional web server techniques, allowing you to write HTTP servers using popular libraries such as Express, and using JSON for simple serialization and deserialization purposes.</p>
<p>HTTP Server functionality will remain experimental for an unknown length of time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-started-1"><a class="header" href="#get-started-1">Get Started</a></h1>
<ul>
<li><a href="get_started.html#installation">Installation</a></li>
<li><a href="get_started.html#deployment">Deployment</a></li>
</ul>
<p>Azle helps you to build secure decentralized/replicated servers in TypeScript or JavaScript on <a href="https://internetcomputer.org/">ICP</a>. The current replication factor is <a href="https://dashboard.internetcomputer.org/subnets">13-40 times</a>.</p>
<p>Please remember that the HTTP Server functionality is only accessible in Azle's experimental mode.</p>
<p>Azle runs in experimental mode through explicitly enabling a flag in <code>dfx.json</code> or certain CLI commands.</p>
<p>This mode is intended for developers who are willing to accept the risk of using an alpha or beta project. Its focus is on quickly enabling new features and functionality without requiring the time and other resources necessary to advance them to the stable mode. The Node.js standard libary, npm ecosystem, and HTTP server functionality are also major areas of focus.</p>
<blockquote>
<p>NOTE: Keep clearly in mind that the experimental mode fundamentally changes the Azle Wasm binary. It is not guaranteed to be secure or stable in API changes or runtime behavior. If you enable the experimental mode, even if you only use APIs from the stable mode, you are accepting a higher risk of bugs, errors, crashes, security exploits, breaking API changes, etc.</p>
</blockquote>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<blockquote>
<p>Windows is only supported through a Linux virtual environment of some kind, such as <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a></p>
</blockquote>
<p>You will need <a href="get_started.html#nodejs-22">Node.js 22</a> and <a href="get_started.html#dfx">dfx</a> to develop ICP applications with Azle:</p>
<h3 id="nodejs-22-1"><a class="header" href="#nodejs-22-1">Node.js 22</a></h3>
<p>It's recommended to use nvm to install Node.js 22:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>Restart your terminal and then run:</p>
<pre><code class="language-bash">nvm install 22
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">node --version
</code></pre>
<h3 id="dfx-1"><a class="header" href="#dfx-1">dfx</a></h3>
<p>Install the dfx command line tools for managing ICP applications:</p>
<pre><code class="language-bash">DFX_VERSION=0.24.3 sh -ci "$(curl -fsSL https://internetcomputer.org/install.sh)"
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">dfx --version
</code></pre>
<h2 id="deployment-1"><a class="header" href="#deployment-1">Deployment</a></h2>
<p>To create and deploy a simple sample application called <code>hello_world</code>:</p>
<pre><code class="language-bash"># create a new default project called hello_world
npx azle new hello_world --http-server --experimental
cd hello_world
</code></pre>
<pre><code class="language-bash"># install all npm dependencies including azle
npm install
</code></pre>
<pre><code class="language-bash"># start up a local ICP replica
dfx start --clean
</code></pre>
<p>In a separate terminal in the <code>hello_world</code> directory:</p>
<pre><code class="language-bash"># deploy your canister
dfx deploy
</code></pre>
<p>If you would like your canister to autoreload on file changes:</p>
<pre><code class="language-bash">AZLE_AUTORELOAD=true dfx deploy
</code></pre>
<p>View your frontend in a web browser at <code>http://[canisterId].raw.localhost:8000</code>.</p>
<p>To obtain your application's [canisterId]:</p>
<pre><code class="language-bash">dfx canister id backend
</code></pre>
<p>Communicate with your canister using any HTTP client library, for example using <code>curl</code>:</p>
<pre><code class="language-bash">curl http://[canisterId].raw.localhost:8000/db
curl -X POST -H "Content-Type: application/json" -d "{ \"hello\": \"world\" }" http://[canisterId].raw.localhost:8000/db/update
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>There are many Azle examples in the <a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server">examples directory</a>. We recommend starting with the following:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/apollo_server">apollo_server</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/audio_and_video">audio_and_video</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/autoreload">autoreload</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers">ethers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers_base">ethers_base</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/express">express</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/fetch_ic">fetch_ic</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/file_protocol">file_protocol</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/fs">fs</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/hello_world_http_server">hello_world_http_server</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/http_outcall_fetch">http_outcall_fetch</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/hybrid_canister">hybrid_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/internet_identity">internet_identity</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/large_files">large_files</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite">sqlite</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/tfjs">tfjs</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/web_assembly">web_assembly</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment-2"><a class="header" href="#deployment-2">Deployment</a></h1>
<ul>
<li><a href="deployment.html#starting-the-local-replica">Starting the local replica</a></li>
<li><a href="deployment.html#deploying-to-the-local-replica">Deploying to the local replica</a></li>
<li><a href="deployment.html#interacting-with-your-canister">Interacting with your canister</a></li>
<li><a href="deployment.html#deploying-to-mainnet">Deploying to mainnet</a></li>
</ul>
<p>There are two main <a href="https://internetcomputer.org/">ICP</a> environments that you will generally interact with: <a href="deployment.html#deploying-to-the-local-replica">the local replica</a> and <a href="deployment.html#deploying-to-mainnet">mainnet</a>.</p>
<p>We recommend using the <code>dfx</code> command line tools to deploy to these environments. Please note that not all <code>dfx</code> commands are shown here. See <a href="https://internetcomputer.org/docs/current/references/cli-reference/dfx-parent">the dfx CLI reference</a> for more information.</p>
<h2 id="starting-the-local-replica"><a class="header" href="#starting-the-local-replica">Starting the local replica</a></h2>
<p>We recommend running your local replica in its own terminal and on a port of your choosing:</p>
<pre><code class="language-bash">dfx start --host 127.0.0.1:8000
</code></pre>
<p>Alternatively you can start the local replica as a background process:</p>
<pre><code class="language-bash">dfx start --background --host 127.0.0.1:8000
</code></pre>
<p>If you want to stop a local replica running in the background:</p>
<pre><code class="language-bash">dfx stop
</code></pre>
<p>If you ever see this kind of error after <code>dfx stop</code>:</p>
<pre><code class="language-bash">Error: Failed to kill all processes.  Remaining: 627221 626923 627260
</code></pre>
<p>Then try this:</p>
<pre><code class="language-bash">dfx killall
</code></pre>
<p>If your replica starts behaving strangely, we recommend starting the replica clean, which will clean the <code>dfx</code> state of your project:</p>
<pre><code class="language-bash">dfx start --clean --host 127.0.0.1:8000
</code></pre>
<h2 id="deploying-to-the-local-replica"><a class="header" href="#deploying-to-the-local-replica">Deploying to the local replica</a></h2>
<p>To deploy all canisters defined in your <code>dfx.json</code>:</p>
<pre><code class="language-bash">dfx deploy
</code></pre>
<p>If you would like your canister to autoreload on file changes:</p>
<pre><code class="language-bash">AZLE_AUTORELOAD=true dfx deploy
</code></pre>
<p>To deploy an individual canister:</p>
<pre><code class="language-bash">dfx deploy [canisterName]
</code></pre>
<h2 id="interacting-with-your-canister"><a class="header" href="#interacting-with-your-canister">Interacting with your canister</a></h2>
<p>You will generally interact with your canister through an HTTP client such as <code>curl</code>, <code>fetch</code>, or a web browser. The URL of your canister locally will look like this: <code>http://[canisterId].raw.localhost:[replicaPort]</code>. Azle will print your canister's URL in the terminal after a successful deploy.</p>
<pre><code class="language-bash"># You can obtain the canisterId like this
dfx canister id [canisterName]

# You can obtain the replicaPort like this
dfx info webserver-port

# An example of performing a GET request to a canister
curl http://a3shf-5eaaa-aaaaa-qaafa-cai.raw.localhost:8000

# An example of performing a POST request to a canister
curl -X POST -H "Content-Type: application/json" -d "{ \"hello\": \"world\" }" http://a3shf-5eaaa-aaaaa-qaafa-cai.raw.localhost:8000
</code></pre>
<h2 id="deploying-to-mainnet"><a class="header" href="#deploying-to-mainnet">Deploying to mainnet</a></h2>
<p>Assuming you are <a href="https://internetcomputer.org/docs/current/developer-docs/getting-started/cycles/cycles-wallet">setup with a cycles wallet</a>, then you are ready to deploy to mainnet.</p>
<p>To deploy all canisters defined in your dfx.json:</p>
<pre><code class="language-bash">dfx deploy --network ic
</code></pre>
<p>To deploy an individual canister:</p>
<pre><code class="language-bash">dfx deploy --network ic [canisterName]
</code></pre>
<p>The URL of your canister on mainnet will look like this: <code>https://[canisterId].raw.icp0.io</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure-tldr"><a class="header" href="#project-structure-tldr">Project Structure TL;DR</a></h1>
<p>Your project is just a directory with a <code>dfx.json</code> file that points to your <code>.ts</code> or <code>.js</code> entrypoint.</p>
<p>Here's what your directory structure might look like:</p>
<pre><code>hello_world/
|
├── dfx.json
|
└── src/
    └── api.ts
</code></pre>
<p>For an HTTP Server canister this would be the simplest corresponding <code>dfx.json</code> file:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http"
            }
        }
    }
}
</code></pre>
<p>For a Candid RPC canister this would be the simplest corresponding <code>dfx.json</code> file:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts"
        }
    }
}
</code></pre>
<p>Once you have created this directory structure you can <a href="./deployment.html#deploying-to-mainnet">deploy to mainnet</a> or a <a href="./deployment.html#starting-the-local-replica">locally running replica</a> by running the <code>dfx deploy</code> command in the same directory as your <code>dfx.json</code> file.</p>
<h2 id="dfxjson"><a class="header" href="#dfxjson">dfx.json</a></h2>
<p>The <code>dfx.json</code> file is the main ICP-specific configuration file for your canisters. The following are various examples of <code>dfx.json</code> files.</p>
<h3 id="automatic-candid-file-generation"><a class="header" href="#automatic-candid-file-generation">Automatic Candid File Generation</a></h3>
<p>The command-line tools <code>dfx</code> require a Candid file to deploy your canister. Candid RPC canisters will automatically have their Candid files generated and stored in the <code>.azle</code> directory without any extra property in the <code>dfx.json</code> file. HTTP Server canisters must specify <code>"candid_gen": "http"</code> for their Candid files to be generated automatically in the <code>.azle</code> directory:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http"
            }
        }
    }
}
</code></pre>
<h3 id="custom-candid-file"><a class="header" href="#custom-candid-file">Custom Candid File</a></h3>
<p>If you would like to provide your own custom Candid file you can specify <code>"candid": "[path to your candid file]"</code> and <code>"candid_gen": "custom"</code>:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "candid": "src/api.did",
            "custom": {
                "experimental": true,
                "candid_gen": "custom"
            }
        }
    }
}
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>You can provide environment variables to Azle canisters by specifying their names in your <code>dfx.json</code> file and then accessing them through the <code>process.env</code> object in Azle.</p>
<p>You must provide the environment variables that you want included in the same process as your <code>dfx deploy</code> command.</p>
<p>Be aware that the environment variables that you specify in your <code>dfx.json</code> file will be included in plain text in your canister's Wasm binary.</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http",
                "env": ["MY_ENVIRONMENT_VARIABLE"]
            }
        }
    }
}
</code></pre>
<h3 id="assets"><a class="header" href="#assets">Assets</a></h3>
<p>See <a href="./assets.html">the Assets chapter</a> for more information:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http",
                "assets": [
                    ["src/frontend/dist", "dist"],
                    ["src/backend/media/audio.ogg", "media/audio.ogg"],
                    ["src/backend/media/video.ogv", "media/video.ogv"]
                ]
            }
        }
    }
}
</code></pre>
<h3 id="build-assets"><a class="header" href="#build-assets">Build Assets</a></h3>
<p>See <a href="./assets.html">the Assets chapter</a> for more information:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http",
                "assets": [
                    ["src/frontend/dist", "dist"],
                    ["src/backend/media/audio.ogg", "media/audio.ogg"],
                    ["src/backend/media/video.ogv", "media/video.ogv"]
                ],
                "build_assets": "npm run build"
            }
        }
    }
}
</code></pre>
<h3 id="esm-externals"><a class="header" href="#esm-externals">ESM Externals</a></h3>
<p>This will instruct Azle's TypeScript/JavaScript build process to ignore bundling the provided named packages.</p>
<p>Sometimes the build process is overly eager to include packages that won't actually be used at runtime. This can be a problem if those packages wouldn't even work at runtime due to limitations in ICP or Azle. It is thus useful to be able to exclude them:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http",
                "esm_externals": ["@nestjs/microservices", "@nestjs/websockets"]
            }
        }
    }
}
</code></pre>
<h3 id="esm-aliases"><a class="header" href="#esm-aliases">ESM Aliases</a></h3>
<p>This will instruct Azle's TypeScript/JavaScript build process to alias a package name to another pacakge name.</p>
<p>This can be useful if you need to polyfill certain packages that might not exist in Azle:</p>
<pre><code class="language-json">{
    "canisters": {
        "api": {
            "type": "azle",
            "main": "src/api.ts",
            "custom": {
                "experimental": true,
                "candid_gen": "http",
                "esm_aliases": {
                    "crypto": "crypto-browserify"
                }
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servers-tldr"><a class="header" href="#servers-tldr">Servers TL;DR</a></h1>
<p>Just write Node.js servers like this:</p>
<pre><code class="language-typescript">import { createServer } from 'http';

const server = createServer((req, res) =&gt; {
    res.write('Hello World!');
    res.end();
});

server.listen();
</code></pre>
<p>or write Express servers like this:</p>
<pre><code class="language-typescript">import express, { Request } from 'express';

let db = {
    hello: ''
};

const app = express();

app.use(express.json());

app.get('/db', (req, res) =&gt; {
    res.json(db);
});

app.post('/db/update', (req: Request&lt;any, any, typeof db&gt;, res) =&gt; {
    db = req.body;

    res.json(db);
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<p>or NestJS servers like this:</p>
<pre><code class="language-typescript">import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';

import { AppModule } from './app.module';

async function bootstrap() {
    const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule);
    await app.listen(3000);
}

bootstrap();
</code></pre>
<h1 id="servers"><a class="header" href="#servers">Servers</a></h1>
<ul>
<li><a href="servers.html#nodejs-httpserver">Node.js http.server</a></li>
<li><a href="servers.html#express">Express</a></li>
<li><a href="servers.html#server">Server</a></li>
<li><a href="servers.html#limitations">Limitations</a></li>
</ul>
<p>Azle supports building HTTP servers on ICP using the <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a> class as the foundation. These servers can serve static files or act as API backends, or both.</p>
<p>Azle currently has good but not comprehensive support for <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a> and <a href="https://expressjs.com/">Express</a>. Support for other libraries like <a href="https://nestjs.com/">Nest</a> are works-in-progress.</p>
<p>Once <a href="./deployment.html">deployed</a> you can access your server at a URL like this locally <code>http://bkyz2-fmaaa-aaaaa-qaaaq-cai.raw.localhost:8000</code> or like this on mainnet <code>https://bkyz2-fmaaa-aaaaa-qaaaq-cai.raw.icp0.io</code>.</p>
<p>You can use any HTTP client to interact with your server, such as <code>curl</code>, <code>fetch</code>, or a web browser. See the <a href="./deployment.html#interacting-with-your-canister">Interacting with your canister section</a> of the <a href="./deployment.html">deployment chapter</a> for help in constructing your canister URL.</p>
<h2 id="nodejs-httpserver"><a class="header" href="#nodejs-httpserver">Node.js http.server</a></h2>
<p>Azle supports instances of <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a>. <code>listen()</code> must be called on the server instance for Azle to use it to handle HTTP requests. Azle does not respect a port being passed into <code>listen()</code>. The port is set by the ICP replica (e.g. <code>dfx start --host 127.0.0.1:8000</code>), not by Azle.</p>
<p>Here's an example of a very simple <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a>:</p>
<pre><code class="language-typescript">import { createServer } from 'http';

const server = createServer((req, res) =&gt; {
    res.write('Hello World!');
    res.end();
});

server.listen();
</code></pre>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<p><a href="https://expressjs.com/">Express</a> is one of the most popular backend JavaScript web frameworks, and it's the recommended way to get started building servers in Azle. Here's the main code from the <a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/hello_world_http_server">hello_world_http_server example</a>:</p>
<pre><code class="language-typescript">import express, { Request } from 'express';

let db = {
    hello: ''
};

const app = express();

app.use(express.json());

app.get('/db', (req, res) =&gt; {
    res.json(db);
});

app.post('/db/update', (req: Request&lt;any, any, typeof db&gt;, res) =&gt; {
    db = req.body;

    res.json(db);
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<h3 id="jsonstringify"><a class="header" href="#jsonstringify">jsonStringify</a></h3>
<p>When working with <code>res.json</code> you may run into errors because of attempting to send back JavaScript objects that are not strictly <code>JSON</code>. This can happen when trying to send back an object with a <code>BigInt</code> for example.</p>
<p>Azle has created a special function called <code>jsonStringify</code> that will serialize many ICP-specific data structures to <code>JSON</code> for you:</p>
<pre><code class="language-typescript">import { jsonStringify } from 'azle/experimental';
import express, { Request } from 'express';

let db = {
    bigInt: 0n
};

const app = express();

app.use(express.json());

app.get('/db', (req, res) =&gt; {
    res.send(jsonStringify(db));
});

app.post('/db/update', (req: Request&lt;any, any, typeof db&gt;, res) =&gt; {
    db = req.body;

    res.send(jsonStringify(db));
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>If you need to add <a href="./query_methods.html">canister methods</a> to your HTTP server, the <code>Server</code> function imported from <code>azle</code> allows you to do so.</p>
<p>Here's an example of a very simple HTTP server:</p>
<pre><code class="language-typescript">import { Server } from 'azle/experimental';
import express from 'express';

export default Server(() =&gt; {
    const app = express();

    app.get('/http-query', (_req, res) =&gt; {
        res.send('http-query-server');
    });

    app.post('/http-update', (_req, res) =&gt; {
        res.send('http-update-server');
    });

    return app.listen();
});
</code></pre>
<p>You can add canister methods like this:</p>
<pre><code class="language-typescript">import { query, Server, text, update } from 'azle/experimental';
import express from 'express';

export default Server(
    () =&gt; {
        const app = express();

        app.get('/http-query', (_req, res) =&gt; {
            res.send('http-query-server');
        });

        app.post('/http-update', (_req, res) =&gt; {
            res.send('http-update-server');
        });

        return app.listen();
    },
    {
        candidQuery: query([], text, () =&gt; {
            return 'candidQueryServer';
        }),
        candidUpdate: update([], text, () =&gt; {
            return 'candidUpdateServer';
        })
    }
);
</code></pre>
<p>The <code>default</code> export of your <code>main</code> module must be the result of calling <code>Server</code>, and the callback argument to <code>Server</code> must return a <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a>. The <code>main</code> module is specified by the <code>main</code> property of your project's <a href="https://github.com/demergent-labs/azle/blob/main/examples/hello_world/dfx.json#L5">dfx.json file</a>. The <code>dfx.json</code> file must be at the root directory of your project.</p>
<p>The callback argument to <code>Server</code> can be asynchronous:</p>
<pre><code class="language-typescript">import { Server } from 'azle/experimental';
import { createServer } from 'http';

export default Server(async () =&gt; {
    const message = await asynchronousHelloWorld();

    return createServer((req, res) =&gt; {
        res.write(message);
        res.end();
    });
});

async function asynchronousHelloWorld() {
    // do some asynchronous task
    return 'Hello World Asynchronous!';
}
</code></pre>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>For a deeper understanding of possible limitations you may want to refer to <a href="https://internetcomputer.org/docs/current/references/http-gateway-protocol-spec">The HTTP Gateway Protocol Specification</a>.</p>
<ul>
<li>The top-level route <code>/api</code> is currently reserved by the replica locally</li>
<li>The <code>Transfer-Encoding</code> header is not supported</li>
<li><code>gzip</code> responses most likely do not work</li>
<li>HTTP requests are generally limited to ~2 MiB</li>
<li>HTTP responses are generally limited to ~3 MiB</li>
<li>You cannot set HTTP status codes in the 1xx range</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets-tldr"><a class="header" href="#assets-tldr">Assets TL;DR</a></h1>
<p>You can automatically copy static assets (essentially files and folders) into your canister's filesystem during deploy by using the <code>assets</code> and <code>build_assets</code> properties of the canister object in your project's <code>dfx.json</code> file.</p>
<p>Here's an example that copies the <code>src/frontend/dist</code> directory on the deploying machine into the <code>dist</code> directory of the canister, using the <code>assets</code> and <code>build_assets</code> properties:</p>
<pre><code class="language-json">{
    "canisters": {
        "backend": {
            "type": "azle",
            "main": "src/backend/index.ts",
            "custom": {
                "experimental": true,
                "assets": [["src/frontend/dist", "dist"]],
                "build_assets": "npm run build"
            }
        }
    }
}
</code></pre>
<p>The <code>assets</code> property is an array of tuples, where the first element of the tuple is the source directory on the deploying machine, and the second element of the tuple is the destination directory in the canister. Use <code>assets</code> for total assets up to ~2 GiB in size. We are working on increasing this limit further.</p>
<p>The <code>build_assets</code> property allows you to specify custom terminal commands that will run before Azle copies the assets into the canister. You can use <code>build_assets</code> to build your frontend code for example. In this case we are running <code>npm run build</code>, which refers to an npm script that we have specified in our <code>package.json</code> file.</p>
<p>Once you have loaded assets into your canister, they are accessible from that canister's filesystem. Here's an example of using the Express static middleware to serve a frontend from the canister's filesystem:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.use(express.static('/dist'));

app.listen();
</code></pre>
<p>Assuming the <code>/dist</code> directory in the canister has an appropriate <code>index.html</code> file, this canister would serve a frontend at its URL when loaded in a web browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-tldr"><a class="header" href="#authentication-tldr">Authentication TL;DR</a></h1>
<p>Azle canisters can import <code>caller</code> from <code>azle</code> and use it to get the <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#principal">principal (public-key linked identifier)</a> of the initiator of an HTTP request. HTTP requests are anonymous (principal <code>2vxsx-fae</code>) by default, but authentication with web browsers (and maybe Node.js) can be done using a JWT-like API from <code>azle/experimental/http_client</code>.</p>
<p>First you import <code>toJwt</code> from <code>azle/experimental/http_client</code>:</p>
<pre><code class="language-typescript">import { toJwt } from 'azle/experimental/http_client';
</code></pre>
<p>Then you use <code>fetch</code> and construct an <code>Authorization</code> header using an <a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a> <code>Identity</code>:</p>
<pre><code class="language-typescript">const response = await fetch(
    `http://bkyz2-fmaaa-aaaaa-qaaaq-cai.raw.localhost:8000/whoami`,
    {
        method: 'GET',
        headers: [['Authorization', toJwt(this.identity)]]
    }
);
</code></pre>
<p>Here's an example of the frontend of a simple web application using <code>azle/experimental/http_client</code> and <a href="https://internetcomputer.org/internet-identity">Internet Identity</a>:</p>
<pre><code class="language-typescript">import { Identity } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { toJwt } from 'azle/experimental/http_client';
import { html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';

@customElement('azle-app')
export class AzleApp extends LitElement {
    @property()
    identity: Identity | null = null;

    @property()
    whoami: string = '';

    connectedCallback() {
        super.connectedCallback();
        this.authenticate();
    }

    async authenticate() {
        const authClient = await AuthClient.create();
        const isAuthenticated = await authClient.isAuthenticated();

        if (isAuthenticated === true) {
            this.handleIsAuthenticated(authClient);
        } else {
            await this.handleIsNotAuthenticated(authClient);
        }
    }

    handleIsAuthenticated(authClient: AuthClient) {
        this.identity = authClient.getIdentity();
    }

    async handleIsNotAuthenticated(authClient: AuthClient) {
        await new Promise((resolve, reject) =&gt; {
            authClient.login({
                identityProvider: import.meta.env.VITE_IDENTITY_PROVIDER,
                onSuccess: resolve as () =&gt; void,
                onError: reject,
                windowOpenerFeatures: `width=500,height=500`
            });
        });

        this.identity = authClient.getIdentity();
    }

    async whoamiUnauthenticated() {
        const response = await fetch(
            `${import.meta.env.VITE_CANISTER_ORIGIN}/whoami`
        );
        const responseText = await response.text();

        this.whoami = responseText;
    }

    async whoamiAuthenticated() {
        const response = await fetch(
            `${import.meta.env.VITE_CANISTER_ORIGIN}/whoami`,
            {
                method: 'GET',
                headers: [['Authorization', toJwt(this.identity)]]
            }
        );
        const responseText = await response.text();

        this.whoami = responseText;
    }

    render() {
        return html`
            &lt;h1&gt;Internet Identity&lt;/h1&gt;

            &lt;h2&gt;
                Whoami principal:
                &lt;span id="whoamiPrincipal"&gt;${this.whoami}&lt;/span&gt;
            &lt;/h2&gt;

            &lt;button
                id="whoamiUnauthenticated"
                @click=${this.whoamiUnauthenticated}
            &gt;
                Whoami Unauthenticated
            &lt;/button&gt;
            &lt;button
                id="whoamiAuthenticated"
                @click=${this.whoamiAuthenticated}
                .disabled=${this.identity === null}
            &gt;
                Whoami Authenticated
            &lt;/button&gt;
        `;
    }
}
</code></pre>
<p>Here's an example of the backend of that same simple web application:</p>
<pre><code class="language-typescript">import { caller } from 'azle';
import express from 'express';

const app = express();

app.get('/whoami', (req, res) =&gt; {
    res.send(caller().toString());
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/fetch_ic">fetch_ic</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/internet_identity">internet_identity</a></li>
</ul>
<h2 id="under-the-hood"><a class="header" href="#under-the-hood">Under-the-hood</a></h2>
<p>Authentication of ICP calls is done through signatures on messages. <a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a> provides very nice abstractions for creating all of the required signatures in the correct formats when calling into canisters on ICP. Unfortunately this requires you to abandon traditional HTTP requests, as you must use the agent's APIs.</p>
<p>Azle attempts to enable you to perform traditional HTTP requests with traditional libraries. Currently Azle focuses on <code>fetch</code>. When importing <code>toJwt</code>, <code>azle/experimental/http_client</code> will overwrite the global <code>fetch</code> function and will intercept <code>fetch</code> requests that have <code>Authorization</code> headers with an <code>Identity</code> as a value.</p>
<p>Once intercepted, these requests are turned into <code>@dfinity/agent</code> requests that call <a href="https://internetcomputer.org/docs/current/references/http-gateway-protocol-spec">the http_request and http_request_update canister methods</a> directly, thus performing all of the required client-side authentication work.</p>
<p>We are working to push for ICP to more natively understand JWTs for authentication, without the need to intercept <code>fetch</code> requests and convert them into agent requests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fetch-tldr"><a class="header" href="#fetch-tldr">fetch TL;DR</a></h1>
<p>Azle canisters use a custom <code>fetch</code> implementation to perform cross-canister calls and to perform HTTPS outcalls.</p>
<p>Here's an example of performing a cross-canister call:</p>
<pre><code class="language-typescript">import { serialize } from 'azle/experimental';
import express from 'express';

const app = express();

app.use(express.json());

app.post('/cross-canister-call', async (req, res) =&gt; {
    const to: string = req.body.to;
    const amount: number = req.body.amount;

    const response = await fetch(`icp://dfdal-2uaaa-aaaaa-qaama-cai/transfer`, {
        body: serialize({
            candidPath: '/token.did',
            args: [to, amount]
        })
    });
    const responseJson = await response.json();

    res.json(responseJson);
});

app.listen();
</code></pre>
<p>Keep these important points in mind when performing a cross-canister call:</p>
<ul>
<li>Use the <code>icp://</code> protocol in the URL</li>
<li>The <code>canister id</code> of the canister that you are calling immediately follows <code>icp://</code> in the URL</li>
<li>The <code>canister method</code> that you are calling immediately follows the <code>canister id</code> in the URL</li>
<li>The <code>candidPath</code> property of the <code>body</code> is the path to the Candid file defining the method signatures of the canister that you are calling. You must obtain this file and copy it into your canister. See the <a href="./assets.html">Assets chapter</a> for info on copying files into your canister</li>
<li>The <code>args</code> property of the <code>body</code> is an array of the arguments that will be passed to the <code>canister method</code> that you are calling</li>
</ul>
<p>Here's an example of performing an HTTPS outcall:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.use(express.json());

app.post('/https-outcall', async (_req, res) =&gt; {
    const response = await fetch(`https://httpbin.org/headers`, {
        headers: {
            'X-Azle-Request-Key-0': 'X-Azle-Request-Value-0',
            'X-Azle-Request-Key-1': 'X-Azle-Request-Value-1',
            'X-Azle-Request-Key-2': 'X-Azle-Request-Value-2'
        }
    });
    const responseJson = await response.json();

    res.json(responseJson);
});

app.listen();
</code></pre>
<h1 id="fetch"><a class="header" href="#fetch">fetch</a></h1>
<p>Azle has custom <code>fetch</code> implementations for clients and canisters.</p>
<p>The client <code>fetch</code> is used for authentication, and you can learn more about it in the <a href="./authentication.html">Authentication chapter</a>.</p>
<p>Canister <code>fetch</code> is used to perform cross-canister calls and <a href="https://internetcomputer.org/https-outcalls">HTTPS outcalls</a>. There are three main types of calls made with canister <code>fetch</code>:</p>
<ol>
<li><a href="fetch.html#cross-canister-calls-to-a-candid-canister">Cross-canister calls to a candid canister</a></li>
<li><a href="fetch.html#cross-canister-calls-to-an-http-canister">Cross-canister calls to an HTTP canister</a></li>
<li><a href="fetch.html#https-outcalls">HTTPS outcalls</a></li>
</ol>
<h2 id="cross-canister-calls-to-a-candid-canister"><a class="header" href="#cross-canister-calls-to-a-candid-canister">Cross-canister calls to a candid canister</a></h2>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/async_await">async_await</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/canister">canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/ckbtc">ckbtc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/composite_queries">composite_queries</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/cross_canister_calls">cross_canister_calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/func_types">func_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/heartbeat">heartbeat</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/icrc">icrc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/ledger_canister">ledger_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/management_canister">management_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/motoko_examples/whoami">whoami</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/recursion">recursion</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/rejections">rejections</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/timers">timers</a></li>
</ul>
<h2 id="cross-canister-calls-to-an-http-canister"><a class="header" href="#cross-canister-calls-to-an-http-canister">Cross-canister calls to an HTTP canister</a></h2>
<p>We are working on better abstractions for these types of calls. For now you would just make a cross-canister call using <code>icp://</code> to the <code>http_request</code> and <code>http_request_update</code> methods of the canister that you are calling.</p>
<h2 id="https-outcalls"><a class="header" href="#https-outcalls">HTTPS outcalls</a></h2>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/http_outcall_fetch">http_outcall_fetch</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<!-- // TODO explain that you can generally only do these in POST unless the method is a query method
// TODO we have to show the imports
// TODO explain the POST, PUT, PATCH etc

TODO explain the ic.setOutgoingHttpOptions

TODO split up the examples for each type of fetch

## Canister fetch cross-canister call to a candid canister

Most canisters on ICP are not HTTP canisters. We are pushing to change this situation, but for now this is how things are. Most canisters will thus only expose Candid canister methods.

So imagine a canister that exposes this Candid update method:

```
transfer: (text, text, nat64) -> (nat64);
```

```typescript
const response = await fetch(`icp://dfdal-2uaaa-aaaaa-qaama-cai/transfer`, {
    body: serialize({
        candidPath: '/src/canister2/index.did',
        args: [from, to, amount]
    })
});
const responseJson = await response.json();

return responseJson;
```

## Canister fetch cross-canister call to an HTTP canister

## Canister fetch HTTPS outcalls -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm-tldr"><a class="header" href="#npm-tldr">npm TL;DR</a></h1>
<p>If you want to know if an <a href="https://www.npmjs.com/">npm</a> package will work with Azle, just try out the package.</p>
<p>It's extremely difficult to know generally if a package will work unless it has been tried out and tested already. This is due to the complexity of understanding and implementing all required JavaScript, web, Node.js, and OS-level APIs required for an <code>npm</code> package to execute correctly.</p>
<p>To get an idea for which <code>npm</code> packages are currently supported, the <a href="./rest_based_examples.html">Azle examples</a> are full of example code with tests.</p>
<p>You can also look at the <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> documentation <a href="https://github.com/WasmEdge/WasmEdge/issues/1535">here</a> and <a href="https://wasmedge.org/docs/develop/javascript/nodejs">here</a>, as <code>wasmedge-quickjs</code> is our implementation for much of the Node.js stdlib.</p>
<h1 id="npm"><a class="header" href="#npm">npm</a></h1>
<p>Azle's goal is to support as many <a href="https://www.npmjs.com/">npm</a> packages as possible.</p>
<p>The current reality is that not all <code>npm</code> packages work well with Azle. It is also very difficult to determine which <code>npm</code> packages might work well.</p>
<p>For example, when asked about a specific package, we usually cannot say whether or not a given package "works". To truly know if a package will work for your situation, the easiest thing to do is to install it, import it, and try it out.</p>
<p>If you do want to reason about whether or not a package is likely to work, consider the following:</p>
<ol>
<li>Which web or Node.js APIs does the package use?</li>
<li>Does the package depend on functionality that ICP supports?</li>
<li>Will the package stay within <a href="./limitations.html">these limitations</a>?</li>
</ol>
<p>For example, any kind of networking outside of HTTP is unlikely to work (without modification), because ICP has very limited support for non-ICP networking.</p>
<p>Also any kind of heavy computation is unlikely to work (without modification), because ICP has very limited instruction limits per call.</p>
<p>We use <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> as our implementation for much of the Node.js stdlib. To get a feel for which Node.js standard libraries Azle supports, see <a href="https://github.com/WasmEdge/WasmEdge/issues/1535">here</a> and <a href="https://wasmedge.org/docs/develop/javascript/nodejs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens-tldr"><a class="header" href="#tokens-tldr">Tokens TL;DR</a></h1>
<p><a href="https://internetcomputer.org/docs/current/concepts/canisters-code">Canisters</a> can either:</p>
<ol>
<li>Interact with tokens that already exist</li>
<li>Implement, extend, or proxy tokens</li>
</ol>
<p>Canisters can use cross-canister calls to interact with tokens implemented using <a href="https://github.com/dfinity/ICRC">ICRC</a> or other standards. They can also interact with non-ICP tokens through <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/encryption/t-ecdsa">threshold ECDSA</a>.</p>
<p>Canisters can implement tokens from scratch, or extend or proxy implementations already written.</p>
<p>Demergent Labs does not keep any token implementations up-to-date. Here are some old implementations for inspiration and learning:</p>
<ul>
<li><a href="https://github.com/demergent-labs/ICRC-1">ICRC-1</a></li>
<li><a href="https://github.com/lastmjs/extendable-token-azle">extendable-token-azle</a></li>
</ul>
<h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/basic_bitcoin">basic_bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcoinjs_lib">bitcoinjs-lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcore_lib">bitcore-lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/ckbtc">ckbtc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers">ethers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers_base">ethers_base</a></li>
<li><a href="https://github.com/lastmjs/extendable-token-azle">extendable-token-azle</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/icrc">icrc</a></li>
<li><a href="https://github.com/demergent-labs/ICRC-1">ICRC-1</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/ledger_canister">ledger_canister</a></li>
</ul>
<!-- -   ICRC transfer from frontend
-   ICRC transfer from backend
-   ckBTC/ckETH transfer from frontend
-   ckBTC/ckETH transfer from backend
-   BTC/ETH transfers from backend
-   Show get balance, total supply, etc as well
-   Basically show the basic needs of users, how to transfer tokens and look up balances

## Interacting with tokens

### ICP tokens

### Foreign blockchain tokens

## Implementing tokens

There are three ways to interact with tokens on ICP. You can interact with a token implemented in another canister with its own standard. You can interact with a token implemented in another canister using ICRC. You can interact with a token canister. You can initiate transfers in a token canister. Or you can implement your own token canister to augment underlying functionality.

You could also act as a proxy to another canister.

You could also interact with tokens on another blockchain like Bitcoin or Ethereum. You can also use ckTokens.

Interacting with:

Custom standard/non-standard ICP tokens
ICRC standard ICP tokens
ck foreign ICP tokens
Foreign tokens

Implementing:

Custom standard/non-standard ICP tokens
ICRC standard ICP tokens
ck foreign ICP tokens

So you can initiate transfers on a custom ICP token. You can initiate transfers on ICRC ICP tokens. You can initiate transfers, read balances, etc on ck tokens which are wrapped tokens on another blockchain. And you can interact with tokens on other blockchains with ECDSA now and soon EdDSA.

So there's interacting with a token that already exists. And then there's creating your own token. If you want to create your own token without changing its functionality, you can just deploy a canister that already exists. If you need to implement your own functionality, you would have to implement your own.

Let's have implementations of all ICRC standards in Azle with tests.

For the TL;DR let's just explain each of these categories and show some code snippets.

This could take a bit of work. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin"><a class="header" href="#bitcoin">Bitcoin</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/basic_bitcoin">basic_bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/bitcoin_psbt">bitcoin_psbt</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcoinjs_lib">bitcoinjs_lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcore_lib">bitcore_lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/ckbtc">ckbtc</a></li>
</ul>
<p>There are two main ways to interact with Bitcoin on ICP: through the <a href="bitcoin.html#management-canister">management canister</a> and through the <a href="bitcoin.html#ckbtc">ckBTC canister</a>.</p>
<h2 id="management-canister"><a class="header" href="#management-canister">management canister</a></h2>
<p>To sign Bitcoin transactions using <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/encryption/t-ecdsa">threshold ECDSA</a> and interact with the Bitcoin blockchain directly from ICP, make <a href="./fetch.html">cross-canister calls</a> to the following methods on the <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#ic-management-canister">management canister</a>: <code>ecdsa_public_key</code>, <code>sign_with_ecdsa</code>, <code>bitcoin_get_balance</code>, <code>bitcoin_get_balance_query</code>, <code>bitcoin_get_utxos</code>, <code>bitcoin_get_utxos_query</code>, <code>bitcoin_send_transaction</code>, <code>bitcoin_get_current_fee_percentiles</code>.</p>
<p>To construct your cross-canister calls to these methods, use <code>canister id</code> <code>aaaaa-aa</code> and the management canister's <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#ic-candid">Candid type information</a> to construct the arguments to send in the <code>body</code> of your <code>fetch</code> call.</p>
<p>Here's an example of doing a test cross-canister call to the <code>bitcoin_get_balance</code> method:</p>
<pre><code class="language-typescript">import { serialize } from 'azle/experimental';

// ...

const response = await fetch(`icp://aaaaa-aa/bitcoin_get_balance`, {
    body: serialize({
        args: [
            {
                'bc1q34aq5drpuwy3wgl9lhup9892qp6svr8ldzyy7c',
                min_confirmations: [],
                network: { regtest: null }
            }
        ],
        cycles: 100_000_000n
    })
});
const responseJson = await response.json();

// ...
</code></pre>
<h2 id="ckbtc"><a class="header" href="#ckbtc">ckBTC</a></h2>
<p><a href="https://internetcomputer.org/docs/current/developer-docs/multi-chain/bitcoin/ckbtc/overview">ckBTC</a> is an <a href="https://internetcomputer.org/docs/current/references/icrc1-standard">ICRC</a> canister that wraps underlying bitcoin controlled with threshold ECDSA.</p>
<p>ICRCs are a set of standards for ICP canisters that define the method signatures and corresponding types for those canisters.</p>
<p>You interact with the <code>ckBTC</code> canister by calling its methods. You can do this from the frontend with <a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a>, or from an Azle canister through <a href="./fetch.html">cross-canister calls</a>.</p>
<p>Here's an example of doing a test cross-canister call to the <code>ckBTC</code> <code>icrc1_balance_of</code> method:</p>
<pre><code class="language-typescript">import { ic, serialize } from 'azle/experimental';

// ...

const response = await fetch(
    `icp://mc6ru-gyaaa-aaaar-qaaaq-cai/icrc1_balance_of`,
    {
        body: serialize({
            candidPath: `/candid/icp/icrc.did`,
            args: [
                {
                    owner: ic.id(),
                    subaccount: [
                        padPrincipalWithZeros(ic.caller().toUint8Array())
                    ]
                }
            ]
        })
    }
);
const responseJson = await response.json();

// ...

function padPrincipalWithZeros(principalBlob: Uint8Array): Uint8Array {
    let newUin8Array = new Uint8Array(32);
    newUin8Array.set(principalBlob);
    return newUin8Array;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethereum"><a class="header" href="#ethereum">Ethereum</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers">ethers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers_base">ethers_base</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databases"><a class="header" href="#databases">Databases</a></h1>
<p>The eventual goal for Azle is to support as many database solutions as possible. This is difficult for a number of reasons related to ICP's decentralized computing paradigm and Wasm environment.</p>
<p><a href="https://sqlite.org/">SQLite</a> is the current recommended approach to databases with Azle. We plan to provide Postgres support through <a href="https://github.com/electric-sql/pglite">pglite</a> next.</p>
<p>Azle has good support for SQLite through <a href="https://www.npmjs.com/package/sql.js">sql.js</a>. It also has good support for ORMs like <a href="https://orm.drizzle.team/">Drizzle</a> and <a href="https://typeorm.io/">TypeORM</a> using <code>sql.js</code>.</p>
<p>The following examples should be very useful as you get started using SQLite in Azle:</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite">sqlite</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite_drizzle">sqlite_drizzle</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite_typeorm">sqlite_typeorm</a></li>
</ul>
<h2 id="sqljs"><a class="header" href="#sqljs">sql.js</a></h2>
<p>SQLite in Azle works using an <a href="https://en.wikipedia.org/wiki/Asm.js">asm.js</a> build of SQLite from <code>sql.js</code> without modifications to the library. The database is stored entirely in memory on the heap, giving you ~2 GiB of space. Serialization across upgrades is possible using stable memory like this:</p>
<pre><code class="language-typescript">// src/index.its

import {
    init,
    postUpgrade,
    preUpgrade,
    Server,
    StableBTreeMap,
    stableJson
} from 'azle/experimental';
import { Database } from 'sql.js/dist/sql-asm.js';

import { initDb } from './db';
import { initServer } from './server';

export let db: Database;

let stableDbMap = StableBTreeMap&lt;'DATABASE', Uint8Array&gt;(0, stableJson, {
    toBytes: (data: Uint8Array) =&gt; data,
    fromBytes: (bytes: Uint8Array) =&gt; bytes
});

export default Server(initServer, {
    init: init([], async () =&gt; {
        db = await initDb();
    }),
    preUpgrade: preUpgrade(() =&gt; {
        stableDbMap.insert('DATABASE', db.export());
    }),
    postUpgrade: postUpgrade([], async () =&gt; {
        db = await initDb(stableDbMap.get('DATABASE').Some);
    })
});
</code></pre>
<pre><code class="language-typescript">// src/db/index.ts

import initSqlJs, {
    Database,
    QueryExecResult,
    SqlValue
} from 'sql.js/dist/sql-asm.js';

import { migrations } from './migrations';

export async function initDb(
    bytes: Uint8Array = Uint8Array.from([])
): Promise&lt;Database&gt; {
    const SQL = await initSqlJs({});

    let db = new SQL.Database(bytes);

    if (bytes.length === 0) {
        for (const migration of migrations) {
            db.run(migration);
        }
    }

    return db;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-tldr"><a class="header" href="#debugging-tldr">Debugging TL;DR</a></h1>
<p>If your terminal logs ever say <code>did not produce a response</code> or <code>response failed classification=Status code: 502 Bad Gateway</code>, it most likely means that your canister has thrown an error and halted execution for that call. Use <code>console.log</code> and <code>try/catch</code> liberally to track down problems and reveal error information. If your error logs do not have useful messages, use <code>try/catch</code> with a <code>console.log</code> of the catch error argument to reveal the underlying error message.</p>
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<ul>
<li><a href="debugging.html#consolelog-and-trycatch">console.log and try/catch</a></li>
<li><a href="debugging.html#canister-did-not-produce-a-response">Canister did not produce a response</a></li>
<li><a href="debugging.html#no-error-message">No error message</a></li>
<li><a href="debugging.html#final-compiled-and-bundled-javascript">Final Compiled and Bundled JavaScript</a></li>
</ul>
<p>Azle currently has less-than-elegant error reporting. We hope to improve this significantly in the future.</p>
<p>In the meantime, consider the following tips when trying to debug your application.</p>
<h2 id="consolelog-and-trycatch"><a class="header" href="#consolelog-and-trycatch">console.log and try/catch</a></h2>
<p>At the highest level, the most important tip is this: use <code>console.log</code> and <code>try/catch</code> liberally to track down problems and reveal error information.</p>
<h2 id="canister-did-not-produce-a-response"><a class="header" href="#canister-did-not-produce-a-response">Canister did not produce a response</a></h2>
<p>If you ever see an error that looks like this:</p>
<pre><code>Replica Error: reject code CanisterError, reject message IC0506: Canister bkyz2-fmaaa-aaaaa-qaaaq-cai did not produce a response, error code Some("IC0506")
</code></pre>
<p>or this:</p>
<pre><code>2024-04-17T15:01:39.194377Z  WARN icx_proxy_dev::proxy::agent: Replica Error
2024-04-17T15:01:39.194565Z ERROR tower_http::trace::on_failure: response failed classification=Status code: 502 Bad Gateway latency=61 ms
</code></pre>
<p>it most likely means that your canister has thrown an error and halted execution for that call. First check the replica's logs for any errors messages. If there are no useful error messages, use <a href="debugging.html#consolelog-and-trycatch">console.log and try/catch</a> liberally to track down the source of the error and to reveal more information about the error.</p>
<p>Don't be surprised if you need to <code>console.log</code> after each of your program's statements (including dependencies found in <code>node_modules</code>) to find out where the error is coming from. And don't be surprised if you need to use <code>try/catch</code> with a <code>console.log</code> of the catch error argument to reveal useful error messaging.</p>
<h2 id="no-error-message"><a class="header" href="#no-error-message">No error message</a></h2>
<p>You might find yourself in a situation where an error is reported without a useful message like this:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;Error&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;pre&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (.azle/main.js:110643)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (.azle/main.js:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (.azle/main.js:73452)&lt;br&gt; &amp;nbsp; &amp;nbsp;at dispatch (.azle/main.js:73432)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (.azle/main.js:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (.azle/main.js:73655)&lt;br&gt; &amp;nbsp; &amp;nbsp;at process_params (.azle/main.js:73692)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (.azle/main.js:73660)&lt;br&gt; &amp;nbsp; &amp;nbsp;at expressInit (.azle/main.js:73910)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (.azle/main.js:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at trim_prefix (.azle/main.js:73684)&lt;br&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (.azle/main.js:73657)&lt;br&gt; &amp;nbsp; &amp;nbsp;at process_params (.azle/main.js:73692)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (.azle/main.js:73660)&lt;br&gt; &amp;nbsp; &amp;nbsp;at query3 (.azle/main.js:73938)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (.azle/main.js:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at trim_prefix (.azle/main.js:73684)&lt;br&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (.azle/main.js:73657)&lt;br&gt; &amp;nbsp; &amp;nbsp;at process_params (.azle/main.js:73692)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (.azle/main.js:73660)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (.azle/main.js:73587)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (.azle/main.js:76233)&lt;br&gt; &amp;nbsp; &amp;nbsp;at app2 (.azle/main.js:78091)&lt;br&gt; &amp;nbsp; &amp;nbsp;at call (native)&lt;br&gt; &amp;nbsp; &amp;nbsp;at emitTwo (.azle/main.js:9782)&lt;br&gt; &amp;nbsp; &amp;nbsp;at emit2 (.azle/main.js:10023)&lt;br&gt; &amp;nbsp; &amp;nbsp;at httpHandler (.azle/main.js:87618)&lt;br&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>or like this:</p>
<pre><code>2024-04-17 14:35:30.433501980 UTC: [Canister bkyz2-fmaaa-aaaaa-qaaaq-cai] "    at &lt;anonymous&gt; (.azle/main.js:110643)\n    at handle (.azle/main.js:73283)\n    at next (.azle/main.js:73452)\n    at dispatch (.azle/main.js:73432)\n    at handle (.azle/main.js:73283)\n    at &lt;anonymous&gt; (.azle/main.js:73655)\n    at process_params (.azle/main.js:73692)\n    at next (.azle/main.js:73660)\n    at expressInit (.azle/main.js:73910)\n    at handle (.azle/main.js:73283)\n    at trim_prefix (.azle/main.js:73684)\n    at &lt;anonymous&gt; (.azle/main.js:73657)\n    at process_params (.azle/main.js:73692)\n    at next (.azle/main.js:73660)\n    at query3 (.azle/main.js:73938)\n    at handle (.azle/main.js:73283)\n    at trim_prefix (.azle/main.js:73684)\n    at &lt;anonymous&gt; (.azle/main.js:73657)\n    at process_params (.azle/main.js:73692)\n    at next (.azle/main.js:73660)\n    at handle (.azle/main.js:73587)\n    at handle (.azle/main.js:76233)\n    at app2 (.azle/main.js:78091)\n    at call (native)\n    at emitTwo (.azle/main.js:9782)\n    at emit2 (.azle/main.js:10023)\n    at httpHandler (.azle/main.js:87618)\n"
2024-04-17T14:35:31.983590Z ERROR tower_http::trace::on_failure: response failed classification=Status code: 500 Internal Server Error latency=101 ms
2024-04-17 14:36:34.652587412 UTC: [Canister bkyz2-fmaaa-aaaaa-qaaaq-cai] "    at &lt;anonymous&gt; (.azle/main.js:110643)\n    at handle (.azle/main.js:73283)\n    at next (.azle/main.js:73452)\n    at dispatch (.azle/main.js:73432)\n    at handle (.azle/main.js:73283)\n    at &lt;anonymous&gt; (.azle/main.js:73655)\n    at process_params (.azle/main.js:73692)\n    at next (.azle/main.js:73660)\n    at expressInit (.azle/main.js:73910)\n    at handle (.azle/main.js:73283)\n    at trim_prefix (.azle/main.js:73684)\n    at &lt;anonymous&gt; (.azle/main.js:73657)\n    at process_params (.azle/main.js:73692)\n    at next (.azle/main.js:73660)\n    at query3 (.azle/main.js:73938)\n    at handle (.azle/main.js:73283)\n    at trim_prefix (.azle/main.js:73684)\n    at &lt;anonymous&gt; (.azle/main.js:73657)\n    at process_params (.azle/main.js:73692)\n    at next (.azle/main.js:73660)\n    at handle (.azle/main.js:73587)\n    at handle (.azle/main.js:76233)\n    at app2 (.azle/main.js:78091)\n    at call (native)\n    at emitTwo (.azle/main.js:9782)\n    at emit2 (.azle/main.js:10023)\n    at httpHandler (.azle/main.js:87618)\n"
</code></pre>
<p>In these situations you might be able to use <code>try/catch</code> with a <code>console.log</code> of the catch error argument to reveal the underlying error message.</p>
<p>For example, this code without a <code>try/catch</code> will log errors without the message <code>This is the error text</code>:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.get('/hello-world', (_req, res) =&gt; {
    throw new Error('This is the error text');
    res.send('Hello World!');
});

app.listen();
</code></pre>
<p>You can get the message to print in the replica terminal like this:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.get('/hello-world', (_req, res) =&gt; {
    try {
        throw new Error('This is the error text');
        res.send('Hello World!');
    } catch (error) {
        console.log(error);
    }
});

app.listen();
</code></pre>
<h2 id="final-compiled-and-bundled-javascript"><a class="header" href="#final-compiled-and-bundled-javascript">Final Compiled and Bundled JavaScript</a></h2>
<p>Azle compiles and bundles your TypeScript/JavaScript into a final JavaScript file to be included and executed inside of your canister. Inspecting this final JavaScript code may help you to debug your application.</p>
<p>When you see something like <code>(.azle/main.js:110643)</code> in your error stack traces, it is a reference to the final compiled and bundled JavaScript file that is actually deployed with and executed by the canister. The right-hand side of <code>.azle/main.js</code> e.g. <code>:110643</code> is the line number in that file.</p>
<p>You can find the file at <code>[project_name]/.azle/[canister_name]/canister/src/main.js</code>. If you have the <code>AZLE_AUTORELOAD</code> environment variable set to <code>true</code> then you should instead look at <code>[project_name]/.azle/[canister_name]/canister/src/main_reloaded.js</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-tldr"><a class="header" href="#limitations-tldr">Limitations TL;DR</a></h1>
<p>There are a number of limitations that you are likely to run into while you develop with Azle on ICP. These are generally the most limiting:</p>
<ul>
<li>5 billion instruction limit for query calls (HTTP GET requests) (~1 second of computation)</li>
<li>40 billion instruction limit for update calls (HTTP POST/etc requests) (~10 seconds of computation)</li>
<li>2 MiB request size limit</li>
<li>3 MiB response size limit</li>
<li>4 GiB heap limit</li>
<li>High request latency relative to traditional web applications (think seconds not milliseconds)</li>
<li>High costs relative to traditional web applications (think ~10x traditional web costs)</li>
<li>StableBTreeMap memory id <code>254</code> is reserved for the stable memory file system</li>
</ul>
<p>Read more <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/maintain/resource-limits">here</a> for in-depth information on current ICP limitations.</p>
<!-- # Limitations

Keep in mind that this is not an exhaustive collection of the limitations of Azle or [ICP](https://internetcomputer.org/).

Let's discuss some important limitations of Azle and ICP that you are likely to run into. This is chapter is currently a work-in-progress:

-   `/api` can't be used locally
-   instruction limit (5 billion)
-   Message size limit (2 MiB request, 3 MiB response)
-   heap limit (4 GiB)
-   http outcalls request and response size, latency, and expense
-   1_000 update calls per sec
-   30_000 query calls per sec
-   stable memory limit (96 GiB)
-   no chunked http responses
-   Wasm binary limits (~10 MiB code section, ~90 MiB data section) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="reference_http/./autoreload.html">Autoreload</a></li>
<li><a href="reference_http/./environment_variables.html">Environment Variables</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoreload"><a class="header" href="#autoreload">Autoreload</a></h1>
<p>You can turn on automatic reloading of your canister's final compiled JavaScript by using the <code>AZLE_AUTORELOAD</code> environment variable during deploy:</p>
<pre><code class="language-bash">AZLE_AUTORELOAD=true dfx deploy
</code></pre>
<p>The autoreload feature watches all <code>.ts</code> and <code>.js</code> files recursively in the directory with your <code>dfx.json</code> file (the root directory of your project), excluding files found in <code>.azle</code>, <code>.dfx</code>, and <code>node_modules</code>.</p>
<p>Autoreload only works properly if you do not change the methods of your canister. HTTP-based canisters will generally work well with autoreload as the query and update methods <code>http_request</code> and <code>http_request_update</code> will not need to change often. Candid-based canisters with explicit <code>query</code> and <code>update</code> methods may require manual deploys more often.</p>
<p>Autoreload will not reload assets uploaded through the <code>assets</code> property of your <code>dfx.json</code>.</p>
<p>Setting <code>AZLE_AUTORELOAD=true</code> will create a new <code>dfx</code> identity and set it as a controller of your canister. By default it will be called <code>_azle_file_uploader_identity</code>. This name can be changed with the <code>AZLE_UPLOADER_IDENTITY_NAME</code> environment variable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h1>
<ul>
<li><a href="reference_http/environment_variables.html#azle_autoreload">AZLE_AUTORELOAD</a></li>
<li><a href="reference_http/environment_variables.html#azle_identity_storage_mode">AZLE_IDENTITY_STORAGE_MODE</a></li>
<li><a href="reference_http/environment_variables.html#azle_instruction_count">AZLE_INSTRUCTION_COUNT</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_num_runs">AZLE_PROPTEST_NUM_RUNS</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_path">AZLE_PROPTEST_PATH</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_quiet">AZLE_PROPTEST_QUIET</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_seed">AZLE_PROPTEST_SEED</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_verbose">AZLE_PROPTEST_VERBOSE</a></li>
<li><a href="reference_http/environment_variables.html#azle_test_fetch">AZLE_TEST_FETCH</a></li>
<li><a href="reference_http/">AZLE_UPLOADER_IDENTITY_NAME</a></li>
<li><a href="reference_http/environment_variables.html#azle_verbose">AZLE_VERBOSE</a></li>
</ul>
<h2 id="azle_autoreload"><a class="header" href="#azle_autoreload">AZLE_AUTORELOAD</a></h2>
<p>Set this to <code>true</code> to enable autoreloading of your TypeScript/JavaScript code when making any changes to <code>.ts</code> or <code>.js</code> files in your project.</p>
<h2 id="azle_identity_storage_mode"><a class="header" href="#azle_identity_storage_mode">AZLE_IDENTITY_STORAGE_MODE</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_instruction_count"><a class="header" href="#azle_instruction_count">AZLE_INSTRUCTION_COUNT</a></h2>
<p>Set this to <code>true</code> to see rough instruction counts just before JavaScript execution completes for calls.</p>
<h2 id="azle_proptest_num_runs"><a class="header" href="#azle_proptest_num_runs">AZLE_PROPTEST_NUM_RUNS</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_path"><a class="header" href="#azle_proptest_path">AZLE_PROPTEST_PATH</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_quiet"><a class="header" href="#azle_proptest_quiet">AZLE_PROPTEST_QUIET</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_seed"><a class="header" href="#azle_proptest_seed">AZLE_PROPTEST_SEED</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_verbose"><a class="header" href="#azle_proptest_verbose">AZLE_PROPTEST_VERBOSE</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_test_fetch"><a class="header" href="#azle_test_fetch">AZLE_TEST_FETCH</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_uploader_identity_name"><a class="header" href="#azle_uploader_identity_name">AZLE_UPLOADER_IDENTITY_NAME</a></h2>
<p>Change the name of the <code>dfx</code> identity added as a controller for uploading large assets and autoreload.</p>
<h2 id="azle_verbose"><a class="header" href="#azle_verbose">AZLE_VERBOSE</a></h2>
<p>Set this to <code>true</code> to enable more logging output during <code>dfx deploy</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
