var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
var __decoratorStart = (base2) => [, , , __create(base2?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n5 = fns && fns.length; i2 < n5; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access3, k = flags & 7, s = !!(flags & 8), p3 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p3 && !s && (target = target.prototype), k < 5 && (k > 3 || !p3) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p3 && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p3, access3 = ctx.access = { has: p3 ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access3.get = p3 ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access3.set = p3 ? (x, y2) => __privateSet(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p3 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p3 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p3 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/azle/node_modules/@sinonjs/text-encoding/lib/encoding-indexes.js
var require_encoding_indexes = __commonJS({
  "node_modules/azle/node_modules/@sinonjs/text-encoding/lib/encoding-indexes.js"(exports4, module) {
    (function(global2) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) {
        module.exports = global2;
      }
      global2["encoding-indexes"] = {
        "big5": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 17392, 19506, 17923, 17830, 17784, 160359, 19831, 17843, 162993, 19682, 163013, 15253, 18230, 18244, 19527, 19520, 148159, 144919, 160594, 159371, 159954, 19543, 172881, 18255, 17882, 19589, 162924, 19719, 19108, 18081, 158499, 29221, 154196, 137827, 146950, 147297, 26189, 22267, null, 32149, 22813, 166841, 15860, 38708, 162799, 23515, 138590, 23204, 13861, 171696, 23249, 23479, 23804, 26478, 34195, 170309, 29793, 29853, 14453, 138579, 145054, 155681, 16108, 153822, 15093, 31484, 40855, 147809, 166157, 143850, 133770, 143966, 17162, 33924, 40854, 37935, 18736, 34323, 22678, 38730, 37400, 31184, 31282, 26208, 27177, 34973, 29772, 31685, 26498, 31276, 21071, 36934, 13542, 29636, 155065, 29894, 40903, 22451, 18735, 21580, 16689, 145038, 22552, 31346, 162661, 35727, 18094, 159368, 16769, 155033, 31662, 140476, 40904, 140481, 140489, 140492, 40905, 34052, 144827, 16564, 40906, 17633, 175615, 25281, 28782, 40907, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 12736, 12737, 12738, 12739, 12740, 131340, 12741, 131281, 131277, 12742, 12743, 131275, 139240, 12744, 131274, 12745, 12746, 12747, 12748, 131342, 12749, 12750, 256, 193, 461, 192, 274, 201, 282, 200, 332, 211, 465, 210, null, 7870, null, 7872, 202, 257, 225, 462, 224, 593, 275, 233, 283, 232, 299, 237, 464, 236, 333, 243, 466, 242, 363, 250, 468, 249, 470, 472, 474, 476, 252, null, 7871, null, 7873, 234, 609, 9178, 9179, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 172969, 135493, null, 25866, null, null, 20029, 28381, 40270, 37343, null, null, 161589, 25745, 20250, 20264, 20392, 20822, 20852, 20892, 20964, 21153, 21160, 21307, 21326, 21457, 21464, 22242, 22768, 22788, 22791, 22834, 22836, 23398, 23454, 23455, 23706, 24198, 24635, 25993, 26622, 26628, 26725, 27982, 28860, 30005, 32420, 32428, 32442, 32455, 32463, 32479, 32518, 32567, 33402, 33487, 33647, 35270, 35774, 35810, 36710, 36711, 36718, 29713, 31996, 32205, 26950, 31433, 21031, null, null, null, null, 37260, 30904, 37214, 32956, null, 36107, 33014, 133607, null, null, 32927, 40647, 19661, 40393, 40460, 19518, 171510, 159758, 40458, 172339, 13761, null, 28314, 33342, 29977, null, 18705, 39532, 39567, 40857, 31111, 164972, 138698, 132560, 142054, 20004, 20097, 20096, 20103, 20159, 20203, 20279, 13388, 20413, 15944, 20483, 20616, 13437, 13459, 13477, 20870, 22789, 20955, 20988, 20997, 20105, 21113, 21136, 21287, 13767, 21417, 13649, 21424, 13651, 21442, 21539, 13677, 13682, 13953, 21651, 21667, 21684, 21689, 21712, 21743, 21784, 21795, 21800, 13720, 21823, 13733, 13759, 21975, 13765, 163204, 21797, null, 134210, 134421, 151851, 21904, 142534, 14828, 131905, 36422, 150968, 169189, 16467, 164030, 30586, 142392, 14900, 18389, 164189, 158194, 151018, 25821, 134524, 135092, 134357, 135412, 25741, 36478, 134806, 134155, 135012, 142505, 164438, 148691, null, 134470, 170573, 164073, 18420, 151207, 142530, 39602, 14951, 169460, 16365, 13574, 152263, 169940, 161992, 142660, 40302, 38933, null, 17369, 155813, 25780, 21731, 142668, 142282, 135287, 14843, 135279, 157402, 157462, 162208, 25834, 151634, 134211, 36456, 139681, 166732, 132913, null, 18443, 131497, 16378, 22643, 142733, null, 148936, 132348, 155799, 134988, 134550, 21881, 16571, 17338, null, 19124, 141926, 135325, 33194, 39157, 134556, 25465, 14846, 141173, 36288, 22177, 25724, 15939, null, 173569, 134665, 142031, 142537, null, 135368, 145858, 14738, 14854, 164507, 13688, 155209, 139463, 22098, 134961, 142514, 169760, 13500, 27709, 151099, null, null, 161140, 142987, 139784, 173659, 167117, 134778, 134196, 157724, 32659, 135375, 141315, 141625, 13819, 152035, 134796, 135053, 134826, 16275, 134960, 134471, 135503, 134732, null, 134827, 134057, 134472, 135360, 135485, 16377, 140950, 25650, 135085, 144372, 161337, 142286, 134526, 134527, 142417, 142421, 14872, 134808, 135367, 134958, 173618, 158544, 167122, 167321, 167114, 38314, 21708, 33476, 21945, null, 171715, 39974, 39606, 161630, 142830, 28992, 33133, 33004, 23580, 157042, 33076, 14231, 21343, 164029, 37302, 134906, 134671, 134775, 134907, 13789, 151019, 13833, 134358, 22191, 141237, 135369, 134672, 134776, 135288, 135496, 164359, 136277, 134777, 151120, 142756, 23124, 135197, 135198, 135413, 135414, 22428, 134673, 161428, 164557, 135093, 134779, 151934, 14083, 135094, 135552, 152280, 172733, 149978, 137274, 147831, 164476, 22681, 21096, 13850, 153405, 31666, 23400, 18432, 19244, 40743, 18919, 39967, 39821, 154484, 143677, 22011, 13810, 22153, 20008, 22786, 138177, 194680, 38737, 131206, 20059, 20155, 13630, 23587, 24401, 24516, 14586, 25164, 25909, 27514, 27701, 27706, 28780, 29227, 20012, 29357, 149737, 32594, 31035, 31993, 32595, 156266, 13505, null, 156491, 32770, 32896, 157202, 158033, 21341, 34916, 35265, 161970, 35744, 36125, 38021, 38264, 38271, 38376, 167439, 38886, 39029, 39118, 39134, 39267, 17e4, 40060, 40479, 40644, 27503, 63751, 20023, 131207, 38429, 25143, 38050, null, 20539, 28158, 171123, 40870, 15817, 34959, 147790, 28791, 23797, 19232, 152013, 13657, 154928, 24866, 166450, 36775, 37366, 29073, 26393, 29626, 144001, 172295, 15499, 137600, 19216, 30948, 29698, 20910, 165647, 16393, 27235, 172730, 16931, 34319, 133743, 31274, 170311, 166634, 38741, 28749, 21284, 139390, 37876, 30425, 166371, 40871, 30685, 20131, 20464, 20668, 20015, 20247, 40872, 21556, 32139, 22674, 22736, 138678, 24210, 24217, 24514, 141074, 25995, 144377, 26905, 27203, 146531, 27903, null, 29184, 148741, 29580, 16091, 150035, 23317, 29881, 35715, 154788, 153237, 31379, 31724, 31939, 32364, 33528, 34199, 40873, 34960, 40874, 36537, 40875, 36815, 34143, 39392, 37409, 40876, 167353, 136255, 16497, 17058, 23066, null, null, null, 39016, 26475, 17014, 22333, null, 34262, 149883, 33471, 160013, 19585, 159092, 23931, 158485, 159678, 40877, 40878, 23446, 40879, 26343, 32347, 28247, 31178, 15752, 17603, 143958, 141206, 17306, 17718, null, 23765, 146202, 35577, 23672, 15634, 144721, 23928, 40882, 29015, 17752, 147692, 138787, 19575, 14712, 13386, 131492, 158785, 35532, 20404, 131641, 22975, 33132, 38998, 170234, 24379, 134047, null, 139713, 166253, 16642, 18107, 168057, 16135, 40883, 172469, 16632, 14294, 18167, 158790, 16764, 165554, 160767, 17773, 14548, 152730, 17761, 17691, 19849, 19579, 19830, 17898, 16328, 150287, 13921, 17630, 17597, 16877, 23870, 23880, 23894, 15868, 14351, 23972, 23993, 14368, 14392, 24130, 24253, 24357, 24451, 14600, 14612, 14655, 14669, 24791, 24893, 23781, 14729, 25015, 25017, 25039, 14776, 25132, 25232, 25317, 25368, 14840, 22193, 14851, 25570, 25595, 25607, 25690, 14923, 25792, 23829, 22049, 40863, 14999, 25990, 15037, 26111, 26195, 15090, 26258, 15138, 26390, 15170, 26532, 26624, 15192, 26698, 26756, 15218, 15217, 15227, 26889, 26947, 29276, 26980, 27039, 27013, 15292, 27094, 15325, 27237, 27252, 27249, 27266, 15340, 27289, 15346, 27307, 27317, 27348, 27382, 27521, 27585, 27626, 27765, 27818, 15563, 27906, 27910, 27942, 28033, 15599, 28068, 28081, 28181, 28184, 28201, 28294, 166336, 28347, 28386, 28378, 40831, 28392, 28393, 28452, 28468, 15686, 147265, 28545, 28606, 15722, 15733, 29111, 23705, 15754, 28716, 15761, 28752, 28756, 28783, 28799, 28809, 131877, 17345, 13809, 134872, 147159, 22462, 159443, 28990, 153568, 13902, 27042, 166889, 23412, 31305, 153825, 169177, 31333, 31357, 154028, 31419, 31408, 31426, 31427, 29137, 156813, 16842, 31450, 31453, 31466, 16879, 21682, 154625, 31499, 31573, 31529, 152334, 154878, 31650, 31599, 33692, 154548, 158847, 31696, 33825, 31634, 31672, 154912, 15789, 154725, 33938, 31738, 31750, 31797, 154817, 31812, 31875, 149634, 31910, 26237, 148856, 31945, 31943, 31974, 31860, 31987, 31989, 31950, 32359, 17693, 159300, 32093, 159446, 29837, 32137, 32171, 28981, 32179, 32210, 147543, 155689, 32228, 15635, 32245, 137209, 32229, 164717, 32285, 155937, 155994, 32366, 32402, 17195, 37996, 32295, 32576, 32577, 32583, 31030, 156368, 39393, 32663, 156497, 32675, 136801, 131176, 17756, 145254, 17667, 164666, 32762, 156809, 32773, 32776, 32797, 32808, 32815, 172167, 158915, 32827, 32828, 32865, 141076, 18825, 157222, 146915, 157416, 26405, 32935, 166472, 33031, 33050, 22704, 141046, 27775, 156824, 151480, 25831, 136330, 33304, 137310, 27219, 150117, 150165, 17530, 33321, 133901, 158290, 146814, 20473, 136445, 34018, 33634, 158474, 149927, 144688, 137075, 146936, 33450, 26907, 194964, 16859, 34123, 33488, 33562, 134678, 137140, 14017, 143741, 144730, 33403, 33506, 33560, 147083, 159139, 158469, 158615, 144846, 15807, 33565, 21996, 33669, 17675, 159141, 33708, 33729, 33747, 13438, 159444, 27223, 34138, 13462, 159298, 143087, 33880, 154596, 33905, 15827, 17636, 27303, 33866, 146613, 31064, 33960, 158614, 159351, 159299, 34014, 33807, 33681, 17568, 33939, 34020, 154769, 16960, 154816, 17731, 34100, 23282, 159385, 17703, 34163, 17686, 26559, 34326, 165413, 165435, 34241, 159880, 34306, 136578, 159949, 194994, 17770, 34344, 13896, 137378, 21495, 160666, 34430, 34673, 172280, 34798, 142375, 34737, 34778, 34831, 22113, 34412, 26710, 17935, 34885, 34886, 161248, 146873, 161252, 34910, 34972, 18011, 34996, 34997, 25537, 35013, 30583, 161551, 35207, 35210, 35238, 35241, 35239, 35260, 166437, 35303, 162084, 162493, 35484, 30611, 37374, 35472, 162393, 31465, 162618, 147343, 18195, 162616, 29052, 35596, 35615, 152624, 152933, 35647, 35660, 35661, 35497, 150138, 35728, 35739, 35503, 136927, 17941, 34895, 35995, 163156, 163215, 195028, 14117, 163155, 36054, 163224, 163261, 36114, 36099, 137488, 36059, 28764, 36113, 150729, 16080, 36215, 36265, 163842, 135188, 149898, 15228, 164284, 160012, 31463, 36525, 36534, 36547, 37588, 36633, 36653, 164709, 164882, 36773, 37635, 172703, 133712, 36787, 18730, 166366, 165181, 146875, 24312, 143970, 36857, 172052, 165564, 165121, 140069, 14720, 159447, 36919, 165180, 162494, 36961, 165228, 165387, 37032, 165651, 37060, 165606, 37038, 37117, 37223, 15088, 37289, 37316, 31916, 166195, 138889, 37390, 27807, 37441, 37474, 153017, 37561, 166598, 146587, 166668, 153051, 134449, 37676, 37739, 166625, 166891, 28815, 23235, 166626, 166629, 18789, 37444, 166892, 166969, 166911, 37747, 37979, 36540, 38277, 38310, 37926, 38304, 28662, 17081, 140922, 165592, 135804, 146990, 18911, 27676, 38523, 38550, 16748, 38563, 159445, 25050, 38582, 30965, 166624, 38589, 21452, 18849, 158904, 131700, 156688, 168111, 168165, 150225, 137493, 144138, 38705, 34370, 38710, 18959, 17725, 17797, 150249, 28789, 23361, 38683, 38748, 168405, 38743, 23370, 168427, 38751, 37925, 20688, 143543, 143548, 38793, 38815, 38833, 38846, 38848, 38866, 38880, 152684, 38894, 29724, 169011, 38911, 38901, 168989, 162170, 19153, 38964, 38963, 38987, 39014, 15118, 160117, 15697, 132656, 147804, 153350, 39114, 39095, 39112, 39111, 19199, 159015, 136915, 21936, 39137, 39142, 39148, 37752, 39225, 150057, 19314, 170071, 170245, 39413, 39436, 39483, 39440, 39512, 153381, 14020, 168113, 170965, 39648, 39650, 170757, 39668, 19470, 39700, 39725, 165376, 20532, 39732, 158120, 14531, 143485, 39760, 39744, 171326, 23109, 137315, 39822, 148043, 39938, 39935, 39948, 171624, 40404, 171959, 172434, 172459, 172257, 172323, 172511, 40318, 40323, 172340, 40462, 26760, 40388, 139611, 172435, 172576, 137531, 172595, 40249, 172217, 172724, 40592, 40597, 40606, 40610, 19764, 40618, 40623, 148324, 40641, 15200, 14821, 15645, 20274, 14270, 166955, 40706, 40712, 19350, 37924, 159138, 40727, 40726, 40761, 22175, 22154, 40773, 39352, 168075, 38898, 33919, 40802, 40809, 31452, 40846, 29206, 19390, 149877, 149947, 29047, 150008, 148296, 150097, 29598, 166874, 137466, 31135, 166270, 167478, 37737, 37875, 166468, 37612, 37761, 37835, 166252, 148665, 29207, 16107, 30578, 31299, 28880, 148595, 148472, 29054, 137199, 28835, 137406, 144793, 16071, 137349, 152623, 137208, 14114, 136955, 137273, 14049, 137076, 137425, 155467, 14115, 136896, 22363, 150053, 136190, 135848, 136134, 136374, 34051, 145062, 34051, 33877, 149908, 160101, 146993, 152924, 147195, 159826, 17652, 145134, 170397, 159526, 26617, 14131, 15381, 15847, 22636, 137506, 26640, 16471, 145215, 147681, 147595, 147727, 158753, 21707, 22174, 157361, 22162, 135135, 134056, 134669, 37830, 166675, 37788, 20216, 20779, 14361, 148534, 20156, 132197, 131967, 20299, 20362, 153169, 23144, 131499, 132043, 14745, 131850, 132116, 13365, 20265, 131776, 167603, 131701, 35546, 131596, 20120, 20685, 20749, 20386, 20227, 150030, 147082, 20290, 20526, 20588, 20609, 20428, 20453, 20568, 20732, 20825, 20827, 20829, 20830, 28278, 144789, 147001, 147135, 28018, 137348, 147081, 20904, 20931, 132576, 17629, 132259, 132242, 132241, 36218, 166556, 132878, 21081, 21156, 133235, 21217, 37742, 18042, 29068, 148364, 134176, 149932, 135396, 27089, 134685, 29817, 16094, 29849, 29716, 29782, 29592, 19342, 150204, 147597, 21456, 13700, 29199, 147657, 21940, 131909, 21709, 134086, 22301, 37469, 38644, 37734, 22493, 22413, 22399, 13886, 22731, 23193, 166470, 136954, 137071, 136976, 23084, 22968, 37519, 23166, 23247, 23058, 153926, 137715, 137313, 148117, 14069, 27909, 29763, 23073, 155267, 23169, 166871, 132115, 37856, 29836, 135939, 28933, 18802, 37896, 166395, 37821, 14240, 23582, 23710, 24158, 24136, 137622, 137596, 146158, 24269, 23375, 137475, 137476, 14081, 137376, 14045, 136958, 14035, 33066, 166471, 138682, 144498, 166312, 24332, 24334, 137511, 137131, 23147, 137019, 23364, 34324, 161277, 34912, 24702, 141408, 140843, 24539, 16056, 140719, 140734, 168072, 159603, 25024, 131134, 131142, 140827, 24985, 24984, 24693, 142491, 142599, 149204, 168269, 25713, 149093, 142186, 14889, 142114, 144464, 170218, 142968, 25399, 173147, 25782, 25393, 25553, 149987, 142695, 25252, 142497, 25659, 25963, 26994, 15348, 143502, 144045, 149897, 144043, 21773, 144096, 137433, 169023, 26318, 144009, 143795, 15072, 16784, 152964, 166690, 152975, 136956, 152923, 152613, 30958, 143619, 137258, 143924, 13412, 143887, 143746, 148169, 26254, 159012, 26219, 19347, 26160, 161904, 138731, 26211, 144082, 144097, 26142, 153714, 14545, 145466, 145340, 15257, 145314, 144382, 29904, 15254, 26511, 149034, 26806, 26654, 15300, 27326, 14435, 145365, 148615, 27187, 27218, 27337, 27397, 137490, 25873, 26776, 27212, 15319, 27258, 27479, 147392, 146586, 37792, 37618, 166890, 166603, 37513, 163870, 166364, 37991, 28069, 28427, 149996, 28007, 147327, 15759, 28164, 147516, 23101, 28170, 22599, 27940, 30786, 28987, 148250, 148086, 28913, 29264, 29319, 29332, 149391, 149285, 20857, 150180, 132587, 29818, 147192, 144991, 150090, 149783, 155617, 16134, 16049, 150239, 166947, 147253, 24743, 16115, 29900, 29756, 37767, 29751, 17567, 159210, 17745, 30083, 16227, 150745, 150790, 16216, 30037, 30323, 173510, 15129, 29800, 166604, 149931, 149902, 15099, 15821, 150094, 16127, 149957, 149747, 37370, 22322, 37698, 166627, 137316, 20703, 152097, 152039, 30584, 143922, 30478, 30479, 30587, 149143, 145281, 14942, 149744, 29752, 29851, 16063, 150202, 150215, 16584, 150166, 156078, 37639, 152961, 30750, 30861, 30856, 30930, 29648, 31065, 161601, 153315, 16654, 31131, 33942, 31141, 27181, 147194, 31290, 31220, 16750, 136934, 16690, 37429, 31217, 134476, 149900, 131737, 146874, 137070, 13719, 21867, 13680, 13994, 131540, 134157, 31458, 23129, 141045, 154287, 154268, 23053, 131675, 30960, 23082, 154566, 31486, 16889, 31837, 31853, 16913, 154547, 155324, 155302, 31949, 150009, 137136, 31886, 31868, 31918, 27314, 32220, 32263, 32211, 32590, 156257, 155996, 162632, 32151, 155266, 17002, 158581, 133398, 26582, 131150, 144847, 22468, 156690, 156664, 149858, 32733, 31527, 133164, 154345, 154947, 31500, 155150, 39398, 34373, 39523, 27164, 144447, 14818, 150007, 157101, 39455, 157088, 33920, 160039, 158929, 17642, 33079, 17410, 32966, 33033, 33090, 157620, 39107, 158274, 33378, 33381, 158289, 33875, 159143, 34320, 160283, 23174, 16767, 137280, 23339, 137377, 23268, 137432, 34464, 195004, 146831, 34861, 160802, 23042, 34926, 20293, 34951, 35007, 35046, 35173, 35149, 153219, 35156, 161669, 161668, 166901, 166873, 166812, 166393, 16045, 33955, 18165, 18127, 14322, 35389, 35356, 169032, 24397, 37419, 148100, 26068, 28969, 28868, 137285, 40301, 35999, 36073, 163292, 22938, 30659, 23024, 17262, 14036, 36394, 36519, 150537, 36656, 36682, 17140, 27736, 28603, 140065, 18587, 28537, 28299, 137178, 39913, 14005, 149807, 37051, 37015, 21873, 18694, 37307, 37892, 166475, 16482, 166652, 37927, 166941, 166971, 34021, 35371, 38297, 38311, 38295, 38294, 167220, 29765, 16066, 149759, 150082, 148458, 16103, 143909, 38543, 167655, 167526, 167525, 16076, 149997, 150136, 147438, 29714, 29803, 16124, 38721, 168112, 26695, 18973, 168083, 153567, 38749, 37736, 166281, 166950, 166703, 156606, 37562, 23313, 35689, 18748, 29689, 147995, 38811, 38769, 39224, 134950, 24001, 166853, 150194, 38943, 169178, 37622, 169431, 37349, 17600, 166736, 150119, 166756, 39132, 166469, 16128, 37418, 18725, 33812, 39227, 39245, 162566, 15869, 39323, 19311, 39338, 39516, 166757, 153800, 27279, 39457, 23294, 39471, 170225, 19344, 170312, 39356, 19389, 19351, 37757, 22642, 135938, 22562, 149944, 136424, 30788, 141087, 146872, 26821, 15741, 37976, 14631, 24912, 141185, 141675, 24839, 40015, 40019, 40059, 39989, 39952, 39807, 39887, 171565, 39839, 172533, 172286, 40225, 19630, 147716, 40472, 19632, 40204, 172468, 172269, 172275, 170287, 40357, 33981, 159250, 159711, 158594, 34300, 17715, 159140, 159364, 159216, 33824, 34286, 159232, 145367, 155748, 31202, 144796, 144960, 18733, 149982, 15714, 37851, 37566, 37704, 131775, 30905, 37495, 37965, 20452, 13376, 36964, 152925, 30781, 30804, 30902, 30795, 137047, 143817, 149825, 13978, 20338, 28634, 28633, 28702, 28702, 21524, 147893, 22459, 22771, 22410, 40214, 22487, 28980, 13487, 147884, 29163, 158784, 151447, 23336, 137141, 166473, 24844, 23246, 23051, 17084, 148616, 14124, 19323, 166396, 37819, 37816, 137430, 134941, 33906, 158912, 136211, 148218, 142374, 148417, 22932, 146871, 157505, 32168, 155995, 155812, 149945, 149899, 166394, 37605, 29666, 16105, 29876, 166755, 137375, 16097, 150195, 27352, 29683, 29691, 16086, 150078, 150164, 137177, 150118, 132007, 136228, 149989, 29768, 149782, 28837, 149878, 37508, 29670, 37727, 132350, 37681, 166606, 166422, 37766, 166887, 153045, 18741, 166530, 29035, 149827, 134399, 22180, 132634, 134123, 134328, 21762, 31172, 137210, 32254, 136898, 150096, 137298, 17710, 37889, 14090, 166592, 149933, 22960, 137407, 137347, 160900, 23201, 14050, 146779, 14e3, 37471, 23161, 166529, 137314, 37748, 15565, 133812, 19094, 14730, 20724, 15721, 15692, 136092, 29045, 17147, 164376, 28175, 168164, 17643, 27991, 163407, 28775, 27823, 15574, 147437, 146989, 28162, 28428, 15727, 132085, 30033, 14012, 13512, 18048, 16090, 18545, 22980, 37486, 18750, 36673, 166940, 158656, 22546, 22472, 14038, 136274, 28926, 148322, 150129, 143331, 135856, 140221, 26809, 26983, 136088, 144613, 162804, 145119, 166531, 145366, 144378, 150687, 27162, 145069, 158903, 33854, 17631, 17614, 159014, 159057, 158850, 159710, 28439, 160009, 33597, 137018, 33773, 158848, 159827, 137179, 22921, 23170, 137139, 23137, 23153, 137477, 147964, 14125, 23023, 137020, 14023, 29070, 37776, 26266, 148133, 23150, 23083, 148115, 27179, 147193, 161590, 148571, 148170, 28957, 148057, 166369, 20400, 159016, 23746, 148686, 163405, 148413, 27148, 148054, 135940, 28838, 28979, 148457, 15781, 27871, 194597, 150095, 32357, 23019, 23855, 15859, 24412, 150109, 137183, 32164, 33830, 21637, 146170, 144128, 131604, 22398, 133333, 132633, 16357, 139166, 172726, 28675, 168283, 23920, 29583, 31955, 166489, 168992, 20424, 32743, 29389, 29456, 162548, 29496, 29497, 153334, 29505, 29512, 16041, 162584, 36972, 29173, 149746, 29665, 33270, 16074, 30476, 16081, 27810, 22269, 29721, 29726, 29727, 16098, 16112, 16116, 16122, 29907, 16142, 16211, 30018, 30061, 30066, 30093, 16252, 30152, 30172, 16320, 30285, 16343, 30324, 16348, 30330, 151388, 29064, 22051, 35200, 22633, 16413, 30531, 16441, 26465, 16453, 13787, 30616, 16490, 16495, 23646, 30654, 30667, 22770, 30744, 28857, 30748, 16552, 30777, 30791, 30801, 30822, 33864, 152885, 31027, 26627, 31026, 16643, 16649, 31121, 31129, 36795, 31238, 36796, 16743, 31377, 16818, 31420, 33401, 16836, 31439, 31451, 16847, 20001, 31586, 31596, 31611, 31762, 31771, 16992, 17018, 31867, 31900, 17036, 31928, 17044, 31981, 36755, 28864, 134351, 32207, 32212, 32208, 32253, 32686, 32692, 29343, 17303, 32800, 32805, 31545, 32814, 32817, 32852, 15820, 22452, 28832, 32951, 33001, 17389, 33036, 29482, 33038, 33042, 30048, 33044, 17409, 15161, 33110, 33113, 33114, 17427, 22586, 33148, 33156, 17445, 33171, 17453, 33189, 22511, 33217, 33252, 33364, 17551, 33446, 33398, 33482, 33496, 33535, 17584, 33623, 38505, 27018, 33797, 28917, 33892, 24803, 33928, 17668, 33982, 34017, 34040, 34064, 34104, 34130, 17723, 34159, 34160, 34272, 17783, 34418, 34450, 34482, 34543, 38469, 34699, 17926, 17943, 34990, 35071, 35108, 35143, 35217, 162151, 35369, 35384, 35476, 35508, 35921, 36052, 36082, 36124, 18328, 22623, 36291, 18413, 20206, 36410, 21976, 22356, 36465, 22005, 36528, 18487, 36558, 36578, 36580, 36589, 36594, 36791, 36801, 36810, 36812, 36915, 39364, 18605, 39136, 37395, 18718, 37416, 37464, 37483, 37553, 37550, 37567, 37603, 37611, 37619, 37620, 37629, 37699, 37764, 37805, 18757, 18769, 40639, 37911, 21249, 37917, 37933, 37950, 18794, 37972, 38009, 38189, 38306, 18855, 38388, 38451, 18917, 26528, 18980, 38720, 18997, 38834, 38850, 22100, 19172, 24808, 39097, 19225, 39153, 22596, 39182, 39193, 20916, 39196, 39223, 39234, 39261, 39266, 19312, 39365, 19357, 39484, 39695, 31363, 39785, 39809, 39901, 39921, 39924, 19565, 39968, 14191, 138178, 40265, 39994, 40702, 22096, 40339, 40381, 40384, 40444, 38134, 36790, 40571, 40620, 40625, 40637, 40646, 38108, 40674, 40689, 40696, 31432, 40772, 131220, 131767, 132e3, 26906, 38083, 22956, 132311, 22592, 38081, 14265, 132565, 132629, 132726, 136890, 22359, 29043, 133826, 133837, 134079, 21610, 194619, 134091, 21662, 134139, 134203, 134227, 134245, 134268, 24807, 134285, 22138, 134325, 134365, 134381, 134511, 134578, 134600, 26965, 39983, 34725, 134660, 134670, 134871, 135056, 134957, 134771, 23584, 135100, 24075, 135260, 135247, 135286, 26398, 135291, 135304, 135318, 13895, 135359, 135379, 135471, 135483, 21348, 33965, 135907, 136053, 135990, 35713, 136567, 136729, 137155, 137159, 20088, 28859, 137261, 137578, 137773, 137797, 138282, 138352, 138412, 138952, 25283, 138965, 139029, 29080, 26709, 139333, 27113, 14024, 139900, 140247, 140282, 141098, 141425, 141647, 33533, 141671, 141715, 142037, 35237, 142056, 36768, 142094, 38840, 142143, 38983, 39613, 142412, null, 142472, 142519, 154600, 142600, 142610, 142775, 142741, 142914, 143220, 143308, 143411, 143462, 144159, 144350, 24497, 26184, 26303, 162425, 144743, 144883, 29185, 149946, 30679, 144922, 145174, 32391, 131910, 22709, 26382, 26904, 146087, 161367, 155618, 146961, 147129, 161278, 139418, 18640, 19128, 147737, 166554, 148206, 148237, 147515, 148276, 148374, 150085, 132554, 20946, 132625, 22943, 138920, 15294, 146687, 148484, 148694, 22408, 149108, 14747, 149295, 165352, 170441, 14178, 139715, 35678, 166734, 39382, 149522, 149755, 150037, 29193, 150208, 134264, 22885, 151205, 151430, 132985, 36570, 151596, 21135, 22335, 29041, 152217, 152601, 147274, 150183, 21948, 152646, 152686, 158546, 37332, 13427, 152895, 161330, 152926, 18200, 152930, 152934, 153543, 149823, 153693, 20582, 13563, 144332, 24798, 153859, 18300, 166216, 154286, 154505, 154630, 138640, 22433, 29009, 28598, 155906, 162834, 36950, 156082, 151450, 35682, 156674, 156746, 23899, 158711, 36662, 156804, 137500, 35562, 150006, 156808, 147439, 156946, 19392, 157119, 157365, 141083, 37989, 153569, 24981, 23079, 194765, 20411, 22201, 148769, 157436, 20074, 149812, 38486, 28047, 158909, 13848, 35191, 157593, 157806, 156689, 157790, 29151, 157895, 31554, 168128, 133649, 157990, 37124, 158009, 31301, 40432, 158202, 39462, 158253, 13919, 156777, 131105, 31107, 158260, 158555, 23852, 144665, 33743, 158621, 18128, 158884, 30011, 34917, 159150, 22710, 14108, 140685, 159819, 160205, 15444, 160384, 160389, 37505, 139642, 160395, 37680, 160486, 149968, 27705, 38047, 160848, 134904, 34855, 35061, 141606, 164979, 137137, 28344, 150058, 137248, 14756, 14009, 23568, 31203, 17727, 26294, 171181, 170148, 35139, 161740, 161880, 22230, 16607, 136714, 14753, 145199, 164072, 136133, 29101, 33638, 162269, 168360, 23143, 19639, 159919, 166315, 162301, 162314, 162571, 163174, 147834, 31555, 31102, 163849, 28597, 172767, 27139, 164632, 21410, 159239, 37823, 26678, 38749, 164207, 163875, 158133, 136173, 143919, 163912, 23941, 166960, 163971, 22293, 38947, 166217, 23979, 149896, 26046, 27093, 21458, 150181, 147329, 15377, 26422, 163984, 164084, 164142, 139169, 164175, 164233, 164271, 164378, 164614, 164655, 164746, 13770, 164968, 165546, 18682, 25574, 166230, 30728, 37461, 166328, 17394, 166375, 17375, 166376, 166726, 166868, 23032, 166921, 36619, 167877, 168172, 31569, 168208, 168252, 15863, 168286, 150218, 36816, 29327, 22155, 169191, 169449, 169392, 169400, 169778, 170193, 170313, 170346, 170435, 170536, 170766, 171354, 171419, 32415, 171768, 171811, 19620, 38215, 172691, 29090, 172799, 19857, 36882, 173515, 19868, 134300, 36798, 21953, 36794, 140464, 36793, 150163, 17673, 32383, 28502, 27313, 20202, 13540, 166700, 161949, 14138, 36480, 137205, 163876, 166764, 166809, 162366, 157359, 15851, 161365, 146615, 153141, 153942, 20122, 155265, 156248, 22207, 134765, 36366, 23405, 147080, 150686, 25566, 25296, 137206, 137339, 25904, 22061, 154698, 21530, 152337, 15814, 171416, 19581, 22050, 22046, 32585, 155352, 22901, 146752, 34672, 19996, 135146, 134473, 145082, 33047, 40286, 36120, 30267, 40005, 30286, 30649, 37701, 21554, 33096, 33527, 22053, 33074, 33816, 32957, 21994, 31074, 22083, 21526, 134813, 13774, 22021, 22001, 26353, 164578, 13869, 30004, 22e3, 21946, 21655, 21874, 134209, 134294, 24272, 151880, 134774, 142434, 134818, 40619, 32090, 21982, 135285, 25245, 38765, 21652, 36045, 29174, 37238, 25596, 25529, 25598, 21865, 142147, 40050, 143027, 20890, 13535, 134567, 20903, 21581, 21790, 21779, 30310, 36397, 157834, 30129, 32950, 34820, 34694, 35015, 33206, 33820, 135361, 17644, 29444, 149254, 23440, 33547, 157843, 22139, 141044, 163119, 147875, 163187, 159440, 160438, 37232, 135641, 37384, 146684, 173737, 134828, 134905, 29286, 138402, 18254, 151490, 163833, 135147, 16634, 40029, 25887, 142752, 18675, 149472, 171388, 135148, 134666, 24674, 161187, 135149, null, 155720, 135559, 29091, 32398, 40272, 19994, 19972, 13687, 23309, 27826, 21351, 13996, 14812, 21373, 13989, 149016, 22682, 150382, 33325, 21579, 22442, 154261, 133497, null, 14930, 140389, 29556, 171692, 19721, 39917, 146686, 171824, 19547, 151465, 169374, 171998, 33884, 146870, 160434, 157619, 145184, 25390, 32037, 147191, 146988, 14890, 36872, 21196, 15988, 13946, 17897, 132238, 30272, 23280, 134838, 30842, 163630, 22695, 16575, 22140, 39819, 23924, 30292, 173108, 40581, 19681, 30201, 14331, 24857, 143578, 148466, null, 22109, 135849, 22439, 149859, 171526, 21044, 159918, 13741, 27722, 40316, 31830, 39737, 22494, 137068, 23635, 25811, 169168, 156469, 160100, 34477, 134440, 159010, 150242, 134513, null, 20990, 139023, 23950, 38659, 138705, 40577, 36940, 31519, 39682, 23761, 31651, 25192, 25397, 39679, 31695, 39722, 31870, 39726, 31810, 31878, 39957, 31740, 39689, 40727, 39963, 149822, 40794, 21875, 23491, 20477, 40600, 20466, 21088, 15878, 21201, 22375, 20566, 22967, 24082, 38856, 40363, 36700, 21609, 38836, 39232, 38842, 21292, 24880, 26924, 21466, 39946, 40194, 19515, 38465, 27008, 20646, 30022, 137069, 39386, 21107, null, 37209, 38529, 37212, null, 37201, 167575, 25471, 159011, 27338, 22033, 37262, 30074, 25221, 132092, 29519, 31856, 154657, 146685, null, 149785, 30422, 39837, 20010, 134356, 33726, 34882, null, 23626, 27072, 20717, 22394, 21023, 24053, 20174, 27697, 131570, 20281, 21660, 21722, 21146, 36226, 13822, 24332, 13811, null, 27474, 37244, 40869, 39831, 38958, 39092, 39610, 40616, 40580, 29050, 31508, null, 27642, 34840, 32632, null, 22048, 173642, 36471, 40787, null, 36308, 36431, 40476, 36353, 25218, 164733, 36392, 36469, 31443, 150135, 31294, 30936, 27882, 35431, 30215, 166490, 40742, 27854, 34774, 30147, 172722, 30803, 194624, 36108, 29410, 29553, 35629, 29442, 29937, 36075, 150203, 34351, 24506, 34976, 17591, null, 137275, 159237, null, 35454, 140571, null, 24829, 30311, 39639, 40260, 37742, 39823, 34805, null, 34831, 36087, 29484, 38689, 39856, 13782, 29362, 19463, 31825, 39242, 155993, 24921, 19460, 40598, 24957, null, 22367, 24943, 25254, 25145, 25294, 14940, 25058, 21418, 144373, 25444, 26626, 13778, 23895, 166850, 36826, 167481, null, 20697, 138566, 30982, 21298, 38456, 134971, 16485, null, 30718, null, 31938, 155418, 31962, 31277, 32870, 32867, 32077, 29957, 29938, 35220, 33306, 26380, 32866, 160902, 32859, 29936, 33027, 30500, 35209, 157644, 30035, 159441, 34729, 34766, 33224, 34700, 35401, 36013, 35651, 30507, 29944, 34010, 13877, 27058, 36262, null, 35241, 29800, 28089, 34753, 147473, 29927, 15835, 29046, 24740, 24988, 15569, 29026, 24695, null, 32625, 166701, 29264, 24809, 19326, 21024, 15384, 146631, 155351, 161366, 152881, 137540, 135934, 170243, 159196, 159917, 23745, 156077, 166415, 145015, 131310, 157766, 151310, 17762, 23327, 156492, 40784, 40614, 156267, 12288, 65292, 12289, 12290, 65294, 8231, 65307, 65306, 65311, 65281, 65072, 8230, 8229, 65104, 65105, 65106, 183, 65108, 65109, 65110, 65111, 65372, 8211, 65073, 8212, 65075, 9588, 65076, 65103, 65288, 65289, 65077, 65078, 65371, 65373, 65079, 65080, 12308, 12309, 65081, 65082, 12304, 12305, 65083, 65084, 12298, 12299, 65085, 65086, 12296, 12297, 65087, 65088, 12300, 12301, 65089, 65090, 12302, 12303, 65091, 65092, 65113, 65114, 65115, 65116, 65117, 65118, 8216, 8217, 8220, 8221, 12317, 12318, 8245, 8242, 65283, 65286, 65290, 8251, 167, 12291, 9675, 9679, 9651, 9650, 9678, 9734, 9733, 9671, 9670, 9633, 9632, 9661, 9660, 12963, 8453, 175, 65507, 65343, 717, 65097, 65098, 65101, 65102, 65099, 65100, 65119, 65120, 65121, 65291, 65293, 215, 247, 177, 8730, 65308, 65310, 65309, 8806, 8807, 8800, 8734, 8786, 8801, 65122, 65123, 65124, 65125, 65126, 65374, 8745, 8746, 8869, 8736, 8735, 8895, 13266, 13265, 8747, 8750, 8757, 8756, 9792, 9794, 8853, 8857, 8593, 8595, 8592, 8594, 8598, 8599, 8601, 8600, 8741, 8739, 65295, 65340, 8725, 65128, 65284, 65509, 12306, 65504, 65505, 65285, 65312, 8451, 8457, 65129, 65130, 65131, 13269, 13212, 13213, 13214, 13262, 13217, 13198, 13199, 13252, 176, 20825, 20827, 20830, 20829, 20833, 20835, 21991, 29929, 31950, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9615, 9614, 9613, 9612, 9611, 9610, 9609, 9532, 9524, 9516, 9508, 9500, 9620, 9472, 9474, 9621, 9484, 9488, 9492, 9496, 9581, 9582, 9584, 9583, 9552, 9566, 9578, 9569, 9698, 9699, 9701, 9700, 9585, 9586, 9587, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 12321, 12322, 12323, 12324, 12325, 12326, 12327, 12328, 12329, 21313, 21316, 21317, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, 12549, 12550, 12551, 12552, 12553, 12554, 12555, 12556, 12557, 12558, 12559, 12560, 12561, 12562, 12563, 12564, 12565, 12566, 12567, 12568, 12569, 12570, 12571, 12572, 12573, 12574, 12575, 12576, 12577, 12578, 12579, 12580, 12581, 12582, 12583, 12584, 12585, 729, 713, 714, 711, 715, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9245, 9246, 9247, 9249, 8364, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 19968, 20057, 19969, 19971, 20035, 20061, 20102, 20108, 20154, 20799, 20837, 20843, 20960, 20992, 20993, 21147, 21269, 21313, 21340, 21448, 19977, 19979, 19976, 19978, 20011, 20024, 20961, 20037, 20040, 20063, 20062, 20110, 20129, 20800, 20995, 21242, 21315, 21449, 21475, 22303, 22763, 22805, 22823, 22899, 23376, 23377, 23379, 23544, 23567, 23586, 23608, 23665, 24029, 24037, 24049, 24050, 24051, 24062, 24178, 24318, 24331, 24339, 25165, 19985, 19984, 19981, 20013, 20016, 20025, 20043, 23609, 20104, 20113, 20117, 20114, 20116, 20130, 20161, 20160, 20163, 20166, 20167, 20173, 20170, 20171, 20164, 20803, 20801, 20839, 20845, 20846, 20844, 20887, 20982, 20998, 20999, 21e3, 21243, 21246, 21247, 21270, 21305, 21320, 21319, 21317, 21342, 21380, 21451, 21450, 21453, 22764, 22825, 22827, 22826, 22829, 23380, 23569, 23588, 23610, 23663, 24052, 24187, 24319, 24340, 24341, 24515, 25096, 25142, 25163, 25166, 25903, 25991, 26007, 26020, 26041, 26085, 26352, 26376, 26408, 27424, 27490, 27513, 27595, 27604, 27611, 27663, 27700, 28779, 29226, 29238, 29243, 29255, 29273, 29275, 29356, 29579, 19993, 19990, 19989, 19988, 19992, 20027, 20045, 20047, 20046, 20197, 20184, 20180, 20181, 20182, 20183, 20195, 20196, 20185, 20190, 20805, 20804, 20873, 20874, 20908, 20985, 20986, 20984, 21002, 21152, 21151, 21253, 21254, 21271, 21277, 20191, 21322, 21321, 21345, 21344, 21359, 21358, 21435, 21487, 21476, 21491, 21484, 21486, 21481, 21480, 21500, 21496, 21493, 21483, 21478, 21482, 21490, 21489, 21488, 21477, 21485, 21499, 22235, 22234, 22806, 22830, 22833, 22900, 22902, 23381, 23427, 23612, 24040, 24039, 24038, 24066, 24067, 24179, 24188, 24321, 24344, 24343, 24517, 25098, 25171, 25172, 25170, 25169, 26021, 26086, 26414, 26412, 26410, 26411, 26413, 27491, 27597, 27665, 27664, 27704, 27713, 27712, 27710, 29359, 29572, 29577, 29916, 29926, 29976, 29983, 29992, 29993, 3e4, 30001, 30002, 30003, 30091, 30333, 30382, 30399, 30446, 30683, 30690, 30707, 31034, 31166, 31348, 31435, 19998, 19999, 20050, 20051, 20073, 20121, 20132, 20134, 20133, 20223, 20233, 20249, 20234, 20245, 20237, 20240, 20241, 20239, 20210, 20214, 20219, 20208, 20211, 20221, 20225, 20235, 20809, 20807, 20806, 20808, 20840, 20849, 20877, 20912, 21015, 21009, 21010, 21006, 21014, 21155, 21256, 21281, 21280, 21360, 21361, 21513, 21519, 21516, 21514, 21520, 21505, 21515, 21508, 21521, 21517, 21512, 21507, 21518, 21510, 21522, 22240, 22238, 22237, 22323, 22320, 22312, 22317, 22316, 22319, 22313, 22809, 22810, 22839, 22840, 22916, 22904, 22915, 22909, 22905, 22914, 22913, 23383, 23384, 23431, 23432, 23429, 23433, 23546, 23574, 23673, 24030, 24070, 24182, 24180, 24335, 24347, 24537, 24534, 25102, 25100, 25101, 25104, 25187, 25179, 25176, 25910, 26089, 26088, 26092, 26093, 26354, 26355, 26377, 26429, 26420, 26417, 26421, 27425, 27492, 27515, 27670, 27741, 27735, 27737, 27743, 27744, 27728, 27733, 27745, 27739, 27725, 27726, 28784, 29279, 29277, 30334, 31481, 31859, 31992, 32566, 32650, 32701, 32769, 32771, 32780, 32786, 32819, 32895, 32905, 32907, 32908, 33251, 33258, 33267, 33276, 33292, 33307, 33311, 33390, 33394, 33406, 34411, 34880, 34892, 34915, 35199, 38433, 20018, 20136, 20301, 20303, 20295, 20311, 20318, 20276, 20315, 20309, 20272, 20304, 20305, 20285, 20282, 20280, 20291, 20308, 20284, 20294, 20323, 20316, 20320, 20271, 20302, 20278, 20313, 20317, 20296, 20314, 20812, 20811, 20813, 20853, 20918, 20919, 21029, 21028, 21033, 21034, 21032, 21163, 21161, 21162, 21164, 21283, 21363, 21365, 21533, 21549, 21534, 21566, 21542, 21582, 21543, 21574, 21571, 21555, 21576, 21570, 21531, 21545, 21578, 21561, 21563, 21560, 21550, 21557, 21558, 21536, 21564, 21568, 21553, 21547, 21535, 21548, 22250, 22256, 22244, 22251, 22346, 22353, 22336, 22349, 22343, 22350, 22334, 22352, 22351, 22331, 22767, 22846, 22941, 22930, 22952, 22942, 22947, 22937, 22934, 22925, 22948, 22931, 22922, 22949, 23389, 23388, 23386, 23387, 23436, 23435, 23439, 23596, 23616, 23617, 23615, 23614, 23696, 23697, 23700, 23692, 24043, 24076, 24207, 24199, 24202, 24311, 24324, 24351, 24420, 24418, 24439, 24441, 24536, 24524, 24535, 24525, 24561, 24555, 24568, 24554, 25106, 25105, 25220, 25239, 25238, 25216, 25206, 25225, 25197, 25226, 25212, 25214, 25209, 25203, 25234, 25199, 25240, 25198, 25237, 25235, 25233, 25222, 25913, 25915, 25912, 26097, 26356, 26463, 26446, 26447, 26448, 26449, 26460, 26454, 26462, 26441, 26438, 26464, 26451, 26455, 27493, 27599, 27714, 27742, 27801, 27777, 27784, 27785, 27781, 27803, 27754, 27770, 27792, 27760, 27788, 27752, 27798, 27794, 27773, 27779, 27762, 27774, 27764, 27782, 27766, 27789, 27796, 27800, 27778, 28790, 28796, 28797, 28792, 29282, 29281, 29280, 29380, 29378, 29590, 29996, 29995, 30007, 30008, 30338, 30447, 30691, 31169, 31168, 31167, 31350, 31995, 32597, 32918, 32915, 32925, 32920, 32923, 32922, 32946, 33391, 33426, 33419, 33421, 35211, 35282, 35328, 35895, 35910, 35925, 35997, 36196, 36208, 36275, 36523, 36554, 36763, 36784, 36802, 36806, 36805, 36804, 24033, 37009, 37026, 37034, 37030, 37027, 37193, 37318, 37324, 38450, 38446, 38449, 38442, 38444, 20006, 20054, 20083, 20107, 20123, 20126, 20139, 20140, 20335, 20381, 20365, 20339, 20351, 20332, 20379, 20363, 20358, 20355, 20336, 20341, 20360, 20329, 20347, 20374, 20350, 20367, 20369, 20346, 20820, 20818, 20821, 20841, 20855, 20854, 20856, 20925, 20989, 21051, 21048, 21047, 21050, 21040, 21038, 21046, 21057, 21182, 21179, 21330, 21332, 21331, 21329, 21350, 21367, 21368, 21369, 21462, 21460, 21463, 21619, 21621, 21654, 21624, 21653, 21632, 21627, 21623, 21636, 21650, 21638, 21628, 21648, 21617, 21622, 21644, 21658, 21602, 21608, 21643, 21629, 21646, 22266, 22403, 22391, 22378, 22377, 22369, 22374, 22372, 22396, 22812, 22857, 22855, 22856, 22852, 22868, 22974, 22971, 22996, 22969, 22958, 22993, 22982, 22992, 22989, 22987, 22995, 22986, 22959, 22963, 22994, 22981, 23391, 23396, 23395, 23447, 23450, 23448, 23452, 23449, 23451, 23578, 23624, 23621, 23622, 23735, 23713, 23736, 23721, 23723, 23729, 23731, 24088, 24090, 24086, 24085, 24091, 24081, 24184, 24218, 24215, 24220, 24213, 24214, 24310, 24358, 24359, 24361, 24448, 24449, 24447, 24444, 24541, 24544, 24573, 24565, 24575, 24591, 24596, 24623, 24629, 24598, 24618, 24597, 24609, 24615, 24617, 24619, 24603, 25110, 25109, 25151, 25150, 25152, 25215, 25289, 25292, 25284, 25279, 25282, 25273, 25298, 25307, 25259, 25299, 25300, 25291, 25288, 25256, 25277, 25276, 25296, 25305, 25287, 25293, 25269, 25306, 25265, 25304, 25302, 25303, 25286, 25260, 25294, 25918, 26023, 26044, 26106, 26132, 26131, 26124, 26118, 26114, 26126, 26112, 26127, 26133, 26122, 26119, 26381, 26379, 26477, 26507, 26517, 26481, 26524, 26483, 26487, 26503, 26525, 26519, 26479, 26480, 26495, 26505, 26494, 26512, 26485, 26522, 26515, 26492, 26474, 26482, 27427, 27494, 27495, 27519, 27667, 27675, 27875, 27880, 27891, 27825, 27852, 27877, 27827, 27837, 27838, 27836, 27874, 27819, 27861, 27859, 27832, 27844, 27833, 27841, 27822, 27863, 27845, 27889, 27839, 27835, 27873, 27867, 27850, 27820, 27887, 27868, 27862, 27872, 28821, 28814, 28818, 28810, 28825, 29228, 29229, 29240, 29256, 29287, 29289, 29376, 29390, 29401, 29399, 29392, 29609, 29608, 29599, 29611, 29605, 30013, 30109, 30105, 30106, 30340, 30402, 30450, 30452, 30693, 30717, 31038, 31040, 31041, 31177, 31176, 31354, 31353, 31482, 31998, 32596, 32652, 32651, 32773, 32954, 32933, 32930, 32945, 32929, 32939, 32937, 32948, 32938, 32943, 33253, 33278, 33293, 33459, 33437, 33433, 33453, 33469, 33439, 33465, 33457, 33452, 33445, 33455, 33464, 33443, 33456, 33470, 33463, 34382, 34417, 21021, 34920, 36555, 36814, 36820, 36817, 37045, 37048, 37041, 37046, 37319, 37329, 38263, 38272, 38428, 38464, 38463, 38459, 38468, 38466, 38585, 38632, 38738, 38750, 20127, 20141, 20142, 20449, 20405, 20399, 20415, 20448, 20433, 20431, 20445, 20419, 20406, 20440, 20447, 20426, 20439, 20398, 20432, 20420, 20418, 20442, 20430, 20446, 20407, 20823, 20882, 20881, 20896, 21070, 21059, 21066, 21069, 21068, 21067, 21063, 21191, 21193, 21187, 21185, 21261, 21335, 21371, 21402, 21467, 21676, 21696, 21672, 21710, 21705, 21688, 21670, 21683, 21703, 21698, 21693, 21674, 21697, 21700, 21704, 21679, 21675, 21681, 21691, 21673, 21671, 21695, 22271, 22402, 22411, 22432, 22435, 22434, 22478, 22446, 22419, 22869, 22865, 22863, 22862, 22864, 23004, 23e3, 23039, 23011, 23016, 23043, 23013, 23018, 23002, 23014, 23041, 23035, 23401, 23459, 23462, 23460, 23458, 23461, 23553, 23630, 23631, 23629, 23627, 23769, 23762, 24055, 24093, 24101, 24095, 24189, 24224, 24230, 24314, 24328, 24365, 24421, 24456, 24453, 24458, 24459, 24455, 24460, 24457, 24594, 24605, 24608, 24613, 24590, 24616, 24653, 24688, 24680, 24674, 24646, 24643, 24684, 24683, 24682, 24676, 25153, 25308, 25366, 25353, 25340, 25325, 25345, 25326, 25341, 25351, 25329, 25335, 25327, 25324, 25342, 25332, 25361, 25346, 25919, 25925, 26027, 26045, 26082, 26149, 26157, 26144, 26151, 26159, 26143, 26152, 26161, 26148, 26359, 26623, 26579, 26609, 26580, 26576, 26604, 26550, 26543, 26613, 26601, 26607, 26564, 26577, 26548, 26586, 26597, 26552, 26575, 26590, 26611, 26544, 26585, 26594, 26589, 26578, 27498, 27523, 27526, 27573, 27602, 27607, 27679, 27849, 27915, 27954, 27946, 27969, 27941, 27916, 27953, 27934, 27927, 27963, 27965, 27966, 27958, 27931, 27893, 27961, 27943, 27960, 27945, 27950, 27957, 27918, 27947, 28843, 28858, 28851, 28844, 28847, 28845, 28856, 28846, 28836, 29232, 29298, 29295, 29300, 29417, 29408, 29409, 29623, 29642, 29627, 29618, 29645, 29632, 29619, 29978, 29997, 30031, 30028, 30030, 30027, 30123, 30116, 30117, 30114, 30115, 30328, 30342, 30343, 30344, 30408, 30406, 30403, 30405, 30465, 30457, 30456, 30473, 30475, 30462, 30460, 30471, 30684, 30722, 30740, 30732, 30733, 31046, 31049, 31048, 31047, 31161, 31162, 31185, 31186, 31179, 31359, 31361, 31487, 31485, 31869, 32002, 32005, 32e3, 32009, 32007, 32004, 32006, 32568, 32654, 32703, 32772, 32784, 32781, 32785, 32822, 32982, 32997, 32986, 32963, 32964, 32972, 32993, 32987, 32974, 32990, 32996, 32989, 33268, 33314, 33511, 33539, 33541, 33507, 33499, 33510, 33540, 33509, 33538, 33545, 33490, 33495, 33521, 33537, 33500, 33492, 33489, 33502, 33491, 33503, 33519, 33542, 34384, 34425, 34427, 34426, 34893, 34923, 35201, 35284, 35336, 35330, 35331, 35998, 36e3, 36212, 36211, 36276, 36557, 36556, 36848, 36838, 36834, 36842, 36837, 36845, 36843, 36836, 36840, 37066, 37070, 37057, 37059, 37195, 37194, 37325, 38274, 38480, 38475, 38476, 38477, 38754, 38761, 38859, 38893, 38899, 38913, 39080, 39131, 39135, 39318, 39321, 20056, 20147, 20492, 20493, 20515, 20463, 20518, 20517, 20472, 20521, 20502, 20486, 20540, 20511, 20506, 20498, 20497, 20474, 20480, 20500, 20520, 20465, 20513, 20491, 20505, 20504, 20467, 20462, 20525, 20522, 20478, 20523, 20489, 20860, 20900, 20901, 20898, 20941, 20940, 20934, 20939, 21078, 21084, 21076, 21083, 21085, 21290, 21375, 21407, 21405, 21471, 21736, 21776, 21761, 21815, 21756, 21733, 21746, 21766, 21754, 21780, 21737, 21741, 21729, 21769, 21742, 21738, 21734, 21799, 21767, 21757, 21775, 22275, 22276, 22466, 22484, 22475, 22467, 22537, 22799, 22871, 22872, 22874, 23057, 23064, 23068, 23071, 23067, 23059, 23020, 23072, 23075, 23081, 23077, 23052, 23049, 23403, 23640, 23472, 23475, 23478, 23476, 23470, 23477, 23481, 23480, 23556, 23633, 23637, 23632, 23789, 23805, 23803, 23786, 23784, 23792, 23798, 23809, 23796, 24046, 24109, 24107, 24235, 24237, 24231, 24369, 24466, 24465, 24464, 24665, 24675, 24677, 24656, 24661, 24685, 24681, 24687, 24708, 24735, 24730, 24717, 24724, 24716, 24709, 24726, 25159, 25331, 25352, 25343, 25422, 25406, 25391, 25429, 25410, 25414, 25423, 25417, 25402, 25424, 25405, 25386, 25387, 25384, 25421, 25420, 25928, 25929, 26009, 26049, 26053, 26178, 26185, 26191, 26179, 26194, 26188, 26181, 26177, 26360, 26388, 26389, 26391, 26657, 26680, 26696, 26694, 26707, 26681, 26690, 26708, 26665, 26803, 26647, 26700, 26705, 26685, 26612, 26704, 26688, 26684, 26691, 26666, 26693, 26643, 26648, 26689, 27530, 27529, 27575, 27683, 27687, 27688, 27686, 27684, 27888, 28010, 28053, 28040, 28039, 28006, 28024, 28023, 27993, 28051, 28012, 28041, 28014, 27994, 28020, 28009, 28044, 28042, 28025, 28037, 28005, 28052, 28874, 28888, 28900, 28889, 28872, 28879, 29241, 29305, 29436, 29433, 29437, 29432, 29431, 29574, 29677, 29705, 29678, 29664, 29674, 29662, 30036, 30045, 30044, 30042, 30041, 30142, 30149, 30151, 30130, 30131, 30141, 30140, 30137, 30146, 30136, 30347, 30384, 30410, 30413, 30414, 30505, 30495, 30496, 30504, 30697, 30768, 30759, 30776, 30749, 30772, 30775, 30757, 30765, 30752, 30751, 30770, 31061, 31056, 31072, 31071, 31062, 31070, 31069, 31063, 31066, 31204, 31203, 31207, 31199, 31206, 31209, 31192, 31364, 31368, 31449, 31494, 31505, 31881, 32033, 32023, 32011, 32010, 32032, 32034, 32020, 32016, 32021, 32026, 32028, 32013, 32025, 32027, 32570, 32607, 32660, 32709, 32705, 32774, 32792, 32789, 32793, 32791, 32829, 32831, 33009, 33026, 33008, 33029, 33005, 33012, 33030, 33016, 33011, 33032, 33021, 33034, 33020, 33007, 33261, 33260, 33280, 33296, 33322, 33323, 33320, 33324, 33467, 33579, 33618, 33620, 33610, 33592, 33616, 33609, 33589, 33588, 33615, 33586, 33593, 33590, 33559, 33600, 33585, 33576, 33603, 34388, 34442, 34474, 34451, 34468, 34473, 34444, 34467, 34460, 34928, 34935, 34945, 34946, 34941, 34937, 35352, 35344, 35342, 35340, 35349, 35338, 35351, 35347, 35350, 35343, 35345, 35912, 35962, 35961, 36001, 36002, 36215, 36524, 36562, 36564, 36559, 36785, 36865, 36870, 36855, 36864, 36858, 36852, 36867, 36861, 36869, 36856, 37013, 37089, 37085, 37090, 37202, 37197, 37196, 37336, 37341, 37335, 37340, 37337, 38275, 38498, 38499, 38497, 38491, 38493, 38500, 38488, 38494, 38587, 39138, 39340, 39592, 39640, 39717, 39730, 39740, 20094, 20602, 20605, 20572, 20551, 20547, 20556, 20570, 20553, 20581, 20598, 20558, 20565, 20597, 20596, 20599, 20559, 20495, 20591, 20589, 20828, 20885, 20976, 21098, 21103, 21202, 21209, 21208, 21205, 21264, 21263, 21273, 21311, 21312, 21310, 21443, 26364, 21830, 21866, 21862, 21828, 21854, 21857, 21827, 21834, 21809, 21846, 21839, 21845, 21807, 21860, 21816, 21806, 21852, 21804, 21859, 21811, 21825, 21847, 22280, 22283, 22281, 22495, 22533, 22538, 22534, 22496, 22500, 22522, 22530, 22581, 22519, 22521, 22816, 22882, 23094, 23105, 23113, 23142, 23146, 23104, 23100, 23138, 23130, 23110, 23114, 23408, 23495, 23493, 23492, 23490, 23487, 23494, 23561, 23560, 23559, 23648, 23644, 23645, 23815, 23814, 23822, 23835, 23830, 23842, 23825, 23849, 23828, 23833, 23844, 23847, 23831, 24034, 24120, 24118, 24115, 24119, 24247, 24248, 24246, 24245, 24254, 24373, 24375, 24407, 24428, 24425, 24427, 24471, 24473, 24478, 24472, 24481, 24480, 24476, 24703, 24739, 24713, 24736, 24744, 24779, 24756, 24806, 24765, 24773, 24763, 24757, 24796, 24764, 24792, 24789, 24774, 24799, 24760, 24794, 24775, 25114, 25115, 25160, 25504, 25511, 25458, 25494, 25506, 25509, 25463, 25447, 25496, 25514, 25457, 25513, 25481, 25475, 25499, 25451, 25512, 25476, 25480, 25497, 25505, 25516, 25490, 25487, 25472, 25467, 25449, 25448, 25466, 25949, 25942, 25937, 25945, 25943, 21855, 25935, 25944, 25941, 25940, 26012, 26011, 26028, 26063, 26059, 26060, 26062, 26205, 26202, 26212, 26216, 26214, 26206, 26361, 21207, 26395, 26753, 26799, 26786, 26771, 26805, 26751, 26742, 26801, 26791, 26775, 26800, 26755, 26820, 26797, 26758, 26757, 26772, 26781, 26792, 26783, 26785, 26754, 27442, 27578, 27627, 27628, 27691, 28046, 28092, 28147, 28121, 28082, 28129, 28108, 28132, 28155, 28154, 28165, 28103, 28107, 28079, 28113, 28078, 28126, 28153, 28088, 28151, 28149, 28101, 28114, 28186, 28085, 28122, 28139, 28120, 28138, 28145, 28142, 28136, 28102, 28100, 28074, 28140, 28095, 28134, 28921, 28937, 28938, 28925, 28911, 29245, 29309, 29313, 29468, 29467, 29462, 29459, 29465, 29575, 29701, 29706, 29699, 29702, 29694, 29709, 29920, 29942, 29943, 29980, 29986, 30053, 30054, 30050, 30064, 30095, 30164, 30165, 30133, 30154, 30157, 30350, 30420, 30418, 30427, 30519, 30526, 30524, 30518, 30520, 30522, 30827, 30787, 30798, 31077, 31080, 31085, 31227, 31378, 31381, 31520, 31528, 31515, 31532, 31526, 31513, 31518, 31534, 31890, 31895, 31893, 32070, 32067, 32113, 32046, 32057, 32060, 32064, 32048, 32051, 32068, 32047, 32066, 32050, 32049, 32573, 32670, 32666, 32716, 32718, 32722, 32796, 32842, 32838, 33071, 33046, 33059, 33067, 33065, 33072, 33060, 33282, 33333, 33335, 33334, 33337, 33678, 33694, 33688, 33656, 33698, 33686, 33725, 33707, 33682, 33674, 33683, 33673, 33696, 33655, 33659, 33660, 33670, 33703, 34389, 24426, 34503, 34496, 34486, 34500, 34485, 34502, 34507, 34481, 34479, 34505, 34899, 34974, 34952, 34987, 34962, 34966, 34957, 34955, 35219, 35215, 35370, 35357, 35363, 35365, 35377, 35373, 35359, 35355, 35362, 35913, 35930, 36009, 36012, 36011, 36008, 36010, 36007, 36199, 36198, 36286, 36282, 36571, 36575, 36889, 36877, 36890, 36887, 36899, 36895, 36893, 36880, 36885, 36894, 36896, 36879, 36898, 36886, 36891, 36884, 37096, 37101, 37117, 37207, 37326, 37365, 37350, 37347, 37351, 37357, 37353, 38281, 38506, 38517, 38515, 38520, 38512, 38516, 38518, 38519, 38508, 38592, 38634, 38633, 31456, 31455, 38914, 38915, 39770, 40165, 40565, 40575, 40613, 40635, 20642, 20621, 20613, 20633, 20625, 20608, 20630, 20632, 20634, 26368, 20977, 21106, 21108, 21109, 21097, 21214, 21213, 21211, 21338, 21413, 21883, 21888, 21927, 21884, 21898, 21917, 21912, 21890, 21916, 21930, 21908, 21895, 21899, 21891, 21939, 21934, 21919, 21822, 21938, 21914, 21947, 21932, 21937, 21886, 21897, 21931, 21913, 22285, 22575, 22570, 22580, 22564, 22576, 22577, 22561, 22557, 22560, 22777, 22778, 22880, 23159, 23194, 23167, 23186, 23195, 23207, 23411, 23409, 23506, 23500, 23507, 23504, 23562, 23563, 23601, 23884, 23888, 23860, 23879, 24061, 24133, 24125, 24128, 24131, 24190, 24266, 24257, 24258, 24260, 24380, 24429, 24489, 24490, 24488, 24785, 24801, 24754, 24758, 24800, 24860, 24867, 24826, 24853, 24816, 24827, 24820, 24936, 24817, 24846, 24822, 24841, 24832, 24850, 25119, 25161, 25507, 25484, 25551, 25536, 25577, 25545, 25542, 25549, 25554, 25571, 25552, 25569, 25558, 25581, 25582, 25462, 25588, 25578, 25563, 25682, 25562, 25593, 25950, 25958, 25954, 25955, 26001, 26e3, 26031, 26222, 26224, 26228, 26230, 26223, 26257, 26234, 26238, 26231, 26366, 26367, 26399, 26397, 26874, 26837, 26848, 26840, 26839, 26885, 26847, 26869, 26862, 26855, 26873, 26834, 26866, 26851, 26827, 26829, 26893, 26898, 26894, 26825, 26842, 26990, 26875, 27454, 27450, 27453, 27544, 27542, 27580, 27631, 27694, 27695, 27692, 28207, 28216, 28244, 28193, 28210, 28263, 28234, 28192, 28197, 28195, 28187, 28251, 28248, 28196, 28246, 28270, 28205, 28198, 28271, 28212, 28237, 28218, 28204, 28227, 28189, 28222, 28363, 28297, 28185, 28238, 28259, 28228, 28274, 28265, 28255, 28953, 28954, 28966, 28976, 28961, 28982, 29038, 28956, 29260, 29316, 29312, 29494, 29477, 29492, 29481, 29754, 29738, 29747, 29730, 29733, 29749, 29750, 29748, 29743, 29723, 29734, 29736, 29989, 29990, 30059, 30058, 30178, 30171, 30179, 30169, 30168, 30174, 30176, 30331, 30332, 30358, 30355, 30388, 30428, 30543, 30701, 30813, 30828, 30831, 31245, 31240, 31243, 31237, 31232, 31384, 31383, 31382, 31461, 31459, 31561, 31574, 31558, 31568, 31570, 31572, 31565, 31563, 31567, 31569, 31903, 31909, 32094, 32080, 32104, 32085, 32043, 32110, 32114, 32097, 32102, 32098, 32112, 32115, 21892, 32724, 32725, 32779, 32850, 32901, 33109, 33108, 33099, 33105, 33102, 33081, 33094, 33086, 33100, 33107, 33140, 33298, 33308, 33769, 33795, 33784, 33805, 33760, 33733, 33803, 33729, 33775, 33777, 33780, 33879, 33802, 33776, 33804, 33740, 33789, 33778, 33738, 33848, 33806, 33796, 33756, 33799, 33748, 33759, 34395, 34527, 34521, 34541, 34516, 34523, 34532, 34512, 34526, 34903, 35009, 35010, 34993, 35203, 35222, 35387, 35424, 35413, 35422, 35388, 35393, 35412, 35419, 35408, 35398, 35380, 35386, 35382, 35414, 35937, 35970, 36015, 36028, 36019, 36029, 36033, 36027, 36032, 36020, 36023, 36022, 36031, 36024, 36234, 36229, 36225, 36302, 36317, 36299, 36314, 36305, 36300, 36315, 36294, 36603, 36600, 36604, 36764, 36910, 36917, 36913, 36920, 36914, 36918, 37122, 37109, 37129, 37118, 37219, 37221, 37327, 37396, 37397, 37411, 37385, 37406, 37389, 37392, 37383, 37393, 38292, 38287, 38283, 38289, 38291, 38290, 38286, 38538, 38542, 38539, 38525, 38533, 38534, 38541, 38514, 38532, 38593, 38597, 38596, 38598, 38599, 38639, 38642, 38860, 38917, 38918, 38920, 39143, 39146, 39151, 39145, 39154, 39149, 39342, 39341, 40643, 40653, 40657, 20098, 20653, 20661, 20658, 20659, 20677, 20670, 20652, 20663, 20667, 20655, 20679, 21119, 21111, 21117, 21215, 21222, 21220, 21218, 21219, 21295, 21983, 21992, 21971, 21990, 21966, 21980, 21959, 21969, 21987, 21988, 21999, 21978, 21985, 21957, 21958, 21989, 21961, 22290, 22291, 22622, 22609, 22616, 22615, 22618, 22612, 22635, 22604, 22637, 22602, 22626, 22610, 22603, 22887, 23233, 23241, 23244, 23230, 23229, 23228, 23219, 23234, 23218, 23913, 23919, 24140, 24185, 24265, 24264, 24338, 24409, 24492, 24494, 24858, 24847, 24904, 24863, 24819, 24859, 24825, 24833, 24840, 24910, 24908, 24900, 24909, 24894, 24884, 24871, 24845, 24838, 24887, 25121, 25122, 25619, 25662, 25630, 25642, 25645, 25661, 25644, 25615, 25628, 25620, 25613, 25654, 25622, 25623, 25606, 25964, 26015, 26032, 26263, 26249, 26247, 26248, 26262, 26244, 26264, 26253, 26371, 27028, 26989, 26970, 26999, 26976, 26964, 26997, 26928, 27010, 26954, 26984, 26987, 26974, 26963, 27001, 27014, 26973, 26979, 26971, 27463, 27506, 27584, 27583, 27603, 27645, 28322, 28335, 28371, 28342, 28354, 28304, 28317, 28359, 28357, 28325, 28312, 28348, 28346, 28331, 28369, 28310, 28316, 28356, 28372, 28330, 28327, 28340, 29006, 29017, 29033, 29028, 29001, 29031, 29020, 29036, 29030, 29004, 29029, 29022, 28998, 29032, 29014, 29242, 29266, 29495, 29509, 29503, 29502, 29807, 29786, 29781, 29791, 29790, 29761, 29759, 29785, 29787, 29788, 30070, 30072, 30208, 30192, 30209, 30194, 30193, 30202, 30207, 30196, 30195, 30430, 30431, 30555, 30571, 30566, 30558, 30563, 30585, 30570, 30572, 30556, 30565, 30568, 30562, 30702, 30862, 30896, 30871, 30872, 30860, 30857, 30844, 30865, 30867, 30847, 31098, 31103, 31105, 33836, 31165, 31260, 31258, 31264, 31252, 31263, 31262, 31391, 31392, 31607, 31680, 31584, 31598, 31591, 31921, 31923, 31925, 32147, 32121, 32145, 32129, 32143, 32091, 32622, 32617, 32618, 32626, 32681, 32680, 32676, 32854, 32856, 32902, 32900, 33137, 33136, 33144, 33125, 33134, 33139, 33131, 33145, 33146, 33126, 33285, 33351, 33922, 33911, 33853, 33841, 33909, 33894, 33899, 33865, 33900, 33883, 33852, 33845, 33889, 33891, 33897, 33901, 33862, 34398, 34396, 34399, 34553, 34579, 34568, 34567, 34560, 34558, 34555, 34562, 34563, 34566, 34570, 34905, 35039, 35028, 35033, 35036, 35032, 35037, 35041, 35018, 35029, 35026, 35228, 35299, 35435, 35442, 35443, 35430, 35433, 35440, 35463, 35452, 35427, 35488, 35441, 35461, 35437, 35426, 35438, 35436, 35449, 35451, 35390, 35432, 35938, 35978, 35977, 36042, 36039, 36040, 36036, 36018, 36035, 36034, 36037, 36321, 36319, 36328, 36335, 36339, 36346, 36330, 36324, 36326, 36530, 36611, 36617, 36606, 36618, 36767, 36786, 36939, 36938, 36947, 36930, 36948, 36924, 36949, 36944, 36935, 36943, 36942, 36941, 36945, 36926, 36929, 37138, 37143, 37228, 37226, 37225, 37321, 37431, 37463, 37432, 37437, 37440, 37438, 37467, 37451, 37476, 37457, 37428, 37449, 37453, 37445, 37433, 37439, 37466, 38296, 38552, 38548, 38549, 38605, 38603, 38601, 38602, 38647, 38651, 38649, 38646, 38742, 38772, 38774, 38928, 38929, 38931, 38922, 38930, 38924, 39164, 39156, 39165, 39166, 39347, 39345, 39348, 39649, 40169, 40578, 40718, 40723, 40736, 20711, 20718, 20709, 20694, 20717, 20698, 20693, 20687, 20689, 20721, 20686, 20713, 20834, 20979, 21123, 21122, 21297, 21421, 22014, 22016, 22043, 22039, 22013, 22036, 22022, 22025, 22029, 22030, 22007, 22038, 22047, 22024, 22032, 22006, 22296, 22294, 22645, 22654, 22659, 22675, 22666, 22649, 22661, 22653, 22781, 22821, 22818, 22820, 22890, 22889, 23265, 23270, 23273, 23255, 23254, 23256, 23267, 23413, 23518, 23527, 23521, 23525, 23526, 23528, 23522, 23524, 23519, 23565, 23650, 23940, 23943, 24155, 24163, 24149, 24151, 24148, 24275, 24278, 24330, 24390, 24432, 24505, 24903, 24895, 24907, 24951, 24930, 24931, 24927, 24922, 24920, 24949, 25130, 25735, 25688, 25684, 25764, 25720, 25695, 25722, 25681, 25703, 25652, 25709, 25723, 25970, 26017, 26071, 26070, 26274, 26280, 26269, 27036, 27048, 27029, 27073, 27054, 27091, 27083, 27035, 27063, 27067, 27051, 27060, 27088, 27085, 27053, 27084, 27046, 27075, 27043, 27465, 27468, 27699, 28467, 28436, 28414, 28435, 28404, 28457, 28478, 28448, 28460, 28431, 28418, 28450, 28415, 28399, 28422, 28465, 28472, 28466, 28451, 28437, 28459, 28463, 28552, 28458, 28396, 28417, 28402, 28364, 28407, 29076, 29081, 29053, 29066, 29060, 29074, 29246, 29330, 29334, 29508, 29520, 29796, 29795, 29802, 29808, 29805, 29956, 30097, 30247, 30221, 30219, 30217, 30227, 30433, 30435, 30596, 30589, 30591, 30561, 30913, 30879, 30887, 30899, 30889, 30883, 31118, 31119, 31117, 31278, 31281, 31402, 31401, 31469, 31471, 31649, 31637, 31627, 31605, 31639, 31645, 31636, 31631, 31672, 31623, 31620, 31929, 31933, 31934, 32187, 32176, 32156, 32189, 32190, 32160, 32202, 32180, 32178, 32177, 32186, 32162, 32191, 32181, 32184, 32173, 32210, 32199, 32172, 32624, 32736, 32737, 32735, 32862, 32858, 32903, 33104, 33152, 33167, 33160, 33162, 33151, 33154, 33255, 33274, 33287, 33300, 33310, 33355, 33993, 33983, 33990, 33988, 33945, 33950, 33970, 33948, 33995, 33976, 33984, 34003, 33936, 33980, 34001, 33994, 34623, 34588, 34619, 34594, 34597, 34612, 34584, 34645, 34615, 34601, 35059, 35074, 35060, 35065, 35064, 35069, 35048, 35098, 35055, 35494, 35468, 35486, 35491, 35469, 35489, 35475, 35492, 35498, 35493, 35496, 35480, 35473, 35482, 35495, 35946, 35981, 35980, 36051, 36049, 36050, 36203, 36249, 36245, 36348, 36628, 36626, 36629, 36627, 36771, 36960, 36952, 36956, 36963, 36953, 36958, 36962, 36957, 36955, 37145, 37144, 37150, 37237, 37240, 37239, 37236, 37496, 37504, 37509, 37528, 37526, 37499, 37523, 37532, 37544, 37500, 37521, 38305, 38312, 38313, 38307, 38309, 38308, 38553, 38556, 38555, 38604, 38610, 38656, 38780, 38789, 38902, 38935, 38936, 39087, 39089, 39171, 39173, 39180, 39177, 39361, 39599, 39600, 39654, 39745, 39746, 40180, 40182, 40179, 40636, 40763, 40778, 20740, 20736, 20731, 20725, 20729, 20738, 20744, 20745, 20741, 20956, 21127, 21128, 21129, 21133, 21130, 21232, 21426, 22062, 22075, 22073, 22066, 22079, 22068, 22057, 22099, 22094, 22103, 22132, 22070, 22063, 22064, 22656, 22687, 22686, 22707, 22684, 22702, 22697, 22694, 22893, 23305, 23291, 23307, 23285, 23308, 23304, 23534, 23532, 23529, 23531, 23652, 23653, 23965, 23956, 24162, 24159, 24161, 24290, 24282, 24287, 24285, 24291, 24288, 24392, 24433, 24503, 24501, 24950, 24935, 24942, 24925, 24917, 24962, 24956, 24944, 24939, 24958, 24999, 24976, 25003, 24974, 25004, 24986, 24996, 24980, 25006, 25134, 25705, 25711, 25721, 25758, 25778, 25736, 25744, 25776, 25765, 25747, 25749, 25769, 25746, 25774, 25773, 25771, 25754, 25772, 25753, 25762, 25779, 25973, 25975, 25976, 26286, 26283, 26292, 26289, 27171, 27167, 27112, 27137, 27166, 27161, 27133, 27169, 27155, 27146, 27123, 27138, 27141, 27117, 27153, 27472, 27470, 27556, 27589, 27590, 28479, 28540, 28548, 28497, 28518, 28500, 28550, 28525, 28507, 28536, 28526, 28558, 28538, 28528, 28516, 28567, 28504, 28373, 28527, 28512, 28511, 29087, 29100, 29105, 29096, 29270, 29339, 29518, 29527, 29801, 29835, 29827, 29822, 29824, 30079, 30240, 30249, 30239, 30244, 30246, 30241, 30242, 30362, 30394, 30436, 30606, 30599, 30604, 30609, 30603, 30923, 30917, 30906, 30922, 30910, 30933, 30908, 30928, 31295, 31292, 31296, 31293, 31287, 31291, 31407, 31406, 31661, 31665, 31684, 31668, 31686, 31687, 31681, 31648, 31692, 31946, 32224, 32244, 32239, 32251, 32216, 32236, 32221, 32232, 32227, 32218, 32222, 32233, 32158, 32217, 32242, 32249, 32629, 32631, 32687, 32745, 32806, 33179, 33180, 33181, 33184, 33178, 33176, 34071, 34109, 34074, 34030, 34092, 34093, 34067, 34065, 34083, 34081, 34068, 34028, 34085, 34047, 34054, 34690, 34676, 34678, 34656, 34662, 34680, 34664, 34649, 34647, 34636, 34643, 34907, 34909, 35088, 35079, 35090, 35091, 35093, 35082, 35516, 35538, 35527, 35524, 35477, 35531, 35576, 35506, 35529, 35522, 35519, 35504, 35542, 35533, 35510, 35513, 35547, 35916, 35918, 35948, 36064, 36062, 36070, 36068, 36076, 36077, 36066, 36067, 36060, 36074, 36065, 36205, 36255, 36259, 36395, 36368, 36381, 36386, 36367, 36393, 36383, 36385, 36382, 36538, 36637, 36635, 36639, 36649, 36646, 36650, 36636, 36638, 36645, 36969, 36974, 36968, 36973, 36983, 37168, 37165, 37159, 37169, 37255, 37257, 37259, 37251, 37573, 37563, 37559, 37610, 37548, 37604, 37569, 37555, 37564, 37586, 37575, 37616, 37554, 38317, 38321, 38660, 38662, 38663, 38665, 38752, 38797, 38795, 38799, 38945, 38955, 38940, 39091, 39178, 39187, 39186, 39192, 39389, 39376, 39391, 39387, 39377, 39381, 39378, 39385, 39607, 39662, 39663, 39719, 39749, 39748, 39799, 39791, 40198, 40201, 40195, 40617, 40638, 40654, 22696, 40786, 20754, 20760, 20756, 20752, 20757, 20864, 20906, 20957, 21137, 21139, 21235, 22105, 22123, 22137, 22121, 22116, 22136, 22122, 22120, 22117, 22129, 22127, 22124, 22114, 22134, 22721, 22718, 22727, 22725, 22894, 23325, 23348, 23416, 23536, 23566, 24394, 25010, 24977, 25001, 24970, 25037, 25014, 25022, 25034, 25032, 25136, 25797, 25793, 25803, 25787, 25788, 25818, 25796, 25799, 25794, 25805, 25791, 25810, 25812, 25790, 25972, 26310, 26313, 26297, 26308, 26311, 26296, 27197, 27192, 27194, 27225, 27243, 27224, 27193, 27204, 27234, 27233, 27211, 27207, 27189, 27231, 27208, 27481, 27511, 27653, 28610, 28593, 28577, 28611, 28580, 28609, 28583, 28595, 28608, 28601, 28598, 28582, 28576, 28596, 29118, 29129, 29136, 29138, 29128, 29141, 29113, 29134, 29145, 29148, 29123, 29124, 29544, 29852, 29859, 29848, 29855, 29854, 29922, 29964, 29965, 30260, 30264, 30266, 30439, 30437, 30624, 30622, 30623, 30629, 30952, 30938, 30956, 30951, 31142, 31309, 31310, 31302, 31308, 31307, 31418, 31705, 31761, 31689, 31716, 31707, 31713, 31721, 31718, 31957, 31958, 32266, 32273, 32264, 32283, 32291, 32286, 32285, 32265, 32272, 32633, 32690, 32752, 32753, 32750, 32808, 33203, 33193, 33192, 33275, 33288, 33368, 33369, 34122, 34137, 34120, 34152, 34153, 34115, 34121, 34157, 34154, 34142, 34691, 34719, 34718, 34722, 34701, 34913, 35114, 35122, 35109, 35115, 35105, 35242, 35238, 35558, 35578, 35563, 35569, 35584, 35548, 35559, 35566, 35582, 35585, 35586, 35575, 35565, 35571, 35574, 35580, 35947, 35949, 35987, 36084, 36420, 36401, 36404, 36418, 36409, 36405, 36667, 36655, 36664, 36659, 36776, 36774, 36981, 36980, 36984, 36978, 36988, 36986, 37172, 37266, 37664, 37686, 37624, 37683, 37679, 37666, 37628, 37675, 37636, 37658, 37648, 37670, 37665, 37653, 37678, 37657, 38331, 38567, 38568, 38570, 38613, 38670, 38673, 38678, 38669, 38675, 38671, 38747, 38748, 38758, 38808, 38960, 38968, 38971, 38967, 38957, 38969, 38948, 39184, 39208, 39198, 39195, 39201, 39194, 39405, 39394, 39409, 39608, 39612, 39675, 39661, 39720, 39825, 40213, 40227, 40230, 40232, 40210, 40219, 40664, 40660, 40845, 40860, 20778, 20767, 20769, 20786, 21237, 22158, 22144, 22160, 22149, 22151, 22159, 22741, 22739, 22737, 22734, 23344, 23338, 23332, 23418, 23607, 23656, 23996, 23994, 23997, 23992, 24171, 24396, 24509, 25033, 25026, 25031, 25062, 25035, 25138, 25140, 25806, 25802, 25816, 25824, 25840, 25830, 25836, 25841, 25826, 25837, 25986, 25987, 26329, 26326, 27264, 27284, 27268, 27298, 27292, 27355, 27299, 27262, 27287, 27280, 27296, 27484, 27566, 27610, 27656, 28632, 28657, 28639, 28640, 28635, 28644, 28651, 28655, 28544, 28652, 28641, 28649, 28629, 28654, 28656, 29159, 29151, 29166, 29158, 29157, 29165, 29164, 29172, 29152, 29237, 29254, 29552, 29554, 29865, 29872, 29862, 29864, 30278, 30274, 30284, 30442, 30643, 30634, 30640, 30636, 30631, 30637, 30703, 30967, 30970, 30964, 30959, 30977, 31143, 31146, 31319, 31423, 31751, 31757, 31742, 31735, 31756, 31712, 31968, 31964, 31966, 31970, 31967, 31961, 31965, 32302, 32318, 32326, 32311, 32306, 32323, 32299, 32317, 32305, 32325, 32321, 32308, 32313, 32328, 32309, 32319, 32303, 32580, 32755, 32764, 32881, 32882, 32880, 32879, 32883, 33222, 33219, 33210, 33218, 33216, 33215, 33213, 33225, 33214, 33256, 33289, 33393, 34218, 34180, 34174, 34204, 34193, 34196, 34223, 34203, 34183, 34216, 34186, 34407, 34752, 34769, 34739, 34770, 34758, 34731, 34747, 34746, 34760, 34763, 35131, 35126, 35140, 35128, 35133, 35244, 35598, 35607, 35609, 35611, 35594, 35616, 35613, 35588, 35600, 35905, 35903, 35955, 36090, 36093, 36092, 36088, 36091, 36264, 36425, 36427, 36424, 36426, 36676, 36670, 36674, 36677, 36671, 36991, 36989, 36996, 36993, 36994, 36992, 37177, 37283, 37278, 37276, 37709, 37762, 37672, 37749, 37706, 37733, 37707, 37656, 37758, 37740, 37723, 37744, 37722, 37716, 38346, 38347, 38348, 38344, 38342, 38577, 38584, 38614, 38684, 38686, 38816, 38867, 38982, 39094, 39221, 39425, 39423, 39854, 39851, 39850, 39853, 40251, 40255, 40587, 40655, 40670, 40668, 40669, 40667, 40766, 40779, 21474, 22165, 22190, 22745, 22744, 23352, 24413, 25059, 25139, 25844, 25842, 25854, 25862, 25850, 25851, 25847, 26039, 26332, 26406, 27315, 27308, 27331, 27323, 27320, 27330, 27310, 27311, 27487, 27512, 27567, 28681, 28683, 28670, 28678, 28666, 28689, 28687, 29179, 29180, 29182, 29176, 29559, 29557, 29863, 29887, 29973, 30294, 30296, 30290, 30653, 30655, 30651, 30652, 30990, 31150, 31329, 31330, 31328, 31428, 31429, 31787, 31783, 31786, 31774, 31779, 31777, 31975, 32340, 32341, 32350, 32346, 32353, 32338, 32345, 32584, 32761, 32763, 32887, 32886, 33229, 33231, 33290, 34255, 34217, 34253, 34256, 34249, 34224, 34234, 34233, 34214, 34799, 34796, 34802, 34784, 35206, 35250, 35316, 35624, 35641, 35628, 35627, 35920, 36101, 36441, 36451, 36454, 36452, 36447, 36437, 36544, 36681, 36685, 36999, 36995, 37e3, 37291, 37292, 37328, 37780, 37770, 37782, 37794, 37811, 37806, 37804, 37808, 37784, 37786, 37783, 38356, 38358, 38352, 38357, 38626, 38620, 38617, 38619, 38622, 38692, 38819, 38822, 38829, 38905, 38989, 38991, 38988, 38990, 38995, 39098, 39230, 39231, 39229, 39214, 39333, 39438, 39617, 39683, 39686, 39759, 39758, 39757, 39882, 39881, 39933, 39880, 39872, 40273, 40285, 40288, 40672, 40725, 40748, 20787, 22181, 22750, 22751, 22754, 23541, 40848, 24300, 25074, 25079, 25078, 25077, 25856, 25871, 26336, 26333, 27365, 27357, 27354, 27347, 28699, 28703, 28712, 28698, 28701, 28693, 28696, 29190, 29197, 29272, 29346, 29560, 29562, 29885, 29898, 29923, 30087, 30086, 30303, 30305, 30663, 31001, 31153, 31339, 31337, 31806, 31807, 31800, 31805, 31799, 31808, 32363, 32365, 32377, 32361, 32362, 32645, 32371, 32694, 32697, 32696, 33240, 34281, 34269, 34282, 34261, 34276, 34277, 34295, 34811, 34821, 34829, 34809, 34814, 35168, 35167, 35158, 35166, 35649, 35676, 35672, 35657, 35674, 35662, 35663, 35654, 35673, 36104, 36106, 36476, 36466, 36487, 36470, 36460, 36474, 36468, 36692, 36686, 36781, 37002, 37003, 37297, 37294, 37857, 37841, 37855, 37827, 37832, 37852, 37853, 37846, 37858, 37837, 37848, 37860, 37847, 37864, 38364, 38580, 38627, 38698, 38695, 38753, 38876, 38907, 39006, 39e3, 39003, 39100, 39237, 39241, 39446, 39449, 39693, 39912, 39911, 39894, 39899, 40329, 40289, 40306, 40298, 40300, 40594, 40599, 40595, 40628, 21240, 22184, 22199, 22198, 22196, 22204, 22756, 23360, 23363, 23421, 23542, 24009, 25080, 25082, 25880, 25876, 25881, 26342, 26407, 27372, 28734, 28720, 28722, 29200, 29563, 29903, 30306, 30309, 31014, 31018, 31020, 31019, 31431, 31478, 31820, 31811, 31821, 31983, 31984, 36782, 32381, 32380, 32386, 32588, 32768, 33242, 33382, 34299, 34297, 34321, 34298, 34310, 34315, 34311, 34314, 34836, 34837, 35172, 35258, 35320, 35696, 35692, 35686, 35695, 35679, 35691, 36111, 36109, 36489, 36481, 36485, 36482, 37300, 37323, 37912, 37891, 37885, 38369, 38704, 39108, 39250, 39249, 39336, 39467, 39472, 39479, 39477, 39955, 39949, 40569, 40629, 40680, 40751, 40799, 40803, 40801, 20791, 20792, 22209, 22208, 22210, 22804, 23660, 24013, 25084, 25086, 25885, 25884, 26005, 26345, 27387, 27396, 27386, 27570, 28748, 29211, 29351, 29910, 29908, 30313, 30675, 31824, 32399, 32396, 32700, 34327, 34349, 34330, 34851, 34850, 34849, 34847, 35178, 35180, 35261, 35700, 35703, 35709, 36115, 36490, 36493, 36491, 36703, 36783, 37306, 37934, 37939, 37941, 37946, 37944, 37938, 37931, 38370, 38712, 38713, 38706, 38911, 39015, 39013, 39255, 39493, 39491, 39488, 39486, 39631, 39764, 39761, 39981, 39973, 40367, 40372, 40386, 40376, 40605, 40687, 40729, 40796, 40806, 40807, 20796, 20795, 22216, 22218, 22217, 23423, 24020, 24018, 24398, 25087, 25892, 27402, 27489, 28753, 28760, 29568, 29924, 30090, 30318, 30316, 31155, 31840, 31839, 32894, 32893, 33247, 35186, 35183, 35324, 35712, 36118, 36119, 36497, 36499, 36705, 37192, 37956, 37969, 37970, 38717, 38718, 38851, 38849, 39019, 39253, 39509, 39501, 39634, 39706, 40009, 39985, 39998, 39995, 40403, 40407, 40756, 40812, 40810, 40852, 22220, 24022, 25088, 25891, 25899, 25898, 26348, 27408, 29914, 31434, 31844, 31843, 31845, 32403, 32406, 32404, 33250, 34360, 34367, 34865, 35722, 37008, 37007, 37987, 37984, 37988, 38760, 39023, 39260, 39514, 39515, 39511, 39635, 39636, 39633, 40020, 40023, 40022, 40421, 40607, 40692, 22225, 22761, 25900, 28766, 30321, 30322, 30679, 32592, 32648, 34870, 34873, 34914, 35731, 35730, 35734, 33399, 36123, 37312, 37994, 38722, 38728, 38724, 38854, 39024, 39519, 39714, 39768, 40031, 40441, 40442, 40572, 40573, 40711, 40823, 40818, 24307, 27414, 28771, 31852, 31854, 34875, 35264, 36513, 37313, 38002, 38e3, 39025, 39262, 39638, 39715, 40652, 28772, 30682, 35738, 38007, 38857, 39522, 39525, 32412, 35740, 36522, 37317, 38013, 38014, 38012, 40055, 40056, 40695, 35924, 38015, 40474, 29224, 39530, 39729, 40475, 40478, 31858, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 20022, 20031, 20101, 20128, 20866, 20886, 20907, 21241, 21304, 21353, 21430, 22794, 23424, 24027, 12083, 24191, 24308, 24400, 24417, 25908, 26080, 30098, 30326, 36789, 38582, 168, 710, 12541, 12542, 12445, 12446, 12291, 20189, 12293, 12294, 12295, 12540, 65339, 65341, 10045, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 8679, 8632, 8633, 12751, 131276, 20058, 131210, 20994, 17553, 40880, 20872, 40881, 161287, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 65506, 65508, 65287, 65282, 12849, 8470, 8481, 12443, 12444, 11904, 11908, 11910, 11911, 11912, 11914, 11916, 11917, 11925, 11932, 11933, 11941, 11943, 11946, 11948, 11950, 11958, 11964, 11966, 11974, 11978, 11980, 11981, 11983, 11990, 11991, 11998, 12003, null, null, null, 643, 592, 603, 596, 629, 339, 248, 331, 650, 618, 20034, 20060, 20981, 21274, 21378, 19975, 19980, 20039, 20109, 22231, 64012, 23662, 24435, 19983, 20871, 19982, 20014, 20115, 20162, 20169, 20168, 20888, 21244, 21356, 21433, 22304, 22787, 22828, 23568, 24063, 26081, 27571, 27596, 27668, 29247, 20017, 20028, 20200, 20188, 20201, 20193, 20189, 20186, 21004, 21276, 21324, 22306, 22307, 22807, 22831, 23425, 23428, 23570, 23611, 23668, 23667, 24068, 24192, 24194, 24521, 25097, 25168, 27669, 27702, 27715, 27711, 27707, 29358, 29360, 29578, 31160, 32906, 38430, 20238, 20248, 20268, 20213, 20244, 20209, 20224, 20215, 20232, 20253, 20226, 20229, 20258, 20243, 20228, 20212, 20242, 20913, 21011, 21001, 21008, 21158, 21282, 21279, 21325, 21386, 21511, 22241, 22239, 22318, 22314, 22324, 22844, 22912, 22908, 22917, 22907, 22910, 22903, 22911, 23382, 23573, 23589, 23676, 23674, 23675, 23678, 24031, 24181, 24196, 24322, 24346, 24436, 24533, 24532, 24527, 25180, 25182, 25188, 25185, 25190, 25186, 25177, 25184, 25178, 25189, 26095, 26094, 26430, 26425, 26424, 26427, 26426, 26431, 26428, 26419, 27672, 27718, 27730, 27740, 27727, 27722, 27732, 27723, 27724, 28785, 29278, 29364, 29365, 29582, 29994, 30335, 31349, 32593, 33400, 33404, 33408, 33405, 33407, 34381, 35198, 37017, 37015, 37016, 37019, 37012, 38434, 38436, 38432, 38435, 20310, 20283, 20322, 20297, 20307, 20324, 20286, 20327, 20306, 20319, 20289, 20312, 20269, 20275, 20287, 20321, 20879, 20921, 21020, 21022, 21025, 21165, 21166, 21257, 21347, 21362, 21390, 21391, 21552, 21559, 21546, 21588, 21573, 21529, 21532, 21541, 21528, 21565, 21583, 21569, 21544, 21540, 21575, 22254, 22247, 22245, 22337, 22341, 22348, 22345, 22347, 22354, 22790, 22848, 22950, 22936, 22944, 22935, 22926, 22946, 22928, 22927, 22951, 22945, 23438, 23442, 23592, 23594, 23693, 23695, 23688, 23691, 23689, 23698, 23690, 23686, 23699, 23701, 24032, 24074, 24078, 24203, 24201, 24204, 24200, 24205, 24325, 24349, 24440, 24438, 24530, 24529, 24528, 24557, 24552, 24558, 24563, 24545, 24548, 24547, 24570, 24559, 24567, 24571, 24576, 24564, 25146, 25219, 25228, 25230, 25231, 25236, 25223, 25201, 25211, 25210, 25200, 25217, 25224, 25207, 25213, 25202, 25204, 25911, 26096, 26100, 26099, 26098, 26101, 26437, 26439, 26457, 26453, 26444, 26440, 26461, 26445, 26458, 26443, 27600, 27673, 27674, 27768, 27751, 27755, 27780, 27787, 27791, 27761, 27759, 27753, 27802, 27757, 27783, 27797, 27804, 27750, 27763, 27749, 27771, 27790, 28788, 28794, 29283, 29375, 29373, 29379, 29382, 29377, 29370, 29381, 29589, 29591, 29587, 29588, 29586, 30010, 30009, 30100, 30101, 30337, 31037, 32820, 32917, 32921, 32912, 32914, 32924, 33424, 33423, 33413, 33422, 33425, 33427, 33418, 33411, 33412, 35960, 36809, 36799, 37023, 37025, 37029, 37022, 37031, 37024, 38448, 38440, 38447, 38445, 20019, 20376, 20348, 20357, 20349, 20352, 20359, 20342, 20340, 20361, 20356, 20343, 20300, 20375, 20330, 20378, 20345, 20353, 20344, 20368, 20380, 20372, 20382, 20370, 20354, 20373, 20331, 20334, 20894, 20924, 20926, 21045, 21042, 21043, 21062, 21041, 21180, 21258, 21259, 21308, 21394, 21396, 21639, 21631, 21633, 21649, 21634, 21640, 21611, 21626, 21630, 21605, 21612, 21620, 21606, 21645, 21615, 21601, 21600, 21656, 21603, 21607, 21604, 22263, 22265, 22383, 22386, 22381, 22379, 22385, 22384, 22390, 22400, 22389, 22395, 22387, 22388, 22370, 22376, 22397, 22796, 22853, 22965, 22970, 22991, 22990, 22962, 22988, 22977, 22966, 22972, 22979, 22998, 22961, 22973, 22976, 22984, 22964, 22983, 23394, 23397, 23443, 23445, 23620, 23623, 23726, 23716, 23712, 23733, 23727, 23720, 23724, 23711, 23715, 23725, 23714, 23722, 23719, 23709, 23717, 23734, 23728, 23718, 24087, 24084, 24089, 24360, 24354, 24355, 24356, 24404, 24450, 24446, 24445, 24542, 24549, 24621, 24614, 24601, 24626, 24587, 24628, 24586, 24599, 24627, 24602, 24606, 24620, 24610, 24589, 24592, 24622, 24595, 24593, 24588, 24585, 24604, 25108, 25149, 25261, 25268, 25297, 25278, 25258, 25270, 25290, 25262, 25267, 25263, 25275, 25257, 25264, 25272, 25917, 26024, 26043, 26121, 26108, 26116, 26130, 26120, 26107, 26115, 26123, 26125, 26117, 26109, 26129, 26128, 26358, 26378, 26501, 26476, 26510, 26514, 26486, 26491, 26520, 26502, 26500, 26484, 26509, 26508, 26490, 26527, 26513, 26521, 26499, 26493, 26497, 26488, 26489, 26516, 27429, 27520, 27518, 27614, 27677, 27795, 27884, 27883, 27886, 27865, 27830, 27860, 27821, 27879, 27831, 27856, 27842, 27834, 27843, 27846, 27885, 27890, 27858, 27869, 27828, 27786, 27805, 27776, 27870, 27840, 27952, 27853, 27847, 27824, 27897, 27855, 27881, 27857, 28820, 28824, 28805, 28819, 28806, 28804, 28817, 28822, 28802, 28826, 28803, 29290, 29398, 29387, 29400, 29385, 29404, 29394, 29396, 29402, 29388, 29393, 29604, 29601, 29613, 29606, 29602, 29600, 29612, 29597, 29917, 29928, 30015, 30016, 30014, 30092, 30104, 30383, 30451, 30449, 30448, 30453, 30712, 30716, 30713, 30715, 30714, 30711, 31042, 31039, 31173, 31352, 31355, 31483, 31861, 31997, 32821, 32911, 32942, 32931, 32952, 32949, 32941, 33312, 33440, 33472, 33451, 33434, 33432, 33435, 33461, 33447, 33454, 33468, 33438, 33466, 33460, 33448, 33441, 33449, 33474, 33444, 33475, 33462, 33442, 34416, 34415, 34413, 34414, 35926, 36818, 36811, 36819, 36813, 36822, 36821, 36823, 37042, 37044, 37039, 37043, 37040, 38457, 38461, 38460, 38458, 38467, 20429, 20421, 20435, 20402, 20425, 20427, 20417, 20436, 20444, 20441, 20411, 20403, 20443, 20423, 20438, 20410, 20416, 20409, 20460, 21060, 21065, 21184, 21186, 21309, 21372, 21399, 21398, 21401, 21400, 21690, 21665, 21677, 21669, 21711, 21699, 33549, 21687, 21678, 21718, 21686, 21701, 21702, 21664, 21616, 21692, 21666, 21694, 21618, 21726, 21680, 22453, 22430, 22431, 22436, 22412, 22423, 22429, 22427, 22420, 22424, 22415, 22425, 22437, 22426, 22421, 22772, 22797, 22867, 23009, 23006, 23022, 23040, 23025, 23005, 23034, 23037, 23036, 23030, 23012, 23026, 23031, 23003, 23017, 23027, 23029, 23008, 23038, 23028, 23021, 23464, 23628, 23760, 23768, 23756, 23767, 23755, 23771, 23774, 23770, 23753, 23751, 23754, 23766, 23763, 23764, 23759, 23752, 23750, 23758, 23775, 23800, 24057, 24097, 24098, 24099, 24096, 24100, 24240, 24228, 24226, 24219, 24227, 24229, 24327, 24366, 24406, 24454, 24631, 24633, 24660, 24690, 24670, 24645, 24659, 24647, 24649, 24667, 24652, 24640, 24642, 24671, 24612, 24644, 24664, 24678, 24686, 25154, 25155, 25295, 25357, 25355, 25333, 25358, 25347, 25323, 25337, 25359, 25356, 25336, 25334, 25344, 25363, 25364, 25338, 25365, 25339, 25328, 25921, 25923, 26026, 26047, 26166, 26145, 26162, 26165, 26140, 26150, 26146, 26163, 26155, 26170, 26141, 26164, 26169, 26158, 26383, 26384, 26561, 26610, 26568, 26554, 26588, 26555, 26616, 26584, 26560, 26551, 26565, 26603, 26596, 26591, 26549, 26573, 26547, 26615, 26614, 26606, 26595, 26562, 26553, 26574, 26599, 26608, 26546, 26620, 26566, 26605, 26572, 26542, 26598, 26587, 26618, 26569, 26570, 26563, 26602, 26571, 27432, 27522, 27524, 27574, 27606, 27608, 27616, 27680, 27681, 27944, 27956, 27949, 27935, 27964, 27967, 27922, 27914, 27866, 27955, 27908, 27929, 27962, 27930, 27921, 27904, 27933, 27970, 27905, 27928, 27959, 27907, 27919, 27968, 27911, 27936, 27948, 27912, 27938, 27913, 27920, 28855, 28831, 28862, 28849, 28848, 28833, 28852, 28853, 28841, 29249, 29257, 29258, 29292, 29296, 29299, 29294, 29386, 29412, 29416, 29419, 29407, 29418, 29414, 29411, 29573, 29644, 29634, 29640, 29637, 29625, 29622, 29621, 29620, 29675, 29631, 29639, 29630, 29635, 29638, 29624, 29643, 29932, 29934, 29998, 30023, 30024, 30119, 30122, 30329, 30404, 30472, 30467, 30468, 30469, 30474, 30455, 30459, 30458, 30695, 30696, 30726, 30737, 30738, 30725, 30736, 30735, 30734, 30729, 30723, 30739, 31050, 31052, 31051, 31045, 31044, 31189, 31181, 31183, 31190, 31182, 31360, 31358, 31441, 31488, 31489, 31866, 31864, 31865, 31871, 31872, 31873, 32003, 32008, 32001, 32600, 32657, 32653, 32702, 32775, 32782, 32783, 32788, 32823, 32984, 32967, 32992, 32977, 32968, 32962, 32976, 32965, 32995, 32985, 32988, 32970, 32981, 32969, 32975, 32983, 32998, 32973, 33279, 33313, 33428, 33497, 33534, 33529, 33543, 33512, 33536, 33493, 33594, 33515, 33494, 33524, 33516, 33505, 33522, 33525, 33548, 33531, 33526, 33520, 33514, 33508, 33504, 33530, 33523, 33517, 34423, 34420, 34428, 34419, 34881, 34894, 34919, 34922, 34921, 35283, 35332, 35335, 36210, 36835, 36833, 36846, 36832, 37105, 37053, 37055, 37077, 37061, 37054, 37063, 37067, 37064, 37332, 37331, 38484, 38479, 38481, 38483, 38474, 38478, 20510, 20485, 20487, 20499, 20514, 20528, 20507, 20469, 20468, 20531, 20535, 20524, 20470, 20471, 20503, 20508, 20512, 20519, 20533, 20527, 20529, 20494, 20826, 20884, 20883, 20938, 20932, 20933, 20936, 20942, 21089, 21082, 21074, 21086, 21087, 21077, 21090, 21197, 21262, 21406, 21798, 21730, 21783, 21778, 21735, 21747, 21732, 21786, 21759, 21764, 21768, 21739, 21777, 21765, 21745, 21770, 21755, 21751, 21752, 21728, 21774, 21763, 21771, 22273, 22274, 22476, 22578, 22485, 22482, 22458, 22470, 22461, 22460, 22456, 22454, 22463, 22471, 22480, 22457, 22465, 22798, 22858, 23065, 23062, 23085, 23086, 23061, 23055, 23063, 23050, 23070, 23091, 23404, 23463, 23469, 23468, 23555, 23638, 23636, 23788, 23807, 23790, 23793, 23799, 23808, 23801, 24105, 24104, 24232, 24238, 24234, 24236, 24371, 24368, 24423, 24669, 24666, 24679, 24641, 24738, 24712, 24704, 24722, 24705, 24733, 24707, 24725, 24731, 24727, 24711, 24732, 24718, 25113, 25158, 25330, 25360, 25430, 25388, 25412, 25413, 25398, 25411, 25572, 25401, 25419, 25418, 25404, 25385, 25409, 25396, 25432, 25428, 25433, 25389, 25415, 25395, 25434, 25425, 25400, 25431, 25408, 25416, 25930, 25926, 26054, 26051, 26052, 26050, 26186, 26207, 26183, 26193, 26386, 26387, 26655, 26650, 26697, 26674, 26675, 26683, 26699, 26703, 26646, 26673, 26652, 26677, 26667, 26669, 26671, 26702, 26692, 26676, 26653, 26642, 26644, 26662, 26664, 26670, 26701, 26682, 26661, 26656, 27436, 27439, 27437, 27441, 27444, 27501, 32898, 27528, 27622, 27620, 27624, 27619, 27618, 27623, 27685, 28026, 28003, 28004, 28022, 27917, 28001, 28050, 27992, 28002, 28013, 28015, 28049, 28045, 28143, 28031, 28038, 27998, 28007, 28e3, 28055, 28016, 28028, 27999, 28034, 28056, 27951, 28008, 28043, 28030, 28032, 28036, 27926, 28035, 28027, 28029, 28021, 28048, 28892, 28883, 28881, 28893, 28875, 32569, 28898, 28887, 28882, 28894, 28896, 28884, 28877, 28869, 28870, 28871, 28890, 28878, 28897, 29250, 29304, 29303, 29302, 29440, 29434, 29428, 29438, 29430, 29427, 29435, 29441, 29651, 29657, 29669, 29654, 29628, 29671, 29667, 29673, 29660, 29650, 29659, 29652, 29661, 29658, 29655, 29656, 29672, 29918, 29919, 29940, 29941, 29985, 30043, 30047, 30128, 30145, 30139, 30148, 30144, 30143, 30134, 30138, 30346, 30409, 30493, 30491, 30480, 30483, 30482, 30499, 30481, 30485, 30489, 30490, 30498, 30503, 30755, 30764, 30754, 30773, 30767, 30760, 30766, 30763, 30753, 30761, 30771, 30762, 30769, 31060, 31067, 31055, 31068, 31059, 31058, 31057, 31211, 31212, 31200, 31214, 31213, 31210, 31196, 31198, 31197, 31366, 31369, 31365, 31371, 31372, 31370, 31367, 31448, 31504, 31492, 31507, 31493, 31503, 31496, 31498, 31502, 31497, 31506, 31876, 31889, 31882, 31884, 31880, 31885, 31877, 32030, 32029, 32017, 32014, 32024, 32022, 32019, 32031, 32018, 32015, 32012, 32604, 32609, 32606, 32608, 32605, 32603, 32662, 32658, 32707, 32706, 32704, 32790, 32830, 32825, 33018, 33010, 33017, 33013, 33025, 33019, 33024, 33281, 33327, 33317, 33587, 33581, 33604, 33561, 33617, 33573, 33622, 33599, 33601, 33574, 33564, 33570, 33602, 33614, 33563, 33578, 33544, 33596, 33613, 33558, 33572, 33568, 33591, 33583, 33577, 33607, 33605, 33612, 33619, 33566, 33580, 33611, 33575, 33608, 34387, 34386, 34466, 34472, 34454, 34445, 34449, 34462, 34439, 34455, 34438, 34443, 34458, 34437, 34469, 34457, 34465, 34471, 34453, 34456, 34446, 34461, 34448, 34452, 34883, 34884, 34925, 34933, 34934, 34930, 34944, 34929, 34943, 34927, 34947, 34942, 34932, 34940, 35346, 35911, 35927, 35963, 36004, 36003, 36214, 36216, 36277, 36279, 36278, 36561, 36563, 36862, 36853, 36866, 36863, 36859, 36868, 36860, 36854, 37078, 37088, 37081, 37082, 37091, 37087, 37093, 37080, 37083, 37079, 37084, 37092, 37200, 37198, 37199, 37333, 37346, 37338, 38492, 38495, 38588, 39139, 39647, 39727, 20095, 20592, 20586, 20577, 20574, 20576, 20563, 20555, 20573, 20594, 20552, 20557, 20545, 20571, 20554, 20578, 20501, 20549, 20575, 20585, 20587, 20579, 20580, 20550, 20544, 20590, 20595, 20567, 20561, 20944, 21099, 21101, 21100, 21102, 21206, 21203, 21293, 21404, 21877, 21878, 21820, 21837, 21840, 21812, 21802, 21841, 21858, 21814, 21813, 21808, 21842, 21829, 21772, 21810, 21861, 21838, 21817, 21832, 21805, 21819, 21824, 21835, 22282, 22279, 22523, 22548, 22498, 22518, 22492, 22516, 22528, 22509, 22525, 22536, 22520, 22539, 22515, 22479, 22535, 22510, 22499, 22514, 22501, 22508, 22497, 22542, 22524, 22544, 22503, 22529, 22540, 22513, 22505, 22512, 22541, 22532, 22876, 23136, 23128, 23125, 23143, 23134, 23096, 23093, 23149, 23120, 23135, 23141, 23148, 23123, 23140, 23127, 23107, 23133, 23122, 23108, 23131, 23112, 23182, 23102, 23117, 23097, 23116, 23152, 23145, 23111, 23121, 23126, 23106, 23132, 23410, 23406, 23489, 23488, 23641, 23838, 23819, 23837, 23834, 23840, 23820, 23848, 23821, 23846, 23845, 23823, 23856, 23826, 23843, 23839, 23854, 24126, 24116, 24241, 24244, 24249, 24242, 24243, 24374, 24376, 24475, 24470, 24479, 24714, 24720, 24710, 24766, 24752, 24762, 24787, 24788, 24783, 24804, 24793, 24797, 24776, 24753, 24795, 24759, 24778, 24767, 24771, 24781, 24768, 25394, 25445, 25482, 25474, 25469, 25533, 25502, 25517, 25501, 25495, 25515, 25486, 25455, 25479, 25488, 25454, 25519, 25461, 25500, 25453, 25518, 25468, 25508, 25403, 25503, 25464, 25477, 25473, 25489, 25485, 25456, 25939, 26061, 26213, 26209, 26203, 26201, 26204, 26210, 26392, 26745, 26759, 26768, 26780, 26733, 26734, 26798, 26795, 26966, 26735, 26787, 26796, 26793, 26741, 26740, 26802, 26767, 26743, 26770, 26748, 26731, 26738, 26794, 26752, 26737, 26750, 26779, 26774, 26763, 26784, 26761, 26788, 26744, 26747, 26769, 26764, 26762, 26749, 27446, 27443, 27447, 27448, 27537, 27535, 27533, 27534, 27532, 27690, 28096, 28075, 28084, 28083, 28276, 28076, 28137, 28130, 28087, 28150, 28116, 28160, 28104, 28128, 28127, 28118, 28094, 28133, 28124, 28125, 28123, 28148, 28106, 28093, 28141, 28144, 28090, 28117, 28098, 28111, 28105, 28112, 28146, 28115, 28157, 28119, 28109, 28131, 28091, 28922, 28941, 28919, 28951, 28916, 28940, 28912, 28932, 28915, 28944, 28924, 28927, 28934, 28947, 28928, 28920, 28918, 28939, 28930, 28942, 29310, 29307, 29308, 29311, 29469, 29463, 29447, 29457, 29464, 29450, 29448, 29439, 29455, 29470, 29576, 29686, 29688, 29685, 29700, 29697, 29693, 29703, 29696, 29690, 29692, 29695, 29708, 29707, 29684, 29704, 30052, 30051, 30158, 30162, 30159, 30155, 30156, 30161, 30160, 30351, 30345, 30419, 30521, 30511, 30509, 30513, 30514, 30516, 30515, 30525, 30501, 30523, 30517, 30792, 30802, 30793, 30797, 30794, 30796, 30758, 30789, 30800, 31076, 31079, 31081, 31082, 31075, 31083, 31073, 31163, 31226, 31224, 31222, 31223, 31375, 31380, 31376, 31541, 31559, 31540, 31525, 31536, 31522, 31524, 31539, 31512, 31530, 31517, 31537, 31531, 31533, 31535, 31538, 31544, 31514, 31523, 31892, 31896, 31894, 31907, 32053, 32061, 32056, 32054, 32058, 32069, 32044, 32041, 32065, 32071, 32062, 32063, 32074, 32059, 32040, 32611, 32661, 32668, 32669, 32667, 32714, 32715, 32717, 32720, 32721, 32711, 32719, 32713, 32799, 32798, 32795, 32839, 32835, 32840, 33048, 33061, 33049, 33051, 33069, 33055, 33068, 33054, 33057, 33045, 33063, 33053, 33058, 33297, 33336, 33331, 33338, 33332, 33330, 33396, 33680, 33699, 33704, 33677, 33658, 33651, 33700, 33652, 33679, 33665, 33685, 33689, 33653, 33684, 33705, 33661, 33667, 33676, 33693, 33691, 33706, 33675, 33662, 33701, 33711, 33672, 33687, 33712, 33663, 33702, 33671, 33710, 33654, 33690, 34393, 34390, 34495, 34487, 34498, 34497, 34501, 34490, 34480, 34504, 34489, 34483, 34488, 34508, 34484, 34491, 34492, 34499, 34493, 34494, 34898, 34953, 34965, 34984, 34978, 34986, 34970, 34961, 34977, 34975, 34968, 34983, 34969, 34971, 34967, 34980, 34988, 34956, 34963, 34958, 35202, 35286, 35289, 35285, 35376, 35367, 35372, 35358, 35897, 35899, 35932, 35933, 35965, 36005, 36221, 36219, 36217, 36284, 36290, 36281, 36287, 36289, 36568, 36574, 36573, 36572, 36567, 36576, 36577, 36900, 36875, 36881, 36892, 36876, 36897, 37103, 37098, 37104, 37108, 37106, 37107, 37076, 37099, 37100, 37097, 37206, 37208, 37210, 37203, 37205, 37356, 37364, 37361, 37363, 37368, 37348, 37369, 37354, 37355, 37367, 37352, 37358, 38266, 38278, 38280, 38524, 38509, 38507, 38513, 38511, 38591, 38762, 38916, 39141, 39319, 20635, 20629, 20628, 20638, 20619, 20643, 20611, 20620, 20622, 20637, 20584, 20636, 20626, 20610, 20615, 20831, 20948, 21266, 21265, 21412, 21415, 21905, 21928, 21925, 21933, 21879, 22085, 21922, 21907, 21896, 21903, 21941, 21889, 21923, 21906, 21924, 21885, 21900, 21926, 21887, 21909, 21921, 21902, 22284, 22569, 22583, 22553, 22558, 22567, 22563, 22568, 22517, 22600, 22565, 22556, 22555, 22579, 22591, 22582, 22574, 22585, 22584, 22573, 22572, 22587, 22881, 23215, 23188, 23199, 23162, 23202, 23198, 23160, 23206, 23164, 23205, 23212, 23189, 23214, 23095, 23172, 23178, 23191, 23171, 23179, 23209, 23163, 23165, 23180, 23196, 23183, 23187, 23197, 23530, 23501, 23499, 23508, 23505, 23498, 23502, 23564, 23600, 23863, 23875, 23915, 23873, 23883, 23871, 23861, 23889, 23886, 23893, 23859, 23866, 23890, 23869, 23857, 23897, 23874, 23865, 23881, 23864, 23868, 23858, 23862, 23872, 23877, 24132, 24129, 24408, 24486, 24485, 24491, 24777, 24761, 24780, 24802, 24782, 24772, 24852, 24818, 24842, 24854, 24837, 24821, 24851, 24824, 24828, 24830, 24769, 24835, 24856, 24861, 24848, 24831, 24836, 24843, 25162, 25492, 25521, 25520, 25550, 25573, 25576, 25583, 25539, 25757, 25587, 25546, 25568, 25590, 25557, 25586, 25589, 25697, 25567, 25534, 25565, 25564, 25540, 25560, 25555, 25538, 25543, 25548, 25547, 25544, 25584, 25559, 25561, 25906, 25959, 25962, 25956, 25948, 25960, 25957, 25996, 26013, 26014, 26030, 26064, 26066, 26236, 26220, 26235, 26240, 26225, 26233, 26218, 26226, 26369, 26892, 26835, 26884, 26844, 26922, 26860, 26858, 26865, 26895, 26838, 26871, 26859, 26852, 26870, 26899, 26896, 26867, 26849, 26887, 26828, 26888, 26992, 26804, 26897, 26863, 26822, 26900, 26872, 26832, 26877, 26876, 26856, 26891, 26890, 26903, 26830, 26824, 26845, 26846, 26854, 26868, 26833, 26886, 26836, 26857, 26901, 26917, 26823, 27449, 27451, 27455, 27452, 27540, 27543, 27545, 27541, 27581, 27632, 27634, 27635, 27696, 28156, 28230, 28231, 28191, 28233, 28296, 28220, 28221, 28229, 28258, 28203, 28223, 28225, 28253, 28275, 28188, 28211, 28235, 28224, 28241, 28219, 28163, 28206, 28254, 28264, 28252, 28257, 28209, 28200, 28256, 28273, 28267, 28217, 28194, 28208, 28243, 28261, 28199, 28280, 28260, 28279, 28245, 28281, 28242, 28262, 28213, 28214, 28250, 28960, 28958, 28975, 28923, 28974, 28977, 28963, 28965, 28962, 28978, 28959, 28968, 28986, 28955, 29259, 29274, 29320, 29321, 29318, 29317, 29323, 29458, 29451, 29488, 29474, 29489, 29491, 29479, 29490, 29485, 29478, 29475, 29493, 29452, 29742, 29740, 29744, 29739, 29718, 29722, 29729, 29741, 29745, 29732, 29731, 29725, 29737, 29728, 29746, 29947, 29999, 30063, 30060, 30183, 30170, 30177, 30182, 30173, 30175, 30180, 30167, 30357, 30354, 30426, 30534, 30535, 30532, 30541, 30533, 30538, 30542, 30539, 30540, 30686, 30700, 30816, 30820, 30821, 30812, 30829, 30833, 30826, 30830, 30832, 30825, 30824, 30814, 30818, 31092, 31091, 31090, 31088, 31234, 31242, 31235, 31244, 31236, 31385, 31462, 31460, 31562, 31547, 31556, 31560, 31564, 31566, 31552, 31576, 31557, 31906, 31902, 31912, 31905, 32088, 32111, 32099, 32083, 32086, 32103, 32106, 32079, 32109, 32092, 32107, 32082, 32084, 32105, 32081, 32095, 32078, 32574, 32575, 32613, 32614, 32674, 32672, 32673, 32727, 32849, 32847, 32848, 33022, 32980, 33091, 33098, 33106, 33103, 33095, 33085, 33101, 33082, 33254, 33262, 33271, 33272, 33273, 33284, 33340, 33341, 33343, 33397, 33595, 33743, 33785, 33827, 33728, 33768, 33810, 33767, 33764, 33788, 33782, 33808, 33734, 33736, 33771, 33763, 33727, 33793, 33757, 33765, 33752, 33791, 33761, 33739, 33742, 33750, 33781, 33737, 33801, 33807, 33758, 33809, 33798, 33730, 33779, 33749, 33786, 33735, 33745, 33770, 33811, 33731, 33772, 33774, 33732, 33787, 33751, 33762, 33819, 33755, 33790, 34520, 34530, 34534, 34515, 34531, 34522, 34538, 34525, 34539, 34524, 34540, 34537, 34519, 34536, 34513, 34888, 34902, 34901, 35002, 35031, 35001, 35e3, 35008, 35006, 34998, 35004, 34999, 35005, 34994, 35073, 35017, 35221, 35224, 35223, 35293, 35290, 35291, 35406, 35405, 35385, 35417, 35392, 35415, 35416, 35396, 35397, 35410, 35400, 35409, 35402, 35404, 35407, 35935, 35969, 35968, 36026, 36030, 36016, 36025, 36021, 36228, 36224, 36233, 36312, 36307, 36301, 36295, 36310, 36316, 36303, 36309, 36313, 36296, 36311, 36293, 36591, 36599, 36602, 36601, 36582, 36590, 36581, 36597, 36583, 36584, 36598, 36587, 36593, 36588, 36596, 36585, 36909, 36916, 36911, 37126, 37164, 37124, 37119, 37116, 37128, 37113, 37115, 37121, 37120, 37127, 37125, 37123, 37217, 37220, 37215, 37218, 37216, 37377, 37386, 37413, 37379, 37402, 37414, 37391, 37388, 37376, 37394, 37375, 37373, 37382, 37380, 37415, 37378, 37404, 37412, 37401, 37399, 37381, 37398, 38267, 38285, 38284, 38288, 38535, 38526, 38536, 38537, 38531, 38528, 38594, 38600, 38595, 38641, 38640, 38764, 38768, 38766, 38919, 39081, 39147, 40166, 40697, 20099, 20100, 20150, 20669, 20671, 20678, 20654, 20676, 20682, 20660, 20680, 20674, 20656, 20673, 20666, 20657, 20683, 20681, 20662, 20664, 20951, 21114, 21112, 21115, 21116, 21955, 21979, 21964, 21968, 21963, 21962, 21981, 21952, 21972, 21956, 21993, 21951, 21970, 21901, 21967, 21973, 21986, 21974, 21960, 22002, 21965, 21977, 21954, 22292, 22611, 22632, 22628, 22607, 22605, 22601, 22639, 22613, 22606, 22621, 22617, 22629, 22619, 22589, 22627, 22641, 22780, 23239, 23236, 23243, 23226, 23224, 23217, 23221, 23216, 23231, 23240, 23227, 23238, 23223, 23232, 23242, 23220, 23222, 23245, 23225, 23184, 23510, 23512, 23513, 23583, 23603, 23921, 23907, 23882, 23909, 23922, 23916, 23902, 23912, 23911, 23906, 24048, 24143, 24142, 24138, 24141, 24139, 24261, 24268, 24262, 24267, 24263, 24384, 24495, 24493, 24823, 24905, 24906, 24875, 24901, 24886, 24882, 24878, 24902, 24879, 24911, 24873, 24896, 25120, 37224, 25123, 25125, 25124, 25541, 25585, 25579, 25616, 25618, 25609, 25632, 25636, 25651, 25667, 25631, 25621, 25624, 25657, 25655, 25634, 25635, 25612, 25638, 25648, 25640, 25665, 25653, 25647, 25610, 25626, 25664, 25637, 25639, 25611, 25575, 25627, 25646, 25633, 25614, 25967, 26002, 26067, 26246, 26252, 26261, 26256, 26251, 26250, 26265, 26260, 26232, 26400, 26982, 26975, 26936, 26958, 26978, 26993, 26943, 26949, 26986, 26937, 26946, 26967, 26969, 27002, 26952, 26953, 26933, 26988, 26931, 26941, 26981, 26864, 27e3, 26932, 26985, 26944, 26991, 26948, 26998, 26968, 26945, 26996, 26956, 26939, 26955, 26935, 26972, 26959, 26961, 26930, 26962, 26927, 27003, 26940, 27462, 27461, 27459, 27458, 27464, 27457, 27547, 64013, 27643, 27644, 27641, 27639, 27640, 28315, 28374, 28360, 28303, 28352, 28319, 28307, 28308, 28320, 28337, 28345, 28358, 28370, 28349, 28353, 28318, 28361, 28343, 28336, 28365, 28326, 28367, 28338, 28350, 28355, 28380, 28376, 28313, 28306, 28302, 28301, 28324, 28321, 28351, 28339, 28368, 28362, 28311, 28334, 28323, 28999, 29012, 29010, 29027, 29024, 28993, 29021, 29026, 29042, 29048, 29034, 29025, 28994, 29016, 28995, 29003, 29040, 29023, 29008, 29011, 28996, 29005, 29018, 29263, 29325, 29324, 29329, 29328, 29326, 29500, 29506, 29499, 29498, 29504, 29514, 29513, 29764, 29770, 29771, 29778, 29777, 29783, 29760, 29775, 29776, 29774, 29762, 29766, 29773, 29780, 29921, 29951, 29950, 29949, 29981, 30073, 30071, 27011, 30191, 30223, 30211, 30199, 30206, 30204, 30201, 30200, 30224, 30203, 30198, 30189, 30197, 30205, 30361, 30389, 30429, 30549, 30559, 30560, 30546, 30550, 30554, 30569, 30567, 30548, 30553, 30573, 30688, 30855, 30874, 30868, 30863, 30852, 30869, 30853, 30854, 30881, 30851, 30841, 30873, 30848, 30870, 30843, 31100, 31106, 31101, 31097, 31249, 31256, 31257, 31250, 31255, 31253, 31266, 31251, 31259, 31248, 31395, 31394, 31390, 31467, 31590, 31588, 31597, 31604, 31593, 31602, 31589, 31603, 31601, 31600, 31585, 31608, 31606, 31587, 31922, 31924, 31919, 32136, 32134, 32128, 32141, 32127, 32133, 32122, 32142, 32123, 32131, 32124, 32140, 32148, 32132, 32125, 32146, 32621, 32619, 32615, 32616, 32620, 32678, 32677, 32679, 32731, 32732, 32801, 33124, 33120, 33143, 33116, 33129, 33115, 33122, 33138, 26401, 33118, 33142, 33127, 33135, 33092, 33121, 33309, 33353, 33348, 33344, 33346, 33349, 34033, 33855, 33878, 33910, 33913, 33935, 33933, 33893, 33873, 33856, 33926, 33895, 33840, 33869, 33917, 33882, 33881, 33908, 33907, 33885, 34055, 33886, 33847, 33850, 33844, 33914, 33859, 33912, 33842, 33861, 33833, 33753, 33867, 33839, 33858, 33837, 33887, 33904, 33849, 33870, 33868, 33874, 33903, 33989, 33934, 33851, 33863, 33846, 33843, 33896, 33918, 33860, 33835, 33888, 33876, 33902, 33872, 34571, 34564, 34551, 34572, 34554, 34518, 34549, 34637, 34552, 34574, 34569, 34561, 34550, 34573, 34565, 35030, 35019, 35021, 35022, 35038, 35035, 35034, 35020, 35024, 35205, 35227, 35295, 35301, 35300, 35297, 35296, 35298, 35292, 35302, 35446, 35462, 35455, 35425, 35391, 35447, 35458, 35460, 35445, 35459, 35457, 35444, 35450, 35900, 35915, 35914, 35941, 35940, 35942, 35974, 35972, 35973, 36044, 36200, 36201, 36241, 36236, 36238, 36239, 36237, 36243, 36244, 36240, 36242, 36336, 36320, 36332, 36337, 36334, 36304, 36329, 36323, 36322, 36327, 36338, 36331, 36340, 36614, 36607, 36609, 36608, 36613, 36615, 36616, 36610, 36619, 36946, 36927, 36932, 36937, 36925, 37136, 37133, 37135, 37137, 37142, 37140, 37131, 37134, 37230, 37231, 37448, 37458, 37424, 37434, 37478, 37427, 37477, 37470, 37507, 37422, 37450, 37446, 37485, 37484, 37455, 37472, 37479, 37487, 37430, 37473, 37488, 37425, 37460, 37475, 37456, 37490, 37454, 37459, 37452, 37462, 37426, 38303, 38300, 38302, 38299, 38546, 38547, 38545, 38551, 38606, 38650, 38653, 38648, 38645, 38771, 38775, 38776, 38770, 38927, 38925, 38926, 39084, 39158, 39161, 39343, 39346, 39344, 39349, 39597, 39595, 39771, 40170, 40173, 40167, 40576, 40701, 20710, 20692, 20695, 20712, 20723, 20699, 20714, 20701, 20708, 20691, 20716, 20720, 20719, 20707, 20704, 20952, 21120, 21121, 21225, 21227, 21296, 21420, 22055, 22037, 22028, 22034, 22012, 22031, 22044, 22017, 22035, 22018, 22010, 22045, 22020, 22015, 22009, 22665, 22652, 22672, 22680, 22662, 22657, 22655, 22644, 22667, 22650, 22663, 22673, 22670, 22646, 22658, 22664, 22651, 22676, 22671, 22782, 22891, 23260, 23278, 23269, 23253, 23274, 23258, 23277, 23275, 23283, 23266, 23264, 23259, 23276, 23262, 23261, 23257, 23272, 23263, 23415, 23520, 23523, 23651, 23938, 23936, 23933, 23942, 23930, 23937, 23927, 23946, 23945, 23944, 23934, 23932, 23949, 23929, 23935, 24152, 24153, 24147, 24280, 24273, 24279, 24270, 24284, 24277, 24281, 24274, 24276, 24388, 24387, 24431, 24502, 24876, 24872, 24897, 24926, 24945, 24947, 24914, 24915, 24946, 24940, 24960, 24948, 24916, 24954, 24923, 24933, 24891, 24938, 24929, 24918, 25129, 25127, 25131, 25643, 25677, 25691, 25693, 25716, 25718, 25714, 25715, 25725, 25717, 25702, 25766, 25678, 25730, 25694, 25692, 25675, 25683, 25696, 25680, 25727, 25663, 25708, 25707, 25689, 25701, 25719, 25971, 26016, 26273, 26272, 26271, 26373, 26372, 26402, 27057, 27062, 27081, 27040, 27086, 27030, 27056, 27052, 27068, 27025, 27033, 27022, 27047, 27021, 27049, 27070, 27055, 27071, 27076, 27069, 27044, 27092, 27065, 27082, 27034, 27087, 27059, 27027, 27050, 27041, 27038, 27097, 27031, 27024, 27074, 27061, 27045, 27078, 27466, 27469, 27467, 27550, 27551, 27552, 27587, 27588, 27646, 28366, 28405, 28401, 28419, 28453, 28408, 28471, 28411, 28462, 28425, 28494, 28441, 28442, 28455, 28440, 28475, 28434, 28397, 28426, 28470, 28531, 28409, 28398, 28461, 28480, 28464, 28476, 28469, 28395, 28423, 28430, 28483, 28421, 28413, 28406, 28473, 28444, 28412, 28474, 28447, 28429, 28446, 28424, 28449, 29063, 29072, 29065, 29056, 29061, 29058, 29071, 29051, 29062, 29057, 29079, 29252, 29267, 29335, 29333, 29331, 29507, 29517, 29521, 29516, 29794, 29811, 29809, 29813, 29810, 29799, 29806, 29952, 29954, 29955, 30077, 30096, 30230, 30216, 30220, 30229, 30225, 30218, 30228, 30392, 30593, 30588, 30597, 30594, 30574, 30592, 30575, 30590, 30595, 30898, 30890, 30900, 30893, 30888, 30846, 30891, 30878, 30885, 30880, 30892, 30882, 30884, 31128, 31114, 31115, 31126, 31125, 31124, 31123, 31127, 31112, 31122, 31120, 31275, 31306, 31280, 31279, 31272, 31270, 31400, 31403, 31404, 31470, 31624, 31644, 31626, 31633, 31632, 31638, 31629, 31628, 31643, 31630, 31621, 31640, 21124, 31641, 31652, 31618, 31931, 31935, 31932, 31930, 32167, 32183, 32194, 32163, 32170, 32193, 32192, 32197, 32157, 32206, 32196, 32198, 32203, 32204, 32175, 32185, 32150, 32188, 32159, 32166, 32174, 32169, 32161, 32201, 32627, 32738, 32739, 32741, 32734, 32804, 32861, 32860, 33161, 33158, 33155, 33159, 33165, 33164, 33163, 33301, 33943, 33956, 33953, 33951, 33978, 33998, 33986, 33964, 33966, 33963, 33977, 33972, 33985, 33997, 33962, 33946, 33969, 34e3, 33949, 33959, 33979, 33954, 33940, 33991, 33996, 33947, 33961, 33967, 33960, 34006, 33944, 33974, 33999, 33952, 34007, 34004, 34002, 34011, 33968, 33937, 34401, 34611, 34595, 34600, 34667, 34624, 34606, 34590, 34593, 34585, 34587, 34627, 34604, 34625, 34622, 34630, 34592, 34610, 34602, 34605, 34620, 34578, 34618, 34609, 34613, 34626, 34598, 34599, 34616, 34596, 34586, 34608, 34577, 35063, 35047, 35057, 35058, 35066, 35070, 35054, 35068, 35062, 35067, 35056, 35052, 35051, 35229, 35233, 35231, 35230, 35305, 35307, 35304, 35499, 35481, 35467, 35474, 35471, 35478, 35901, 35944, 35945, 36053, 36047, 36055, 36246, 36361, 36354, 36351, 36365, 36349, 36362, 36355, 36359, 36358, 36357, 36350, 36352, 36356, 36624, 36625, 36622, 36621, 37155, 37148, 37152, 37154, 37151, 37149, 37146, 37156, 37153, 37147, 37242, 37234, 37241, 37235, 37541, 37540, 37494, 37531, 37498, 37536, 37524, 37546, 37517, 37542, 37530, 37547, 37497, 37527, 37503, 37539, 37614, 37518, 37506, 37525, 37538, 37501, 37512, 37537, 37514, 37510, 37516, 37529, 37543, 37502, 37511, 37545, 37533, 37515, 37421, 38558, 38561, 38655, 38744, 38781, 38778, 38782, 38787, 38784, 38786, 38779, 38788, 38785, 38783, 38862, 38861, 38934, 39085, 39086, 39170, 39168, 39175, 39325, 39324, 39363, 39353, 39355, 39354, 39362, 39357, 39367, 39601, 39651, 39655, 39742, 39743, 39776, 39777, 39775, 40177, 40178, 40181, 40615, 20735, 20739, 20784, 20728, 20742, 20743, 20726, 20734, 20747, 20748, 20733, 20746, 21131, 21132, 21233, 21231, 22088, 22082, 22092, 22069, 22081, 22090, 22089, 22086, 22104, 22106, 22080, 22067, 22077, 22060, 22078, 22072, 22058, 22074, 22298, 22699, 22685, 22705, 22688, 22691, 22703, 22700, 22693, 22689, 22783, 23295, 23284, 23293, 23287, 23286, 23299, 23288, 23298, 23289, 23297, 23303, 23301, 23311, 23655, 23961, 23959, 23967, 23954, 23970, 23955, 23957, 23968, 23964, 23969, 23962, 23966, 24169, 24157, 24160, 24156, 32243, 24283, 24286, 24289, 24393, 24498, 24971, 24963, 24953, 25009, 25008, 24994, 24969, 24987, 24979, 25007, 25005, 24991, 24978, 25002, 24993, 24973, 24934, 25011, 25133, 25710, 25712, 25750, 25760, 25733, 25751, 25756, 25743, 25739, 25738, 25740, 25763, 25759, 25704, 25777, 25752, 25974, 25978, 25977, 25979, 26034, 26035, 26293, 26288, 26281, 26290, 26295, 26282, 26287, 27136, 27142, 27159, 27109, 27128, 27157, 27121, 27108, 27168, 27135, 27116, 27106, 27163, 27165, 27134, 27175, 27122, 27118, 27156, 27127, 27111, 27200, 27144, 27110, 27131, 27149, 27132, 27115, 27145, 27140, 27160, 27173, 27151, 27126, 27174, 27143, 27124, 27158, 27473, 27557, 27555, 27554, 27558, 27649, 27648, 27647, 27650, 28481, 28454, 28542, 28551, 28614, 28562, 28557, 28553, 28556, 28514, 28495, 28549, 28506, 28566, 28534, 28524, 28546, 28501, 28530, 28498, 28496, 28503, 28564, 28563, 28509, 28416, 28513, 28523, 28541, 28519, 28560, 28499, 28555, 28521, 28543, 28565, 28515, 28535, 28522, 28539, 29106, 29103, 29083, 29104, 29088, 29082, 29097, 29109, 29085, 29093, 29086, 29092, 29089, 29098, 29084, 29095, 29107, 29336, 29338, 29528, 29522, 29534, 29535, 29536, 29533, 29531, 29537, 29530, 29529, 29538, 29831, 29833, 29834, 29830, 29825, 29821, 29829, 29832, 29820, 29817, 29960, 29959, 30078, 30245, 30238, 30233, 30237, 30236, 30243, 30234, 30248, 30235, 30364, 30365, 30366, 30363, 30605, 30607, 30601, 30600, 30925, 30907, 30927, 30924, 30929, 30926, 30932, 30920, 30915, 30916, 30921, 31130, 31137, 31136, 31132, 31138, 31131, 27510, 31289, 31410, 31412, 31411, 31671, 31691, 31678, 31660, 31694, 31663, 31673, 31690, 31669, 31941, 31944, 31948, 31947, 32247, 32219, 32234, 32231, 32215, 32225, 32259, 32250, 32230, 32246, 32241, 32240, 32238, 32223, 32630, 32684, 32688, 32685, 32749, 32747, 32746, 32748, 32742, 32744, 32868, 32871, 33187, 33183, 33182, 33173, 33186, 33177, 33175, 33302, 33359, 33363, 33362, 33360, 33358, 33361, 34084, 34107, 34063, 34048, 34089, 34062, 34057, 34061, 34079, 34058, 34087, 34076, 34043, 34091, 34042, 34056, 34060, 34036, 34090, 34034, 34069, 34039, 34027, 34035, 34044, 34066, 34026, 34025, 34070, 34046, 34088, 34077, 34094, 34050, 34045, 34078, 34038, 34097, 34086, 34023, 34024, 34032, 34031, 34041, 34072, 34080, 34096, 34059, 34073, 34095, 34402, 34646, 34659, 34660, 34679, 34785, 34675, 34648, 34644, 34651, 34642, 34657, 34650, 34641, 34654, 34669, 34666, 34640, 34638, 34655, 34653, 34671, 34668, 34682, 34670, 34652, 34661, 34639, 34683, 34677, 34658, 34663, 34665, 34906, 35077, 35084, 35092, 35083, 35095, 35096, 35097, 35078, 35094, 35089, 35086, 35081, 35234, 35236, 35235, 35309, 35312, 35308, 35535, 35526, 35512, 35539, 35537, 35540, 35541, 35515, 35543, 35518, 35520, 35525, 35544, 35523, 35514, 35517, 35545, 35902, 35917, 35983, 36069, 36063, 36057, 36072, 36058, 36061, 36071, 36256, 36252, 36257, 36251, 36384, 36387, 36389, 36388, 36398, 36373, 36379, 36374, 36369, 36377, 36390, 36391, 36372, 36370, 36376, 36371, 36380, 36375, 36378, 36652, 36644, 36632, 36634, 36640, 36643, 36630, 36631, 36979, 36976, 36975, 36967, 36971, 37167, 37163, 37161, 37162, 37170, 37158, 37166, 37253, 37254, 37258, 37249, 37250, 37252, 37248, 37584, 37571, 37572, 37568, 37593, 37558, 37583, 37617, 37599, 37592, 37609, 37591, 37597, 37580, 37615, 37570, 37608, 37578, 37576, 37582, 37606, 37581, 37589, 37577, 37600, 37598, 37607, 37585, 37587, 37557, 37601, 37574, 37556, 38268, 38316, 38315, 38318, 38320, 38564, 38562, 38611, 38661, 38664, 38658, 38746, 38794, 38798, 38792, 38864, 38863, 38942, 38941, 38950, 38953, 38952, 38944, 38939, 38951, 39090, 39176, 39162, 39185, 39188, 39190, 39191, 39189, 39388, 39373, 39375, 39379, 39380, 39374, 39369, 39382, 39384, 39371, 39383, 39372, 39603, 39660, 39659, 39667, 39666, 39665, 39750, 39747, 39783, 39796, 39793, 39782, 39798, 39797, 39792, 39784, 39780, 39788, 40188, 40186, 40189, 40191, 40183, 40199, 40192, 40185, 40187, 40200, 40197, 40196, 40579, 40659, 40719, 40720, 20764, 20755, 20759, 20762, 20753, 20958, 21300, 21473, 22128, 22112, 22126, 22131, 22118, 22115, 22125, 22130, 22110, 22135, 22300, 22299, 22728, 22717, 22729, 22719, 22714, 22722, 22716, 22726, 23319, 23321, 23323, 23329, 23316, 23315, 23312, 23318, 23336, 23322, 23328, 23326, 23535, 23980, 23985, 23977, 23975, 23989, 23984, 23982, 23978, 23976, 23986, 23981, 23983, 23988, 24167, 24168, 24166, 24175, 24297, 24295, 24294, 24296, 24293, 24395, 24508, 24989, 25e3, 24982, 25029, 25012, 25030, 25025, 25036, 25018, 25023, 25016, 24972, 25815, 25814, 25808, 25807, 25801, 25789, 25737, 25795, 25819, 25843, 25817, 25907, 25983, 25980, 26018, 26312, 26302, 26304, 26314, 26315, 26319, 26301, 26299, 26298, 26316, 26403, 27188, 27238, 27209, 27239, 27186, 27240, 27198, 27229, 27245, 27254, 27227, 27217, 27176, 27226, 27195, 27199, 27201, 27242, 27236, 27216, 27215, 27220, 27247, 27241, 27232, 27196, 27230, 27222, 27221, 27213, 27214, 27206, 27477, 27476, 27478, 27559, 27562, 27563, 27592, 27591, 27652, 27651, 27654, 28589, 28619, 28579, 28615, 28604, 28622, 28616, 28510, 28612, 28605, 28574, 28618, 28584, 28676, 28581, 28590, 28602, 28588, 28586, 28623, 28607, 28600, 28578, 28617, 28587, 28621, 28591, 28594, 28592, 29125, 29122, 29119, 29112, 29142, 29120, 29121, 29131, 29140, 29130, 29127, 29135, 29117, 29144, 29116, 29126, 29146, 29147, 29341, 29342, 29545, 29542, 29543, 29548, 29541, 29547, 29546, 29823, 29850, 29856, 29844, 29842, 29845, 29857, 29963, 30080, 30255, 30253, 30257, 30269, 30259, 30268, 30261, 30258, 30256, 30395, 30438, 30618, 30621, 30625, 30620, 30619, 30626, 30627, 30613, 30617, 30615, 30941, 30953, 30949, 30954, 30942, 30947, 30939, 30945, 30946, 30957, 30943, 30944, 31140, 31300, 31304, 31303, 31414, 31416, 31413, 31409, 31415, 31710, 31715, 31719, 31709, 31701, 31717, 31706, 31720, 31737, 31700, 31722, 31714, 31708, 31723, 31704, 31711, 31954, 31956, 31959, 31952, 31953, 32274, 32289, 32279, 32268, 32287, 32288, 32275, 32270, 32284, 32277, 32282, 32290, 32267, 32271, 32278, 32269, 32276, 32293, 32292, 32579, 32635, 32636, 32634, 32689, 32751, 32810, 32809, 32876, 33201, 33190, 33198, 33209, 33205, 33195, 33200, 33196, 33204, 33202, 33207, 33191, 33266, 33365, 33366, 33367, 34134, 34117, 34155, 34125, 34131, 34145, 34136, 34112, 34118, 34148, 34113, 34146, 34116, 34129, 34119, 34147, 34110, 34139, 34161, 34126, 34158, 34165, 34133, 34151, 34144, 34188, 34150, 34141, 34132, 34149, 34156, 34403, 34405, 34404, 34715, 34703, 34711, 34707, 34706, 34696, 34689, 34710, 34712, 34681, 34695, 34723, 34693, 34704, 34705, 34717, 34692, 34708, 34716, 34714, 34697, 35102, 35110, 35120, 35117, 35118, 35111, 35121, 35106, 35113, 35107, 35119, 35116, 35103, 35313, 35552, 35554, 35570, 35572, 35573, 35549, 35604, 35556, 35551, 35568, 35528, 35550, 35553, 35560, 35583, 35567, 35579, 35985, 35986, 35984, 36085, 36078, 36081, 36080, 36083, 36204, 36206, 36261, 36263, 36403, 36414, 36408, 36416, 36421, 36406, 36412, 36413, 36417, 36400, 36415, 36541, 36662, 36654, 36661, 36658, 36665, 36663, 36660, 36982, 36985, 36987, 36998, 37114, 37171, 37173, 37174, 37267, 37264, 37265, 37261, 37263, 37671, 37662, 37640, 37663, 37638, 37647, 37754, 37688, 37692, 37659, 37667, 37650, 37633, 37702, 37677, 37646, 37645, 37579, 37661, 37626, 37669, 37651, 37625, 37623, 37684, 37634, 37668, 37631, 37673, 37689, 37685, 37674, 37652, 37644, 37643, 37630, 37641, 37632, 37627, 37654, 38332, 38349, 38334, 38329, 38330, 38326, 38335, 38325, 38333, 38569, 38612, 38667, 38674, 38672, 38809, 38807, 38804, 38896, 38904, 38965, 38959, 38962, 39204, 39199, 39207, 39209, 39326, 39406, 39404, 39397, 39396, 39408, 39395, 39402, 39401, 39399, 39609, 39615, 39604, 39611, 39670, 39674, 39673, 39671, 39731, 39808, 39813, 39815, 39804, 39806, 39803, 39810, 39827, 39826, 39824, 39802, 39829, 39805, 39816, 40229, 40215, 40224, 40222, 40212, 40233, 40221, 40216, 40226, 40208, 40217, 40223, 40584, 40582, 40583, 40622, 40621, 40661, 40662, 40698, 40722, 40765, 20774, 20773, 20770, 20772, 20768, 20777, 21236, 22163, 22156, 22157, 22150, 22148, 22147, 22142, 22146, 22143, 22145, 22742, 22740, 22735, 22738, 23341, 23333, 23346, 23331, 23340, 23335, 23334, 23343, 23342, 23419, 23537, 23538, 23991, 24172, 24170, 24510, 24507, 25027, 25013, 25020, 25063, 25056, 25061, 25060, 25064, 25054, 25839, 25833, 25827, 25835, 25828, 25832, 25985, 25984, 26038, 26074, 26322, 27277, 27286, 27265, 27301, 27273, 27295, 27291, 27297, 27294, 27271, 27283, 27278, 27285, 27267, 27304, 27300, 27281, 27263, 27302, 27290, 27269, 27276, 27282, 27483, 27565, 27657, 28620, 28585, 28660, 28628, 28643, 28636, 28653, 28647, 28646, 28638, 28658, 28637, 28642, 28648, 29153, 29169, 29160, 29170, 29156, 29168, 29154, 29555, 29550, 29551, 29847, 29874, 29867, 29840, 29866, 29869, 29873, 29861, 29871, 29968, 29969, 29970, 29967, 30084, 30275, 30280, 30281, 30279, 30372, 30441, 30645, 30635, 30642, 30647, 30646, 30644, 30641, 30632, 30704, 30963, 30973, 30978, 30971, 30972, 30962, 30981, 30969, 30974, 30980, 31147, 31144, 31324, 31323, 31318, 31320, 31316, 31322, 31422, 31424, 31425, 31749, 31759, 31730, 31744, 31743, 31739, 31758, 31732, 31755, 31731, 31746, 31753, 31747, 31745, 31736, 31741, 31750, 31728, 31729, 31760, 31754, 31976, 32301, 32316, 32322, 32307, 38984, 32312, 32298, 32329, 32320, 32327, 32297, 32332, 32304, 32315, 32310, 32324, 32314, 32581, 32639, 32638, 32637, 32756, 32754, 32812, 33211, 33220, 33228, 33226, 33221, 33223, 33212, 33257, 33371, 33370, 33372, 34179, 34176, 34191, 34215, 34197, 34208, 34187, 34211, 34171, 34212, 34202, 34206, 34167, 34172, 34185, 34209, 34170, 34168, 34135, 34190, 34198, 34182, 34189, 34201, 34205, 34177, 34210, 34178, 34184, 34181, 34169, 34166, 34200, 34192, 34207, 34408, 34750, 34730, 34733, 34757, 34736, 34732, 34745, 34741, 34748, 34734, 34761, 34755, 34754, 34764, 34743, 34735, 34756, 34762, 34740, 34742, 34751, 34744, 34749, 34782, 34738, 35125, 35123, 35132, 35134, 35137, 35154, 35127, 35138, 35245, 35247, 35246, 35314, 35315, 35614, 35608, 35606, 35601, 35589, 35595, 35618, 35599, 35602, 35605, 35591, 35597, 35592, 35590, 35612, 35603, 35610, 35919, 35952, 35954, 35953, 35951, 35989, 35988, 36089, 36207, 36430, 36429, 36435, 36432, 36428, 36423, 36675, 36672, 36997, 36990, 37176, 37274, 37282, 37275, 37273, 37279, 37281, 37277, 37280, 37793, 37763, 37807, 37732, 37718, 37703, 37756, 37720, 37724, 37750, 37705, 37712, 37713, 37728, 37741, 37775, 37708, 37738, 37753, 37719, 37717, 37714, 37711, 37745, 37751, 37755, 37729, 37726, 37731, 37735, 37760, 37710, 37721, 38343, 38336, 38345, 38339, 38341, 38327, 38574, 38576, 38572, 38688, 38687, 38680, 38685, 38681, 38810, 38817, 38812, 38814, 38813, 38869, 38868, 38897, 38977, 38980, 38986, 38985, 38981, 38979, 39205, 39211, 39212, 39210, 39219, 39218, 39215, 39213, 39217, 39216, 39320, 39331, 39329, 39426, 39418, 39412, 39415, 39417, 39416, 39414, 39419, 39421, 39422, 39420, 39427, 39614, 39678, 39677, 39681, 39676, 39752, 39834, 39848, 39838, 39835, 39846, 39841, 39845, 39844, 39814, 39842, 39840, 39855, 40243, 40257, 40295, 40246, 40238, 40239, 40241, 40248, 40240, 40261, 40258, 40259, 40254, 40247, 40256, 40253, 32757, 40237, 40586, 40585, 40589, 40624, 40648, 40666, 40699, 40703, 40740, 40739, 40738, 40788, 40864, 20785, 20781, 20782, 22168, 22172, 22167, 22170, 22173, 22169, 22896, 23356, 23657, 23658, 24e3, 24173, 24174, 25048, 25055, 25069, 25070, 25073, 25066, 25072, 25067, 25046, 25065, 25855, 25860, 25853, 25848, 25857, 25859, 25852, 26004, 26075, 26330, 26331, 26328, 27333, 27321, 27325, 27361, 27334, 27322, 27318, 27319, 27335, 27316, 27309, 27486, 27593, 27659, 28679, 28684, 28685, 28673, 28677, 28692, 28686, 28671, 28672, 28667, 28710, 28668, 28663, 28682, 29185, 29183, 29177, 29187, 29181, 29558, 29880, 29888, 29877, 29889, 29886, 29878, 29883, 29890, 29972, 29971, 30300, 30308, 30297, 30288, 30291, 30295, 30298, 30374, 30397, 30444, 30658, 30650, 30975, 30988, 30995, 30996, 30985, 30992, 30994, 30993, 31149, 31148, 31327, 31772, 31785, 31769, 31776, 31775, 31789, 31773, 31782, 31784, 31778, 31781, 31792, 32348, 32336, 32342, 32355, 32344, 32354, 32351, 32337, 32352, 32343, 32339, 32693, 32691, 32759, 32760, 32885, 33233, 33234, 33232, 33375, 33374, 34228, 34246, 34240, 34243, 34242, 34227, 34229, 34237, 34247, 34244, 34239, 34251, 34254, 34248, 34245, 34225, 34230, 34258, 34340, 34232, 34231, 34238, 34409, 34791, 34790, 34786, 34779, 34795, 34794, 34789, 34783, 34803, 34788, 34772, 34780, 34771, 34797, 34776, 34787, 34724, 34775, 34777, 34817, 34804, 34792, 34781, 35155, 35147, 35151, 35148, 35142, 35152, 35153, 35145, 35626, 35623, 35619, 35635, 35632, 35637, 35655, 35631, 35644, 35646, 35633, 35621, 35639, 35622, 35638, 35630, 35620, 35643, 35645, 35642, 35906, 35957, 35993, 35992, 35991, 36094, 36100, 36098, 36096, 36444, 36450, 36448, 36439, 36438, 36446, 36453, 36455, 36443, 36442, 36449, 36445, 36457, 36436, 36678, 36679, 36680, 36683, 37160, 37178, 37179, 37182, 37288, 37285, 37287, 37295, 37290, 37813, 37772, 37778, 37815, 37787, 37789, 37769, 37799, 37774, 37802, 37790, 37798, 37781, 37768, 37785, 37791, 37773, 37809, 37777, 37810, 37796, 37800, 37812, 37795, 37797, 38354, 38355, 38353, 38579, 38615, 38618, 24002, 38623, 38616, 38621, 38691, 38690, 38693, 38828, 38830, 38824, 38827, 38820, 38826, 38818, 38821, 38871, 38873, 38870, 38872, 38906, 38992, 38993, 38994, 39096, 39233, 39228, 39226, 39439, 39435, 39433, 39437, 39428, 39441, 39434, 39429, 39431, 39430, 39616, 39644, 39688, 39684, 39685, 39721, 39733, 39754, 39756, 39755, 39879, 39878, 39875, 39871, 39873, 39861, 39864, 39891, 39862, 39876, 39865, 39869, 40284, 40275, 40271, 40266, 40283, 40267, 40281, 40278, 40268, 40279, 40274, 40276, 40287, 40280, 40282, 40590, 40588, 40671, 40705, 40704, 40726, 40741, 40747, 40746, 40745, 40744, 40780, 40789, 20788, 20789, 21142, 21239, 21428, 22187, 22189, 22182, 22183, 22186, 22188, 22746, 22749, 22747, 22802, 23357, 23358, 23359, 24003, 24176, 24511, 25083, 25863, 25872, 25869, 25865, 25868, 25870, 25988, 26078, 26077, 26334, 27367, 27360, 27340, 27345, 27353, 27339, 27359, 27356, 27344, 27371, 27343, 27341, 27358, 27488, 27568, 27660, 28697, 28711, 28704, 28694, 28715, 28705, 28706, 28707, 28713, 28695, 28708, 28700, 28714, 29196, 29194, 29191, 29186, 29189, 29349, 29350, 29348, 29347, 29345, 29899, 29893, 29879, 29891, 29974, 30304, 30665, 30666, 30660, 30705, 31005, 31003, 31009, 31004, 30999, 31006, 31152, 31335, 31336, 31795, 31804, 31801, 31788, 31803, 31980, 31978, 32374, 32373, 32376, 32368, 32375, 32367, 32378, 32370, 32372, 32360, 32587, 32586, 32643, 32646, 32695, 32765, 32766, 32888, 33239, 33237, 33380, 33377, 33379, 34283, 34289, 34285, 34265, 34273, 34280, 34266, 34263, 34284, 34290, 34296, 34264, 34271, 34275, 34268, 34257, 34288, 34278, 34287, 34270, 34274, 34816, 34810, 34819, 34806, 34807, 34825, 34828, 34827, 34822, 34812, 34824, 34815, 34826, 34818, 35170, 35162, 35163, 35159, 35169, 35164, 35160, 35165, 35161, 35208, 35255, 35254, 35318, 35664, 35656, 35658, 35648, 35667, 35670, 35668, 35659, 35669, 35665, 35650, 35666, 35671, 35907, 35959, 35958, 35994, 36102, 36103, 36105, 36268, 36266, 36269, 36267, 36461, 36472, 36467, 36458, 36463, 36475, 36546, 36690, 36689, 36687, 36688, 36691, 36788, 37184, 37183, 37296, 37293, 37854, 37831, 37839, 37826, 37850, 37840, 37881, 37868, 37836, 37849, 37801, 37862, 37834, 37844, 37870, 37859, 37845, 37828, 37838, 37824, 37842, 37863, 38269, 38362, 38363, 38625, 38697, 38699, 38700, 38696, 38694, 38835, 38839, 38838, 38877, 38878, 38879, 39004, 39001, 39005, 38999, 39103, 39101, 39099, 39102, 39240, 39239, 39235, 39334, 39335, 39450, 39445, 39461, 39453, 39460, 39451, 39458, 39456, 39463, 39459, 39454, 39452, 39444, 39618, 39691, 39690, 39694, 39692, 39735, 39914, 39915, 39904, 39902, 39908, 39910, 39906, 39920, 39892, 39895, 39916, 39900, 39897, 39909, 39893, 39905, 39898, 40311, 40321, 40330, 40324, 40328, 40305, 40320, 40312, 40326, 40331, 40332, 40317, 40299, 40308, 40309, 40304, 40297, 40325, 40307, 40315, 40322, 40303, 40313, 40319, 40327, 40296, 40596, 40593, 40640, 40700, 40749, 40768, 40769, 40781, 40790, 40791, 40792, 21303, 22194, 22197, 22195, 22755, 23365, 24006, 24007, 24302, 24303, 24512, 24513, 25081, 25879, 25878, 25877, 25875, 26079, 26344, 26339, 26340, 27379, 27376, 27370, 27368, 27385, 27377, 27374, 27375, 28732, 28725, 28719, 28727, 28724, 28721, 28738, 28728, 28735, 28730, 28729, 28736, 28731, 28723, 28737, 29203, 29204, 29352, 29565, 29564, 29882, 30379, 30378, 30398, 30445, 30668, 30670, 30671, 30669, 30706, 31013, 31011, 31015, 31016, 31012, 31017, 31154, 31342, 31340, 31341, 31479, 31817, 31816, 31818, 31815, 31813, 31982, 32379, 32382, 32385, 32384, 32698, 32767, 32889, 33243, 33241, 33291, 33384, 33385, 34338, 34303, 34305, 34302, 34331, 34304, 34294, 34308, 34313, 34309, 34316, 34301, 34841, 34832, 34833, 34839, 34835, 34838, 35171, 35174, 35257, 35319, 35680, 35690, 35677, 35688, 35683, 35685, 35687, 35693, 36270, 36486, 36488, 36484, 36697, 36694, 36695, 36693, 36696, 36698, 37005, 37187, 37185, 37303, 37301, 37298, 37299, 37899, 37907, 37883, 37920, 37903, 37908, 37886, 37909, 37904, 37928, 37913, 37901, 37877, 37888, 37879, 37895, 37902, 37910, 37906, 37882, 37897, 37880, 37898, 37887, 37884, 37900, 37878, 37905, 37894, 38366, 38368, 38367, 38702, 38703, 38841, 38843, 38909, 38910, 39008, 39010, 39011, 39007, 39105, 39106, 39248, 39246, 39257, 39244, 39243, 39251, 39474, 39476, 39473, 39468, 39466, 39478, 39465, 39470, 39480, 39469, 39623, 39626, 39622, 39696, 39698, 39697, 39947, 39944, 39927, 39941, 39954, 39928, 4e4, 39943, 39950, 39942, 39959, 39956, 39945, 40351, 40345, 40356, 40349, 40338, 40344, 40336, 40347, 40352, 40340, 40348, 40362, 40343, 40353, 40346, 40354, 40360, 40350, 40355, 40383, 40361, 40342, 40358, 40359, 40601, 40603, 40602, 40677, 40676, 40679, 40678, 40752, 40750, 40795, 40800, 40798, 40797, 40793, 40849, 20794, 20793, 21144, 21143, 22211, 22205, 22206, 23368, 23367, 24011, 24015, 24305, 25085, 25883, 27394, 27388, 27395, 27384, 27392, 28739, 28740, 28746, 28744, 28745, 28741, 28742, 29213, 29210, 29209, 29566, 29975, 30314, 30672, 31021, 31025, 31023, 31828, 31827, 31986, 32394, 32391, 32392, 32395, 32390, 32397, 32589, 32699, 32816, 33245, 34328, 34346, 34342, 34335, 34339, 34332, 34329, 34343, 34350, 34337, 34336, 34345, 34334, 34341, 34857, 34845, 34843, 34848, 34852, 34844, 34859, 34890, 35181, 35177, 35182, 35179, 35322, 35705, 35704, 35653, 35706, 35707, 36112, 36116, 36271, 36494, 36492, 36702, 36699, 36701, 37190, 37188, 37189, 37305, 37951, 37947, 37942, 37929, 37949, 37948, 37936, 37945, 37930, 37943, 37932, 37952, 37937, 38373, 38372, 38371, 38709, 38714, 38847, 38881, 39012, 39113, 39110, 39104, 39256, 39254, 39481, 39485, 39494, 39492, 39490, 39489, 39482, 39487, 39629, 39701, 39703, 39704, 39702, 39738, 39762, 39979, 39965, 39964, 39980, 39971, 39976, 39977, 39972, 39969, 40375, 40374, 40380, 40385, 40391, 40394, 40399, 40382, 40389, 40387, 40379, 40373, 40398, 40377, 40378, 40364, 40392, 40369, 40365, 40396, 40371, 40397, 40370, 40570, 40604, 40683, 40686, 40685, 40731, 40728, 40730, 40753, 40782, 40805, 40804, 40850, 20153, 22214, 22213, 22219, 22897, 23371, 23372, 24021, 24017, 24306, 25889, 25888, 25894, 25890, 27403, 27400, 27401, 27661, 28757, 28758, 28759, 28754, 29214, 29215, 29353, 29567, 29912, 29909, 29913, 29911, 30317, 30381, 31029, 31156, 31344, 31345, 31831, 31836, 31833, 31835, 31834, 31988, 31985, 32401, 32591, 32647, 33246, 33387, 34356, 34357, 34355, 34348, 34354, 34358, 34860, 34856, 34854, 34858, 34853, 35185, 35263, 35262, 35323, 35710, 35716, 35714, 35718, 35717, 35711, 36117, 36501, 36500, 36506, 36498, 36496, 36502, 36503, 36704, 36706, 37191, 37964, 37968, 37962, 37963, 37967, 37959, 37957, 37960, 37961, 37958, 38719, 38883, 39018, 39017, 39115, 39252, 39259, 39502, 39507, 39508, 39500, 39503, 39496, 39498, 39497, 39506, 39504, 39632, 39705, 39723, 39739, 39766, 39765, 40006, 40008, 39999, 40004, 39993, 39987, 40001, 39996, 39991, 39988, 39986, 39997, 39990, 40411, 40402, 40414, 40410, 40395, 40400, 40412, 40401, 40415, 40425, 40409, 40408, 40406, 40437, 40405, 40413, 40630, 40688, 40757, 40755, 40754, 40770, 40811, 40853, 40866, 20797, 21145, 22760, 22759, 22898, 23373, 24024, 34863, 24399, 25089, 25091, 25092, 25897, 25893, 26006, 26347, 27409, 27410, 27407, 27594, 28763, 28762, 29218, 29570, 29569, 29571, 30320, 30676, 31847, 31846, 32405, 33388, 34362, 34368, 34361, 34364, 34353, 34363, 34366, 34864, 34866, 34862, 34867, 35190, 35188, 35187, 35326, 35724, 35726, 35723, 35720, 35909, 36121, 36504, 36708, 36707, 37308, 37986, 37973, 37981, 37975, 37982, 38852, 38853, 38912, 39510, 39513, 39710, 39711, 39712, 40018, 40024, 40016, 40010, 40013, 40011, 40021, 40025, 40012, 40014, 40443, 40439, 40431, 40419, 40427, 40440, 40420, 40438, 40417, 40430, 40422, 40434, 40432, 40418, 40428, 40436, 40435, 40424, 40429, 40642, 40656, 40690, 40691, 40710, 40732, 40760, 40759, 40758, 40771, 40783, 40817, 40816, 40814, 40815, 22227, 22221, 23374, 23661, 25901, 26349, 26350, 27411, 28767, 28769, 28765, 28768, 29219, 29915, 29925, 30677, 31032, 31159, 31158, 31850, 32407, 32649, 33389, 34371, 34872, 34871, 34869, 34891, 35732, 35733, 36510, 36511, 36512, 36509, 37310, 37309, 37314, 37995, 37992, 37993, 38629, 38726, 38723, 38727, 38855, 38885, 39518, 39637, 39769, 40035, 40039, 40038, 40034, 40030, 40032, 40450, 40446, 40455, 40451, 40454, 40453, 40448, 40449, 40457, 40447, 40445, 40452, 40608, 40734, 40774, 40820, 40821, 40822, 22228, 25902, 26040, 27416, 27417, 27415, 27418, 28770, 29222, 29354, 30680, 30681, 31033, 31849, 31851, 31990, 32410, 32408, 32411, 32409, 33248, 33249, 34374, 34375, 34376, 35193, 35194, 35196, 35195, 35327, 35736, 35737, 36517, 36516, 36515, 37998, 37997, 37999, 38001, 38003, 38729, 39026, 39263, 40040, 40046, 40045, 40459, 40461, 40464, 40463, 40466, 40465, 40609, 40693, 40713, 40775, 40824, 40827, 40826, 40825, 22302, 28774, 31855, 34876, 36274, 36518, 37315, 38004, 38008, 38006, 38005, 39520, 40052, 40051, 40049, 40053, 40468, 40467, 40694, 40714, 40868, 28776, 28773, 31991, 34410, 34878, 34877, 34879, 35742, 35996, 36521, 36553, 38731, 39027, 39028, 39116, 39265, 39339, 39524, 39526, 39527, 39716, 40469, 40471, 40776, 25095, 27422, 29223, 34380, 36520, 38018, 38016, 38017, 39529, 39528, 39726, 40473, 29225, 34379, 35743, 38019, 40057, 40631, 30325, 39531, 40058, 40477, 28777, 28778, 40612, 40830, 40777, 40856, 30849, 37561, 35023, 22715, 24658, 31911, 23290, 9556, 9574, 9559, 9568, 9580, 9571, 9562, 9577, 9565, 9554, 9572, 9557, 9566, 9578, 9569, 9560, 9575, 9563, 9555, 9573, 9558, 9567, 9579, 9570, 9561, 9576, 9564, 9553, 9552, 9581, 9582, 9584, 9583, 65517, 132423, 37595, 132575, 147397, 34124, 17077, 29679, 20917, 13897, 149826, 166372, 37700, 137691, 33518, 146632, 30780, 26436, 25311, 149811, 166314, 131744, 158643, 135941, 20395, 140525, 20488, 159017, 162436, 144896, 150193, 140563, 20521, 131966, 24484, 131968, 131911, 28379, 132127, 20605, 20737, 13434, 20750, 39020, 14147, 33814, 149924, 132231, 20832, 144308, 20842, 134143, 139516, 131813, 140592, 132494, 143923, 137603, 23426, 34685, 132531, 146585, 20914, 20920, 40244, 20937, 20943, 20945, 15580, 20947, 150182, 20915, 20962, 21314, 20973, 33741, 26942, 145197, 24443, 21003, 21030, 21052, 21173, 21079, 21140, 21177, 21189, 31765, 34114, 21216, 34317, 158483, 21253, 166622, 21833, 28377, 147328, 133460, 147436, 21299, 21316, 134114, 27851, 136998, 26651, 29653, 24650, 16042, 14540, 136936, 29149, 17570, 21357, 21364, 165547, 21374, 21375, 136598, 136723, 30694, 21395, 166555, 21408, 21419, 21422, 29607, 153458, 16217, 29596, 21441, 21445, 27721, 20041, 22526, 21465, 15019, 134031, 21472, 147435, 142755, 21494, 134263, 21523, 28793, 21803, 26199, 27995, 21613, 158547, 134516, 21853, 21647, 21668, 18342, 136973, 134877, 15796, 134477, 166332, 140952, 21831, 19693, 21551, 29719, 21894, 21929, 22021, 137431, 147514, 17746, 148533, 26291, 135348, 22071, 26317, 144010, 26276, 26285, 22093, 22095, 30961, 22257, 38791, 21502, 22272, 22255, 22253, 166758, 13859, 135759, 22342, 147877, 27758, 28811, 22338, 14001, 158846, 22502, 136214, 22531, 136276, 148323, 22566, 150517, 22620, 22698, 13665, 22752, 22748, 135740, 22779, 23551, 22339, 172368, 148088, 37843, 13729, 22815, 26790, 14019, 28249, 136766, 23076, 21843, 136850, 34053, 22985, 134478, 158849, 159018, 137180, 23001, 137211, 137138, 159142, 28017, 137256, 136917, 23033, 159301, 23211, 23139, 14054, 149929, 23159, 14088, 23190, 29797, 23251, 159649, 140628, 15749, 137489, 14130, 136888, 24195, 21200, 23414, 25992, 23420, 162318, 16388, 18525, 131588, 23509, 24928, 137780, 154060, 132517, 23539, 23453, 19728, 23557, 138052, 23571, 29646, 23572, 138405, 158504, 23625, 18653, 23685, 23785, 23791, 23947, 138745, 138807, 23824, 23832, 23878, 138916, 23738, 24023, 33532, 14381, 149761, 139337, 139635, 33415, 14390, 15298, 24110, 27274, 24181, 24186, 148668, 134355, 21414, 20151, 24272, 21416, 137073, 24073, 24308, 164994, 24313, 24315, 14496, 24316, 26686, 37915, 24333, 131521, 194708, 15070, 18606, 135994, 24378, 157832, 140240, 24408, 140401, 24419, 38845, 159342, 24434, 37696, 166454, 24487, 23990, 15711, 152144, 139114, 159992, 140904, 37334, 131742, 166441, 24625, 26245, 137335, 14691, 15815, 13881, 22416, 141236, 31089, 15936, 24734, 24740, 24755, 149890, 149903, 162387, 29860, 20705, 23200, 24932, 33828, 24898, 194726, 159442, 24961, 20980, 132694, 24967, 23466, 147383, 141407, 25043, 166813, 170333, 25040, 14642, 141696, 141505, 24611, 24924, 25886, 25483, 131352, 25285, 137072, 25301, 142861, 25452, 149983, 14871, 25656, 25592, 136078, 137212, 25744, 28554, 142902, 38932, 147596, 153373, 25825, 25829, 38011, 14950, 25658, 14935, 25933, 28438, 150056, 150051, 25989, 25965, 25951, 143486, 26037, 149824, 19255, 26065, 16600, 137257, 26080, 26083, 24543, 144384, 26136, 143863, 143864, 26180, 143780, 143781, 26187, 134773, 26215, 152038, 26227, 26228, 138813, 143921, 165364, 143816, 152339, 30661, 141559, 39332, 26370, 148380, 150049, 15147, 27130, 145346, 26462, 26471, 26466, 147917, 168173, 26583, 17641, 26658, 28240, 37436, 26625, 144358, 159136, 26717, 144495, 27105, 27147, 166623, 26995, 26819, 144845, 26881, 26880, 15666, 14849, 144956, 15232, 26540, 26977, 166474, 17148, 26934, 27032, 15265, 132041, 33635, 20624, 27129, 144985, 139562, 27205, 145155, 27293, 15347, 26545, 27336, 168348, 15373, 27421, 133411, 24798, 27445, 27508, 141261, 28341, 146139, 132021, 137560, 14144, 21537, 146266, 27617, 147196, 27612, 27703, 140427, 149745, 158545, 27738, 33318, 27769, 146876, 17605, 146877, 147876, 149772, 149760, 146633, 14053, 15595, 134450, 39811, 143865, 140433, 32655, 26679, 159013, 159137, 159211, 28054, 27996, 28284, 28420, 149887, 147589, 159346, 34099, 159604, 20935, 27804, 28189, 33838, 166689, 28207, 146991, 29779, 147330, 31180, 28239, 23185, 143435, 28664, 14093, 28573, 146992, 28410, 136343, 147517, 17749, 37872, 28484, 28508, 15694, 28532, 168304, 15675, 28575, 147780, 28627, 147601, 147797, 147513, 147440, 147380, 147775, 20959, 147798, 147799, 147776, 156125, 28747, 28798, 28839, 28801, 28876, 28885, 28886, 28895, 16644, 15848, 29108, 29078, 148087, 28971, 28997, 23176, 29002, 29038, 23708, 148325, 29007, 37730, 148161, 28972, 148570, 150055, 150050, 29114, 166888, 28861, 29198, 37954, 29205, 22801, 37955, 29220, 37697, 153093, 29230, 29248, 149876, 26813, 29269, 29271, 15957, 143428, 26637, 28477, 29314, 29482, 29483, 149539, 165931, 18669, 165892, 29480, 29486, 29647, 29610, 134202, 158254, 29641, 29769, 147938, 136935, 150052, 26147, 14021, 149943, 149901, 150011, 29687, 29717, 26883, 150054, 29753, 132547, 16087, 29788, 141485, 29792, 167602, 29767, 29668, 29814, 33721, 29804, 14128, 29812, 37873, 27180, 29826, 18771, 150156, 147807, 150137, 166799, 23366, 166915, 137374, 29896, 137608, 29966, 29929, 29982, 167641, 137803, 23511, 167596, 37765, 30029, 30026, 30055, 30062, 151426, 16132, 150803, 30094, 29789, 30110, 30132, 30210, 30252, 30289, 30287, 30319, 30326, 156661, 30352, 33263, 14328, 157969, 157966, 30369, 30373, 30391, 30412, 159647, 33890, 151709, 151933, 138780, 30494, 30502, 30528, 25775, 152096, 30552, 144044, 30639, 166244, 166248, 136897, 30708, 30729, 136054, 150034, 26826, 30895, 30919, 30931, 38565, 31022, 153056, 30935, 31028, 30897, 161292, 36792, 34948, 166699, 155779, 140828, 31110, 35072, 26882, 31104, 153687, 31133, 162617, 31036, 31145, 28202, 160038, 16040, 31174, 168205, 31188],
        "euc-kr": [44034, 44035, 44037, 44038, 44043, 44044, 44045, 44046, 44047, 44056, 44062, 44063, 44065, 44066, 44067, 44069, 44070, 44071, 44072, 44073, 44074, 44075, 44078, 44082, 44083, 44084, null, null, null, null, null, null, 44085, 44086, 44087, 44090, 44091, 44093, 44094, 44095, 44097, 44098, 44099, 44100, 44101, 44102, 44103, 44104, 44105, 44106, 44108, 44110, 44111, 44112, 44113, 44114, 44115, 44117, null, null, null, null, null, null, 44118, 44119, 44121, 44122, 44123, 44125, 44126, 44127, 44128, 44129, 44130, 44131, 44132, 44133, 44134, 44135, 44136, 44137, 44138, 44139, 44140, 44141, 44142, 44143, 44146, 44147, 44149, 44150, 44153, 44155, 44156, 44157, 44158, 44159, 44162, 44167, 44168, 44173, 44174, 44175, 44177, 44178, 44179, 44181, 44182, 44183, 44184, 44185, 44186, 44187, 44190, 44194, 44195, 44196, 44197, 44198, 44199, 44203, 44205, 44206, 44209, 44210, 44211, 44212, 44213, 44214, 44215, 44218, 44222, 44223, 44224, 44226, 44227, 44229, 44230, 44231, 44233, 44234, 44235, 44237, 44238, 44239, 44240, 44241, 44242, 44243, 44244, 44246, 44248, 44249, 44250, 44251, 44252, 44253, 44254, 44255, 44258, 44259, 44261, 44262, 44265, 44267, 44269, 44270, 44274, 44276, 44279, 44280, 44281, 44282, 44283, 44286, 44287, 44289, 44290, 44291, 44293, 44295, 44296, 44297, 44298, 44299, 44302, 44304, 44306, 44307, 44308, 44309, 44310, 44311, 44313, 44314, 44315, 44317, 44318, 44319, 44321, 44322, 44323, 44324, 44325, 44326, 44327, 44328, 44330, 44331, 44334, 44335, 44336, 44337, 44338, 44339, null, null, null, null, null, null, 44342, 44343, 44345, 44346, 44347, 44349, 44350, 44351, 44352, 44353, 44354, 44355, 44358, 44360, 44362, 44363, 44364, 44365, 44366, 44367, 44369, 44370, 44371, 44373, 44374, 44375, null, null, null, null, null, null, 44377, 44378, 44379, 44380, 44381, 44382, 44383, 44384, 44386, 44388, 44389, 44390, 44391, 44392, 44393, 44394, 44395, 44398, 44399, 44401, 44402, 44407, 44408, 44409, 44410, 44414, 44416, 44419, 44420, 44421, 44422, 44423, 44426, 44427, 44429, 44430, 44431, 44433, 44434, 44435, 44436, 44437, 44438, 44439, 44440, 44441, 44442, 44443, 44446, 44447, 44448, 44449, 44450, 44451, 44453, 44454, 44455, 44456, 44457, 44458, 44459, 44460, 44461, 44462, 44463, 44464, 44465, 44466, 44467, 44468, 44469, 44470, 44472, 44473, 44474, 44475, 44476, 44477, 44478, 44479, 44482, 44483, 44485, 44486, 44487, 44489, 44490, 44491, 44492, 44493, 44494, 44495, 44498, 44500, 44501, 44502, 44503, 44504, 44505, 44506, 44507, 44509, 44510, 44511, 44513, 44514, 44515, 44517, 44518, 44519, 44520, 44521, 44522, 44523, 44524, 44525, 44526, 44527, 44528, 44529, 44530, 44531, 44532, 44533, 44534, 44535, 44538, 44539, 44541, 44542, 44546, 44547, 44548, 44549, 44550, 44551, 44554, 44556, 44558, 44559, 44560, 44561, 44562, 44563, 44565, 44566, 44567, 44568, 44569, 44570, 44571, 44572, null, null, null, null, null, null, 44573, 44574, 44575, 44576, 44577, 44578, 44579, 44580, 44581, 44582, 44583, 44584, 44585, 44586, 44587, 44588, 44589, 44590, 44591, 44594, 44595, 44597, 44598, 44601, 44603, 44604, null, null, null, null, null, null, 44605, 44606, 44607, 44610, 44612, 44615, 44616, 44617, 44619, 44623, 44625, 44626, 44627, 44629, 44631, 44632, 44633, 44634, 44635, 44638, 44642, 44643, 44644, 44646, 44647, 44650, 44651, 44653, 44654, 44655, 44657, 44658, 44659, 44660, 44661, 44662, 44663, 44666, 44670, 44671, 44672, 44673, 44674, 44675, 44678, 44679, 44680, 44681, 44682, 44683, 44685, 44686, 44687, 44688, 44689, 44690, 44691, 44692, 44693, 44694, 44695, 44696, 44697, 44698, 44699, 44700, 44701, 44702, 44703, 44704, 44705, 44706, 44707, 44708, 44709, 44710, 44711, 44712, 44713, 44714, 44715, 44716, 44717, 44718, 44719, 44720, 44721, 44722, 44723, 44724, 44725, 44726, 44727, 44728, 44729, 44730, 44731, 44735, 44737, 44738, 44739, 44741, 44742, 44743, 44744, 44745, 44746, 44747, 44750, 44754, 44755, 44756, 44757, 44758, 44759, 44762, 44763, 44765, 44766, 44767, 44768, 44769, 44770, 44771, 44772, 44773, 44774, 44775, 44777, 44778, 44780, 44782, 44783, 44784, 44785, 44786, 44787, 44789, 44790, 44791, 44793, 44794, 44795, 44797, 44798, 44799, 44800, 44801, 44802, 44803, 44804, 44805, null, null, null, null, null, null, 44806, 44809, 44810, 44811, 44812, 44814, 44815, 44817, 44818, 44819, 44820, 44821, 44822, 44823, 44824, 44825, 44826, 44827, 44828, 44829, 44830, 44831, 44832, 44833, 44834, 44835, null, null, null, null, null, null, 44836, 44837, 44838, 44839, 44840, 44841, 44842, 44843, 44846, 44847, 44849, 44851, 44853, 44854, 44855, 44856, 44857, 44858, 44859, 44862, 44864, 44868, 44869, 44870, 44871, 44874, 44875, 44876, 44877, 44878, 44879, 44881, 44882, 44883, 44884, 44885, 44886, 44887, 44888, 44889, 44890, 44891, 44894, 44895, 44896, 44897, 44898, 44899, 44902, 44903, 44904, 44905, 44906, 44907, 44908, 44909, 44910, 44911, 44912, 44913, 44914, 44915, 44916, 44917, 44918, 44919, 44920, 44922, 44923, 44924, 44925, 44926, 44927, 44929, 44930, 44931, 44933, 44934, 44935, 44937, 44938, 44939, 44940, 44941, 44942, 44943, 44946, 44947, 44948, 44950, 44951, 44952, 44953, 44954, 44955, 44957, 44958, 44959, 44960, 44961, 44962, 44963, 44964, 44965, 44966, 44967, 44968, 44969, 44970, 44971, 44972, 44973, 44974, 44975, 44976, 44977, 44978, 44979, 44980, 44981, 44982, 44983, 44986, 44987, 44989, 44990, 44991, 44993, 44994, 44995, 44996, 44997, 44998, 45002, 45004, 45007, 45008, 45009, 45010, 45011, 45013, 45014, 45015, 45016, 45017, 45018, 45019, 45021, 45022, 45023, 45024, 45025, null, null, null, null, null, null, 45026, 45027, 45028, 45029, 45030, 45031, 45034, 45035, 45036, 45037, 45038, 45039, 45042, 45043, 45045, 45046, 45047, 45049, 45050, 45051, 45052, 45053, 45054, 45055, 45058, 45059, null, null, null, null, null, null, 45061, 45062, 45063, 45064, 45065, 45066, 45067, 45069, 45070, 45071, 45073, 45074, 45075, 45077, 45078, 45079, 45080, 45081, 45082, 45083, 45086, 45087, 45088, 45089, 45090, 45091, 45092, 45093, 45094, 45095, 45097, 45098, 45099, 45100, 45101, 45102, 45103, 45104, 45105, 45106, 45107, 45108, 45109, 45110, 45111, 45112, 45113, 45114, 45115, 45116, 45117, 45118, 45119, 45120, 45121, 45122, 45123, 45126, 45127, 45129, 45131, 45133, 45135, 45136, 45137, 45138, 45142, 45144, 45146, 45147, 45148, 45150, 45151, 45152, 45153, 45154, 45155, 45156, 45157, 45158, 45159, 45160, 45161, 45162, 45163, 45164, 45165, 45166, 45167, 45168, 45169, 45170, 45171, 45172, 45173, 45174, 45175, 45176, 45177, 45178, 45179, 45182, 45183, 45185, 45186, 45187, 45189, 45190, 45191, 45192, 45193, 45194, 45195, 45198, 45200, 45202, 45203, 45204, 45205, 45206, 45207, 45211, 45213, 45214, 45219, 45220, 45221, 45222, 45223, 45226, 45232, 45234, 45238, 45239, 45241, 45242, 45243, 45245, 45246, 45247, 45248, 45249, 45250, 45251, 45254, 45258, 45259, 45260, 45261, 45262, 45263, 45266, null, null, null, null, null, null, 45267, 45269, 45270, 45271, 45273, 45274, 45275, 45276, 45277, 45278, 45279, 45281, 45282, 45283, 45284, 45286, 45287, 45288, 45289, 45290, 45291, 45292, 45293, 45294, 45295, 45296, null, null, null, null, null, null, 45297, 45298, 45299, 45300, 45301, 45302, 45303, 45304, 45305, 45306, 45307, 45308, 45309, 45310, 45311, 45312, 45313, 45314, 45315, 45316, 45317, 45318, 45319, 45322, 45325, 45326, 45327, 45329, 45332, 45333, 45334, 45335, 45338, 45342, 45343, 45344, 45345, 45346, 45350, 45351, 45353, 45354, 45355, 45357, 45358, 45359, 45360, 45361, 45362, 45363, 45366, 45370, 45371, 45372, 45373, 45374, 45375, 45378, 45379, 45381, 45382, 45383, 45385, 45386, 45387, 45388, 45389, 45390, 45391, 45394, 45395, 45398, 45399, 45401, 45402, 45403, 45405, 45406, 45407, 45409, 45410, 45411, 45412, 45413, 45414, 45415, 45416, 45417, 45418, 45419, 45420, 45421, 45422, 45423, 45424, 45425, 45426, 45427, 45428, 45429, 45430, 45431, 45434, 45435, 45437, 45438, 45439, 45441, 45443, 45444, 45445, 45446, 45447, 45450, 45452, 45454, 45455, 45456, 45457, 45461, 45462, 45463, 45465, 45466, 45467, 45469, 45470, 45471, 45472, 45473, 45474, 45475, 45476, 45477, 45478, 45479, 45481, 45482, 45483, 45484, 45485, 45486, 45487, 45488, 45489, 45490, 45491, 45492, 45493, 45494, 45495, 45496, null, null, null, null, null, null, 45497, 45498, 45499, 45500, 45501, 45502, 45503, 45504, 45505, 45506, 45507, 45508, 45509, 45510, 45511, 45512, 45513, 45514, 45515, 45517, 45518, 45519, 45521, 45522, 45523, 45525, null, null, null, null, null, null, 45526, 45527, 45528, 45529, 45530, 45531, 45534, 45536, 45537, 45538, 45539, 45540, 45541, 45542, 45543, 45546, 45547, 45549, 45550, 45551, 45553, 45554, 45555, 45556, 45557, 45558, 45559, 45560, 45562, 45564, 45566, 45567, 45568, 45569, 45570, 45571, 45574, 45575, 45577, 45578, 45581, 45582, 45583, 45584, 45585, 45586, 45587, 45590, 45592, 45594, 45595, 45596, 45597, 45598, 45599, 45601, 45602, 45603, 45604, 45605, 45606, 45607, 45608, 45609, 45610, 45611, 45612, 45613, 45614, 45615, 45616, 45617, 45618, 45619, 45621, 45622, 45623, 45624, 45625, 45626, 45627, 45629, 45630, 45631, 45632, 45633, 45634, 45635, 45636, 45637, 45638, 45639, 45640, 45641, 45642, 45643, 45644, 45645, 45646, 45647, 45648, 45649, 45650, 45651, 45652, 45653, 45654, 45655, 45657, 45658, 45659, 45661, 45662, 45663, 45665, 45666, 45667, 45668, 45669, 45670, 45671, 45674, 45675, 45676, 45677, 45678, 45679, 45680, 45681, 45682, 45683, 45686, 45687, 45688, 45689, 45690, 45691, 45693, 45694, 45695, 45696, 45697, 45698, 45699, 45702, 45703, 45704, 45706, 45707, 45708, 45709, 45710, null, null, null, null, null, null, 45711, 45714, 45715, 45717, 45718, 45719, 45723, 45724, 45725, 45726, 45727, 45730, 45732, 45735, 45736, 45737, 45739, 45741, 45742, 45743, 45745, 45746, 45747, 45749, 45750, 45751, null, null, null, null, null, null, 45752, 45753, 45754, 45755, 45756, 45757, 45758, 45759, 45760, 45761, 45762, 45763, 45764, 45765, 45766, 45767, 45770, 45771, 45773, 45774, 45775, 45777, 45779, 45780, 45781, 45782, 45783, 45786, 45788, 45790, 45791, 45792, 45793, 45795, 45799, 45801, 45802, 45808, 45809, 45810, 45814, 45820, 45821, 45822, 45826, 45827, 45829, 45830, 45831, 45833, 45834, 45835, 45836, 45837, 45838, 45839, 45842, 45846, 45847, 45848, 45849, 45850, 45851, 45853, 45854, 45855, 45856, 45857, 45858, 45859, 45860, 45861, 45862, 45863, 45864, 45865, 45866, 45867, 45868, 45869, 45870, 45871, 45872, 45873, 45874, 45875, 45876, 45877, 45878, 45879, 45880, 45881, 45882, 45883, 45884, 45885, 45886, 45887, 45888, 45889, 45890, 45891, 45892, 45893, 45894, 45895, 45896, 45897, 45898, 45899, 45900, 45901, 45902, 45903, 45904, 45905, 45906, 45907, 45911, 45913, 45914, 45917, 45920, 45921, 45922, 45923, 45926, 45928, 45930, 45932, 45933, 45935, 45938, 45939, 45941, 45942, 45943, 45945, 45946, 45947, 45948, 45949, 45950, 45951, 45954, 45958, 45959, 45960, 45961, 45962, 45963, 45965, null, null, null, null, null, null, 45966, 45967, 45969, 45970, 45971, 45973, 45974, 45975, 45976, 45977, 45978, 45979, 45980, 45981, 45982, 45983, 45986, 45987, 45988, 45989, 45990, 45991, 45993, 45994, 45995, 45997, null, null, null, null, null, null, 45998, 45999, 46e3, 46001, 46002, 46003, 46004, 46005, 46006, 46007, 46008, 46009, 46010, 46011, 46012, 46013, 46014, 46015, 46016, 46017, 46018, 46019, 46022, 46023, 46025, 46026, 46029, 46031, 46033, 46034, 46035, 46038, 46040, 46042, 46044, 46046, 46047, 46049, 46050, 46051, 46053, 46054, 46055, 46057, 46058, 46059, 46060, 46061, 46062, 46063, 46064, 46065, 46066, 46067, 46068, 46069, 46070, 46071, 46072, 46073, 46074, 46075, 46077, 46078, 46079, 46080, 46081, 46082, 46083, 46084, 46085, 46086, 46087, 46088, 46089, 46090, 46091, 46092, 46093, 46094, 46095, 46097, 46098, 46099, 46100, 46101, 46102, 46103, 46105, 46106, 46107, 46109, 46110, 46111, 46113, 46114, 46115, 46116, 46117, 46118, 46119, 46122, 46124, 46125, 46126, 46127, 46128, 46129, 46130, 46131, 46133, 46134, 46135, 46136, 46137, 46138, 46139, 46140, 46141, 46142, 46143, 46144, 46145, 46146, 46147, 46148, 46149, 46150, 46151, 46152, 46153, 46154, 46155, 46156, 46157, 46158, 46159, 46162, 46163, 46165, 46166, 46167, 46169, 46170, 46171, 46172, 46173, 46174, 46175, 46178, 46180, 46182, null, null, null, null, null, null, 46183, 46184, 46185, 46186, 46187, 46189, 46190, 46191, 46192, 46193, 46194, 46195, 46196, 46197, 46198, 46199, 46200, 46201, 46202, 46203, 46204, 46205, 46206, 46207, 46209, 46210, null, null, null, null, null, null, 46211, 46212, 46213, 46214, 46215, 46217, 46218, 46219, 46220, 46221, 46222, 46223, 46224, 46225, 46226, 46227, 46228, 46229, 46230, 46231, 46232, 46233, 46234, 46235, 46236, 46238, 46239, 46240, 46241, 46242, 46243, 46245, 46246, 46247, 46249, 46250, 46251, 46253, 46254, 46255, 46256, 46257, 46258, 46259, 46260, 46262, 46264, 46266, 46267, 46268, 46269, 46270, 46271, 46273, 46274, 46275, 46277, 46278, 46279, 46281, 46282, 46283, 46284, 46285, 46286, 46287, 46289, 46290, 46291, 46292, 46294, 46295, 46296, 46297, 46298, 46299, 46302, 46303, 46305, 46306, 46309, 46311, 46312, 46313, 46314, 46315, 46318, 46320, 46322, 46323, 46324, 46325, 46326, 46327, 46329, 46330, 46331, 46332, 46333, 46334, 46335, 46336, 46337, 46338, 46339, 46340, 46341, 46342, 46343, 46344, 46345, 46346, 46347, 46348, 46349, 46350, 46351, 46352, 46353, 46354, 46355, 46358, 46359, 46361, 46362, 46365, 46366, 46367, 46368, 46369, 46370, 46371, 46374, 46379, 46380, 46381, 46382, 46383, 46386, 46387, 46389, 46390, 46391, 46393, 46394, 46395, 46396, 46397, 46398, 46399, 46402, 46406, null, null, null, null, null, null, 46407, 46408, 46409, 46410, 46414, 46415, 46417, 46418, 46419, 46421, 46422, 46423, 46424, 46425, 46426, 46427, 46430, 46434, 46435, 46436, 46437, 46438, 46439, 46440, 46441, 46442, null, null, null, null, null, null, 46443, 46444, 46445, 46446, 46447, 46448, 46449, 46450, 46451, 46452, 46453, 46454, 46455, 46456, 46457, 46458, 46459, 46460, 46461, 46462, 46463, 46464, 46465, 46466, 46467, 46468, 46469, 46470, 46471, 46472, 46473, 46474, 46475, 46476, 46477, 46478, 46479, 46480, 46481, 46482, 46483, 46484, 46485, 46486, 46487, 46488, 46489, 46490, 46491, 46492, 46493, 46494, 46495, 46498, 46499, 46501, 46502, 46503, 46505, 46508, 46509, 46510, 46511, 46514, 46518, 46519, 46520, 46521, 46522, 46526, 46527, 46529, 46530, 46531, 46533, 46534, 46535, 46536, 46537, 46538, 46539, 46542, 46546, 46547, 46548, 46549, 46550, 46551, 46553, 46554, 46555, 46556, 46557, 46558, 46559, 46560, 46561, 46562, 46563, 46564, 46565, 46566, 46567, 46568, 46569, 46570, 46571, 46573, 46574, 46575, 46576, 46577, 46578, 46579, 46580, 46581, 46582, 46583, 46584, 46585, 46586, 46587, 46588, 46589, 46590, 46591, 46592, 46593, 46594, 46595, 46596, 46597, 46598, 46599, 46600, 46601, 46602, 46603, 46604, 46605, 46606, 46607, 46610, 46611, 46613, 46614, 46615, 46617, 46618, 46619, 46620, 46621, null, null, null, null, null, null, 46622, 46623, 46624, 46625, 46626, 46627, 46628, 46630, 46631, 46632, 46633, 46634, 46635, 46637, 46638, 46639, 46640, 46641, 46642, 46643, 46645, 46646, 46647, 46648, 46649, 46650, null, null, null, null, null, null, 46651, 46652, 46653, 46654, 46655, 46656, 46657, 46658, 46659, 46660, 46661, 46662, 46663, 46665, 46666, 46667, 46668, 46669, 46670, 46671, 46672, 46673, 46674, 46675, 46676, 46677, 46678, 46679, 46680, 46681, 46682, 46683, 46684, 46685, 46686, 46687, 46688, 46689, 46690, 46691, 46693, 46694, 46695, 46697, 46698, 46699, 46700, 46701, 46702, 46703, 46704, 46705, 46706, 46707, 46708, 46709, 46710, 46711, 46712, 46713, 46714, 46715, 46716, 46717, 46718, 46719, 46720, 46721, 46722, 46723, 46724, 46725, 46726, 46727, 46728, 46729, 46730, 46731, 46732, 46733, 46734, 46735, 46736, 46737, 46738, 46739, 46740, 46741, 46742, 46743, 46744, 46745, 46746, 46747, 46750, 46751, 46753, 46754, 46755, 46757, 46758, 46759, 46760, 46761, 46762, 46765, 46766, 46767, 46768, 46770, 46771, 46772, 46773, 46774, 46775, 46776, 46777, 46778, 46779, 46780, 46781, 46782, 46783, 46784, 46785, 46786, 46787, 46788, 46789, 46790, 46791, 46792, 46793, 46794, 46795, 46796, 46797, 46798, 46799, 46800, 46801, 46802, 46803, 46805, 46806, 46807, 46808, 46809, 46810, 46811, 46812, 46813, null, null, null, null, null, null, 46814, 46815, 46816, 46817, 46818, 46819, 46820, 46821, 46822, 46823, 46824, 46825, 46826, 46827, 46828, 46829, 46830, 46831, 46833, 46834, 46835, 46837, 46838, 46839, 46841, 46842, null, null, null, null, null, null, 46843, 46844, 46845, 46846, 46847, 46850, 46851, 46852, 46854, 46855, 46856, 46857, 46858, 46859, 46860, 46861, 46862, 46863, 46864, 46865, 46866, 46867, 46868, 46869, 46870, 46871, 46872, 46873, 46874, 46875, 46876, 46877, 46878, 46879, 46880, 46881, 46882, 46883, 46884, 46885, 46886, 46887, 46890, 46891, 46893, 46894, 46897, 46898, 46899, 46900, 46901, 46902, 46903, 46906, 46908, 46909, 46910, 46911, 46912, 46913, 46914, 46915, 46917, 46918, 46919, 46921, 46922, 46923, 46925, 46926, 46927, 46928, 46929, 46930, 46931, 46934, 46935, 46936, 46937, 46938, 46939, 46940, 46941, 46942, 46943, 46945, 46946, 46947, 46949, 46950, 46951, 46953, 46954, 46955, 46956, 46957, 46958, 46959, 46962, 46964, 46966, 46967, 46968, 46969, 46970, 46971, 46974, 46975, 46977, 46978, 46979, 46981, 46982, 46983, 46984, 46985, 46986, 46987, 46990, 46995, 46996, 46997, 47002, 47003, 47005, 47006, 47007, 47009, 47010, 47011, 47012, 47013, 47014, 47015, 47018, 47022, 47023, 47024, 47025, 47026, 47027, 47030, 47031, 47033, 47034, 47035, 47036, 47037, 47038, 47039, 47040, 47041, null, null, null, null, null, null, 47042, 47043, 47044, 47045, 47046, 47048, 47050, 47051, 47052, 47053, 47054, 47055, 47056, 47057, 47058, 47059, 47060, 47061, 47062, 47063, 47064, 47065, 47066, 47067, 47068, 47069, null, null, null, null, null, null, 47070, 47071, 47072, 47073, 47074, 47075, 47076, 47077, 47078, 47079, 47080, 47081, 47082, 47083, 47086, 47087, 47089, 47090, 47091, 47093, 47094, 47095, 47096, 47097, 47098, 47099, 47102, 47106, 47107, 47108, 47109, 47110, 47114, 47115, 47117, 47118, 47119, 47121, 47122, 47123, 47124, 47125, 47126, 47127, 47130, 47132, 47134, 47135, 47136, 47137, 47138, 47139, 47142, 47143, 47145, 47146, 47147, 47149, 47150, 47151, 47152, 47153, 47154, 47155, 47158, 47162, 47163, 47164, 47165, 47166, 47167, 47169, 47170, 47171, 47173, 47174, 47175, 47176, 47177, 47178, 47179, 47180, 47181, 47182, 47183, 47184, 47186, 47188, 47189, 47190, 47191, 47192, 47193, 47194, 47195, 47198, 47199, 47201, 47202, 47203, 47205, 47206, 47207, 47208, 47209, 47210, 47211, 47214, 47216, 47218, 47219, 47220, 47221, 47222, 47223, 47225, 47226, 47227, 47229, 47230, 47231, 47232, 47233, 47234, 47235, 47236, 47237, 47238, 47239, 47240, 47241, 47242, 47243, 47244, 47246, 47247, 47248, 47249, 47250, 47251, 47252, 47253, 47254, 47255, 47256, 47257, 47258, 47259, 47260, 47261, 47262, 47263, null, null, null, null, null, null, 47264, 47265, 47266, 47267, 47268, 47269, 47270, 47271, 47273, 47274, 47275, 47276, 47277, 47278, 47279, 47281, 47282, 47283, 47285, 47286, 47287, 47289, 47290, 47291, 47292, 47293, null, null, null, null, null, null, 47294, 47295, 47298, 47300, 47302, 47303, 47304, 47305, 47306, 47307, 47309, 47310, 47311, 47313, 47314, 47315, 47317, 47318, 47319, 47320, 47321, 47322, 47323, 47324, 47326, 47328, 47330, 47331, 47332, 47333, 47334, 47335, 47338, 47339, 47341, 47342, 47343, 47345, 47346, 47347, 47348, 47349, 47350, 47351, 47354, 47356, 47358, 47359, 47360, 47361, 47362, 47363, 47365, 47366, 47367, 47368, 47369, 47370, 47371, 47372, 47373, 47374, 47375, 47376, 47377, 47378, 47379, 47380, 47381, 47382, 47383, 47385, 47386, 47387, 47388, 47389, 47390, 47391, 47393, 47394, 47395, 47396, 47397, 47398, 47399, 47400, 47401, 47402, 47403, 47404, 47405, 47406, 47407, 47408, 47409, 47410, 47411, 47412, 47413, 47414, 47415, 47416, 47417, 47418, 47419, 47422, 47423, 47425, 47426, 47427, 47429, 47430, 47431, 47432, 47433, 47434, 47435, 47437, 47438, 47440, 47442, 47443, 47444, 47445, 47446, 47447, 47450, 47451, 47453, 47454, 47455, 47457, 47458, 47459, 47460, 47461, 47462, 47463, 47466, 47468, 47470, 47471, 47472, 47473, 47474, 47475, 47478, 47479, 47481, 47482, 47483, 47485, null, null, null, null, null, null, 47486, 47487, 47488, 47489, 47490, 47491, 47494, 47496, 47499, 47500, 47503, 47504, 47505, 47506, 47507, 47508, 47509, 47510, 47511, 47512, 47513, 47514, 47515, 47516, 47517, 47518, null, null, null, null, null, null, 47519, 47520, 47521, 47522, 47523, 47524, 47525, 47526, 47527, 47528, 47529, 47530, 47531, 47534, 47535, 47537, 47538, 47539, 47541, 47542, 47543, 47544, 47545, 47546, 47547, 47550, 47552, 47554, 47555, 47556, 47557, 47558, 47559, 47562, 47563, 47565, 47571, 47572, 47573, 47574, 47575, 47578, 47580, 47583, 47584, 47586, 47590, 47591, 47593, 47594, 47595, 47597, 47598, 47599, 47600, 47601, 47602, 47603, 47606, 47611, 47612, 47613, 47614, 47615, 47618, 47619, 47620, 47621, 47622, 47623, 47625, 47626, 47627, 47628, 47629, 47630, 47631, 47632, 47633, 47634, 47635, 47636, 47638, 47639, 47640, 47641, 47642, 47643, 47644, 47645, 47646, 47647, 47648, 47649, 47650, 47651, 47652, 47653, 47654, 47655, 47656, 47657, 47658, 47659, 47660, 47661, 47662, 47663, 47664, 47665, 47666, 47667, 47668, 47669, 47670, 47671, 47674, 47675, 47677, 47678, 47679, 47681, 47683, 47684, 47685, 47686, 47687, 47690, 47692, 47695, 47696, 47697, 47698, 47702, 47703, 47705, 47706, 47707, 47709, 47710, 47711, 47712, 47713, 47714, 47715, 47718, 47722, 47723, 47724, 47725, 47726, 47727, null, null, null, null, null, null, 47730, 47731, 47733, 47734, 47735, 47737, 47738, 47739, 47740, 47741, 47742, 47743, 47744, 47745, 47746, 47750, 47752, 47753, 47754, 47755, 47757, 47758, 47759, 47760, 47761, 47762, null, null, null, null, null, null, 47763, 47764, 47765, 47766, 47767, 47768, 47769, 47770, 47771, 47772, 47773, 47774, 47775, 47776, 47777, 47778, 47779, 47780, 47781, 47782, 47783, 47786, 47789, 47790, 47791, 47793, 47795, 47796, 47797, 47798, 47799, 47802, 47804, 47806, 47807, 47808, 47809, 47810, 47811, 47813, 47814, 47815, 47817, 47818, 47819, 47820, 47821, 47822, 47823, 47824, 47825, 47826, 47827, 47828, 47829, 47830, 47831, 47834, 47835, 47836, 47837, 47838, 47839, 47840, 47841, 47842, 47843, 47844, 47845, 47846, 47847, 47848, 47849, 47850, 47851, 47852, 47853, 47854, 47855, 47856, 47857, 47858, 47859, 47860, 47861, 47862, 47863, 47864, 47865, 47866, 47867, 47869, 47870, 47871, 47873, 47874, 47875, 47877, 47878, 47879, 47880, 47881, 47882, 47883, 47884, 47886, 47888, 47890, 47891, 47892, 47893, 47894, 47895, 47897, 47898, 47899, 47901, 47902, 47903, 47905, 47906, 47907, 47908, 47909, 47910, 47911, 47912, 47914, 47916, 47917, 47918, 47919, 47920, 47921, 47922, 47923, 47927, 47929, 47930, 47935, 47936, 47937, 47938, 47939, 47942, 47944, 47946, 47947, 47948, 47950, 47953, 47954, null, null, null, null, null, null, 47955, 47957, 47958, 47959, 47961, 47962, 47963, 47964, 47965, 47966, 47967, 47968, 47970, 47972, 47973, 47974, 47975, 47976, 47977, 47978, 47979, 47981, 47982, 47983, 47984, 47985, null, null, null, null, null, null, 47986, 47987, 47988, 47989, 47990, 47991, 47992, 47993, 47994, 47995, 47996, 47997, 47998, 47999, 48e3, 48001, 48002, 48003, 48004, 48005, 48006, 48007, 48009, 48010, 48011, 48013, 48014, 48015, 48017, 48018, 48019, 48020, 48021, 48022, 48023, 48024, 48025, 48026, 48027, 48028, 48029, 48030, 48031, 48032, 48033, 48034, 48035, 48037, 48038, 48039, 48041, 48042, 48043, 48045, 48046, 48047, 48048, 48049, 48050, 48051, 48053, 48054, 48056, 48057, 48058, 48059, 48060, 48061, 48062, 48063, 48065, 48066, 48067, 48069, 48070, 48071, 48073, 48074, 48075, 48076, 48077, 48078, 48079, 48081, 48082, 48084, 48085, 48086, 48087, 48088, 48089, 48090, 48091, 48092, 48093, 48094, 48095, 48096, 48097, 48098, 48099, 48100, 48101, 48102, 48103, 48104, 48105, 48106, 48107, 48108, 48109, 48110, 48111, 48112, 48113, 48114, 48115, 48116, 48117, 48118, 48119, 48122, 48123, 48125, 48126, 48129, 48131, 48132, 48133, 48134, 48135, 48138, 48142, 48144, 48146, 48147, 48153, 48154, 48160, 48161, 48162, 48163, 48166, 48168, 48170, 48171, 48172, 48174, 48175, 48178, 48179, 48181, null, null, null, null, null, null, 48182, 48183, 48185, 48186, 48187, 48188, 48189, 48190, 48191, 48194, 48198, 48199, 48200, 48202, 48203, 48206, 48207, 48209, 48210, 48211, 48212, 48213, 48214, 48215, 48216, 48217, null, null, null, null, null, null, 48218, 48219, 48220, 48222, 48223, 48224, 48225, 48226, 48227, 48228, 48229, 48230, 48231, 48232, 48233, 48234, 48235, 48236, 48237, 48238, 48239, 48240, 48241, 48242, 48243, 48244, 48245, 48246, 48247, 48248, 48249, 48250, 48251, 48252, 48253, 48254, 48255, 48256, 48257, 48258, 48259, 48262, 48263, 48265, 48266, 48269, 48271, 48272, 48273, 48274, 48275, 48278, 48280, 48283, 48284, 48285, 48286, 48287, 48290, 48291, 48293, 48294, 48297, 48298, 48299, 48300, 48301, 48302, 48303, 48306, 48310, 48311, 48312, 48313, 48314, 48315, 48318, 48319, 48321, 48322, 48323, 48325, 48326, 48327, 48328, 48329, 48330, 48331, 48332, 48334, 48338, 48339, 48340, 48342, 48343, 48345, 48346, 48347, 48349, 48350, 48351, 48352, 48353, 48354, 48355, 48356, 48357, 48358, 48359, 48360, 48361, 48362, 48363, 48364, 48365, 48366, 48367, 48368, 48369, 48370, 48371, 48375, 48377, 48378, 48379, 48381, 48382, 48383, 48384, 48385, 48386, 48387, 48390, 48392, 48394, 48395, 48396, 48397, 48398, 48399, 48401, 48402, 48403, 48405, 48406, 48407, 48408, 48409, 48410, 48411, 48412, 48413, null, null, null, null, null, null, 48414, 48415, 48416, 48417, 48418, 48419, 48421, 48422, 48423, 48424, 48425, 48426, 48427, 48429, 48430, 48431, 48432, 48433, 48434, 48435, 48436, 48437, 48438, 48439, 48440, 48441, null, null, null, null, null, null, 48442, 48443, 48444, 48445, 48446, 48447, 48449, 48450, 48451, 48452, 48453, 48454, 48455, 48458, 48459, 48461, 48462, 48463, 48465, 48466, 48467, 48468, 48469, 48470, 48471, 48474, 48475, 48476, 48477, 48478, 48479, 48480, 48481, 48482, 48483, 48485, 48486, 48487, 48489, 48490, 48491, 48492, 48493, 48494, 48495, 48496, 48497, 48498, 48499, 48500, 48501, 48502, 48503, 48504, 48505, 48506, 48507, 48508, 48509, 48510, 48511, 48514, 48515, 48517, 48518, 48523, 48524, 48525, 48526, 48527, 48530, 48532, 48534, 48535, 48536, 48539, 48541, 48542, 48543, 48544, 48545, 48546, 48547, 48549, 48550, 48551, 48552, 48553, 48554, 48555, 48556, 48557, 48558, 48559, 48561, 48562, 48563, 48564, 48565, 48566, 48567, 48569, 48570, 48571, 48572, 48573, 48574, 48575, 48576, 48577, 48578, 48579, 48580, 48581, 48582, 48583, 48584, 48585, 48586, 48587, 48588, 48589, 48590, 48591, 48592, 48593, 48594, 48595, 48598, 48599, 48601, 48602, 48603, 48605, 48606, 48607, 48608, 48609, 48610, 48611, 48612, 48613, 48614, 48615, 48616, 48618, 48619, 48620, 48621, 48622, 48623, 48625, null, null, null, null, null, null, 48626, 48627, 48629, 48630, 48631, 48633, 48634, 48635, 48636, 48637, 48638, 48639, 48641, 48642, 48644, 48646, 48647, 48648, 48649, 48650, 48651, 48654, 48655, 48657, 48658, 48659, null, null, null, null, null, null, 48661, 48662, 48663, 48664, 48665, 48666, 48667, 48670, 48672, 48673, 48674, 48675, 48676, 48677, 48678, 48679, 48680, 48681, 48682, 48683, 48684, 48685, 48686, 48687, 48688, 48689, 48690, 48691, 48692, 48693, 48694, 48695, 48696, 48697, 48698, 48699, 48700, 48701, 48702, 48703, 48704, 48705, 48706, 48707, 48710, 48711, 48713, 48714, 48715, 48717, 48719, 48720, 48721, 48722, 48723, 48726, 48728, 48732, 48733, 48734, 48735, 48738, 48739, 48741, 48742, 48743, 48745, 48747, 48748, 48749, 48750, 48751, 48754, 48758, 48759, 48760, 48761, 48762, 48766, 48767, 48769, 48770, 48771, 48773, 48774, 48775, 48776, 48777, 48778, 48779, 48782, 48786, 48787, 48788, 48789, 48790, 48791, 48794, 48795, 48796, 48797, 48798, 48799, 48800, 48801, 48802, 48803, 48804, 48805, 48806, 48807, 48809, 48810, 48811, 48812, 48813, 48814, 48815, 48816, 48817, 48818, 48819, 48820, 48821, 48822, 48823, 48824, 48825, 48826, 48827, 48828, 48829, 48830, 48831, 48832, 48833, 48834, 48835, 48836, 48837, 48838, 48839, 48840, 48841, 48842, 48843, 48844, 48845, 48846, 48847, 48850, 48851, null, null, null, null, null, null, 48853, 48854, 48857, 48858, 48859, 48860, 48861, 48862, 48863, 48865, 48866, 48870, 48871, 48872, 48873, 48874, 48875, 48877, 48878, 48879, 48880, 48881, 48882, 48883, 48884, 48885, null, null, null, null, null, null, 48886, 48887, 48888, 48889, 48890, 48891, 48892, 48893, 48894, 48895, 48896, 48898, 48899, 48900, 48901, 48902, 48903, 48906, 48907, 48908, 48909, 48910, 48911, 48912, 48913, 48914, 48915, 48916, 48917, 48918, 48919, 48922, 48926, 48927, 48928, 48929, 48930, 48931, 48932, 48933, 48934, 48935, 48936, 48937, 48938, 48939, 48940, 48941, 48942, 48943, 48944, 48945, 48946, 48947, 48948, 48949, 48950, 48951, 48952, 48953, 48954, 48955, 48956, 48957, 48958, 48959, 48962, 48963, 48965, 48966, 48967, 48969, 48970, 48971, 48972, 48973, 48974, 48975, 48978, 48979, 48980, 48982, 48983, 48984, 48985, 48986, 48987, 48988, 48989, 48990, 48991, 48992, 48993, 48994, 48995, 48996, 48997, 48998, 48999, 49e3, 49001, 49002, 49003, 49004, 49005, 49006, 49007, 49008, 49009, 49010, 49011, 49012, 49013, 49014, 49015, 49016, 49017, 49018, 49019, 49020, 49021, 49022, 49023, 49024, 49025, 49026, 49027, 49028, 49029, 49030, 49031, 49032, 49033, 49034, 49035, 49036, 49037, 49038, 49039, 49040, 49041, 49042, 49043, 49045, 49046, 49047, 49048, 49049, 49050, 49051, 49052, 49053, null, null, null, null, null, null, 49054, 49055, 49056, 49057, 49058, 49059, 49060, 49061, 49062, 49063, 49064, 49065, 49066, 49067, 49068, 49069, 49070, 49071, 49073, 49074, 49075, 49076, 49077, 49078, 49079, 49080, null, null, null, null, null, null, 49081, 49082, 49083, 49084, 49085, 49086, 49087, 49088, 49089, 49090, 49091, 49092, 49094, 49095, 49096, 49097, 49098, 49099, 49102, 49103, 49105, 49106, 49107, 49109, 49110, 49111, 49112, 49113, 49114, 49115, 49117, 49118, 49120, 49122, 49123, 49124, 49125, 49126, 49127, 49128, 49129, 49130, 49131, 49132, 49133, 49134, 49135, 49136, 49137, 49138, 49139, 49140, 49141, 49142, 49143, 49144, 49145, 49146, 49147, 49148, 49149, 49150, 49151, 49152, 49153, 49154, 49155, 49156, 49157, 49158, 49159, 49160, 49161, 49162, 49163, 49164, 49165, 49166, 49167, 49168, 49169, 49170, 49171, 49172, 49173, 49174, 49175, 49176, 49177, 49178, 49179, 49180, 49181, 49182, 49183, 49184, 49185, 49186, 49187, 49188, 49189, 49190, 49191, 49192, 49193, 49194, 49195, 49196, 49197, 49198, 49199, 49200, 49201, 49202, 49203, 49204, 49205, 49206, 49207, 49208, 49209, 49210, 49211, 49213, 49214, 49215, 49216, 49217, 49218, 49219, 49220, 49221, 49222, 49223, 49224, 49225, 49226, 49227, 49228, 49229, 49230, 49231, 49232, 49234, 49235, 49236, 49237, 49238, 49239, 49241, 49242, 49243, null, null, null, null, null, null, 49245, 49246, 49247, 49249, 49250, 49251, 49252, 49253, 49254, 49255, 49258, 49259, 49260, 49261, 49262, 49263, 49264, 49265, 49266, 49267, 49268, 49269, 49270, 49271, 49272, 49273, null, null, null, null, null, null, 49274, 49275, 49276, 49277, 49278, 49279, 49280, 49281, 49282, 49283, 49284, 49285, 49286, 49287, 49288, 49289, 49290, 49291, 49292, 49293, 49294, 49295, 49298, 49299, 49301, 49302, 49303, 49305, 49306, 49307, 49308, 49309, 49310, 49311, 49314, 49316, 49318, 49319, 49320, 49321, 49322, 49323, 49326, 49329, 49330, 49335, 49336, 49337, 49338, 49339, 49342, 49346, 49347, 49348, 49350, 49351, 49354, 49355, 49357, 49358, 49359, 49361, 49362, 49363, 49364, 49365, 49366, 49367, 49370, 49374, 49375, 49376, 49377, 49378, 49379, 49382, 49383, 49385, 49386, 49387, 49389, 49390, 49391, 49392, 49393, 49394, 49395, 49398, 49400, 49402, 49403, 49404, 49405, 49406, 49407, 49409, 49410, 49411, 49413, 49414, 49415, 49417, 49418, 49419, 49420, 49421, 49422, 49423, 49425, 49426, 49427, 49428, 49430, 49431, 49432, 49433, 49434, 49435, 49441, 49442, 49445, 49448, 49449, 49450, 49451, 49454, 49458, 49459, 49460, 49461, 49463, 49466, 49467, 49469, 49470, 49471, 49473, 49474, 49475, 49476, 49477, 49478, 49479, 49482, 49486, 49487, 49488, 49489, 49490, 49491, 49494, 49495, null, null, null, null, null, null, 49497, 49498, 49499, 49501, 49502, 49503, 49504, 49505, 49506, 49507, 49510, 49514, 49515, 49516, 49517, 49518, 49519, 49521, 49522, 49523, 49525, 49526, 49527, 49529, 49530, 49531, null, null, null, null, null, null, 49532, 49533, 49534, 49535, 49536, 49537, 49538, 49539, 49540, 49542, 49543, 49544, 49545, 49546, 49547, 49551, 49553, 49554, 49555, 49557, 49559, 49560, 49561, 49562, 49563, 49566, 49568, 49570, 49571, 49572, 49574, 49575, 49578, 49579, 49581, 49582, 49583, 49585, 49586, 49587, 49588, 49589, 49590, 49591, 49592, 49593, 49594, 49595, 49596, 49598, 49599, 49600, 49601, 49602, 49603, 49605, 49606, 49607, 49609, 49610, 49611, 49613, 49614, 49615, 49616, 49617, 49618, 49619, 49621, 49622, 49625, 49626, 49627, 49628, 49629, 49630, 49631, 49633, 49634, 49635, 49637, 49638, 49639, 49641, 49642, 49643, 49644, 49645, 49646, 49647, 49650, 49652, 49653, 49654, 49655, 49656, 49657, 49658, 49659, 49662, 49663, 49665, 49666, 49667, 49669, 49670, 49671, 49672, 49673, 49674, 49675, 49678, 49680, 49682, 49683, 49684, 49685, 49686, 49687, 49690, 49691, 49693, 49694, 49697, 49698, 49699, 49700, 49701, 49702, 49703, 49706, 49708, 49710, 49712, 49715, 49717, 49718, 49719, 49720, 49721, 49722, 49723, 49724, 49725, 49726, 49727, 49728, 49729, 49730, 49731, 49732, 49733, null, null, null, null, null, null, 49734, 49735, 49737, 49738, 49739, 49740, 49741, 49742, 49743, 49746, 49747, 49749, 49750, 49751, 49753, 49754, 49755, 49756, 49757, 49758, 49759, 49761, 49762, 49763, 49764, 49766, null, null, null, null, null, null, 49767, 49768, 49769, 49770, 49771, 49774, 49775, 49777, 49778, 49779, 49781, 49782, 49783, 49784, 49785, 49786, 49787, 49790, 49792, 49794, 49795, 49796, 49797, 49798, 49799, 49802, 49803, 49804, 49805, 49806, 49807, 49809, 49810, 49811, 49812, 49813, 49814, 49815, 49817, 49818, 49820, 49822, 49823, 49824, 49825, 49826, 49827, 49830, 49831, 49833, 49834, 49835, 49838, 49839, 49840, 49841, 49842, 49843, 49846, 49848, 49850, 49851, 49852, 49853, 49854, 49855, 49856, 49857, 49858, 49859, 49860, 49861, 49862, 49863, 49864, 49865, 49866, 49867, 49868, 49869, 49870, 49871, 49872, 49873, 49874, 49875, 49876, 49877, 49878, 49879, 49880, 49881, 49882, 49883, 49886, 49887, 49889, 49890, 49893, 49894, 49895, 49896, 49897, 49898, 49902, 49904, 49906, 49907, 49908, 49909, 49911, 49914, 49917, 49918, 49919, 49921, 49922, 49923, 49924, 49925, 49926, 49927, 49930, 49931, 49934, 49935, 49936, 49937, 49938, 49942, 49943, 49945, 49946, 49947, 49949, 49950, 49951, 49952, 49953, 49954, 49955, 49958, 49959, 49962, 49963, 49964, 49965, 49966, 49967, 49968, 49969, 49970, null, null, null, null, null, null, 49971, 49972, 49973, 49974, 49975, 49976, 49977, 49978, 49979, 49980, 49981, 49982, 49983, 49984, 49985, 49986, 49987, 49988, 49990, 49991, 49992, 49993, 49994, 49995, 49996, 49997, null, null, null, null, null, null, 49998, 49999, 5e4, 50001, 50002, 50003, 50004, 50005, 50006, 50007, 50008, 50009, 50010, 50011, 50012, 50013, 50014, 50015, 50016, 50017, 50018, 50019, 50020, 50021, 50022, 50023, 50026, 50027, 50029, 50030, 50031, 50033, 50035, 50036, 50037, 50038, 50039, 50042, 50043, 50046, 50047, 50048, 50049, 50050, 50051, 50053, 50054, 50055, 50057, 50058, 50059, 50061, 50062, 50063, 50064, 50065, 50066, 50067, 50068, 50069, 50070, 50071, 50072, 50073, 50074, 50075, 50076, 50077, 50078, 50079, 50080, 50081, 50082, 50083, 50084, 50085, 50086, 50087, 50088, 50089, 50090, 50091, 50092, 50093, 50094, 50095, 50096, 50097, 50098, 50099, 50100, 50101, 50102, 50103, 50104, 50105, 50106, 50107, 50108, 50109, 50110, 50111, 50113, 50114, 50115, 50116, 50117, 50118, 50119, 50120, 50121, 50122, 50123, 50124, 50125, 50126, 50127, 50128, 50129, 50130, 50131, 50132, 50133, 50134, 50135, 50138, 50139, 50141, 50142, 50145, 50147, 50148, 50149, 50150, 50151, 50154, 50155, 50156, 50158, 50159, 50160, 50161, 50162, 50163, 50166, 50167, 50169, 50170, 50171, 50172, 50173, 50174, null, null, null, null, null, null, 50175, 50176, 50177, 50178, 50179, 50180, 50181, 50182, 50183, 50185, 50186, 50187, 50188, 50189, 50190, 50191, 50193, 50194, 50195, 50196, 50197, 50198, 50199, 50200, 50201, 50202, null, null, null, null, null, null, 50203, 50204, 50205, 50206, 50207, 50208, 50209, 50210, 50211, 50213, 50214, 50215, 50216, 50217, 50218, 50219, 50221, 50222, 50223, 50225, 50226, 50227, 50229, 50230, 50231, 50232, 50233, 50234, 50235, 50238, 50239, 50240, 50241, 50242, 50243, 50244, 50245, 50246, 50247, 50249, 50250, 50251, 50252, 50253, 50254, 50255, 50256, 50257, 50258, 50259, 50260, 50261, 50262, 50263, 50264, 50265, 50266, 50267, 50268, 50269, 50270, 50271, 50272, 50273, 50274, 50275, 50278, 50279, 50281, 50282, 50283, 50285, 50286, 50287, 50288, 50289, 50290, 50291, 50294, 50295, 50296, 50298, 50299, 50300, 50301, 50302, 50303, 50305, 50306, 50307, 50308, 50309, 50310, 50311, 50312, 50313, 50314, 50315, 50316, 50317, 50318, 50319, 50320, 50321, 50322, 50323, 50325, 50326, 50327, 50328, 50329, 50330, 50331, 50333, 50334, 50335, 50336, 50337, 50338, 50339, 50340, 50341, 50342, 50343, 50344, 50345, 50346, 50347, 50348, 50349, 50350, 50351, 50352, 50353, 50354, 50355, 50356, 50357, 50358, 50359, 50361, 50362, 50363, 50365, 50366, 50367, 50368, 50369, 50370, 50371, 50372, 50373, null, null, null, null, null, null, 50374, 50375, 50376, 50377, 50378, 50379, 50380, 50381, 50382, 50383, 50384, 50385, 50386, 50387, 50388, 50389, 50390, 50391, 50392, 50393, 50394, 50395, 50396, 50397, 50398, 50399, null, null, null, null, null, null, 50400, 50401, 50402, 50403, 50404, 50405, 50406, 50407, 50408, 50410, 50411, 50412, 50413, 50414, 50415, 50418, 50419, 50421, 50422, 50423, 50425, 50427, 50428, 50429, 50430, 50434, 50435, 50436, 50437, 50438, 50439, 50440, 50441, 50442, 50443, 50445, 50446, 50447, 50449, 50450, 50451, 50453, 50454, 50455, 50456, 50457, 50458, 50459, 50461, 50462, 50463, 50464, 50465, 50466, 50467, 50468, 50469, 50470, 50471, 50474, 50475, 50477, 50478, 50479, 50481, 50482, 50483, 50484, 50485, 50486, 50487, 50490, 50492, 50494, 50495, 50496, 50497, 50498, 50499, 50502, 50503, 50507, 50511, 50512, 50513, 50514, 50518, 50522, 50523, 50524, 50527, 50530, 50531, 50533, 50534, 50535, 50537, 50538, 50539, 50540, 50541, 50542, 50543, 50546, 50550, 50551, 50552, 50553, 50554, 50555, 50558, 50559, 50561, 50562, 50563, 50565, 50566, 50568, 50569, 50570, 50571, 50574, 50576, 50578, 50579, 50580, 50582, 50585, 50586, 50587, 50589, 50590, 50591, 50593, 50594, 50595, 50596, 50597, 50598, 50599, 50600, 50602, 50603, 50604, 50605, 50606, 50607, 50608, 50609, 50610, 50611, 50614, null, null, null, null, null, null, 50615, 50618, 50623, 50624, 50625, 50626, 50627, 50635, 50637, 50639, 50642, 50643, 50645, 50646, 50647, 50649, 50650, 50651, 50652, 50653, 50654, 50655, 50658, 50660, 50662, 50663, null, null, null, null, null, null, 50664, 50665, 50666, 50667, 50671, 50673, 50674, 50675, 50677, 50680, 50681, 50682, 50683, 50690, 50691, 50692, 50697, 50698, 50699, 50701, 50702, 50703, 50705, 50706, 50707, 50708, 50709, 50710, 50711, 50714, 50717, 50718, 50719, 50720, 50721, 50722, 50723, 50726, 50727, 50729, 50730, 50731, 50735, 50737, 50738, 50742, 50744, 50746, 50748, 50749, 50750, 50751, 50754, 50755, 50757, 50758, 50759, 50761, 50762, 50763, 50764, 50765, 50766, 50767, 50770, 50774, 50775, 50776, 50777, 50778, 50779, 50782, 50783, 50785, 50786, 50787, 50788, 50789, 50790, 50791, 50792, 50793, 50794, 50795, 50797, 50798, 50800, 50802, 50803, 50804, 50805, 50806, 50807, 50810, 50811, 50813, 50814, 50815, 50817, 50818, 50819, 50820, 50821, 50822, 50823, 50826, 50828, 50830, 50831, 50832, 50833, 50834, 50835, 50838, 50839, 50841, 50842, 50843, 50845, 50846, 50847, 50848, 50849, 50850, 50851, 50854, 50856, 50858, 50859, 50860, 50861, 50862, 50863, 50866, 50867, 50869, 50870, 50871, 50875, 50876, 50877, 50878, 50879, 50882, 50884, 50886, 50887, 50888, 50889, 50890, 50891, 50894, null, null, null, null, null, null, 50895, 50897, 50898, 50899, 50901, 50902, 50903, 50904, 50905, 50906, 50907, 50910, 50911, 50914, 50915, 50916, 50917, 50918, 50919, 50922, 50923, 50925, 50926, 50927, 50929, 50930, null, null, null, null, null, null, 50931, 50932, 50933, 50934, 50935, 50938, 50939, 50940, 50942, 50943, 50944, 50945, 50946, 50947, 50950, 50951, 50953, 50954, 50955, 50957, 50958, 50959, 50960, 50961, 50962, 50963, 50966, 50968, 50970, 50971, 50972, 50973, 50974, 50975, 50978, 50979, 50981, 50982, 50983, 50985, 50986, 50987, 50988, 50989, 50990, 50991, 50994, 50996, 50998, 51e3, 51001, 51002, 51003, 51006, 51007, 51009, 51010, 51011, 51013, 51014, 51015, 51016, 51017, 51019, 51022, 51024, 51033, 51034, 51035, 51037, 51038, 51039, 51041, 51042, 51043, 51044, 51045, 51046, 51047, 51049, 51050, 51052, 51053, 51054, 51055, 51056, 51057, 51058, 51059, 51062, 51063, 51065, 51066, 51067, 51071, 51072, 51073, 51074, 51078, 51083, 51084, 51085, 51087, 51090, 51091, 51093, 51097, 51099, 51100, 51101, 51102, 51103, 51106, 51111, 51112, 51113, 51114, 51115, 51118, 51119, 51121, 51122, 51123, 51125, 51126, 51127, 51128, 51129, 51130, 51131, 51134, 51138, 51139, 51140, 51141, 51142, 51143, 51146, 51147, 51149, 51151, 51153, 51154, 51155, 51156, 51157, 51158, 51159, 51161, 51162, 51163, 51164, null, null, null, null, null, null, 51166, 51167, 51168, 51169, 51170, 51171, 51173, 51174, 51175, 51177, 51178, 51179, 51181, 51182, 51183, 51184, 51185, 51186, 51187, 51188, 51189, 51190, 51191, 51192, 51193, 51194, null, null, null, null, null, null, 51195, 51196, 51197, 51198, 51199, 51202, 51203, 51205, 51206, 51207, 51209, 51211, 51212, 51213, 51214, 51215, 51218, 51220, 51223, 51224, 51225, 51226, 51227, 51230, 51231, 51233, 51234, 51235, 51237, 51238, 51239, 51240, 51241, 51242, 51243, 51246, 51248, 51250, 51251, 51252, 51253, 51254, 51255, 51257, 51258, 51259, 51261, 51262, 51263, 51265, 51266, 51267, 51268, 51269, 51270, 51271, 51274, 51275, 51278, 51279, 51280, 51281, 51282, 51283, 51285, 51286, 51287, 51288, 51289, 51290, 51291, 51292, 51293, 51294, 51295, 51296, 51297, 51298, 51299, 51300, 51301, 51302, 51303, 51304, 51305, 51306, 51307, 51308, 51309, 51310, 51311, 51314, 51315, 51317, 51318, 51319, 51321, 51323, 51324, 51325, 51326, 51327, 51330, 51332, 51336, 51337, 51338, 51342, 51343, 51344, 51345, 51346, 51347, 51349, 51350, 51351, 51352, 51353, 51354, 51355, 51356, 51358, 51360, 51362, 51363, 51364, 51365, 51366, 51367, 51369, 51370, 51371, 51372, 51373, 51374, 51375, 51376, 51377, 51378, 51379, 51380, 51381, 51382, 51383, 51384, 51385, 51386, 51387, 51390, 51391, 51392, 51393, null, null, null, null, null, null, 51394, 51395, 51397, 51398, 51399, 51401, 51402, 51403, 51405, 51406, 51407, 51408, 51409, 51410, 51411, 51414, 51416, 51418, 51419, 51420, 51421, 51422, 51423, 51426, 51427, 51429, null, null, null, null, null, null, 51430, 51431, 51432, 51433, 51434, 51435, 51436, 51437, 51438, 51439, 51440, 51441, 51442, 51443, 51444, 51446, 51447, 51448, 51449, 51450, 51451, 51454, 51455, 51457, 51458, 51459, 51463, 51464, 51465, 51466, 51467, 51470, 12288, 12289, 12290, 183, 8229, 8230, 168, 12291, 173, 8213, 8741, 65340, 8764, 8216, 8217, 8220, 8221, 12308, 12309, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12304, 12305, 177, 215, 247, 8800, 8804, 8805, 8734, 8756, 176, 8242, 8243, 8451, 8491, 65504, 65505, 65509, 9794, 9792, 8736, 8869, 8978, 8706, 8711, 8801, 8786, 167, 8251, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 9661, 9660, 8594, 8592, 8593, 8595, 8596, 12307, 8810, 8811, 8730, 8765, 8733, 8757, 8747, 8748, 8712, 8715, 8838, 8839, 8834, 8835, 8746, 8745, 8743, 8744, 65506, 51472, 51474, 51475, 51476, 51477, 51478, 51479, 51481, 51482, 51483, 51484, 51485, 51486, 51487, 51488, 51489, 51490, 51491, 51492, 51493, 51494, 51495, 51496, 51497, 51498, 51499, null, null, null, null, null, null, 51501, 51502, 51503, 51504, 51505, 51506, 51507, 51509, 51510, 51511, 51512, 51513, 51514, 51515, 51516, 51517, 51518, 51519, 51520, 51521, 51522, 51523, 51524, 51525, 51526, 51527, null, null, null, null, null, null, 51528, 51529, 51530, 51531, 51532, 51533, 51534, 51535, 51538, 51539, 51541, 51542, 51543, 51545, 51546, 51547, 51548, 51549, 51550, 51551, 51554, 51556, 51557, 51558, 51559, 51560, 51561, 51562, 51563, 51565, 51566, 51567, 8658, 8660, 8704, 8707, 180, 65374, 711, 728, 733, 730, 729, 184, 731, 161, 191, 720, 8750, 8721, 8719, 164, 8457, 8240, 9665, 9664, 9655, 9654, 9828, 9824, 9825, 9829, 9831, 9827, 8857, 9672, 9635, 9680, 9681, 9618, 9636, 9637, 9640, 9639, 9638, 9641, 9832, 9743, 9742, 9756, 9758, 182, 8224, 8225, 8597, 8599, 8601, 8598, 8600, 9837, 9833, 9834, 9836, 12927, 12828, 8470, 13255, 8482, 13250, 13272, 8481, 8364, 174, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 51569, 51570, 51571, 51573, 51574, 51575, 51576, 51577, 51578, 51579, 51581, 51582, 51583, 51584, 51585, 51586, 51587, 51588, 51589, 51590, 51591, 51594, 51595, 51597, 51598, 51599, null, null, null, null, null, null, 51601, 51602, 51603, 51604, 51605, 51606, 51607, 51610, 51612, 51614, 51615, 51616, 51617, 51618, 51619, 51620, 51621, 51622, 51623, 51624, 51625, 51626, 51627, 51628, 51629, 51630, null, null, null, null, null, null, 51631, 51632, 51633, 51634, 51635, 51636, 51637, 51638, 51639, 51640, 51641, 51642, 51643, 51644, 51645, 51646, 51647, 51650, 51651, 51653, 51654, 51657, 51659, 51660, 51661, 51662, 51663, 51666, 51668, 51671, 51672, 51675, 65281, 65282, 65283, 65284, 65285, 65286, 65287, 65288, 65289, 65290, 65291, 65292, 65293, 65294, 65295, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, 65306, 65307, 65308, 65309, 65310, 65311, 65312, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65339, 65510, 65341, 65342, 65343, 65344, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 65371, 65372, 65373, 65507, 51678, 51679, 51681, 51683, 51685, 51686, 51688, 51689, 51690, 51691, 51694, 51698, 51699, 51700, 51701, 51702, 51703, 51706, 51707, 51709, 51710, 51711, 51713, 51714, 51715, 51716, null, null, null, null, null, null, 51717, 51718, 51719, 51722, 51726, 51727, 51728, 51729, 51730, 51731, 51733, 51734, 51735, 51737, 51738, 51739, 51740, 51741, 51742, 51743, 51744, 51745, 51746, 51747, 51748, 51749, null, null, null, null, null, null, 51750, 51751, 51752, 51754, 51755, 51756, 51757, 51758, 51759, 51760, 51761, 51762, 51763, 51764, 51765, 51766, 51767, 51768, 51769, 51770, 51771, 51772, 51773, 51774, 51775, 51776, 51777, 51778, 51779, 51780, 51781, 51782, 12593, 12594, 12595, 12596, 12597, 12598, 12599, 12600, 12601, 12602, 12603, 12604, 12605, 12606, 12607, 12608, 12609, 12610, 12611, 12612, 12613, 12614, 12615, 12616, 12617, 12618, 12619, 12620, 12621, 12622, 12623, 12624, 12625, 12626, 12627, 12628, 12629, 12630, 12631, 12632, 12633, 12634, 12635, 12636, 12637, 12638, 12639, 12640, 12641, 12642, 12643, 12644, 12645, 12646, 12647, 12648, 12649, 12650, 12651, 12652, 12653, 12654, 12655, 12656, 12657, 12658, 12659, 12660, 12661, 12662, 12663, 12664, 12665, 12666, 12667, 12668, 12669, 12670, 12671, 12672, 12673, 12674, 12675, 12676, 12677, 12678, 12679, 12680, 12681, 12682, 12683, 12684, 12685, 12686, 51783, 51784, 51785, 51786, 51787, 51790, 51791, 51793, 51794, 51795, 51797, 51798, 51799, 51800, 51801, 51802, 51803, 51806, 51810, 51811, 51812, 51813, 51814, 51815, 51817, 51818, null, null, null, null, null, null, 51819, 51820, 51821, 51822, 51823, 51824, 51825, 51826, 51827, 51828, 51829, 51830, 51831, 51832, 51833, 51834, 51835, 51836, 51838, 51839, 51840, 51841, 51842, 51843, 51845, 51846, null, null, null, null, null, null, 51847, 51848, 51849, 51850, 51851, 51852, 51853, 51854, 51855, 51856, 51857, 51858, 51859, 51860, 51861, 51862, 51863, 51865, 51866, 51867, 51868, 51869, 51870, 51871, 51872, 51873, 51874, 51875, 51876, 51877, 51878, 51879, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, null, null, null, null, null, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, null, null, null, null, null, null, null, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, null, null, null, null, null, null, null, null, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, null, null, null, null, null, null, 51880, 51881, 51882, 51883, 51884, 51885, 51886, 51887, 51888, 51889, 51890, 51891, 51892, 51893, 51894, 51895, 51896, 51897, 51898, 51899, 51902, 51903, 51905, 51906, 51907, 51909, null, null, null, null, null, null, 51910, 51911, 51912, 51913, 51914, 51915, 51918, 51920, 51922, 51924, 51925, 51926, 51927, 51930, 51931, 51932, 51933, 51934, 51935, 51937, 51938, 51939, 51940, 51941, 51942, 51943, null, null, null, null, null, null, 51944, 51945, 51946, 51947, 51949, 51950, 51951, 51952, 51953, 51954, 51955, 51957, 51958, 51959, 51960, 51961, 51962, 51963, 51964, 51965, 51966, 51967, 51968, 51969, 51970, 51971, 51972, 51973, 51974, 51975, 51977, 51978, 9472, 9474, 9484, 9488, 9496, 9492, 9500, 9516, 9508, 9524, 9532, 9473, 9475, 9487, 9491, 9499, 9495, 9507, 9523, 9515, 9531, 9547, 9504, 9519, 9512, 9527, 9535, 9501, 9520, 9509, 9528, 9538, 9490, 9489, 9498, 9497, 9494, 9493, 9486, 9485, 9502, 9503, 9505, 9506, 9510, 9511, 9513, 9514, 9517, 9518, 9521, 9522, 9525, 9526, 9529, 9530, 9533, 9534, 9536, 9537, 9539, 9540, 9541, 9542, 9543, 9544, 9545, 9546, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 51979, 51980, 51981, 51982, 51983, 51985, 51986, 51987, 51989, 51990, 51991, 51993, 51994, 51995, 51996, 51997, 51998, 51999, 52002, 52003, 52004, 52005, 52006, 52007, 52008, 52009, null, null, null, null, null, null, 52010, 52011, 52012, 52013, 52014, 52015, 52016, 52017, 52018, 52019, 52020, 52021, 52022, 52023, 52024, 52025, 52026, 52027, 52028, 52029, 52030, 52031, 52032, 52034, 52035, 52036, null, null, null, null, null, null, 52037, 52038, 52039, 52042, 52043, 52045, 52046, 52047, 52049, 52050, 52051, 52052, 52053, 52054, 52055, 52058, 52059, 52060, 52062, 52063, 52064, 52065, 52066, 52067, 52069, 52070, 52071, 52072, 52073, 52074, 52075, 52076, 13205, 13206, 13207, 8467, 13208, 13252, 13219, 13220, 13221, 13222, 13209, 13210, 13211, 13212, 13213, 13214, 13215, 13216, 13217, 13218, 13258, 13197, 13198, 13199, 13263, 13192, 13193, 13256, 13223, 13224, 13232, 13233, 13234, 13235, 13236, 13237, 13238, 13239, 13240, 13241, 13184, 13185, 13186, 13187, 13188, 13242, 13243, 13244, 13245, 13246, 13247, 13200, 13201, 13202, 13203, 13204, 8486, 13248, 13249, 13194, 13195, 13196, 13270, 13253, 13229, 13230, 13231, 13275, 13225, 13226, 13227, 13228, 13277, 13264, 13267, 13251, 13257, 13276, 13254, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52077, 52078, 52079, 52080, 52081, 52082, 52083, 52084, 52085, 52086, 52087, 52090, 52091, 52092, 52093, 52094, 52095, 52096, 52097, 52098, 52099, 52100, 52101, 52102, 52103, 52104, null, null, null, null, null, null, 52105, 52106, 52107, 52108, 52109, 52110, 52111, 52112, 52113, 52114, 52115, 52116, 52117, 52118, 52119, 52120, 52121, 52122, 52123, 52125, 52126, 52127, 52128, 52129, 52130, 52131, null, null, null, null, null, null, 52132, 52133, 52134, 52135, 52136, 52137, 52138, 52139, 52140, 52141, 52142, 52143, 52144, 52145, 52146, 52147, 52148, 52149, 52150, 52151, 52153, 52154, 52155, 52156, 52157, 52158, 52159, 52160, 52161, 52162, 52163, 52164, 198, 208, 170, 294, null, 306, null, 319, 321, 216, 338, 186, 222, 358, 330, null, 12896, 12897, 12898, 12899, 12900, 12901, 12902, 12903, 12904, 12905, 12906, 12907, 12908, 12909, 12910, 12911, 12912, 12913, 12914, 12915, 12916, 12917, 12918, 12919, 12920, 12921, 12922, 12923, 9424, 9425, 9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9449, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 189, 8531, 8532, 188, 190, 8539, 8540, 8541, 8542, 52165, 52166, 52167, 52168, 52169, 52170, 52171, 52172, 52173, 52174, 52175, 52176, 52177, 52178, 52179, 52181, 52182, 52183, 52184, 52185, 52186, 52187, 52188, 52189, 52190, 52191, null, null, null, null, null, null, 52192, 52193, 52194, 52195, 52197, 52198, 52200, 52202, 52203, 52204, 52205, 52206, 52207, 52208, 52209, 52210, 52211, 52212, 52213, 52214, 52215, 52216, 52217, 52218, 52219, 52220, null, null, null, null, null, null, 52221, 52222, 52223, 52224, 52225, 52226, 52227, 52228, 52229, 52230, 52231, 52232, 52233, 52234, 52235, 52238, 52239, 52241, 52242, 52243, 52245, 52246, 52247, 52248, 52249, 52250, 52251, 52254, 52255, 52256, 52259, 52260, 230, 273, 240, 295, 305, 307, 312, 320, 322, 248, 339, 223, 254, 359, 331, 329, 12800, 12801, 12802, 12803, 12804, 12805, 12806, 12807, 12808, 12809, 12810, 12811, 12812, 12813, 12814, 12815, 12816, 12817, 12818, 12819, 12820, 12821, 12822, 12823, 12824, 12825, 12826, 12827, 9372, 9373, 9374, 9375, 9376, 9377, 9378, 9379, 9380, 9381, 9382, 9383, 9384, 9385, 9386, 9387, 9388, 9389, 9390, 9391, 9392, 9393, 9394, 9395, 9396, 9397, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 185, 178, 179, 8308, 8319, 8321, 8322, 8323, 8324, 52261, 52262, 52266, 52267, 52269, 52271, 52273, 52274, 52275, 52276, 52277, 52278, 52279, 52282, 52287, 52288, 52289, 52290, 52291, 52294, 52295, 52297, 52298, 52299, 52301, 52302, null, null, null, null, null, null, 52303, 52304, 52305, 52306, 52307, 52310, 52314, 52315, 52316, 52317, 52318, 52319, 52321, 52322, 52323, 52325, 52327, 52329, 52330, 52331, 52332, 52333, 52334, 52335, 52337, 52338, null, null, null, null, null, null, 52339, 52340, 52342, 52343, 52344, 52345, 52346, 52347, 52348, 52349, 52350, 52351, 52352, 52353, 52354, 52355, 52356, 52357, 52358, 52359, 52360, 52361, 52362, 52363, 52364, 52365, 52366, 52367, 52368, 52369, 52370, 52371, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, null, null, null, null, null, null, null, null, null, null, null, 52372, 52373, 52374, 52375, 52378, 52379, 52381, 52382, 52383, 52385, 52386, 52387, 52388, 52389, 52390, 52391, 52394, 52398, 52399, 52400, 52401, 52402, 52403, 52406, 52407, 52409, null, null, null, null, null, null, 52410, 52411, 52413, 52414, 52415, 52416, 52417, 52418, 52419, 52422, 52424, 52426, 52427, 52428, 52429, 52430, 52431, 52433, 52434, 52435, 52437, 52438, 52439, 52440, 52441, 52442, null, null, null, null, null, null, 52443, 52444, 52445, 52446, 52447, 52448, 52449, 52450, 52451, 52453, 52454, 52455, 52456, 52457, 52458, 52459, 52461, 52462, 52463, 52465, 52466, 52467, 52468, 52469, 52470, 52471, 52472, 52473, 52474, 52475, 52476, 52477, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, null, null, null, null, null, null, null, null, 52478, 52479, 52480, 52482, 52483, 52484, 52485, 52486, 52487, 52490, 52491, 52493, 52494, 52495, 52497, 52498, 52499, 52500, 52501, 52502, 52503, 52506, 52508, 52510, 52511, 52512, null, null, null, null, null, null, 52513, 52514, 52515, 52517, 52518, 52519, 52521, 52522, 52523, 52525, 52526, 52527, 52528, 52529, 52530, 52531, 52532, 52533, 52534, 52535, 52536, 52538, 52539, 52540, 52541, 52542, null, null, null, null, null, null, 52543, 52544, 52545, 52546, 52547, 52548, 52549, 52550, 52551, 52552, 52553, 52554, 52555, 52556, 52557, 52558, 52559, 52560, 52561, 52562, 52563, 52564, 52565, 52566, 52567, 52568, 52569, 52570, 52571, 52573, 52574, 52575, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, null, null, null, null, null, null, null, null, null, null, null, null, null, 52577, 52578, 52579, 52581, 52582, 52583, 52584, 52585, 52586, 52587, 52590, 52592, 52594, 52595, 52596, 52597, 52598, 52599, 52601, 52602, 52603, 52604, 52605, 52606, 52607, 52608, null, null, null, null, null, null, 52609, 52610, 52611, 52612, 52613, 52614, 52615, 52617, 52618, 52619, 52620, 52621, 52622, 52623, 52624, 52625, 52626, 52627, 52630, 52631, 52633, 52634, 52635, 52637, 52638, 52639, null, null, null, null, null, null, 52640, 52641, 52642, 52643, 52646, 52648, 52650, 52651, 52652, 52653, 52654, 52655, 52657, 52658, 52659, 52660, 52661, 52662, 52663, 52664, 52665, 52666, 52667, 52668, 52669, 52670, 52671, 52672, 52673, 52674, 52675, 52677, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52678, 52679, 52680, 52681, 52682, 52683, 52685, 52686, 52687, 52689, 52690, 52691, 52692, 52693, 52694, 52695, 52696, 52697, 52698, 52699, 52700, 52701, 52702, 52703, 52704, 52705, null, null, null, null, null, null, 52706, 52707, 52708, 52709, 52710, 52711, 52713, 52714, 52715, 52717, 52718, 52719, 52721, 52722, 52723, 52724, 52725, 52726, 52727, 52730, 52732, 52734, 52735, 52736, 52737, 52738, null, null, null, null, null, null, 52739, 52741, 52742, 52743, 52745, 52746, 52747, 52749, 52750, 52751, 52752, 52753, 52754, 52755, 52757, 52758, 52759, 52760, 52762, 52763, 52764, 52765, 52766, 52767, 52770, 52771, 52773, 52774, 52775, 52777, 52778, 52779, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52780, 52781, 52782, 52783, 52786, 52788, 52790, 52791, 52792, 52793, 52794, 52795, 52796, 52797, 52798, 52799, 52800, 52801, 52802, 52803, 52804, 52805, 52806, 52807, 52808, 52809, null, null, null, null, null, null, 52810, 52811, 52812, 52813, 52814, 52815, 52816, 52817, 52818, 52819, 52820, 52821, 52822, 52823, 52826, 52827, 52829, 52830, 52834, 52835, 52836, 52837, 52838, 52839, 52842, 52844, null, null, null, null, null, null, 52846, 52847, 52848, 52849, 52850, 52851, 52854, 52855, 52857, 52858, 52859, 52861, 52862, 52863, 52864, 52865, 52866, 52867, 52870, 52872, 52874, 52875, 52876, 52877, 52878, 52879, 52882, 52883, 52885, 52886, 52887, 52889, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52890, 52891, 52892, 52893, 52894, 52895, 52898, 52902, 52903, 52904, 52905, 52906, 52907, 52910, 52911, 52912, 52913, 52914, 52915, 52916, 52917, 52918, 52919, 52920, 52921, 52922, null, null, null, null, null, null, 52923, 52924, 52925, 52926, 52927, 52928, 52930, 52931, 52932, 52933, 52934, 52935, 52936, 52937, 52938, 52939, 52940, 52941, 52942, 52943, 52944, 52945, 52946, 52947, 52948, 52949, null, null, null, null, null, null, 52950, 52951, 52952, 52953, 52954, 52955, 52956, 52957, 52958, 52959, 52960, 52961, 52962, 52963, 52966, 52967, 52969, 52970, 52973, 52974, 52975, 52976, 52977, 52978, 52979, 52982, 52986, 52987, 52988, 52989, 52990, 52991, 44032, 44033, 44036, 44039, 44040, 44041, 44042, 44048, 44049, 44050, 44051, 44052, 44053, 44054, 44055, 44057, 44058, 44059, 44060, 44061, 44064, 44068, 44076, 44077, 44079, 44080, 44081, 44088, 44089, 44092, 44096, 44107, 44109, 44116, 44120, 44124, 44144, 44145, 44148, 44151, 44152, 44154, 44160, 44161, 44163, 44164, 44165, 44166, 44169, 44170, 44171, 44172, 44176, 44180, 44188, 44189, 44191, 44192, 44193, 44200, 44201, 44202, 44204, 44207, 44208, 44216, 44217, 44219, 44220, 44221, 44225, 44228, 44232, 44236, 44245, 44247, 44256, 44257, 44260, 44263, 44264, 44266, 44268, 44271, 44272, 44273, 44275, 44277, 44278, 44284, 44285, 44288, 44292, 44294, 52994, 52995, 52997, 52998, 52999, 53001, 53002, 53003, 53004, 53005, 53006, 53007, 53010, 53012, 53014, 53015, 53016, 53017, 53018, 53019, 53021, 53022, 53023, 53025, 53026, 53027, null, null, null, null, null, null, 53029, 53030, 53031, 53032, 53033, 53034, 53035, 53038, 53042, 53043, 53044, 53045, 53046, 53047, 53049, 53050, 53051, 53052, 53053, 53054, 53055, 53056, 53057, 53058, 53059, 53060, null, null, null, null, null, null, 53061, 53062, 53063, 53064, 53065, 53066, 53067, 53068, 53069, 53070, 53071, 53072, 53073, 53074, 53075, 53078, 53079, 53081, 53082, 53083, 53085, 53086, 53087, 53088, 53089, 53090, 53091, 53094, 53096, 53098, 53099, 53100, 44300, 44301, 44303, 44305, 44312, 44316, 44320, 44329, 44332, 44333, 44340, 44341, 44344, 44348, 44356, 44357, 44359, 44361, 44368, 44372, 44376, 44385, 44387, 44396, 44397, 44400, 44403, 44404, 44405, 44406, 44411, 44412, 44413, 44415, 44417, 44418, 44424, 44425, 44428, 44432, 44444, 44445, 44452, 44471, 44480, 44481, 44484, 44488, 44496, 44497, 44499, 44508, 44512, 44516, 44536, 44537, 44540, 44543, 44544, 44545, 44552, 44553, 44555, 44557, 44564, 44592, 44593, 44596, 44599, 44600, 44602, 44608, 44609, 44611, 44613, 44614, 44618, 44620, 44621, 44622, 44624, 44628, 44630, 44636, 44637, 44639, 44640, 44641, 44645, 44648, 44649, 44652, 44656, 44664, 53101, 53102, 53103, 53106, 53107, 53109, 53110, 53111, 53113, 53114, 53115, 53116, 53117, 53118, 53119, 53121, 53122, 53123, 53124, 53126, 53127, 53128, 53129, 53130, 53131, 53133, null, null, null, null, null, null, 53134, 53135, 53136, 53137, 53138, 53139, 53140, 53141, 53142, 53143, 53144, 53145, 53146, 53147, 53148, 53149, 53150, 53151, 53152, 53154, 53155, 53156, 53157, 53158, 53159, 53161, null, null, null, null, null, null, 53162, 53163, 53164, 53165, 53166, 53167, 53169, 53170, 53171, 53172, 53173, 53174, 53175, 53176, 53177, 53178, 53179, 53180, 53181, 53182, 53183, 53184, 53185, 53186, 53187, 53189, 53190, 53191, 53192, 53193, 53194, 53195, 44665, 44667, 44668, 44669, 44676, 44677, 44684, 44732, 44733, 44734, 44736, 44740, 44748, 44749, 44751, 44752, 44753, 44760, 44761, 44764, 44776, 44779, 44781, 44788, 44792, 44796, 44807, 44808, 44813, 44816, 44844, 44845, 44848, 44850, 44852, 44860, 44861, 44863, 44865, 44866, 44867, 44872, 44873, 44880, 44892, 44893, 44900, 44901, 44921, 44928, 44932, 44936, 44944, 44945, 44949, 44956, 44984, 44985, 44988, 44992, 44999, 45e3, 45001, 45003, 45005, 45006, 45012, 45020, 45032, 45033, 45040, 45041, 45044, 45048, 45056, 45057, 45060, 45068, 45072, 45076, 45084, 45085, 45096, 45124, 45125, 45128, 45130, 45132, 45134, 45139, 45140, 45141, 45143, 45145, 53196, 53197, 53198, 53199, 53200, 53201, 53202, 53203, 53204, 53205, 53206, 53207, 53208, 53209, 53210, 53211, 53212, 53213, 53214, 53215, 53218, 53219, 53221, 53222, 53223, 53225, null, null, null, null, null, null, 53226, 53227, 53228, 53229, 53230, 53231, 53234, 53236, 53238, 53239, 53240, 53241, 53242, 53243, 53245, 53246, 53247, 53249, 53250, 53251, 53253, 53254, 53255, 53256, 53257, 53258, null, null, null, null, null, null, 53259, 53260, 53261, 53262, 53263, 53264, 53266, 53267, 53268, 53269, 53270, 53271, 53273, 53274, 53275, 53276, 53277, 53278, 53279, 53280, 53281, 53282, 53283, 53284, 53285, 53286, 53287, 53288, 53289, 53290, 53291, 53292, 45149, 45180, 45181, 45184, 45188, 45196, 45197, 45199, 45201, 45208, 45209, 45210, 45212, 45215, 45216, 45217, 45218, 45224, 45225, 45227, 45228, 45229, 45230, 45231, 45233, 45235, 45236, 45237, 45240, 45244, 45252, 45253, 45255, 45256, 45257, 45264, 45265, 45268, 45272, 45280, 45285, 45320, 45321, 45323, 45324, 45328, 45330, 45331, 45336, 45337, 45339, 45340, 45341, 45347, 45348, 45349, 45352, 45356, 45364, 45365, 45367, 45368, 45369, 45376, 45377, 45380, 45384, 45392, 45393, 45396, 45397, 45400, 45404, 45408, 45432, 45433, 45436, 45440, 45442, 45448, 45449, 45451, 45453, 45458, 45459, 45460, 45464, 45468, 45480, 45516, 45520, 45524, 45532, 45533, 53294, 53295, 53296, 53297, 53298, 53299, 53302, 53303, 53305, 53306, 53307, 53309, 53310, 53311, 53312, 53313, 53314, 53315, 53318, 53320, 53322, 53323, 53324, 53325, 53326, 53327, null, null, null, null, null, null, 53329, 53330, 53331, 53333, 53334, 53335, 53337, 53338, 53339, 53340, 53341, 53342, 53343, 53345, 53346, 53347, 53348, 53349, 53350, 53351, 53352, 53353, 53354, 53355, 53358, 53359, null, null, null, null, null, null, 53361, 53362, 53363, 53365, 53366, 53367, 53368, 53369, 53370, 53371, 53374, 53375, 53376, 53378, 53379, 53380, 53381, 53382, 53383, 53384, 53385, 53386, 53387, 53388, 53389, 53390, 53391, 53392, 53393, 53394, 53395, 53396, 45535, 45544, 45545, 45548, 45552, 45561, 45563, 45565, 45572, 45573, 45576, 45579, 45580, 45588, 45589, 45591, 45593, 45600, 45620, 45628, 45656, 45660, 45664, 45672, 45673, 45684, 45685, 45692, 45700, 45701, 45705, 45712, 45713, 45716, 45720, 45721, 45722, 45728, 45729, 45731, 45733, 45734, 45738, 45740, 45744, 45748, 45768, 45769, 45772, 45776, 45778, 45784, 45785, 45787, 45789, 45794, 45796, 45797, 45798, 45800, 45803, 45804, 45805, 45806, 45807, 45811, 45812, 45813, 45815, 45816, 45817, 45818, 45819, 45823, 45824, 45825, 45828, 45832, 45840, 45841, 45843, 45844, 45845, 45852, 45908, 45909, 45910, 45912, 45915, 45916, 45918, 45919, 45924, 45925, 53397, 53398, 53399, 53400, 53401, 53402, 53403, 53404, 53405, 53406, 53407, 53408, 53409, 53410, 53411, 53414, 53415, 53417, 53418, 53419, 53421, 53422, 53423, 53424, 53425, 53426, null, null, null, null, null, null, 53427, 53430, 53432, 53434, 53435, 53436, 53437, 53438, 53439, 53442, 53443, 53445, 53446, 53447, 53450, 53451, 53452, 53453, 53454, 53455, 53458, 53462, 53463, 53464, 53465, 53466, null, null, null, null, null, null, 53467, 53470, 53471, 53473, 53474, 53475, 53477, 53478, 53479, 53480, 53481, 53482, 53483, 53486, 53490, 53491, 53492, 53493, 53494, 53495, 53497, 53498, 53499, 53500, 53501, 53502, 53503, 53504, 53505, 53506, 53507, 53508, 45927, 45929, 45931, 45934, 45936, 45937, 45940, 45944, 45952, 45953, 45955, 45956, 45957, 45964, 45968, 45972, 45984, 45985, 45992, 45996, 46020, 46021, 46024, 46027, 46028, 46030, 46032, 46036, 46037, 46039, 46041, 46043, 46045, 46048, 46052, 46056, 46076, 46096, 46104, 46108, 46112, 46120, 46121, 46123, 46132, 46160, 46161, 46164, 46168, 46176, 46177, 46179, 46181, 46188, 46208, 46216, 46237, 46244, 46248, 46252, 46261, 46263, 46265, 46272, 46276, 46280, 46288, 46293, 46300, 46301, 46304, 46307, 46308, 46310, 46316, 46317, 46319, 46321, 46328, 46356, 46357, 46360, 46363, 46364, 46372, 46373, 46375, 46376, 46377, 46378, 46384, 46385, 46388, 46392, 53509, 53510, 53511, 53512, 53513, 53514, 53515, 53516, 53518, 53519, 53520, 53521, 53522, 53523, 53524, 53525, 53526, 53527, 53528, 53529, 53530, 53531, 53532, 53533, 53534, 53535, null, null, null, null, null, null, 53536, 53537, 53538, 53539, 53540, 53541, 53542, 53543, 53544, 53545, 53546, 53547, 53548, 53549, 53550, 53551, 53554, 53555, 53557, 53558, 53559, 53561, 53563, 53564, 53565, 53566, null, null, null, null, null, null, 53567, 53570, 53574, 53575, 53576, 53577, 53578, 53579, 53582, 53583, 53585, 53586, 53587, 53589, 53590, 53591, 53592, 53593, 53594, 53595, 53598, 53600, 53602, 53603, 53604, 53605, 53606, 53607, 53609, 53610, 53611, 53613, 46400, 46401, 46403, 46404, 46405, 46411, 46412, 46413, 46416, 46420, 46428, 46429, 46431, 46432, 46433, 46496, 46497, 46500, 46504, 46506, 46507, 46512, 46513, 46515, 46516, 46517, 46523, 46524, 46525, 46528, 46532, 46540, 46541, 46543, 46544, 46545, 46552, 46572, 46608, 46609, 46612, 46616, 46629, 46636, 46644, 46664, 46692, 46696, 46748, 46749, 46752, 46756, 46763, 46764, 46769, 46804, 46832, 46836, 46840, 46848, 46849, 46853, 46888, 46889, 46892, 46895, 46896, 46904, 46905, 46907, 46916, 46920, 46924, 46932, 46933, 46944, 46948, 46952, 46960, 46961, 46963, 46965, 46972, 46973, 46976, 46980, 46988, 46989, 46991, 46992, 46993, 46994, 46998, 46999, 53614, 53615, 53616, 53617, 53618, 53619, 53620, 53621, 53622, 53623, 53624, 53625, 53626, 53627, 53629, 53630, 53631, 53632, 53633, 53634, 53635, 53637, 53638, 53639, 53641, 53642, null, null, null, null, null, null, 53643, 53644, 53645, 53646, 53647, 53648, 53649, 53650, 53651, 53652, 53653, 53654, 53655, 53656, 53657, 53658, 53659, 53660, 53661, 53662, 53663, 53666, 53667, 53669, 53670, 53671, null, null, null, null, null, null, 53673, 53674, 53675, 53676, 53677, 53678, 53679, 53682, 53684, 53686, 53687, 53688, 53689, 53691, 53693, 53694, 53695, 53697, 53698, 53699, 53700, 53701, 53702, 53703, 53704, 53705, 53706, 53707, 53708, 53709, 53710, 53711, 47e3, 47001, 47004, 47008, 47016, 47017, 47019, 47020, 47021, 47028, 47029, 47032, 47047, 47049, 47084, 47085, 47088, 47092, 47100, 47101, 47103, 47104, 47105, 47111, 47112, 47113, 47116, 47120, 47128, 47129, 47131, 47133, 47140, 47141, 47144, 47148, 47156, 47157, 47159, 47160, 47161, 47168, 47172, 47185, 47187, 47196, 47197, 47200, 47204, 47212, 47213, 47215, 47217, 47224, 47228, 47245, 47272, 47280, 47284, 47288, 47296, 47297, 47299, 47301, 47308, 47312, 47316, 47325, 47327, 47329, 47336, 47337, 47340, 47344, 47352, 47353, 47355, 47357, 47364, 47384, 47392, 47420, 47421, 47424, 47428, 47436, 47439, 47441, 47448, 47449, 47452, 47456, 47464, 47465, 53712, 53713, 53714, 53715, 53716, 53717, 53718, 53719, 53721, 53722, 53723, 53724, 53725, 53726, 53727, 53728, 53729, 53730, 53731, 53732, 53733, 53734, 53735, 53736, 53737, 53738, null, null, null, null, null, null, 53739, 53740, 53741, 53742, 53743, 53744, 53745, 53746, 53747, 53749, 53750, 53751, 53753, 53754, 53755, 53756, 53757, 53758, 53759, 53760, 53761, 53762, 53763, 53764, 53765, 53766, null, null, null, null, null, null, 53768, 53770, 53771, 53772, 53773, 53774, 53775, 53777, 53778, 53779, 53780, 53781, 53782, 53783, 53784, 53785, 53786, 53787, 53788, 53789, 53790, 53791, 53792, 53793, 53794, 53795, 53796, 53797, 53798, 53799, 53800, 53801, 47467, 47469, 47476, 47477, 47480, 47484, 47492, 47493, 47495, 47497, 47498, 47501, 47502, 47532, 47533, 47536, 47540, 47548, 47549, 47551, 47553, 47560, 47561, 47564, 47566, 47567, 47568, 47569, 47570, 47576, 47577, 47579, 47581, 47582, 47585, 47587, 47588, 47589, 47592, 47596, 47604, 47605, 47607, 47608, 47609, 47610, 47616, 47617, 47624, 47637, 47672, 47673, 47676, 47680, 47682, 47688, 47689, 47691, 47693, 47694, 47699, 47700, 47701, 47704, 47708, 47716, 47717, 47719, 47720, 47721, 47728, 47729, 47732, 47736, 47747, 47748, 47749, 47751, 47756, 47784, 47785, 47787, 47788, 47792, 47794, 47800, 47801, 47803, 47805, 47812, 47816, 47832, 47833, 47868, 53802, 53803, 53806, 53807, 53809, 53810, 53811, 53813, 53814, 53815, 53816, 53817, 53818, 53819, 53822, 53824, 53826, 53827, 53828, 53829, 53830, 53831, 53833, 53834, 53835, 53836, null, null, null, null, null, null, 53837, 53838, 53839, 53840, 53841, 53842, 53843, 53844, 53845, 53846, 53847, 53848, 53849, 53850, 53851, 53853, 53854, 53855, 53856, 53857, 53858, 53859, 53861, 53862, 53863, 53864, null, null, null, null, null, null, 53865, 53866, 53867, 53868, 53869, 53870, 53871, 53872, 53873, 53874, 53875, 53876, 53877, 53878, 53879, 53880, 53881, 53882, 53883, 53884, 53885, 53886, 53887, 53890, 53891, 53893, 53894, 53895, 53897, 53898, 53899, 53900, 47872, 47876, 47885, 47887, 47889, 47896, 47900, 47904, 47913, 47915, 47924, 47925, 47926, 47928, 47931, 47932, 47933, 47934, 47940, 47941, 47943, 47945, 47949, 47951, 47952, 47956, 47960, 47969, 47971, 47980, 48008, 48012, 48016, 48036, 48040, 48044, 48052, 48055, 48064, 48068, 48072, 48080, 48083, 48120, 48121, 48124, 48127, 48128, 48130, 48136, 48137, 48139, 48140, 48141, 48143, 48145, 48148, 48149, 48150, 48151, 48152, 48155, 48156, 48157, 48158, 48159, 48164, 48165, 48167, 48169, 48173, 48176, 48177, 48180, 48184, 48192, 48193, 48195, 48196, 48197, 48201, 48204, 48205, 48208, 48221, 48260, 48261, 48264, 48267, 48268, 48270, 48276, 48277, 48279, 53901, 53902, 53903, 53906, 53907, 53908, 53910, 53911, 53912, 53913, 53914, 53915, 53917, 53918, 53919, 53921, 53922, 53923, 53925, 53926, 53927, 53928, 53929, 53930, 53931, 53933, null, null, null, null, null, null, 53934, 53935, 53936, 53938, 53939, 53940, 53941, 53942, 53943, 53946, 53947, 53949, 53950, 53953, 53955, 53956, 53957, 53958, 53959, 53962, 53964, 53965, 53966, 53967, 53968, 53969, null, null, null, null, null, null, 53970, 53971, 53973, 53974, 53975, 53977, 53978, 53979, 53981, 53982, 53983, 53984, 53985, 53986, 53987, 53990, 53991, 53992, 53993, 53994, 53995, 53996, 53997, 53998, 53999, 54002, 54003, 54005, 54006, 54007, 54009, 54010, 48281, 48282, 48288, 48289, 48292, 48295, 48296, 48304, 48305, 48307, 48308, 48309, 48316, 48317, 48320, 48324, 48333, 48335, 48336, 48337, 48341, 48344, 48348, 48372, 48373, 48374, 48376, 48380, 48388, 48389, 48391, 48393, 48400, 48404, 48420, 48428, 48448, 48456, 48457, 48460, 48464, 48472, 48473, 48484, 48488, 48512, 48513, 48516, 48519, 48520, 48521, 48522, 48528, 48529, 48531, 48533, 48537, 48538, 48540, 48548, 48560, 48568, 48596, 48597, 48600, 48604, 48617, 48624, 48628, 48632, 48640, 48643, 48645, 48652, 48653, 48656, 48660, 48668, 48669, 48671, 48708, 48709, 48712, 48716, 48718, 48724, 48725, 48727, 48729, 48730, 48731, 48736, 48737, 48740, 54011, 54012, 54013, 54014, 54015, 54018, 54020, 54022, 54023, 54024, 54025, 54026, 54027, 54031, 54033, 54034, 54035, 54037, 54039, 54040, 54041, 54042, 54043, 54046, 54050, 54051, null, null, null, null, null, null, 54052, 54054, 54055, 54058, 54059, 54061, 54062, 54063, 54065, 54066, 54067, 54068, 54069, 54070, 54071, 54074, 54078, 54079, 54080, 54081, 54082, 54083, 54086, 54087, 54088, 54089, null, null, null, null, null, null, 54090, 54091, 54092, 54093, 54094, 54095, 54096, 54097, 54098, 54099, 54100, 54101, 54102, 54103, 54104, 54105, 54106, 54107, 54108, 54109, 54110, 54111, 54112, 54113, 54114, 54115, 54116, 54117, 54118, 54119, 54120, 54121, 48744, 48746, 48752, 48753, 48755, 48756, 48757, 48763, 48764, 48765, 48768, 48772, 48780, 48781, 48783, 48784, 48785, 48792, 48793, 48808, 48848, 48849, 48852, 48855, 48856, 48864, 48867, 48868, 48869, 48876, 48897, 48904, 48905, 48920, 48921, 48923, 48924, 48925, 48960, 48961, 48964, 48968, 48976, 48977, 48981, 49044, 49072, 49093, 49100, 49101, 49104, 49108, 49116, 49119, 49121, 49212, 49233, 49240, 49244, 49248, 49256, 49257, 49296, 49297, 49300, 49304, 49312, 49313, 49315, 49317, 49324, 49325, 49327, 49328, 49331, 49332, 49333, 49334, 49340, 49341, 49343, 49344, 49345, 49349, 49352, 49353, 49356, 49360, 49368, 49369, 49371, 49372, 49373, 49380, 54122, 54123, 54124, 54125, 54126, 54127, 54128, 54129, 54130, 54131, 54132, 54133, 54134, 54135, 54136, 54137, 54138, 54139, 54142, 54143, 54145, 54146, 54147, 54149, 54150, 54151, null, null, null, null, null, null, 54152, 54153, 54154, 54155, 54158, 54162, 54163, 54164, 54165, 54166, 54167, 54170, 54171, 54173, 54174, 54175, 54177, 54178, 54179, 54180, 54181, 54182, 54183, 54186, 54188, 54190, null, null, null, null, null, null, 54191, 54192, 54193, 54194, 54195, 54197, 54198, 54199, 54201, 54202, 54203, 54205, 54206, 54207, 54208, 54209, 54210, 54211, 54214, 54215, 54218, 54219, 54220, 54221, 54222, 54223, 54225, 54226, 54227, 54228, 54229, 54230, 49381, 49384, 49388, 49396, 49397, 49399, 49401, 49408, 49412, 49416, 49424, 49429, 49436, 49437, 49438, 49439, 49440, 49443, 49444, 49446, 49447, 49452, 49453, 49455, 49456, 49457, 49462, 49464, 49465, 49468, 49472, 49480, 49481, 49483, 49484, 49485, 49492, 49493, 49496, 49500, 49508, 49509, 49511, 49512, 49513, 49520, 49524, 49528, 49541, 49548, 49549, 49550, 49552, 49556, 49558, 49564, 49565, 49567, 49569, 49573, 49576, 49577, 49580, 49584, 49597, 49604, 49608, 49612, 49620, 49623, 49624, 49632, 49636, 49640, 49648, 49649, 49651, 49660, 49661, 49664, 49668, 49676, 49677, 49679, 49681, 49688, 49689, 49692, 49695, 49696, 49704, 49705, 49707, 49709, 54231, 54233, 54234, 54235, 54236, 54237, 54238, 54239, 54240, 54242, 54244, 54245, 54246, 54247, 54248, 54249, 54250, 54251, 54254, 54255, 54257, 54258, 54259, 54261, 54262, 54263, null, null, null, null, null, null, 54264, 54265, 54266, 54267, 54270, 54272, 54274, 54275, 54276, 54277, 54278, 54279, 54281, 54282, 54283, 54284, 54285, 54286, 54287, 54288, 54289, 54290, 54291, 54292, 54293, 54294, null, null, null, null, null, null, 54295, 54296, 54297, 54298, 54299, 54300, 54302, 54303, 54304, 54305, 54306, 54307, 54308, 54309, 54310, 54311, 54312, 54313, 54314, 54315, 54316, 54317, 54318, 54319, 54320, 54321, 54322, 54323, 54324, 54325, 54326, 54327, 49711, 49713, 49714, 49716, 49736, 49744, 49745, 49748, 49752, 49760, 49765, 49772, 49773, 49776, 49780, 49788, 49789, 49791, 49793, 49800, 49801, 49808, 49816, 49819, 49821, 49828, 49829, 49832, 49836, 49837, 49844, 49845, 49847, 49849, 49884, 49885, 49888, 49891, 49892, 49899, 49900, 49901, 49903, 49905, 49910, 49912, 49913, 49915, 49916, 49920, 49928, 49929, 49932, 49933, 49939, 49940, 49941, 49944, 49948, 49956, 49957, 49960, 49961, 49989, 50024, 50025, 50028, 50032, 50034, 50040, 50041, 50044, 50045, 50052, 50056, 50060, 50112, 50136, 50137, 50140, 50143, 50144, 50146, 50152, 50153, 50157, 50164, 50165, 50168, 50184, 50192, 50212, 50220, 50224, 54328, 54329, 54330, 54331, 54332, 54333, 54334, 54335, 54337, 54338, 54339, 54341, 54342, 54343, 54344, 54345, 54346, 54347, 54348, 54349, 54350, 54351, 54352, 54353, 54354, 54355, null, null, null, null, null, null, 54356, 54357, 54358, 54359, 54360, 54361, 54362, 54363, 54365, 54366, 54367, 54369, 54370, 54371, 54373, 54374, 54375, 54376, 54377, 54378, 54379, 54380, 54382, 54384, 54385, 54386, null, null, null, null, null, null, 54387, 54388, 54389, 54390, 54391, 54394, 54395, 54397, 54398, 54401, 54403, 54404, 54405, 54406, 54407, 54410, 54412, 54414, 54415, 54416, 54417, 54418, 54419, 54421, 54422, 54423, 54424, 54425, 54426, 54427, 54428, 54429, 50228, 50236, 50237, 50248, 50276, 50277, 50280, 50284, 50292, 50293, 50297, 50304, 50324, 50332, 50360, 50364, 50409, 50416, 50417, 50420, 50424, 50426, 50431, 50432, 50433, 50444, 50448, 50452, 50460, 50472, 50473, 50476, 50480, 50488, 50489, 50491, 50493, 50500, 50501, 50504, 50505, 50506, 50508, 50509, 50510, 50515, 50516, 50517, 50519, 50520, 50521, 50525, 50526, 50528, 50529, 50532, 50536, 50544, 50545, 50547, 50548, 50549, 50556, 50557, 50560, 50564, 50567, 50572, 50573, 50575, 50577, 50581, 50583, 50584, 50588, 50592, 50601, 50612, 50613, 50616, 50617, 50619, 50620, 50621, 50622, 50628, 50629, 50630, 50631, 50632, 50633, 50634, 50636, 50638, 54430, 54431, 54432, 54433, 54434, 54435, 54436, 54437, 54438, 54439, 54440, 54442, 54443, 54444, 54445, 54446, 54447, 54448, 54449, 54450, 54451, 54452, 54453, 54454, 54455, 54456, null, null, null, null, null, null, 54457, 54458, 54459, 54460, 54461, 54462, 54463, 54464, 54465, 54466, 54467, 54468, 54469, 54470, 54471, 54472, 54473, 54474, 54475, 54477, 54478, 54479, 54481, 54482, 54483, 54485, null, null, null, null, null, null, 54486, 54487, 54488, 54489, 54490, 54491, 54493, 54494, 54496, 54497, 54498, 54499, 54500, 54501, 54502, 54503, 54505, 54506, 54507, 54509, 54510, 54511, 54513, 54514, 54515, 54516, 54517, 54518, 54519, 54521, 54522, 54524, 50640, 50641, 50644, 50648, 50656, 50657, 50659, 50661, 50668, 50669, 50670, 50672, 50676, 50678, 50679, 50684, 50685, 50686, 50687, 50688, 50689, 50693, 50694, 50695, 50696, 50700, 50704, 50712, 50713, 50715, 50716, 50724, 50725, 50728, 50732, 50733, 50734, 50736, 50739, 50740, 50741, 50743, 50745, 50747, 50752, 50753, 50756, 50760, 50768, 50769, 50771, 50772, 50773, 50780, 50781, 50784, 50796, 50799, 50801, 50808, 50809, 50812, 50816, 50824, 50825, 50827, 50829, 50836, 50837, 50840, 50844, 50852, 50853, 50855, 50857, 50864, 50865, 50868, 50872, 50873, 50874, 50880, 50881, 50883, 50885, 50892, 50893, 50896, 50900, 50908, 50909, 50912, 50913, 50920, 54526, 54527, 54528, 54529, 54530, 54531, 54533, 54534, 54535, 54537, 54538, 54539, 54541, 54542, 54543, 54544, 54545, 54546, 54547, 54550, 54552, 54553, 54554, 54555, 54556, 54557, null, null, null, null, null, null, 54558, 54559, 54560, 54561, 54562, 54563, 54564, 54565, 54566, 54567, 54568, 54569, 54570, 54571, 54572, 54573, 54574, 54575, 54576, 54577, 54578, 54579, 54580, 54581, 54582, 54583, null, null, null, null, null, null, 54584, 54585, 54586, 54587, 54590, 54591, 54593, 54594, 54595, 54597, 54598, 54599, 54600, 54601, 54602, 54603, 54606, 54608, 54610, 54611, 54612, 54613, 54614, 54615, 54618, 54619, 54621, 54622, 54623, 54625, 54626, 54627, 50921, 50924, 50928, 50936, 50937, 50941, 50948, 50949, 50952, 50956, 50964, 50965, 50967, 50969, 50976, 50977, 50980, 50984, 50992, 50993, 50995, 50997, 50999, 51004, 51005, 51008, 51012, 51018, 51020, 51021, 51023, 51025, 51026, 51027, 51028, 51029, 51030, 51031, 51032, 51036, 51040, 51048, 51051, 51060, 51061, 51064, 51068, 51069, 51070, 51075, 51076, 51077, 51079, 51080, 51081, 51082, 51086, 51088, 51089, 51092, 51094, 51095, 51096, 51098, 51104, 51105, 51107, 51108, 51109, 51110, 51116, 51117, 51120, 51124, 51132, 51133, 51135, 51136, 51137, 51144, 51145, 51148, 51150, 51152, 51160, 51165, 51172, 51176, 51180, 51200, 51201, 51204, 51208, 51210, 54628, 54630, 54631, 54634, 54636, 54638, 54639, 54640, 54641, 54642, 54643, 54646, 54647, 54649, 54650, 54651, 54653, 54654, 54655, 54656, 54657, 54658, 54659, 54662, 54666, 54667, null, null, null, null, null, null, 54668, 54669, 54670, 54671, 54673, 54674, 54675, 54676, 54677, 54678, 54679, 54680, 54681, 54682, 54683, 54684, 54685, 54686, 54687, 54688, 54689, 54690, 54691, 54692, 54694, 54695, null, null, null, null, null, null, 54696, 54697, 54698, 54699, 54700, 54701, 54702, 54703, 54704, 54705, 54706, 54707, 54708, 54709, 54710, 54711, 54712, 54713, 54714, 54715, 54716, 54717, 54718, 54719, 54720, 54721, 54722, 54723, 54724, 54725, 54726, 54727, 51216, 51217, 51219, 51221, 51222, 51228, 51229, 51232, 51236, 51244, 51245, 51247, 51249, 51256, 51260, 51264, 51272, 51273, 51276, 51277, 51284, 51312, 51313, 51316, 51320, 51322, 51328, 51329, 51331, 51333, 51334, 51335, 51339, 51340, 51341, 51348, 51357, 51359, 51361, 51368, 51388, 51389, 51396, 51400, 51404, 51412, 51413, 51415, 51417, 51424, 51425, 51428, 51445, 51452, 51453, 51456, 51460, 51461, 51462, 51468, 51469, 51471, 51473, 51480, 51500, 51508, 51536, 51537, 51540, 51544, 51552, 51553, 51555, 51564, 51568, 51572, 51580, 51592, 51593, 51596, 51600, 51608, 51609, 51611, 51613, 51648, 51649, 51652, 51655, 51656, 51658, 51664, 51665, 51667, 54730, 54731, 54733, 54734, 54735, 54737, 54739, 54740, 54741, 54742, 54743, 54746, 54748, 54750, 54751, 54752, 54753, 54754, 54755, 54758, 54759, 54761, 54762, 54763, 54765, 54766, null, null, null, null, null, null, 54767, 54768, 54769, 54770, 54771, 54774, 54776, 54778, 54779, 54780, 54781, 54782, 54783, 54786, 54787, 54789, 54790, 54791, 54793, 54794, 54795, 54796, 54797, 54798, 54799, 54802, null, null, null, null, null, null, 54806, 54807, 54808, 54809, 54810, 54811, 54813, 54814, 54815, 54817, 54818, 54819, 54821, 54822, 54823, 54824, 54825, 54826, 54827, 54828, 54830, 54831, 54832, 54833, 54834, 54835, 54836, 54837, 54838, 54839, 54842, 54843, 51669, 51670, 51673, 51674, 51676, 51677, 51680, 51682, 51684, 51687, 51692, 51693, 51695, 51696, 51697, 51704, 51705, 51708, 51712, 51720, 51721, 51723, 51724, 51725, 51732, 51736, 51753, 51788, 51789, 51792, 51796, 51804, 51805, 51807, 51808, 51809, 51816, 51837, 51844, 51864, 51900, 51901, 51904, 51908, 51916, 51917, 51919, 51921, 51923, 51928, 51929, 51936, 51948, 51956, 51976, 51984, 51988, 51992, 52e3, 52001, 52033, 52040, 52041, 52044, 52048, 52056, 52057, 52061, 52068, 52088, 52089, 52124, 52152, 52180, 52196, 52199, 52201, 52236, 52237, 52240, 52244, 52252, 52253, 52257, 52258, 52263, 52264, 52265, 52268, 52270, 52272, 52280, 52281, 52283, 54845, 54846, 54847, 54849, 54850, 54851, 54852, 54854, 54855, 54858, 54860, 54862, 54863, 54864, 54866, 54867, 54870, 54871, 54873, 54874, 54875, 54877, 54878, 54879, 54880, 54881, null, null, null, null, null, null, 54882, 54883, 54884, 54885, 54886, 54888, 54890, 54891, 54892, 54893, 54894, 54895, 54898, 54899, 54901, 54902, 54903, 54904, 54905, 54906, 54907, 54908, 54909, 54910, 54911, 54912, null, null, null, null, null, null, 54913, 54914, 54916, 54918, 54919, 54920, 54921, 54922, 54923, 54926, 54927, 54929, 54930, 54931, 54933, 54934, 54935, 54936, 54937, 54938, 54939, 54940, 54942, 54944, 54946, 54947, 54948, 54949, 54950, 54951, 54953, 54954, 52284, 52285, 52286, 52292, 52293, 52296, 52300, 52308, 52309, 52311, 52312, 52313, 52320, 52324, 52326, 52328, 52336, 52341, 52376, 52377, 52380, 52384, 52392, 52393, 52395, 52396, 52397, 52404, 52405, 52408, 52412, 52420, 52421, 52423, 52425, 52432, 52436, 52452, 52460, 52464, 52481, 52488, 52489, 52492, 52496, 52504, 52505, 52507, 52509, 52516, 52520, 52524, 52537, 52572, 52576, 52580, 52588, 52589, 52591, 52593, 52600, 52616, 52628, 52629, 52632, 52636, 52644, 52645, 52647, 52649, 52656, 52676, 52684, 52688, 52712, 52716, 52720, 52728, 52729, 52731, 52733, 52740, 52744, 52748, 52756, 52761, 52768, 52769, 52772, 52776, 52784, 52785, 52787, 52789, 54955, 54957, 54958, 54959, 54961, 54962, 54963, 54964, 54965, 54966, 54967, 54968, 54970, 54972, 54973, 54974, 54975, 54976, 54977, 54978, 54979, 54982, 54983, 54985, 54986, 54987, null, null, null, null, null, null, 54989, 54990, 54991, 54992, 54994, 54995, 54997, 54998, 55e3, 55002, 55003, 55004, 55005, 55006, 55007, 55009, 55010, 55011, 55013, 55014, 55015, 55017, 55018, 55019, 55020, 55021, null, null, null, null, null, null, 55022, 55023, 55025, 55026, 55027, 55028, 55030, 55031, 55032, 55033, 55034, 55035, 55038, 55039, 55041, 55042, 55043, 55045, 55046, 55047, 55048, 55049, 55050, 55051, 55052, 55053, 55054, 55055, 55056, 55058, 55059, 55060, 52824, 52825, 52828, 52831, 52832, 52833, 52840, 52841, 52843, 52845, 52852, 52853, 52856, 52860, 52868, 52869, 52871, 52873, 52880, 52881, 52884, 52888, 52896, 52897, 52899, 52900, 52901, 52908, 52909, 52929, 52964, 52965, 52968, 52971, 52972, 52980, 52981, 52983, 52984, 52985, 52992, 52993, 52996, 53e3, 53008, 53009, 53011, 53013, 53020, 53024, 53028, 53036, 53037, 53039, 53040, 53041, 53048, 53076, 53077, 53080, 53084, 53092, 53093, 53095, 53097, 53104, 53105, 53108, 53112, 53120, 53125, 53132, 53153, 53160, 53168, 53188, 53216, 53217, 53220, 53224, 53232, 53233, 53235, 53237, 53244, 53248, 53252, 53265, 53272, 53293, 53300, 53301, 53304, 53308, 55061, 55062, 55063, 55066, 55067, 55069, 55070, 55071, 55073, 55074, 55075, 55076, 55077, 55078, 55079, 55082, 55084, 55086, 55087, 55088, 55089, 55090, 55091, 55094, 55095, 55097, null, null, null, null, null, null, 55098, 55099, 55101, 55102, 55103, 55104, 55105, 55106, 55107, 55109, 55110, 55112, 55114, 55115, 55116, 55117, 55118, 55119, 55122, 55123, 55125, 55130, 55131, 55132, 55133, 55134, null, null, null, null, null, null, 55135, 55138, 55140, 55142, 55143, 55144, 55146, 55147, 55149, 55150, 55151, 55153, 55154, 55155, 55157, 55158, 55159, 55160, 55161, 55162, 55163, 55166, 55167, 55168, 55170, 55171, 55172, 55173, 55174, 55175, 55178, 55179, 53316, 53317, 53319, 53321, 53328, 53332, 53336, 53344, 53356, 53357, 53360, 53364, 53372, 53373, 53377, 53412, 53413, 53416, 53420, 53428, 53429, 53431, 53433, 53440, 53441, 53444, 53448, 53449, 53456, 53457, 53459, 53460, 53461, 53468, 53469, 53472, 53476, 53484, 53485, 53487, 53488, 53489, 53496, 53517, 53552, 53553, 53556, 53560, 53562, 53568, 53569, 53571, 53572, 53573, 53580, 53581, 53584, 53588, 53596, 53597, 53599, 53601, 53608, 53612, 53628, 53636, 53640, 53664, 53665, 53668, 53672, 53680, 53681, 53683, 53685, 53690, 53692, 53696, 53720, 53748, 53752, 53767, 53769, 53776, 53804, 53805, 53808, 53812, 53820, 53821, 53823, 53825, 53832, 53852, 55181, 55182, 55183, 55185, 55186, 55187, 55188, 55189, 55190, 55191, 55194, 55196, 55198, 55199, 55200, 55201, 55202, 55203, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 53860, 53888, 53889, 53892, 53896, 53904, 53905, 53909, 53916, 53920, 53924, 53932, 53937, 53944, 53945, 53948, 53951, 53952, 53954, 53960, 53961, 53963, 53972, 53976, 53980, 53988, 53989, 54e3, 54001, 54004, 54008, 54016, 54017, 54019, 54021, 54028, 54029, 54030, 54032, 54036, 54038, 54044, 54045, 54047, 54048, 54049, 54053, 54056, 54057, 54060, 54064, 54072, 54073, 54075, 54076, 54077, 54084, 54085, 54140, 54141, 54144, 54148, 54156, 54157, 54159, 54160, 54161, 54168, 54169, 54172, 54176, 54184, 54185, 54187, 54189, 54196, 54200, 54204, 54212, 54213, 54216, 54217, 54224, 54232, 54241, 54243, 54252, 54253, 54256, 54260, 54268, 54269, 54271, 54273, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 54280, 54301, 54336, 54340, 54364, 54368, 54372, 54381, 54383, 54392, 54393, 54396, 54399, 54400, 54402, 54408, 54409, 54411, 54413, 54420, 54441, 54476, 54480, 54484, 54492, 54495, 54504, 54508, 54512, 54520, 54523, 54525, 54532, 54536, 54540, 54548, 54549, 54551, 54588, 54589, 54592, 54596, 54604, 54605, 54607, 54609, 54616, 54617, 54620, 54624, 54629, 54632, 54633, 54635, 54637, 54644, 54645, 54648, 54652, 54660, 54661, 54663, 54664, 54665, 54672, 54693, 54728, 54729, 54732, 54736, 54738, 54744, 54745, 54747, 54749, 54756, 54757, 54760, 54764, 54772, 54773, 54775, 54777, 54784, 54785, 54788, 54792, 54800, 54801, 54803, 54804, 54805, 54812, 54816, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 54820, 54829, 54840, 54841, 54844, 54848, 54853, 54856, 54857, 54859, 54861, 54865, 54868, 54869, 54872, 54876, 54887, 54889, 54896, 54897, 54900, 54915, 54917, 54924, 54925, 54928, 54932, 54941, 54943, 54945, 54952, 54956, 54960, 54969, 54971, 54980, 54981, 54984, 54988, 54993, 54996, 54999, 55001, 55008, 55012, 55016, 55024, 55029, 55036, 55037, 55040, 55044, 55057, 55064, 55065, 55068, 55072, 55080, 55081, 55083, 55085, 55092, 55093, 55096, 55100, 55108, 55111, 55113, 55120, 55121, 55124, 55126, 55127, 55128, 55129, 55136, 55137, 55139, 55141, 55145, 55148, 55152, 55156, 55164, 55165, 55169, 55176, 55177, 55180, 55184, 55192, 55193, 55195, 55197, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20285, 20339, 20551, 20729, 21152, 21487, 21621, 21733, 22025, 23233, 23478, 26247, 26550, 26551, 26607, 27468, 29634, 30146, 31292, 33499, 33540, 34903, 34952, 35382, 36040, 36303, 36603, 36838, 39381, 21051, 21364, 21508, 24682, 24932, 27580, 29647, 33050, 35258, 35282, 38307, 20355, 21002, 22718, 22904, 23014, 24178, 24185, 25031, 25536, 26438, 26604, 26751, 28567, 30286, 30475, 30965, 31240, 31487, 31777, 32925, 33390, 33393, 35563, 38291, 20075, 21917, 26359, 28212, 30883, 31469, 33883, 35088, 34638, 38824, 21208, 22350, 22570, 23884, 24863, 25022, 25121, 25954, 26577, 27204, 28187, 29976, 30131, 30435, 30640, 32058, 37039, 37969, 37970, 40853, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21283, 23724, 30002, 32987, 37440, 38296, 21083, 22536, 23004, 23713, 23831, 24247, 24378, 24394, 24951, 27743, 30074, 30086, 31968, 32115, 32177, 32652, 33108, 33313, 34193, 35137, 35611, 37628, 38477, 40007, 20171, 20215, 20491, 20977, 22607, 24887, 24894, 24936, 25913, 27114, 28433, 30117, 30342, 30422, 31623, 33445, 33995, 63744, 37799, 38283, 21888, 23458, 22353, 63745, 31923, 32697, 37301, 20520, 21435, 23621, 24040, 25298, 25454, 25818, 25831, 28192, 28844, 31067, 36317, 36382, 63746, 36989, 37445, 37624, 20094, 20214, 20581, 24062, 24314, 24838, 26967, 33137, 34388, 36423, 37749, 39467, 20062, 20625, 26480, 26688, 20745, 21133, 21138, 27298, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 30652, 37392, 40660, 21163, 24623, 36850, 20552, 25001, 25581, 25802, 26684, 27268, 28608, 33160, 35233, 38548, 22533, 29309, 29356, 29956, 32121, 32365, 32937, 35211, 35700, 36963, 40273, 25225, 27770, 28500, 32080, 32570, 35363, 20860, 24906, 31645, 35609, 37463, 37772, 20140, 20435, 20510, 20670, 20742, 21185, 21197, 21375, 22384, 22659, 24218, 24465, 24950, 25004, 25806, 25964, 26223, 26299, 26356, 26775, 28039, 28805, 28913, 29855, 29861, 29898, 30169, 30828, 30956, 31455, 31478, 32069, 32147, 32789, 32831, 33051, 33686, 35686, 36629, 36885, 37857, 38915, 38968, 39514, 39912, 20418, 21843, 22586, 22865, 23395, 23622, 24760, 25106, 26690, 26800, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26856, 28330, 30028, 30328, 30926, 31293, 31995, 32363, 32380, 35336, 35489, 35903, 38542, 40388, 21476, 21481, 21578, 21617, 22266, 22993, 23396, 23611, 24235, 25335, 25911, 25925, 25970, 26272, 26543, 27073, 27837, 30204, 30352, 30590, 31295, 32660, 32771, 32929, 33167, 33510, 33533, 33776, 34241, 34865, 34996, 35493, 63747, 36764, 37678, 38599, 39015, 39640, 40723, 21741, 26011, 26354, 26767, 31296, 35895, 40288, 22256, 22372, 23825, 26118, 26801, 26829, 28414, 29736, 34974, 39908, 27752, 63748, 39592, 20379, 20844, 20849, 21151, 23380, 24037, 24656, 24685, 25329, 25511, 25915, 29657, 31354, 34467, 36002, 38799, 20018, 23521, 25096, 26524, 29916, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31185, 33747, 35463, 35506, 36328, 36942, 37707, 38982, 24275, 27112, 34303, 37101, 63749, 20896, 23448, 23532, 24931, 26874, 27454, 28748, 29743, 29912, 31649, 32592, 33733, 35264, 36011, 38364, 39208, 21038, 24669, 25324, 36866, 20362, 20809, 21281, 22745, 24291, 26336, 27960, 28826, 29378, 29654, 31568, 33009, 37979, 21350, 25499, 32619, 20054, 20608, 22602, 22750, 24618, 24871, 25296, 27088, 39745, 23439, 32024, 32945, 36703, 20132, 20689, 21676, 21932, 23308, 23968, 24039, 25898, 25934, 26657, 27211, 29409, 30350, 30703, 32094, 32761, 33184, 34126, 34527, 36611, 36686, 37066, 39171, 39509, 39851, 19992, 20037, 20061, 20167, 20465, 20855, 21246, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21312, 21475, 21477, 21646, 22036, 22389, 22434, 23495, 23943, 24272, 25084, 25304, 25937, 26552, 26601, 27083, 27472, 27590, 27628, 27714, 28317, 28792, 29399, 29590, 29699, 30655, 30697, 31350, 32127, 32777, 33276, 33285, 33290, 33503, 34914, 35635, 36092, 36544, 36881, 37041, 37476, 37558, 39378, 39493, 40169, 40407, 40860, 22283, 23616, 33738, 38816, 38827, 40628, 21531, 31384, 32676, 35033, 36557, 37089, 22528, 23624, 25496, 31391, 23470, 24339, 31353, 31406, 33422, 36524, 20518, 21048, 21240, 21367, 22280, 25331, 25458, 27402, 28099, 30519, 21413, 29527, 34152, 36470, 38357, 26426, 27331, 28528, 35437, 36556, 39243, 63750, 26231, 27512, 36020, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 39740, 63751, 21483, 22317, 22862, 25542, 27131, 29674, 30789, 31418, 31429, 31998, 33909, 35215, 36211, 36917, 38312, 21243, 22343, 30023, 31584, 33740, 37406, 63752, 27224, 20811, 21067, 21127, 25119, 26840, 26997, 38553, 20677, 21156, 21220, 25027, 26020, 26681, 27135, 29822, 31563, 33465, 33771, 35250, 35641, 36817, 39241, 63753, 20170, 22935, 25810, 26129, 27278, 29748, 31105, 31165, 33449, 34942, 34943, 35167, 63754, 37670, 20235, 21450, 24613, 25201, 27762, 32026, 32102, 20120, 20834, 30684, 32943, 20225, 20238, 20854, 20864, 21980, 22120, 22331, 22522, 22524, 22804, 22855, 22931, 23492, 23696, 23822, 24049, 24190, 24524, 25216, 26071, 26083, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26398, 26399, 26462, 26827, 26820, 27231, 27450, 27683, 27773, 27778, 28103, 29592, 29734, 29738, 29826, 29859, 30072, 30079, 30849, 30959, 31041, 31047, 31048, 31098, 31637, 32e3, 32186, 32648, 32774, 32813, 32908, 35352, 35663, 35912, 36215, 37665, 37668, 39138, 39249, 39438, 39439, 39525, 40594, 32202, 20342, 21513, 25326, 26708, 37329, 21931, 20794, 63755, 63756, 23068, 25062, 63757, 25295, 25343, 63758, 63759, 63760, 63761, 63762, 63763, 37027, 63764, 63765, 63766, 63767, 63768, 35582, 63769, 63770, 63771, 63772, 26262, 63773, 29014, 63774, 63775, 38627, 63776, 25423, 25466, 21335, 63777, 26511, 26976, 28275, 63778, 30007, 63779, 63780, 63781, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32013, 63782, 63783, 34930, 22218, 23064, 63784, 63785, 63786, 63787, 63788, 20035, 63789, 20839, 22856, 26608, 32784, 63790, 22899, 24180, 25754, 31178, 24565, 24684, 25288, 25467, 23527, 23511, 21162, 63791, 22900, 24361, 24594, 63792, 63793, 63794, 29785, 63795, 63796, 63797, 63798, 63799, 63800, 39377, 63801, 63802, 63803, 63804, 63805, 63806, 63807, 63808, 63809, 63810, 63811, 28611, 63812, 63813, 33215, 36786, 24817, 63814, 63815, 33126, 63816, 63817, 23615, 63818, 63819, 63820, 63821, 63822, 63823, 63824, 63825, 23273, 35365, 26491, 32016, 63826, 63827, 63828, 63829, 63830, 63831, 33021, 63832, 63833, 23612, 27877, 21311, 28346, 22810, 33590, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20025, 20150, 20294, 21934, 22296, 22727, 24406, 26039, 26086, 27264, 27573, 28237, 30701, 31471, 31774, 32222, 34507, 34962, 37170, 37723, 25787, 28606, 29562, 30136, 36948, 21846, 22349, 25018, 25812, 26311, 28129, 28251, 28525, 28601, 30192, 32835, 33213, 34113, 35203, 35527, 35674, 37663, 27795, 30035, 31572, 36367, 36957, 21776, 22530, 22616, 24162, 25095, 25758, 26848, 30070, 31958, 34739, 40680, 20195, 22408, 22382, 22823, 23565, 23729, 24118, 24453, 25140, 25825, 29619, 33274, 34955, 36024, 38538, 40667, 23429, 24503, 24755, 20498, 20992, 21040, 22294, 22581, 22615, 23566, 23648, 23798, 23947, 24230, 24466, 24764, 25361, 25481, 25623, 26691, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26873, 27330, 28120, 28193, 28372, 28644, 29182, 30428, 30585, 31153, 31291, 33796, 35241, 36077, 36339, 36424, 36867, 36884, 36947, 37117, 37709, 38518, 38876, 27602, 28678, 29272, 29346, 29544, 30563, 31167, 31716, 32411, 35712, 22697, 24775, 25958, 26109, 26302, 27788, 28958, 29129, 35930, 38931, 20077, 31361, 20189, 20908, 20941, 21205, 21516, 24999, 26481, 26704, 26847, 27934, 28540, 30140, 30643, 31461, 33012, 33891, 37509, 20828, 26007, 26460, 26515, 30168, 31431, 33651, 63834, 35910, 36887, 38957, 23663, 33216, 33434, 36929, 36975, 37389, 24471, 23965, 27225, 29128, 30331, 31561, 34276, 35588, 37159, 39472, 21895, 25078, 63835, 30313, 32645, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 34367, 34746, 35064, 37007, 63836, 27931, 28889, 29662, 32097, 33853, 63837, 37226, 39409, 63838, 20098, 21365, 27396, 27410, 28734, 29211, 34349, 40478, 21068, 36771, 23888, 25829, 25900, 27414, 28651, 31811, 32412, 34253, 35172, 35261, 25289, 33240, 34847, 24266, 26391, 28010, 29436, 29701, 29807, 34690, 37086, 20358, 23821, 24480, 33802, 20919, 25504, 30053, 20142, 20486, 20841, 20937, 26753, 27153, 31918, 31921, 31975, 33391, 35538, 36635, 37327, 20406, 20791, 21237, 21570, 24300, 24942, 25150, 26053, 27354, 28670, 31018, 34268, 34851, 38317, 39522, 39530, 40599, 40654, 21147, 26310, 27511, 28701, 31019, 36706, 38722, 24976, 25088, 25891, 28451, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 29001, 29833, 32244, 32879, 34030, 36646, 36899, 37706, 20925, 21015, 21155, 27916, 28872, 35010, 24265, 25986, 27566, 28610, 31806, 29557, 20196, 20278, 22265, 63839, 23738, 23994, 24604, 29618, 31533, 32666, 32718, 32838, 36894, 37428, 38646, 38728, 38936, 40801, 20363, 28583, 31150, 37300, 38583, 21214, 63840, 25736, 25796, 27347, 28510, 28696, 29200, 30439, 32769, 34310, 34396, 36335, 36613, 38706, 39791, 40442, 40565, 30860, 31103, 32160, 33737, 37636, 40575, 40595, 35542, 22751, 24324, 26407, 28711, 29903, 31840, 32894, 20769, 28712, 29282, 30922, 36034, 36058, 36084, 38647, 20102, 20698, 23534, 24278, 26009, 29134, 30274, 30637, 32842, 34044, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36988, 39719, 40845, 22744, 23105, 23650, 27155, 28122, 28431, 30267, 32047, 32311, 34078, 35128, 37860, 38475, 21129, 26066, 26611, 27060, 27969, 28316, 28687, 29705, 29792, 30041, 30244, 30827, 35628, 39006, 20845, 25134, 38520, 20374, 20523, 23833, 28138, 32184, 36650, 24459, 24900, 26647, 63841, 38534, 21202, 32907, 20956, 20940, 26974, 31260, 32190, 33777, 38517, 20442, 21033, 21400, 21519, 21774, 23653, 24743, 26446, 26792, 28012, 29313, 29432, 29702, 29827, 63842, 30178, 31852, 32633, 32696, 33673, 35023, 35041, 37324, 37328, 38626, 39881, 21533, 28542, 29136, 29848, 34298, 36522, 38563, 40023, 40607, 26519, 28107, 29747, 33256, 38678, 30764, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31435, 31520, 31890, 25705, 29802, 30194, 30908, 30952, 39340, 39764, 40635, 23518, 24149, 28448, 33180, 33707, 37e3, 19975, 21325, 23081, 24018, 24398, 24930, 25405, 26217, 26364, 28415, 28459, 28771, 30622, 33836, 34067, 34875, 36627, 39237, 39995, 21788, 25273, 26411, 27819, 33545, 35178, 38778, 20129, 22916, 24536, 24537, 26395, 32178, 32596, 33426, 33579, 33725, 36638, 37017, 22475, 22969, 23186, 23504, 26151, 26522, 26757, 27599, 29028, 32629, 36023, 36067, 36993, 39749, 33032, 35978, 38476, 39488, 40613, 23391, 27667, 29467, 30450, 30431, 33804, 20906, 35219, 20813, 20885, 21193, 26825, 27796, 30468, 30496, 32191, 32236, 38754, 40629, 28357, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 34065, 20901, 21517, 21629, 26126, 26269, 26919, 28319, 30399, 30609, 33559, 33986, 34719, 37225, 37528, 40180, 34946, 20398, 20882, 21215, 22982, 24125, 24917, 25720, 25721, 26286, 26576, 27169, 27597, 27611, 29279, 29281, 29761, 30520, 30683, 32791, 33468, 33541, 35584, 35624, 35980, 26408, 27792, 29287, 30446, 30566, 31302, 40361, 27519, 27794, 22818, 26406, 33945, 21359, 22675, 22937, 24287, 25551, 26164, 26483, 28218, 29483, 31447, 33495, 37672, 21209, 24043, 25006, 25035, 25098, 25287, 25771, 26080, 26969, 27494, 27595, 28961, 29687, 30045, 32326, 33310, 33538, 34154, 35491, 36031, 38695, 40289, 22696, 40664, 20497, 21006, 21563, 21839, 25991, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 27766, 32010, 32011, 32862, 34442, 38272, 38639, 21247, 27797, 29289, 21619, 23194, 23614, 23883, 24396, 24494, 26410, 26806, 26979, 28220, 28228, 30473, 31859, 32654, 34183, 35598, 36855, 38753, 40692, 23735, 24758, 24845, 25003, 25935, 26107, 26108, 27665, 27887, 29599, 29641, 32225, 38292, 23494, 34588, 35600, 21085, 21338, 25293, 25615, 25778, 26420, 27192, 27850, 29632, 29854, 31636, 31893, 32283, 33162, 33334, 34180, 36843, 38649, 39361, 20276, 21322, 21453, 21467, 25292, 25644, 25856, 26001, 27075, 27886, 28504, 29677, 30036, 30242, 30436, 30460, 30928, 30971, 31020, 32070, 33324, 34784, 36820, 38930, 39151, 21187, 25300, 25765, 28196, 28497, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 30332, 36299, 37297, 37474, 39662, 39747, 20515, 20621, 22346, 22952, 23592, 24135, 24439, 25151, 25918, 26041, 26049, 26121, 26507, 27036, 28354, 30917, 32033, 32938, 33152, 33323, 33459, 33953, 34444, 35370, 35607, 37030, 38450, 40848, 20493, 20467, 63843, 22521, 24472, 25308, 25490, 26479, 28227, 28953, 30403, 32972, 32986, 35060, 35061, 35097, 36064, 36649, 37197, 38506, 20271, 20336, 24091, 26575, 26658, 30333, 30334, 39748, 24161, 27146, 29033, 29140, 30058, 63844, 32321, 34115, 34281, 39132, 20240, 31567, 32624, 38309, 20961, 24070, 26805, 27710, 27726, 27867, 29359, 31684, 33539, 27861, 29754, 20731, 21128, 22721, 25816, 27287, 29863, 30294, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 30887, 34327, 38370, 38713, 63845, 21342, 24321, 35722, 36776, 36783, 37002, 21029, 30629, 40009, 40712, 19993, 20482, 20853, 23643, 24183, 26142, 26170, 26564, 26821, 28851, 29953, 30149, 31177, 31453, 36647, 39200, 39432, 20445, 22561, 22577, 23542, 26222, 27493, 27921, 28282, 28541, 29668, 29995, 33769, 35036, 35091, 35676, 36628, 20239, 20693, 21264, 21340, 23443, 24489, 26381, 31119, 33145, 33583, 34068, 35079, 35206, 36665, 36667, 39333, 39954, 26412, 20086, 20472, 22857, 23553, 23791, 23792, 25447, 26834, 28925, 29090, 29739, 32299, 34028, 34562, 36898, 37586, 40179, 19981, 20184, 20463, 20613, 21078, 21103, 21542, 21648, 22496, 22827, 23142, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 23386, 23413, 23500, 24220, 63846, 25206, 25975, 26023, 28014, 28325, 29238, 31526, 31807, 32566, 33104, 33105, 33178, 33344, 33433, 33705, 35331, 36e3, 36070, 36091, 36212, 36282, 37096, 37340, 38428, 38468, 39385, 40167, 21271, 20998, 21545, 22132, 22707, 22868, 22894, 24575, 24996, 25198, 26128, 27774, 28954, 30406, 31881, 31966, 32027, 33452, 36033, 38640, 63847, 20315, 24343, 24447, 25282, 23849, 26379, 26842, 30844, 32323, 40300, 19989, 20633, 21269, 21290, 21329, 22915, 23138, 24199, 24754, 24970, 25161, 25209, 26e3, 26503, 27047, 27604, 27606, 27607, 27608, 27832, 63848, 29749, 30202, 30738, 30865, 31189, 31192, 31875, 32203, 32737, 32933, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 33086, 33218, 33778, 34586, 35048, 35513, 35692, 36027, 37145, 38750, 39131, 40763, 22188, 23338, 24428, 25996, 27315, 27567, 27996, 28657, 28693, 29277, 29613, 36007, 36051, 38971, 24977, 27703, 32856, 39425, 20045, 20107, 20123, 20181, 20282, 20284, 20351, 20447, 20735, 21490, 21496, 21766, 21987, 22235, 22763, 22882, 23057, 23531, 23546, 23556, 24051, 24107, 24473, 24605, 25448, 26012, 26031, 26614, 26619, 26797, 27515, 27801, 27863, 28195, 28681, 29509, 30722, 31038, 31040, 31072, 31169, 31721, 32023, 32114, 32902, 33293, 33678, 34001, 34503, 35039, 35408, 35422, 35613, 36060, 36198, 36781, 37034, 39164, 39391, 40605, 21066, 63849, 26388, 63850, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20632, 21034, 23665, 25955, 27733, 29642, 29987, 30109, 31639, 33948, 37240, 38704, 20087, 25746, 27578, 29022, 34217, 19977, 63851, 26441, 26862, 28183, 33439, 34072, 34923, 25591, 28545, 37394, 39087, 19978, 20663, 20687, 20767, 21830, 21930, 22039, 23360, 23577, 23776, 24120, 24202, 24224, 24258, 24819, 26705, 27233, 28248, 29245, 29248, 29376, 30456, 31077, 31665, 32724, 35059, 35316, 35443, 35937, 36062, 38684, 22622, 29885, 36093, 21959, 63852, 31329, 32034, 33394, 29298, 29983, 29989, 63853, 31513, 22661, 22779, 23996, 24207, 24246, 24464, 24661, 25234, 25471, 25933, 26257, 26329, 26360, 26646, 26866, 29312, 29790, 31598, 32110, 32214, 32626, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32997, 33298, 34223, 35199, 35475, 36893, 37604, 40653, 40736, 22805, 22893, 24109, 24796, 26132, 26227, 26512, 27728, 28101, 28511, 30707, 30889, 33990, 37323, 37675, 20185, 20682, 20808, 21892, 23307, 23459, 25159, 25982, 26059, 28210, 29053, 29697, 29764, 29831, 29887, 30316, 31146, 32218, 32341, 32680, 33146, 33203, 33337, 34330, 34796, 35445, 36323, 36984, 37521, 37925, 39245, 39854, 21352, 23633, 26964, 27844, 27945, 28203, 33292, 34203, 35131, 35373, 35498, 38634, 40807, 21089, 26297, 27570, 32406, 34814, 36109, 38275, 38493, 25885, 28041, 29166, 63854, 22478, 22995, 23468, 24615, 24826, 25104, 26143, 26207, 29481, 29689, 30427, 30465, 31596, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32854, 32882, 33125, 35488, 37266, 19990, 21218, 27506, 27927, 31237, 31545, 32048, 63855, 36016, 21484, 22063, 22609, 23477, 23567, 23569, 24034, 25152, 25475, 25620, 26157, 26803, 27836, 28040, 28335, 28703, 28836, 29138, 29990, 30095, 30094, 30233, 31505, 31712, 31787, 32032, 32057, 34092, 34157, 34311, 35380, 36877, 36961, 37045, 37559, 38902, 39479, 20439, 23660, 26463, 28049, 31903, 32396, 35606, 36118, 36895, 23403, 24061, 25613, 33984, 36956, 39137, 29575, 23435, 24730, 26494, 28126, 35359, 35494, 36865, 38924, 21047, 63856, 28753, 30862, 37782, 34928, 37335, 20462, 21463, 22013, 22234, 22402, 22781, 23234, 23432, 23723, 23744, 24101, 24833, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 25101, 25163, 25480, 25628, 25910, 25976, 27193, 27530, 27700, 27929, 28465, 29159, 29417, 29560, 29703, 29874, 30246, 30561, 31168, 31319, 31466, 31929, 32143, 32172, 32353, 32670, 33065, 33585, 33936, 34010, 34282, 34966, 35504, 35728, 36664, 36930, 36995, 37228, 37526, 37561, 38539, 38567, 38568, 38614, 38656, 38920, 39318, 39635, 39706, 21460, 22654, 22809, 23408, 23487, 28113, 28506, 29087, 29729, 29881, 32901, 33789, 24033, 24455, 24490, 24642, 26092, 26642, 26991, 27219, 27529, 27957, 28147, 29667, 30462, 30636, 31565, 32020, 33059, 33308, 33600, 34036, 34147, 35426, 35524, 37255, 37662, 38918, 39348, 25100, 34899, 36848, 37477, 23815, 23847, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 23913, 29791, 33181, 34664, 28629, 25342, 32722, 35126, 35186, 19998, 20056, 20711, 21213, 21319, 25215, 26119, 32361, 34821, 38494, 20365, 21273, 22070, 22987, 23204, 23608, 23630, 23629, 24066, 24337, 24643, 26045, 26159, 26178, 26558, 26612, 29468, 30690, 31034, 32709, 33940, 33997, 35222, 35430, 35433, 35553, 35925, 35962, 22516, 23508, 24335, 24687, 25325, 26893, 27542, 28252, 29060, 31698, 34645, 35672, 36606, 39135, 39166, 20280, 20353, 20449, 21627, 23072, 23480, 24892, 26032, 26216, 29180, 30003, 31070, 32051, 33102, 33251, 33688, 34218, 34254, 34563, 35338, 36523, 36763, 63857, 36805, 22833, 23460, 23526, 24713, 23529, 23563, 24515, 27777, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63858, 28145, 28683, 29978, 33455, 35574, 20160, 21313, 63859, 38617, 27663, 20126, 20420, 20818, 21854, 23077, 23784, 25105, 29273, 33469, 33706, 34558, 34905, 35357, 38463, 38597, 39187, 40201, 40285, 22538, 23731, 23997, 24132, 24801, 24853, 25569, 27138, 28197, 37122, 37716, 38990, 39952, 40823, 23433, 23736, 25353, 26191, 26696, 30524, 38593, 38797, 38996, 39839, 26017, 35585, 36555, 38332, 21813, 23721, 24022, 24245, 26263, 30284, 33780, 38343, 22739, 25276, 29390, 40232, 20208, 22830, 24591, 26171, 27523, 31207, 40230, 21395, 21696, 22467, 23830, 24859, 26326, 28079, 30861, 33406, 38552, 38724, 21380, 25212, 25494, 28082, 32266, 33099, 38989, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 27387, 32588, 40367, 40474, 20063, 20539, 20918, 22812, 24825, 25590, 26928, 29242, 32822, 63860, 37326, 24369, 63861, 63862, 32004, 33509, 33903, 33979, 34277, 36493, 63863, 20335, 63864, 63865, 22756, 23363, 24665, 25562, 25880, 25965, 26264, 63866, 26954, 27171, 27915, 28673, 29036, 30162, 30221, 31155, 31344, 63867, 32650, 63868, 35140, 63869, 35731, 37312, 38525, 63870, 39178, 22276, 24481, 26044, 28417, 30208, 31142, 35486, 39341, 39770, 40812, 20740, 25014, 25233, 27277, 33222, 20547, 22576, 24422, 28937, 35328, 35578, 23420, 34326, 20474, 20796, 22196, 22852, 25513, 28153, 23978, 26989, 20870, 20104, 20313, 63871, 63872, 63873, 22914, 63874, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63875, 27487, 27741, 63876, 29877, 30998, 63877, 33287, 33349, 33593, 36671, 36701, 63878, 39192, 63879, 63880, 63881, 20134, 63882, 22495, 24441, 26131, 63883, 63884, 30123, 32377, 35695, 63885, 36870, 39515, 22181, 22567, 23032, 23071, 23476, 63886, 24310, 63887, 63888, 25424, 25403, 63889, 26941, 27783, 27839, 28046, 28051, 28149, 28436, 63890, 28895, 28982, 29017, 63891, 29123, 29141, 63892, 30799, 30831, 63893, 31605, 32227, 63894, 32303, 63895, 34893, 36575, 63896, 63897, 63898, 37467, 63899, 40182, 63900, 63901, 63902, 24709, 28037, 63903, 29105, 63904, 63905, 38321, 21421, 63906, 63907, 63908, 26579, 63909, 28814, 28976, 29744, 33398, 33490, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63910, 38331, 39653, 40573, 26308, 63911, 29121, 33865, 63912, 63913, 22603, 63914, 63915, 23992, 24433, 63916, 26144, 26254, 27001, 27054, 27704, 27891, 28214, 28481, 28634, 28699, 28719, 29008, 29151, 29552, 63917, 29787, 63918, 29908, 30408, 31310, 32403, 63919, 63920, 33521, 35424, 36814, 63921, 37704, 63922, 38681, 63923, 63924, 20034, 20522, 63925, 21e3, 21473, 26355, 27757, 28618, 29450, 30591, 31330, 33454, 34269, 34306, 63926, 35028, 35427, 35709, 35947, 63927, 37555, 63928, 38675, 38928, 20116, 20237, 20425, 20658, 21320, 21566, 21555, 21978, 22626, 22714, 22887, 23067, 23524, 24735, 63929, 25034, 25942, 26111, 26212, 26791, 27738, 28595, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 28879, 29100, 29522, 31613, 34568, 35492, 39986, 40711, 23627, 27779, 29508, 29577, 37434, 28331, 29797, 30239, 31337, 32277, 34314, 20800, 22725, 25793, 29934, 29973, 30320, 32705, 37013, 38605, 39252, 28198, 29926, 31401, 31402, 33253, 34521, 34680, 35355, 23113, 23436, 23451, 26785, 26880, 28003, 29609, 29715, 29740, 30871, 32233, 32747, 33048, 33109, 33694, 35916, 38446, 38929, 26352, 24448, 26106, 26505, 27754, 29579, 20525, 23043, 27498, 30702, 22806, 23916, 24013, 29477, 30031, 63930, 63931, 20709, 20985, 22575, 22829, 22934, 23002, 23525, 63932, 63933, 23970, 25303, 25622, 25747, 25854, 63934, 26332, 63935, 27208, 63936, 29183, 29796, 63937, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31368, 31407, 32327, 32350, 32768, 33136, 63938, 34799, 35201, 35616, 36953, 63939, 36992, 39250, 24958, 27442, 28020, 32287, 35109, 36785, 20433, 20653, 20887, 21191, 22471, 22665, 23481, 24248, 24898, 27029, 28044, 28263, 28342, 29076, 29794, 29992, 29996, 32883, 33592, 33993, 36362, 37780, 37854, 63940, 20110, 20305, 20598, 20778, 21448, 21451, 21491, 23431, 23507, 23588, 24858, 24962, 26100, 29275, 29591, 29760, 30402, 31056, 31121, 31161, 32006, 32701, 33419, 34261, 34398, 36802, 36935, 37109, 37354, 38533, 38632, 38633, 21206, 24423, 26093, 26161, 26671, 29020, 31286, 37057, 38922, 20113, 63941, 27218, 27550, 28560, 29065, 32792, 33464, 34131, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36939, 38549, 38642, 38907, 34074, 39729, 20112, 29066, 38596, 20803, 21407, 21729, 22291, 22290, 22435, 23195, 23236, 23491, 24616, 24895, 25588, 27781, 27961, 28274, 28304, 29232, 29503, 29783, 33489, 34945, 36677, 36960, 63942, 38498, 39e3, 40219, 26376, 36234, 37470, 20301, 20553, 20702, 21361, 22285, 22996, 23041, 23561, 24944, 26256, 28205, 29234, 29771, 32239, 32963, 33806, 33894, 34111, 34655, 34907, 35096, 35586, 36949, 38859, 39759, 20083, 20369, 20754, 20842, 63943, 21807, 21929, 23418, 23461, 24188, 24189, 24254, 24736, 24799, 24840, 24841, 25540, 25912, 26377, 63944, 26580, 26586, 63945, 26977, 26978, 27833, 27943, 63946, 28216, 63947, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 28641, 29494, 29495, 63948, 29788, 30001, 63949, 30290, 63950, 63951, 32173, 33278, 33848, 35029, 35480, 35547, 35565, 36400, 36418, 36938, 36926, 36986, 37193, 37321, 37742, 63952, 63953, 22537, 63954, 27603, 32905, 32946, 63955, 63956, 20801, 22891, 23609, 63957, 63958, 28516, 29607, 32996, 36103, 63959, 37399, 38287, 63960, 63961, 63962, 63963, 32895, 25102, 28700, 32104, 34701, 63964, 22432, 24681, 24903, 27575, 35518, 37504, 38577, 20057, 21535, 28139, 34093, 38512, 38899, 39150, 25558, 27875, 37009, 20957, 25033, 33210, 40441, 20381, 20506, 20736, 23452, 24847, 25087, 25836, 26885, 27589, 30097, 30691, 32681, 33380, 34191, 34811, 34915, 35516, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 35696, 37291, 20108, 20197, 20234, 63965, 63966, 22839, 23016, 63967, 24050, 24347, 24411, 24609, 63968, 63969, 63970, 63971, 29246, 29669, 63972, 30064, 30157, 63973, 31227, 63974, 32780, 32819, 32900, 33505, 33617, 63975, 63976, 36029, 36019, 36999, 63977, 63978, 39156, 39180, 63979, 63980, 28727, 30410, 32714, 32716, 32764, 35610, 20154, 20161, 20995, 21360, 63981, 21693, 22240, 23035, 23493, 24341, 24525, 28270, 63982, 63983, 32106, 33589, 63984, 34451, 35469, 63985, 38765, 38775, 63986, 63987, 19968, 20314, 20350, 22777, 26085, 28322, 36920, 37808, 39353, 20219, 22764, 22922, 23001, 24641, 63988, 63989, 31252, 63990, 33615, 36035, 20837, 21316, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63991, 63992, 63993, 20173, 21097, 23381, 33471, 20180, 21050, 21672, 22985, 23039, 23376, 23383, 23388, 24675, 24904, 28363, 28825, 29038, 29574, 29943, 30133, 30913, 32043, 32773, 33258, 33576, 34071, 34249, 35566, 36039, 38604, 20316, 21242, 22204, 26027, 26152, 28796, 28856, 29237, 32189, 33421, 37196, 38592, 40306, 23409, 26855, 27544, 28538, 30430, 23697, 26283, 28507, 31668, 31786, 34870, 38620, 19976, 20183, 21280, 22580, 22715, 22767, 22892, 23559, 24115, 24196, 24373, 25484, 26290, 26454, 27167, 27299, 27404, 28479, 29254, 63994, 29520, 29835, 31456, 31911, 33144, 33247, 33255, 33674, 33900, 34083, 34196, 34255, 35037, 36115, 37292, 38263, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 38556, 20877, 21705, 22312, 23472, 25165, 26448, 26685, 26771, 28221, 28371, 28797, 32289, 35009, 36001, 36617, 40779, 40782, 29229, 31631, 35533, 37658, 20295, 20302, 20786, 21632, 22992, 24213, 25269, 26485, 26990, 27159, 27822, 28186, 29401, 29482, 30141, 31672, 32053, 33511, 33785, 33879, 34295, 35419, 36015, 36487, 36889, 37048, 38606, 40799, 21219, 21514, 23265, 23490, 25688, 25973, 28404, 29380, 63995, 30340, 31309, 31515, 31821, 32318, 32735, 33659, 35627, 36042, 36196, 36321, 36447, 36842, 36857, 36969, 37841, 20291, 20346, 20659, 20840, 20856, 21069, 21098, 22625, 22652, 22880, 23560, 23637, 24283, 24731, 25136, 26643, 27583, 27656, 28593, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 29006, 29728, 3e4, 30008, 30033, 30322, 31564, 31627, 31661, 31686, 32399, 35438, 36670, 36681, 37439, 37523, 37666, 37931, 38651, 39002, 39019, 39198, 20999, 25130, 25240, 27993, 30308, 31434, 31680, 32118, 21344, 23742, 24215, 28472, 28857, 31896, 38673, 39822, 40670, 25509, 25722, 34678, 19969, 20117, 20141, 20572, 20597, 21576, 22979, 23450, 24128, 24237, 24311, 24449, 24773, 25402, 25919, 25972, 26060, 26230, 26232, 26622, 26984, 27273, 27491, 27712, 28096, 28136, 28191, 28254, 28702, 28833, 29582, 29693, 30010, 30555, 30855, 31118, 31243, 31357, 31934, 32142, 33351, 35330, 35562, 35998, 37165, 37194, 37336, 37478, 37580, 37664, 38662, 38742, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 38748, 38914, 40718, 21046, 21137, 21884, 22564, 24093, 24351, 24716, 25552, 26799, 28639, 31085, 31532, 33229, 34234, 35069, 35576, 36420, 37261, 38500, 38555, 38717, 38988, 40778, 20430, 20806, 20939, 21161, 22066, 24340, 24427, 25514, 25805, 26089, 26177, 26362, 26361, 26397, 26781, 26839, 27133, 28437, 28526, 29031, 29157, 29226, 29866, 30522, 31062, 31066, 31199, 31264, 31381, 31895, 31967, 32068, 32368, 32903, 34299, 34468, 35412, 35519, 36249, 36481, 36896, 36973, 37347, 38459, 38613, 40165, 26063, 31751, 36275, 37827, 23384, 23562, 21330, 25305, 29469, 20519, 23447, 24478, 24752, 24939, 26837, 28121, 29742, 31278, 32066, 32156, 32305, 33131, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36394, 36405, 37758, 37912, 20304, 22352, 24038, 24231, 25387, 32618, 20027, 20303, 20367, 20570, 23005, 32964, 21610, 21608, 22014, 22863, 23449, 24030, 24282, 26205, 26417, 26609, 26666, 27880, 27954, 28234, 28557, 28855, 29664, 30087, 31820, 32002, 32044, 32162, 33311, 34523, 35387, 35461, 36208, 36490, 36659, 36913, 37198, 37202, 37956, 39376, 31481, 31909, 20426, 20737, 20934, 22472, 23535, 23803, 26201, 27197, 27994, 28310, 28652, 28940, 30063, 31459, 34850, 36897, 36981, 38603, 39423, 33537, 20013, 20210, 34886, 37325, 21373, 27355, 26987, 27713, 33914, 22686, 24974, 26366, 25327, 28893, 29969, 30151, 32338, 33976, 35657, 36104, 20043, 21482, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21675, 22320, 22336, 24535, 25345, 25351, 25711, 25903, 26088, 26234, 26525, 26547, 27490, 27744, 27802, 28460, 30693, 30757, 31049, 31063, 32025, 32930, 33026, 33267, 33437, 33463, 34584, 35468, 63996, 36100, 36286, 36978, 30452, 31257, 31287, 32340, 32887, 21767, 21972, 22645, 25391, 25634, 26185, 26187, 26733, 27035, 27524, 27941, 28337, 29645, 29800, 29857, 30043, 30137, 30433, 30494, 30603, 31206, 32265, 32285, 33275, 34095, 34967, 35386, 36049, 36587, 36784, 36914, 37805, 38499, 38515, 38663, 20356, 21489, 23018, 23241, 24089, 26702, 29894, 30142, 31209, 31378, 33187, 34541, 36074, 36300, 36845, 26015, 26389, 63997, 22519, 28503, 32221, 36655, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 37878, 38598, 24501, 25074, 28548, 19988, 20376, 20511, 21449, 21983, 23919, 24046, 27425, 27492, 30923, 31642, 63998, 36425, 36554, 36974, 25417, 25662, 30528, 31364, 37679, 38015, 40810, 25776, 28591, 29158, 29864, 29914, 31428, 31762, 32386, 31922, 32408, 35738, 36106, 38013, 39184, 39244, 21049, 23519, 25830, 26413, 32046, 20717, 21443, 22649, 24920, 24921, 25082, 26028, 31449, 35730, 35734, 20489, 20513, 21109, 21809, 23100, 24288, 24432, 24884, 25950, 26124, 26166, 26274, 27085, 28356, 28466, 29462, 30241, 31379, 33081, 33369, 33750, 33980, 20661, 22512, 23488, 23528, 24425, 25505, 30758, 32181, 33756, 34081, 37319, 37365, 20874, 26613, 31574, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36012, 20932, 22971, 24765, 34389, 20508, 63999, 21076, 23610, 24957, 25114, 25299, 25842, 26021, 28364, 30240, 33034, 36448, 38495, 38587, 20191, 21315, 21912, 22825, 24029, 25797, 27849, 28154, 29588, 31359, 33307, 34214, 36068, 36368, 36983, 37351, 38369, 38433, 38854, 20984, 21746, 21894, 24505, 25764, 28552, 32180, 36639, 36685, 37941, 20681, 23574, 27838, 28155, 29979, 30651, 31805, 31844, 35449, 35522, 22558, 22974, 24086, 25463, 29266, 30090, 30571, 35548, 36028, 36626, 24307, 26228, 28152, 32893, 33729, 35531, 38737, 39894, 64e3, 21059, 26367, 28053, 28399, 32224, 35558, 36910, 36958, 39636, 21021, 21119, 21736, 24980, 25220, 25307, 26786, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26898, 26970, 27189, 28818, 28966, 30813, 30977, 30990, 31186, 31245, 32918, 33400, 33493, 33609, 34121, 35970, 36229, 37218, 37259, 37294, 20419, 22225, 29165, 30679, 34560, 35320, 23544, 24534, 26449, 37032, 21474, 22618, 23541, 24740, 24961, 25696, 32317, 32880, 34085, 37507, 25774, 20652, 23828, 26368, 22684, 25277, 25512, 26894, 27e3, 27166, 28267, 30394, 31179, 33467, 33833, 35535, 36264, 36861, 37138, 37195, 37276, 37648, 37656, 37786, 38619, 39478, 39949, 19985, 30044, 31069, 31482, 31569, 31689, 32302, 33988, 36441, 36468, 36600, 36880, 26149, 26943, 29763, 20986, 26414, 40668, 20805, 24544, 27798, 34802, 34909, 34935, 24756, 33205, 33795, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36101, 21462, 21561, 22068, 23094, 23601, 28810, 32736, 32858, 33030, 33261, 36259, 37257, 39519, 40434, 20596, 20164, 21408, 24827, 28204, 23652, 20360, 20516, 21988, 23769, 24159, 24677, 26772, 27835, 28100, 29118, 30164, 30196, 30305, 31258, 31305, 32199, 32251, 32622, 33268, 34473, 36636, 38601, 39347, 40786, 21063, 21189, 39149, 35242, 19971, 26578, 28422, 20405, 23522, 26517, 27784, 28024, 29723, 30759, 37341, 37756, 34756, 31204, 31281, 24555, 20182, 21668, 21822, 22702, 22949, 24816, 25171, 25302, 26422, 26965, 33333, 38464, 39345, 39389, 20524, 21331, 21828, 22396, 64001, 25176, 64002, 25826, 26219, 26589, 28609, 28655, 29730, 29752, 35351, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 37944, 21585, 22022, 22374, 24392, 24986, 27470, 28760, 28845, 32187, 35477, 22890, 33067, 25506, 30472, 32829, 36010, 22612, 25645, 27067, 23445, 24081, 28271, 64003, 34153, 20812, 21488, 22826, 24608, 24907, 27526, 27760, 27888, 31518, 32974, 33492, 36294, 37040, 39089, 64004, 25799, 28580, 25745, 25860, 20814, 21520, 22303, 35342, 24927, 26742, 64005, 30171, 31570, 32113, 36890, 22534, 27084, 33151, 35114, 36864, 38969, 20600, 22871, 22956, 25237, 36879, 39722, 24925, 29305, 38358, 22369, 23110, 24052, 25226, 25773, 25850, 26487, 27874, 27966, 29228, 29750, 30772, 32631, 33453, 36315, 38935, 21028, 22338, 26495, 29256, 29923, 36009, 36774, 37393, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 38442, 20843, 21485, 25420, 20329, 21764, 24726, 25943, 27803, 28031, 29260, 29437, 31255, 35207, 35997, 24429, 28558, 28921, 33192, 24846, 20415, 20559, 25153, 29255, 31687, 32232, 32745, 36941, 38829, 39449, 36022, 22378, 24179, 26544, 33805, 35413, 21536, 23318, 24163, 24290, 24330, 25987, 32954, 34109, 38281, 38491, 20296, 21253, 21261, 21263, 21638, 21754, 22275, 24067, 24598, 25243, 25265, 25429, 64006, 27873, 28006, 30129, 30770, 32990, 33071, 33502, 33889, 33970, 34957, 35090, 36875, 37610, 39165, 39825, 24133, 26292, 26333, 28689, 29190, 64007, 20469, 21117, 24426, 24915, 26451, 27161, 28418, 29922, 31080, 34920, 35961, 39111, 39108, 39491, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21697, 31263, 26963, 35575, 35914, 39080, 39342, 24444, 25259, 30130, 30382, 34987, 36991, 38466, 21305, 24380, 24517, 27852, 29644, 30050, 30091, 31558, 33534, 39325, 20047, 36924, 19979, 20309, 21414, 22799, 24264, 26160, 27827, 29781, 33655, 34662, 36032, 36944, 38686, 39957, 22737, 23416, 34384, 35604, 40372, 23506, 24680, 24717, 26097, 27735, 28450, 28579, 28698, 32597, 32752, 38289, 38290, 38480, 38867, 21106, 36676, 20989, 21547, 21688, 21859, 21898, 27323, 28085, 32216, 33382, 37532, 38519, 40569, 21512, 21704, 30418, 34532, 38308, 38356, 38492, 20130, 20233, 23022, 23270, 24055, 24658, 25239, 26477, 26689, 27782, 28207, 32568, 32923, 33322, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 64008, 64009, 38917, 20133, 20565, 21683, 22419, 22874, 23401, 23475, 25032, 26999, 28023, 28707, 34809, 35299, 35442, 35559, 36994, 39405, 39608, 21182, 26680, 20502, 24184, 26447, 33607, 34892, 20139, 21521, 22190, 29670, 37141, 38911, 39177, 39255, 39321, 22099, 22687, 34395, 35377, 25010, 27382, 29563, 36562, 27463, 38570, 39511, 22869, 29184, 36203, 38761, 20436, 23796, 24358, 25080, 26203, 27883, 28843, 29572, 29625, 29694, 30505, 30541, 32067, 32098, 32291, 33335, 34898, 64010, 36066, 37449, 39023, 23377, 31348, 34880, 38913, 23244, 20448, 21332, 22846, 23805, 25406, 28025, 29433, 33029, 33031, 33698, 37583, 38960, 20136, 20804, 21009, 22411, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 24418, 27842, 28366, 28677, 28752, 28847, 29074, 29673, 29801, 33610, 34722, 34913, 36872, 37026, 37795, 39336, 20846, 24407, 24800, 24935, 26291, 34137, 36426, 37295, 38795, 20046, 20114, 21628, 22741, 22778, 22909, 23733, 24359, 25142, 25160, 26122, 26215, 27627, 28009, 28111, 28246, 28408, 28564, 28640, 28649, 28765, 29392, 29733, 29786, 29920, 30355, 31068, 31946, 32286, 32993, 33446, 33899, 33983, 34382, 34399, 34676, 35703, 35946, 37804, 38912, 39013, 24785, 25110, 37239, 23130, 26127, 28151, 28222, 29759, 39746, 24573, 24794, 31503, 21700, 24344, 27742, 27859, 27946, 28888, 32005, 34425, 35340, 40251, 21270, 21644, 23301, 27194, 28779, 30069, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31117, 31166, 33457, 33775, 35441, 35649, 36008, 38772, 64011, 25844, 25899, 30906, 30907, 31339, 20024, 21914, 22864, 23462, 24187, 24739, 25563, 27489, 26213, 26707, 28185, 29029, 29872, 32008, 36996, 39529, 39973, 27963, 28369, 29502, 35905, 38346, 20976, 24140, 24488, 24653, 24822, 24880, 24908, 26179, 26180, 27045, 27841, 28255, 28361, 28514, 29004, 29852, 30343, 31681, 31783, 33618, 34647, 36945, 38541, 40643, 21295, 22238, 24315, 24458, 24674, 24724, 25079, 26214, 26371, 27292, 28142, 28590, 28784, 29546, 32362, 33214, 33588, 34516, 35496, 36036, 21123, 29554, 23446, 27243, 37892, 21742, 22150, 23389, 25928, 25989, 26313, 26783, 28045, 28102, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 29243, 32948, 37237, 39501, 20399, 20505, 21402, 21518, 21564, 21897, 21957, 24127, 24460, 26429, 29030, 29661, 36869, 21211, 21235, 22628, 22734, 28932, 29071, 29179, 34224, 35347, 26248, 34216, 21927, 26244, 29002, 33841, 21321, 21913, 27585, 24409, 24509, 25582, 26249, 28999, 35569, 36637, 40638, 20241, 25658, 28875, 30054, 34407, 24676, 35662, 40440, 20807, 20982, 21256, 27958, 33016, 40657, 26133, 27427, 28824, 30165, 21507, 23673, 32007, 35350, 27424, 27453, 27462, 21560, 24688, 27965, 32725, 33288, 20694, 20958, 21916, 22123, 22221, 23020, 23305, 24076, 24985, 24984, 25137, 26206, 26342, 29081, 29113, 29114, 29351, 31143, 31232, 32690, 35440, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "gb18030": [19970, 19972, 19973, 19974, 19983, 19986, 19991, 19999, 2e4, 20001, 20003, 20006, 20009, 20014, 20015, 20017, 20019, 20021, 20023, 20028, 20032, 20033, 20034, 20036, 20038, 20042, 20049, 20053, 20055, 20058, 20059, 20066, 20067, 20068, 20069, 20071, 20072, 20074, 20075, 20076, 20077, 20078, 20079, 20082, 20084, 20085, 20086, 20087, 20088, 20089, 20090, 20091, 20092, 20093, 20095, 20096, 20097, 20098, 20099, 20100, 20101, 20103, 20106, 20112, 20118, 20119, 20121, 20124, 20125, 20126, 20131, 20138, 20143, 20144, 20145, 20148, 20150, 20151, 20152, 20153, 20156, 20157, 20158, 20168, 20172, 20175, 20176, 20178, 20186, 20187, 20188, 20192, 20194, 20198, 20199, 20201, 20205, 20206, 20207, 20209, 20212, 20216, 20217, 20218, 20220, 20222, 20224, 20226, 20227, 20228, 20229, 20230, 20231, 20232, 20235, 20236, 20242, 20243, 20244, 20245, 20246, 20252, 20253, 20257, 20259, 20264, 20265, 20268, 20269, 20270, 20273, 20275, 20277, 20279, 20281, 20283, 20286, 20287, 20288, 20289, 20290, 20292, 20293, 20295, 20296, 20297, 20298, 20299, 20300, 20306, 20308, 20310, 20321, 20322, 20326, 20328, 20330, 20331, 20333, 20334, 20337, 20338, 20341, 20343, 20344, 20345, 20346, 20349, 20352, 20353, 20354, 20357, 20358, 20359, 20362, 20364, 20366, 20368, 20370, 20371, 20373, 20374, 20376, 20377, 20378, 20380, 20382, 20383, 20385, 20386, 20388, 20395, 20397, 20400, 20401, 20402, 20403, 20404, 20406, 20407, 20408, 20409, 20410, 20411, 20412, 20413, 20414, 20416, 20417, 20418, 20422, 20423, 20424, 20425, 20427, 20428, 20429, 20434, 20435, 20436, 20437, 20438, 20441, 20443, 20448, 20450, 20452, 20453, 20455, 20459, 20460, 20464, 20466, 20468, 20469, 20470, 20471, 20473, 20475, 20476, 20477, 20479, 20480, 20481, 20482, 20483, 20484, 20485, 20486, 20487, 20488, 20489, 20490, 20491, 20494, 20496, 20497, 20499, 20501, 20502, 20503, 20507, 20509, 20510, 20512, 20514, 20515, 20516, 20519, 20523, 20527, 20528, 20529, 20530, 20531, 20532, 20533, 20534, 20535, 20536, 20537, 20539, 20541, 20543, 20544, 20545, 20546, 20548, 20549, 20550, 20553, 20554, 20555, 20557, 20560, 20561, 20562, 20563, 20564, 20566, 20567, 20568, 20569, 20571, 20573, 20574, 20575, 20576, 20577, 20578, 20579, 20580, 20582, 20583, 20584, 20585, 20586, 20587, 20589, 20590, 20591, 20592, 20593, 20594, 20595, 20596, 20597, 20600, 20601, 20602, 20604, 20605, 20609, 20610, 20611, 20612, 20614, 20615, 20617, 20618, 20619, 20620, 20622, 20623, 20624, 20625, 20626, 20627, 20628, 20629, 20630, 20631, 20632, 20633, 20634, 20635, 20636, 20637, 20638, 20639, 20640, 20641, 20642, 20644, 20646, 20650, 20651, 20653, 20654, 20655, 20656, 20657, 20659, 20660, 20661, 20662, 20663, 20664, 20665, 20668, 20669, 20670, 20671, 20672, 20673, 20674, 20675, 20676, 20677, 20678, 20679, 20680, 20681, 20682, 20683, 20684, 20685, 20686, 20688, 20689, 20690, 20691, 20692, 20693, 20695, 20696, 20697, 20699, 20700, 20701, 20702, 20703, 20704, 20705, 20706, 20707, 20708, 20709, 20712, 20713, 20714, 20715, 20719, 20720, 20721, 20722, 20724, 20726, 20727, 20728, 20729, 20730, 20732, 20733, 20734, 20735, 20736, 20737, 20738, 20739, 20740, 20741, 20744, 20745, 20746, 20748, 20749, 20750, 20751, 20752, 20753, 20755, 20756, 20757, 20758, 20759, 20760, 20761, 20762, 20763, 20764, 20765, 20766, 20767, 20768, 20770, 20771, 20772, 20773, 20774, 20775, 20776, 20777, 20778, 20779, 20780, 20781, 20782, 20783, 20784, 20785, 20786, 20787, 20788, 20789, 20790, 20791, 20792, 20793, 20794, 20795, 20796, 20797, 20798, 20802, 20807, 20810, 20812, 20814, 20815, 20816, 20818, 20819, 20823, 20824, 20825, 20827, 20829, 20830, 20831, 20832, 20833, 20835, 20836, 20838, 20839, 20841, 20842, 20847, 20850, 20858, 20862, 20863, 20867, 20868, 20870, 20871, 20874, 20875, 20878, 20879, 20880, 20881, 20883, 20884, 20888, 20890, 20893, 20894, 20895, 20897, 20899, 20902, 20903, 20904, 20905, 20906, 20909, 20910, 20916, 20920, 20921, 20922, 20926, 20927, 20929, 20930, 20931, 20933, 20936, 20938, 20941, 20942, 20944, 20946, 20947, 20948, 20949, 20950, 20951, 20952, 20953, 20954, 20956, 20958, 20959, 20962, 20963, 20965, 20966, 20967, 20968, 20969, 20970, 20972, 20974, 20977, 20978, 20980, 20983, 20990, 20996, 20997, 21001, 21003, 21004, 21007, 21008, 21011, 21012, 21013, 21020, 21022, 21023, 21025, 21026, 21027, 21029, 21030, 21031, 21034, 21036, 21039, 21041, 21042, 21044, 21045, 21052, 21054, 21060, 21061, 21062, 21063, 21064, 21065, 21067, 21070, 21071, 21074, 21075, 21077, 21079, 21080, 21081, 21082, 21083, 21085, 21087, 21088, 21090, 21091, 21092, 21094, 21096, 21099, 21100, 21101, 21102, 21104, 21105, 21107, 21108, 21109, 21110, 21111, 21112, 21113, 21114, 21115, 21116, 21118, 21120, 21123, 21124, 21125, 21126, 21127, 21129, 21130, 21131, 21132, 21133, 21134, 21135, 21137, 21138, 21140, 21141, 21142, 21143, 21144, 21145, 21146, 21148, 21156, 21157, 21158, 21159, 21166, 21167, 21168, 21172, 21173, 21174, 21175, 21176, 21177, 21178, 21179, 21180, 21181, 21184, 21185, 21186, 21188, 21189, 21190, 21192, 21194, 21196, 21197, 21198, 21199, 21201, 21203, 21204, 21205, 21207, 21209, 21210, 21211, 21212, 21213, 21214, 21216, 21217, 21218, 21219, 21221, 21222, 21223, 21224, 21225, 21226, 21227, 21228, 21229, 21230, 21231, 21233, 21234, 21235, 21236, 21237, 21238, 21239, 21240, 21243, 21244, 21245, 21249, 21250, 21251, 21252, 21255, 21257, 21258, 21259, 21260, 21262, 21265, 21266, 21267, 21268, 21272, 21275, 21276, 21278, 21279, 21282, 21284, 21285, 21287, 21288, 21289, 21291, 21292, 21293, 21295, 21296, 21297, 21298, 21299, 21300, 21301, 21302, 21303, 21304, 21308, 21309, 21312, 21314, 21316, 21318, 21323, 21324, 21325, 21328, 21332, 21336, 21337, 21339, 21341, 21349, 21352, 21354, 21356, 21357, 21362, 21366, 21369, 21371, 21372, 21373, 21374, 21376, 21377, 21379, 21383, 21384, 21386, 21390, 21391, 21392, 21393, 21394, 21395, 21396, 21398, 21399, 21401, 21403, 21404, 21406, 21408, 21409, 21412, 21415, 21418, 21419, 21420, 21421, 21423, 21424, 21425, 21426, 21427, 21428, 21429, 21431, 21432, 21433, 21434, 21436, 21437, 21438, 21440, 21443, 21444, 21445, 21446, 21447, 21454, 21455, 21456, 21458, 21459, 21461, 21466, 21468, 21469, 21470, 21473, 21474, 21479, 21492, 21498, 21502, 21503, 21504, 21506, 21509, 21511, 21515, 21524, 21528, 21529, 21530, 21532, 21538, 21540, 21541, 21546, 21552, 21555, 21558, 21559, 21562, 21565, 21567, 21569, 21570, 21572, 21573, 21575, 21577, 21580, 21581, 21582, 21583, 21585, 21594, 21597, 21598, 21599, 21600, 21601, 21603, 21605, 21607, 21609, 21610, 21611, 21612, 21613, 21614, 21615, 21616, 21620, 21625, 21626, 21630, 21631, 21633, 21635, 21637, 21639, 21640, 21641, 21642, 21645, 21649, 21651, 21655, 21656, 21660, 21662, 21663, 21664, 21665, 21666, 21669, 21678, 21680, 21682, 21685, 21686, 21687, 21689, 21690, 21692, 21694, 21699, 21701, 21706, 21707, 21718, 21720, 21723, 21728, 21729, 21730, 21731, 21732, 21739, 21740, 21743, 21744, 21745, 21748, 21749, 21750, 21751, 21752, 21753, 21755, 21758, 21760, 21762, 21763, 21764, 21765, 21768, 21770, 21771, 21772, 21773, 21774, 21778, 21779, 21781, 21782, 21783, 21784, 21785, 21786, 21788, 21789, 21790, 21791, 21793, 21797, 21798, 21800, 21801, 21803, 21805, 21810, 21812, 21813, 21814, 21816, 21817, 21818, 21819, 21821, 21824, 21826, 21829, 21831, 21832, 21835, 21836, 21837, 21838, 21839, 21841, 21842, 21843, 21844, 21847, 21848, 21849, 21850, 21851, 21853, 21854, 21855, 21856, 21858, 21859, 21864, 21865, 21867, 21871, 21872, 21873, 21874, 21875, 21876, 21881, 21882, 21885, 21887, 21893, 21894, 21900, 21901, 21902, 21904, 21906, 21907, 21909, 21910, 21911, 21914, 21915, 21918, 21920, 21921, 21922, 21923, 21924, 21925, 21926, 21928, 21929, 21930, 21931, 21932, 21933, 21934, 21935, 21936, 21938, 21940, 21942, 21944, 21946, 21948, 21951, 21952, 21953, 21954, 21955, 21958, 21959, 21960, 21962, 21963, 21966, 21967, 21968, 21973, 21975, 21976, 21977, 21978, 21979, 21982, 21984, 21986, 21991, 21993, 21997, 21998, 22e3, 22001, 22004, 22006, 22008, 22009, 22010, 22011, 22012, 22015, 22018, 22019, 22020, 22021, 22022, 22023, 22026, 22027, 22029, 22032, 22033, 22034, 22035, 22036, 22037, 22038, 22039, 22041, 22042, 22044, 22045, 22048, 22049, 22050, 22053, 22054, 22056, 22057, 22058, 22059, 22062, 22063, 22064, 22067, 22069, 22071, 22072, 22074, 22076, 22077, 22078, 22080, 22081, 22082, 22083, 22084, 22085, 22086, 22087, 22088, 22089, 22090, 22091, 22095, 22096, 22097, 22098, 22099, 22101, 22102, 22106, 22107, 22109, 22110, 22111, 22112, 22113, 22115, 22117, 22118, 22119, 22125, 22126, 22127, 22128, 22130, 22131, 22132, 22133, 22135, 22136, 22137, 22138, 22141, 22142, 22143, 22144, 22145, 22146, 22147, 22148, 22151, 22152, 22153, 22154, 22155, 22156, 22157, 22160, 22161, 22162, 22164, 22165, 22166, 22167, 22168, 22169, 22170, 22171, 22172, 22173, 22174, 22175, 22176, 22177, 22178, 22180, 22181, 22182, 22183, 22184, 22185, 22186, 22187, 22188, 22189, 22190, 22192, 22193, 22194, 22195, 22196, 22197, 22198, 22200, 22201, 22202, 22203, 22205, 22206, 22207, 22208, 22209, 22210, 22211, 22212, 22213, 22214, 22215, 22216, 22217, 22219, 22220, 22221, 22222, 22223, 22224, 22225, 22226, 22227, 22229, 22230, 22232, 22233, 22236, 22243, 22245, 22246, 22247, 22248, 22249, 22250, 22252, 22254, 22255, 22258, 22259, 22262, 22263, 22264, 22267, 22268, 22272, 22273, 22274, 22277, 22279, 22283, 22284, 22285, 22286, 22287, 22288, 22289, 22290, 22291, 22292, 22293, 22294, 22295, 22296, 22297, 22298, 22299, 22301, 22302, 22304, 22305, 22306, 22308, 22309, 22310, 22311, 22315, 22321, 22322, 22324, 22325, 22326, 22327, 22328, 22332, 22333, 22335, 22337, 22339, 22340, 22341, 22342, 22344, 22345, 22347, 22354, 22355, 22356, 22357, 22358, 22360, 22361, 22370, 22371, 22373, 22375, 22380, 22382, 22384, 22385, 22386, 22388, 22389, 22392, 22393, 22394, 22397, 22398, 22399, 22400, 22401, 22407, 22408, 22409, 22410, 22413, 22414, 22415, 22416, 22417, 22420, 22421, 22422, 22423, 22424, 22425, 22426, 22428, 22429, 22430, 22431, 22437, 22440, 22442, 22444, 22447, 22448, 22449, 22451, 22453, 22454, 22455, 22457, 22458, 22459, 22460, 22461, 22462, 22463, 22464, 22465, 22468, 22469, 22470, 22471, 22472, 22473, 22474, 22476, 22477, 22480, 22481, 22483, 22486, 22487, 22491, 22492, 22494, 22497, 22498, 22499, 22501, 22502, 22503, 22504, 22505, 22506, 22507, 22508, 22510, 22512, 22513, 22514, 22515, 22517, 22518, 22519, 22523, 22524, 22526, 22527, 22529, 22531, 22532, 22533, 22536, 22537, 22538, 22540, 22542, 22543, 22544, 22546, 22547, 22548, 22550, 22551, 22552, 22554, 22555, 22556, 22557, 22559, 22562, 22563, 22565, 22566, 22567, 22568, 22569, 22571, 22572, 22573, 22574, 22575, 22577, 22578, 22579, 22580, 22582, 22583, 22584, 22585, 22586, 22587, 22588, 22589, 22590, 22591, 22592, 22593, 22594, 22595, 22597, 22598, 22599, 22600, 22601, 22602, 22603, 22606, 22607, 22608, 22610, 22611, 22613, 22614, 22615, 22617, 22618, 22619, 22620, 22621, 22623, 22624, 22625, 22626, 22627, 22628, 22630, 22631, 22632, 22633, 22634, 22637, 22638, 22639, 22640, 22641, 22642, 22643, 22644, 22645, 22646, 22647, 22648, 22649, 22650, 22651, 22652, 22653, 22655, 22658, 22660, 22662, 22663, 22664, 22666, 22667, 22668, 22669, 22670, 22671, 22672, 22673, 22676, 22677, 22678, 22679, 22680, 22683, 22684, 22685, 22688, 22689, 22690, 22691, 22692, 22693, 22694, 22695, 22698, 22699, 22700, 22701, 22702, 22703, 22704, 22705, 22706, 22707, 22708, 22709, 22710, 22711, 22712, 22713, 22714, 22715, 22717, 22718, 22719, 22720, 22722, 22723, 22724, 22726, 22727, 22728, 22729, 22730, 22731, 22732, 22733, 22734, 22735, 22736, 22738, 22739, 22740, 22742, 22743, 22744, 22745, 22746, 22747, 22748, 22749, 22750, 22751, 22752, 22753, 22754, 22755, 22757, 22758, 22759, 22760, 22761, 22762, 22765, 22767, 22769, 22770, 22772, 22773, 22775, 22776, 22778, 22779, 22780, 22781, 22782, 22783, 22784, 22785, 22787, 22789, 22790, 22792, 22793, 22794, 22795, 22796, 22798, 22800, 22801, 22802, 22803, 22807, 22808, 22811, 22813, 22814, 22816, 22817, 22818, 22819, 22822, 22824, 22828, 22832, 22834, 22835, 22837, 22838, 22843, 22845, 22846, 22847, 22848, 22851, 22853, 22854, 22858, 22860, 22861, 22864, 22866, 22867, 22873, 22875, 22876, 22877, 22878, 22879, 22881, 22883, 22884, 22886, 22887, 22888, 22889, 22890, 22891, 22892, 22893, 22894, 22895, 22896, 22897, 22898, 22901, 22903, 22906, 22907, 22908, 22910, 22911, 22912, 22917, 22921, 22923, 22924, 22926, 22927, 22928, 22929, 22932, 22933, 22936, 22938, 22939, 22940, 22941, 22943, 22944, 22945, 22946, 22950, 22951, 22956, 22957, 22960, 22961, 22963, 22964, 22965, 22966, 22967, 22968, 22970, 22972, 22973, 22975, 22976, 22977, 22978, 22979, 22980, 22981, 22983, 22984, 22985, 22988, 22989, 22990, 22991, 22997, 22998, 23001, 23003, 23006, 23007, 23008, 23009, 23010, 23012, 23014, 23015, 23017, 23018, 23019, 23021, 23022, 23023, 23024, 23025, 23026, 23027, 23028, 23029, 23030, 23031, 23032, 23034, 23036, 23037, 23038, 23040, 23042, 23050, 23051, 23053, 23054, 23055, 23056, 23058, 23060, 23061, 23062, 23063, 23065, 23066, 23067, 23069, 23070, 23073, 23074, 23076, 23078, 23079, 23080, 23082, 23083, 23084, 23085, 23086, 23087, 23088, 23091, 23093, 23095, 23096, 23097, 23098, 23099, 23101, 23102, 23103, 23105, 23106, 23107, 23108, 23109, 23111, 23112, 23115, 23116, 23117, 23118, 23119, 23120, 23121, 23122, 23123, 23124, 23126, 23127, 23128, 23129, 23131, 23132, 23133, 23134, 23135, 23136, 23137, 23139, 23140, 23141, 23142, 23144, 23145, 23147, 23148, 23149, 23150, 23151, 23152, 23153, 23154, 23155, 23160, 23161, 23163, 23164, 23165, 23166, 23168, 23169, 23170, 23171, 23172, 23173, 23174, 23175, 23176, 23177, 23178, 23179, 23180, 23181, 23182, 23183, 23184, 23185, 23187, 23188, 23189, 23190, 23191, 23192, 23193, 23196, 23197, 23198, 23199, 23200, 23201, 23202, 23203, 23204, 23205, 23206, 23207, 23208, 23209, 23211, 23212, 23213, 23214, 23215, 23216, 23217, 23220, 23222, 23223, 23225, 23226, 23227, 23228, 23229, 23231, 23232, 23235, 23236, 23237, 23238, 23239, 23240, 23242, 23243, 23245, 23246, 23247, 23248, 23249, 23251, 23253, 23255, 23257, 23258, 23259, 23261, 23262, 23263, 23266, 23268, 23269, 23271, 23272, 23274, 23276, 23277, 23278, 23279, 23280, 23282, 23283, 23284, 23285, 23286, 23287, 23288, 23289, 23290, 23291, 23292, 23293, 23294, 23295, 23296, 23297, 23298, 23299, 23300, 23301, 23302, 23303, 23304, 23306, 23307, 23308, 23309, 23310, 23311, 23312, 23313, 23314, 23315, 23316, 23317, 23320, 23321, 23322, 23323, 23324, 23325, 23326, 23327, 23328, 23329, 23330, 23331, 23332, 23333, 23334, 23335, 23336, 23337, 23338, 23339, 23340, 23341, 23342, 23343, 23344, 23345, 23347, 23349, 23350, 23352, 23353, 23354, 23355, 23356, 23357, 23358, 23359, 23361, 23362, 23363, 23364, 23365, 23366, 23367, 23368, 23369, 23370, 23371, 23372, 23373, 23374, 23375, 23378, 23382, 23390, 23392, 23393, 23399, 23400, 23403, 23405, 23406, 23407, 23410, 23412, 23414, 23415, 23416, 23417, 23419, 23420, 23422, 23423, 23426, 23430, 23434, 23437, 23438, 23440, 23441, 23442, 23444, 23446, 23455, 23463, 23464, 23465, 23468, 23469, 23470, 23471, 23473, 23474, 23479, 23482, 23483, 23484, 23488, 23489, 23491, 23496, 23497, 23498, 23499, 23501, 23502, 23503, 23505, 23508, 23509, 23510, 23511, 23512, 23513, 23514, 23515, 23516, 23520, 23522, 23523, 23526, 23527, 23529, 23530, 23531, 23532, 23533, 23535, 23537, 23538, 23539, 23540, 23541, 23542, 23543, 23549, 23550, 23552, 23554, 23555, 23557, 23559, 23560, 23563, 23564, 23565, 23566, 23568, 23570, 23571, 23575, 23577, 23579, 23582, 23583, 23584, 23585, 23587, 23590, 23592, 23593, 23594, 23595, 23597, 23598, 23599, 23600, 23602, 23603, 23605, 23606, 23607, 23619, 23620, 23622, 23623, 23628, 23629, 23634, 23635, 23636, 23638, 23639, 23640, 23642, 23643, 23644, 23645, 23647, 23650, 23652, 23655, 23656, 23657, 23658, 23659, 23660, 23661, 23664, 23666, 23667, 23668, 23669, 23670, 23671, 23672, 23675, 23676, 23677, 23678, 23680, 23683, 23684, 23685, 23686, 23687, 23689, 23690, 23691, 23694, 23695, 23698, 23699, 23701, 23709, 23710, 23711, 23712, 23713, 23716, 23717, 23718, 23719, 23720, 23722, 23726, 23727, 23728, 23730, 23732, 23734, 23737, 23738, 23739, 23740, 23742, 23744, 23746, 23747, 23749, 23750, 23751, 23752, 23753, 23754, 23756, 23757, 23758, 23759, 23760, 23761, 23763, 23764, 23765, 23766, 23767, 23768, 23770, 23771, 23772, 23773, 23774, 23775, 23776, 23778, 23779, 23783, 23785, 23787, 23788, 23790, 23791, 23793, 23794, 23795, 23796, 23797, 23798, 23799, 23800, 23801, 23802, 23804, 23805, 23806, 23807, 23808, 23809, 23812, 23813, 23816, 23817, 23818, 23819, 23820, 23821, 23823, 23824, 23825, 23826, 23827, 23829, 23831, 23832, 23833, 23834, 23836, 23837, 23839, 23840, 23841, 23842, 23843, 23845, 23848, 23850, 23851, 23852, 23855, 23856, 23857, 23858, 23859, 23861, 23862, 23863, 23864, 23865, 23866, 23867, 23868, 23871, 23872, 23873, 23874, 23875, 23876, 23877, 23878, 23880, 23881, 23885, 23886, 23887, 23888, 23889, 23890, 23891, 23892, 23893, 23894, 23895, 23897, 23898, 23900, 23902, 23903, 23904, 23905, 23906, 23907, 23908, 23909, 23910, 23911, 23912, 23914, 23917, 23918, 23920, 23921, 23922, 23923, 23925, 23926, 23927, 23928, 23929, 23930, 23931, 23932, 23933, 23934, 23935, 23936, 23937, 23939, 23940, 23941, 23942, 23943, 23944, 23945, 23946, 23947, 23948, 23949, 23950, 23951, 23952, 23953, 23954, 23955, 23956, 23957, 23958, 23959, 23960, 23962, 23963, 23964, 23966, 23967, 23968, 23969, 23970, 23971, 23972, 23973, 23974, 23975, 23976, 23977, 23978, 23979, 23980, 23981, 23982, 23983, 23984, 23985, 23986, 23987, 23988, 23989, 23990, 23992, 23993, 23994, 23995, 23996, 23997, 23998, 23999, 24e3, 24001, 24002, 24003, 24004, 24006, 24007, 24008, 24009, 24010, 24011, 24012, 24014, 24015, 24016, 24017, 24018, 24019, 24020, 24021, 24022, 24023, 24024, 24025, 24026, 24028, 24031, 24032, 24035, 24036, 24042, 24044, 24045, 24048, 24053, 24054, 24056, 24057, 24058, 24059, 24060, 24063, 24064, 24068, 24071, 24073, 24074, 24075, 24077, 24078, 24082, 24083, 24087, 24094, 24095, 24096, 24097, 24098, 24099, 24100, 24101, 24104, 24105, 24106, 24107, 24108, 24111, 24112, 24114, 24115, 24116, 24117, 24118, 24121, 24122, 24126, 24127, 24128, 24129, 24131, 24134, 24135, 24136, 24137, 24138, 24139, 24141, 24142, 24143, 24144, 24145, 24146, 24147, 24150, 24151, 24152, 24153, 24154, 24156, 24157, 24159, 24160, 24163, 24164, 24165, 24166, 24167, 24168, 24169, 24170, 24171, 24172, 24173, 24174, 24175, 24176, 24177, 24181, 24183, 24185, 24190, 24193, 24194, 24195, 24197, 24200, 24201, 24204, 24205, 24206, 24210, 24216, 24219, 24221, 24225, 24226, 24227, 24228, 24232, 24233, 24234, 24235, 24236, 24238, 24239, 24240, 24241, 24242, 24244, 24250, 24251, 24252, 24253, 24255, 24256, 24257, 24258, 24259, 24260, 24261, 24262, 24263, 24264, 24267, 24268, 24269, 24270, 24271, 24272, 24276, 24277, 24279, 24280, 24281, 24282, 24284, 24285, 24286, 24287, 24288, 24289, 24290, 24291, 24292, 24293, 24294, 24295, 24297, 24299, 24300, 24301, 24302, 24303, 24304, 24305, 24306, 24307, 24309, 24312, 24313, 24315, 24316, 24317, 24325, 24326, 24327, 24329, 24332, 24333, 24334, 24336, 24338, 24340, 24342, 24345, 24346, 24348, 24349, 24350, 24353, 24354, 24355, 24356, 24360, 24363, 24364, 24366, 24368, 24370, 24371, 24372, 24373, 24374, 24375, 24376, 24379, 24381, 24382, 24383, 24385, 24386, 24387, 24388, 24389, 24390, 24391, 24392, 24393, 24394, 24395, 24396, 24397, 24398, 24399, 24401, 24404, 24409, 24410, 24411, 24412, 24414, 24415, 24416, 24419, 24421, 24423, 24424, 24427, 24430, 24431, 24434, 24436, 24437, 24438, 24440, 24442, 24445, 24446, 24447, 24451, 24454, 24461, 24462, 24463, 24465, 24467, 24468, 24470, 24474, 24475, 24477, 24478, 24479, 24480, 24482, 24483, 24484, 24485, 24486, 24487, 24489, 24491, 24492, 24495, 24496, 24497, 24498, 24499, 24500, 24502, 24504, 24505, 24506, 24507, 24510, 24511, 24512, 24513, 24514, 24519, 24520, 24522, 24523, 24526, 24531, 24532, 24533, 24538, 24539, 24540, 24542, 24543, 24546, 24547, 24549, 24550, 24552, 24553, 24556, 24559, 24560, 24562, 24563, 24564, 24566, 24567, 24569, 24570, 24572, 24583, 24584, 24585, 24587, 24588, 24592, 24593, 24595, 24599, 24600, 24602, 24606, 24607, 24610, 24611, 24612, 24620, 24621, 24622, 24624, 24625, 24626, 24627, 24628, 24630, 24631, 24632, 24633, 24634, 24637, 24638, 24640, 24644, 24645, 24646, 24647, 24648, 24649, 24650, 24652, 24654, 24655, 24657, 24659, 24660, 24662, 24663, 24664, 24667, 24668, 24670, 24671, 24672, 24673, 24677, 24678, 24686, 24689, 24690, 24692, 24693, 24695, 24702, 24704, 24705, 24706, 24709, 24710, 24711, 24712, 24714, 24715, 24718, 24719, 24720, 24721, 24723, 24725, 24727, 24728, 24729, 24732, 24734, 24737, 24738, 24740, 24741, 24743, 24745, 24746, 24750, 24752, 24755, 24757, 24758, 24759, 24761, 24762, 24765, 24766, 24767, 24768, 24769, 24770, 24771, 24772, 24775, 24776, 24777, 24780, 24781, 24782, 24783, 24784, 24786, 24787, 24788, 24790, 24791, 24793, 24795, 24798, 24801, 24802, 24803, 24804, 24805, 24810, 24817, 24818, 24821, 24823, 24824, 24827, 24828, 24829, 24830, 24831, 24834, 24835, 24836, 24837, 24839, 24842, 24843, 24844, 24848, 24849, 24850, 24851, 24852, 24854, 24855, 24856, 24857, 24859, 24860, 24861, 24862, 24865, 24866, 24869, 24872, 24873, 24874, 24876, 24877, 24878, 24879, 24880, 24881, 24882, 24883, 24884, 24885, 24886, 24887, 24888, 24889, 24890, 24891, 24892, 24893, 24894, 24896, 24897, 24898, 24899, 24900, 24901, 24902, 24903, 24905, 24907, 24909, 24911, 24912, 24914, 24915, 24916, 24918, 24919, 24920, 24921, 24922, 24923, 24924, 24926, 24927, 24928, 24929, 24931, 24932, 24933, 24934, 24937, 24938, 24939, 24940, 24941, 24942, 24943, 24945, 24946, 24947, 24948, 24950, 24952, 24953, 24954, 24955, 24956, 24957, 24958, 24959, 24960, 24961, 24962, 24963, 24964, 24965, 24966, 24967, 24968, 24969, 24970, 24972, 24973, 24975, 24976, 24977, 24978, 24979, 24981, 24982, 24983, 24984, 24985, 24986, 24987, 24988, 24990, 24991, 24992, 24993, 24994, 24995, 24996, 24997, 24998, 25002, 25003, 25005, 25006, 25007, 25008, 25009, 25010, 25011, 25012, 25013, 25014, 25016, 25017, 25018, 25019, 25020, 25021, 25023, 25024, 25025, 25027, 25028, 25029, 25030, 25031, 25033, 25036, 25037, 25038, 25039, 25040, 25043, 25045, 25046, 25047, 25048, 25049, 25050, 25051, 25052, 25053, 25054, 25055, 25056, 25057, 25058, 25059, 25060, 25061, 25063, 25064, 25065, 25066, 25067, 25068, 25069, 25070, 25071, 25072, 25073, 25074, 25075, 25076, 25078, 25079, 25080, 25081, 25082, 25083, 25084, 25085, 25086, 25088, 25089, 25090, 25091, 25092, 25093, 25095, 25097, 25107, 25108, 25113, 25116, 25117, 25118, 25120, 25123, 25126, 25127, 25128, 25129, 25131, 25133, 25135, 25136, 25137, 25138, 25141, 25142, 25144, 25145, 25146, 25147, 25148, 25154, 25156, 25157, 25158, 25162, 25167, 25168, 25173, 25174, 25175, 25177, 25178, 25180, 25181, 25182, 25183, 25184, 25185, 25186, 25188, 25189, 25192, 25201, 25202, 25204, 25205, 25207, 25208, 25210, 25211, 25213, 25217, 25218, 25219, 25221, 25222, 25223, 25224, 25227, 25228, 25229, 25230, 25231, 25232, 25236, 25241, 25244, 25245, 25246, 25251, 25254, 25255, 25257, 25258, 25261, 25262, 25263, 25264, 25266, 25267, 25268, 25270, 25271, 25272, 25274, 25278, 25280, 25281, 25283, 25291, 25295, 25297, 25301, 25309, 25310, 25312, 25313, 25316, 25322, 25323, 25328, 25330, 25333, 25336, 25337, 25338, 25339, 25344, 25347, 25348, 25349, 25350, 25354, 25355, 25356, 25357, 25359, 25360, 25362, 25363, 25364, 25365, 25367, 25368, 25369, 25372, 25382, 25383, 25385, 25388, 25389, 25390, 25392, 25393, 25395, 25396, 25397, 25398, 25399, 25400, 25403, 25404, 25406, 25407, 25408, 25409, 25412, 25415, 25416, 25418, 25425, 25426, 25427, 25428, 25430, 25431, 25432, 25433, 25434, 25435, 25436, 25437, 25440, 25444, 25445, 25446, 25448, 25450, 25451, 25452, 25455, 25456, 25458, 25459, 25460, 25461, 25464, 25465, 25468, 25469, 25470, 25471, 25473, 25475, 25476, 25477, 25478, 25483, 25485, 25489, 25491, 25492, 25493, 25495, 25497, 25498, 25499, 25500, 25501, 25502, 25503, 25505, 25508, 25510, 25515, 25519, 25521, 25522, 25525, 25526, 25529, 25531, 25533, 25535, 25536, 25537, 25538, 25539, 25541, 25543, 25544, 25546, 25547, 25548, 25553, 25555, 25556, 25557, 25559, 25560, 25561, 25562, 25563, 25564, 25565, 25567, 25570, 25572, 25573, 25574, 25575, 25576, 25579, 25580, 25582, 25583, 25584, 25585, 25587, 25589, 25591, 25593, 25594, 25595, 25596, 25598, 25603, 25604, 25606, 25607, 25608, 25609, 25610, 25613, 25614, 25617, 25618, 25621, 25622, 25623, 25624, 25625, 25626, 25629, 25631, 25634, 25635, 25636, 25637, 25639, 25640, 25641, 25643, 25646, 25647, 25648, 25649, 25650, 25651, 25653, 25654, 25655, 25656, 25657, 25659, 25660, 25662, 25664, 25666, 25667, 25673, 25675, 25676, 25677, 25678, 25679, 25680, 25681, 25683, 25685, 25686, 25687, 25689, 25690, 25691, 25692, 25693, 25695, 25696, 25697, 25698, 25699, 25700, 25701, 25702, 25704, 25706, 25707, 25708, 25710, 25711, 25712, 25713, 25714, 25715, 25716, 25717, 25718, 25719, 25723, 25724, 25725, 25726, 25727, 25728, 25729, 25731, 25734, 25736, 25737, 25738, 25739, 25740, 25741, 25742, 25743, 25744, 25747, 25748, 25751, 25752, 25754, 25755, 25756, 25757, 25759, 25760, 25761, 25762, 25763, 25765, 25766, 25767, 25768, 25770, 25771, 25775, 25777, 25778, 25779, 25780, 25782, 25785, 25787, 25789, 25790, 25791, 25793, 25795, 25796, 25798, 25799, 25800, 25801, 25802, 25803, 25804, 25807, 25809, 25811, 25812, 25813, 25814, 25817, 25818, 25819, 25820, 25821, 25823, 25824, 25825, 25827, 25829, 25831, 25832, 25833, 25834, 25835, 25836, 25837, 25838, 25839, 25840, 25841, 25842, 25843, 25844, 25845, 25846, 25847, 25848, 25849, 25850, 25851, 25852, 25853, 25854, 25855, 25857, 25858, 25859, 25860, 25861, 25862, 25863, 25864, 25866, 25867, 25868, 25869, 25870, 25871, 25872, 25873, 25875, 25876, 25877, 25878, 25879, 25881, 25882, 25883, 25884, 25885, 25886, 25887, 25888, 25889, 25890, 25891, 25892, 25894, 25895, 25896, 25897, 25898, 25900, 25901, 25904, 25905, 25906, 25907, 25911, 25914, 25916, 25917, 25920, 25921, 25922, 25923, 25924, 25926, 25927, 25930, 25931, 25933, 25934, 25936, 25938, 25939, 25940, 25943, 25944, 25946, 25948, 25951, 25952, 25953, 25956, 25957, 25959, 25960, 25961, 25962, 25965, 25966, 25967, 25969, 25971, 25973, 25974, 25976, 25977, 25978, 25979, 25980, 25981, 25982, 25983, 25984, 25985, 25986, 25987, 25988, 25989, 25990, 25992, 25993, 25994, 25997, 25998, 25999, 26002, 26004, 26005, 26006, 26008, 26010, 26013, 26014, 26016, 26018, 26019, 26022, 26024, 26026, 26028, 26030, 26033, 26034, 26035, 26036, 26037, 26038, 26039, 26040, 26042, 26043, 26046, 26047, 26048, 26050, 26055, 26056, 26057, 26058, 26061, 26064, 26065, 26067, 26068, 26069, 26072, 26073, 26074, 26075, 26076, 26077, 26078, 26079, 26081, 26083, 26084, 26090, 26091, 26098, 26099, 26100, 26101, 26104, 26105, 26107, 26108, 26109, 26110, 26111, 26113, 26116, 26117, 26119, 26120, 26121, 26123, 26125, 26128, 26129, 26130, 26134, 26135, 26136, 26138, 26139, 26140, 26142, 26145, 26146, 26147, 26148, 26150, 26153, 26154, 26155, 26156, 26158, 26160, 26162, 26163, 26167, 26168, 26169, 26170, 26171, 26173, 26175, 26176, 26178, 26180, 26181, 26182, 26183, 26184, 26185, 26186, 26189, 26190, 26192, 26193, 26200, 26201, 26203, 26204, 26205, 26206, 26208, 26210, 26211, 26213, 26215, 26217, 26218, 26219, 26220, 26221, 26225, 26226, 26227, 26229, 26232, 26233, 26235, 26236, 26237, 26239, 26240, 26241, 26243, 26245, 26246, 26248, 26249, 26250, 26251, 26253, 26254, 26255, 26256, 26258, 26259, 26260, 26261, 26264, 26265, 26266, 26267, 26268, 26270, 26271, 26272, 26273, 26274, 26275, 26276, 26277, 26278, 26281, 26282, 26283, 26284, 26285, 26287, 26288, 26289, 26290, 26291, 26293, 26294, 26295, 26296, 26298, 26299, 26300, 26301, 26303, 26304, 26305, 26306, 26307, 26308, 26309, 26310, 26311, 26312, 26313, 26314, 26315, 26316, 26317, 26318, 26319, 26320, 26321, 26322, 26323, 26324, 26325, 26326, 26327, 26328, 26330, 26334, 26335, 26336, 26337, 26338, 26339, 26340, 26341, 26343, 26344, 26346, 26347, 26348, 26349, 26350, 26351, 26353, 26357, 26358, 26360, 26362, 26363, 26365, 26369, 26370, 26371, 26372, 26373, 26374, 26375, 26380, 26382, 26383, 26385, 26386, 26387, 26390, 26392, 26393, 26394, 26396, 26398, 26400, 26401, 26402, 26403, 26404, 26405, 26407, 26409, 26414, 26416, 26418, 26419, 26422, 26423, 26424, 26425, 26427, 26428, 26430, 26431, 26433, 26436, 26437, 26439, 26442, 26443, 26445, 26450, 26452, 26453, 26455, 26456, 26457, 26458, 26459, 26461, 26466, 26467, 26468, 26470, 26471, 26475, 26476, 26478, 26481, 26484, 26486, 26488, 26489, 26490, 26491, 26493, 26496, 26498, 26499, 26501, 26502, 26504, 26506, 26508, 26509, 26510, 26511, 26513, 26514, 26515, 26516, 26518, 26521, 26523, 26527, 26528, 26529, 26532, 26534, 26537, 26540, 26542, 26545, 26546, 26548, 26553, 26554, 26555, 26556, 26557, 26558, 26559, 26560, 26562, 26565, 26566, 26567, 26568, 26569, 26570, 26571, 26572, 26573, 26574, 26581, 26582, 26583, 26587, 26591, 26593, 26595, 26596, 26598, 26599, 26600, 26602, 26603, 26605, 26606, 26610, 26613, 26614, 26615, 26616, 26617, 26618, 26619, 26620, 26622, 26625, 26626, 26627, 26628, 26630, 26637, 26640, 26642, 26644, 26645, 26648, 26649, 26650, 26651, 26652, 26654, 26655, 26656, 26658, 26659, 26660, 26661, 26662, 26663, 26664, 26667, 26668, 26669, 26670, 26671, 26672, 26673, 26676, 26677, 26678, 26682, 26683, 26687, 26695, 26699, 26701, 26703, 26706, 26710, 26711, 26712, 26713, 26714, 26715, 26716, 26717, 26718, 26719, 26730, 26732, 26733, 26734, 26735, 26736, 26737, 26738, 26739, 26741, 26744, 26745, 26746, 26747, 26748, 26749, 26750, 26751, 26752, 26754, 26756, 26759, 26760, 26761, 26762, 26763, 26764, 26765, 26766, 26768, 26769, 26770, 26772, 26773, 26774, 26776, 26777, 26778, 26779, 26780, 26781, 26782, 26783, 26784, 26785, 26787, 26788, 26789, 26793, 26794, 26795, 26796, 26798, 26801, 26802, 26804, 26806, 26807, 26808, 26809, 26810, 26811, 26812, 26813, 26814, 26815, 26817, 26819, 26820, 26821, 26822, 26823, 26824, 26826, 26828, 26830, 26831, 26832, 26833, 26835, 26836, 26838, 26839, 26841, 26843, 26844, 26845, 26846, 26847, 26849, 26850, 26852, 26853, 26854, 26855, 26856, 26857, 26858, 26859, 26860, 26861, 26863, 26866, 26867, 26868, 26870, 26871, 26872, 26875, 26877, 26878, 26879, 26880, 26882, 26883, 26884, 26886, 26887, 26888, 26889, 26890, 26892, 26895, 26897, 26899, 26900, 26901, 26902, 26903, 26904, 26905, 26906, 26907, 26908, 26909, 26910, 26913, 26914, 26915, 26917, 26918, 26919, 26920, 26921, 26922, 26923, 26924, 26926, 26927, 26929, 26930, 26931, 26933, 26934, 26935, 26936, 26938, 26939, 26940, 26942, 26944, 26945, 26947, 26948, 26949, 26950, 26951, 26952, 26953, 26954, 26955, 26956, 26957, 26958, 26959, 26960, 26961, 26962, 26963, 26965, 26966, 26968, 26969, 26971, 26972, 26975, 26977, 26978, 26980, 26981, 26983, 26984, 26985, 26986, 26988, 26989, 26991, 26992, 26994, 26995, 26996, 26997, 26998, 27002, 27003, 27005, 27006, 27007, 27009, 27011, 27013, 27018, 27019, 27020, 27022, 27023, 27024, 27025, 27026, 27027, 27030, 27031, 27033, 27034, 27037, 27038, 27039, 27040, 27041, 27042, 27043, 27044, 27045, 27046, 27049, 27050, 27052, 27054, 27055, 27056, 27058, 27059, 27061, 27062, 27064, 27065, 27066, 27068, 27069, 27070, 27071, 27072, 27074, 27075, 27076, 27077, 27078, 27079, 27080, 27081, 27083, 27085, 27087, 27089, 27090, 27091, 27093, 27094, 27095, 27096, 27097, 27098, 27100, 27101, 27102, 27105, 27106, 27107, 27108, 27109, 27110, 27111, 27112, 27113, 27114, 27115, 27116, 27118, 27119, 27120, 27121, 27123, 27124, 27125, 27126, 27127, 27128, 27129, 27130, 27131, 27132, 27134, 27136, 27137, 27138, 27139, 27140, 27141, 27142, 27143, 27144, 27145, 27147, 27148, 27149, 27150, 27151, 27152, 27153, 27154, 27155, 27156, 27157, 27158, 27161, 27162, 27163, 27164, 27165, 27166, 27168, 27170, 27171, 27172, 27173, 27174, 27175, 27177, 27179, 27180, 27181, 27182, 27184, 27186, 27187, 27188, 27190, 27191, 27192, 27193, 27194, 27195, 27196, 27199, 27200, 27201, 27202, 27203, 27205, 27206, 27208, 27209, 27210, 27211, 27212, 27213, 27214, 27215, 27217, 27218, 27219, 27220, 27221, 27222, 27223, 27226, 27228, 27229, 27230, 27231, 27232, 27234, 27235, 27236, 27238, 27239, 27240, 27241, 27242, 27243, 27244, 27245, 27246, 27247, 27248, 27250, 27251, 27252, 27253, 27254, 27255, 27256, 27258, 27259, 27261, 27262, 27263, 27265, 27266, 27267, 27269, 27270, 27271, 27272, 27273, 27274, 27275, 27276, 27277, 27279, 27282, 27283, 27284, 27285, 27286, 27288, 27289, 27290, 27291, 27292, 27293, 27294, 27295, 27297, 27298, 27299, 27300, 27301, 27302, 27303, 27304, 27306, 27309, 27310, 27311, 27312, 27313, 27314, 27315, 27316, 27317, 27318, 27319, 27320, 27321, 27322, 27323, 27324, 27325, 27326, 27327, 27328, 27329, 27330, 27331, 27332, 27333, 27334, 27335, 27336, 27337, 27338, 27339, 27340, 27341, 27342, 27343, 27344, 27345, 27346, 27347, 27348, 27349, 27350, 27351, 27352, 27353, 27354, 27355, 27356, 27357, 27358, 27359, 27360, 27361, 27362, 27363, 27364, 27365, 27366, 27367, 27368, 27369, 27370, 27371, 27372, 27373, 27374, 27375, 27376, 27377, 27378, 27379, 27380, 27381, 27382, 27383, 27384, 27385, 27386, 27387, 27388, 27389, 27390, 27391, 27392, 27393, 27394, 27395, 27396, 27397, 27398, 27399, 27400, 27401, 27402, 27403, 27404, 27405, 27406, 27407, 27408, 27409, 27410, 27411, 27412, 27413, 27414, 27415, 27416, 27417, 27418, 27419, 27420, 27421, 27422, 27423, 27429, 27430, 27432, 27433, 27434, 27435, 27436, 27437, 27438, 27439, 27440, 27441, 27443, 27444, 27445, 27446, 27448, 27451, 27452, 27453, 27455, 27456, 27457, 27458, 27460, 27461, 27464, 27466, 27467, 27469, 27470, 27471, 27472, 27473, 27474, 27475, 27476, 27477, 27478, 27479, 27480, 27482, 27483, 27484, 27485, 27486, 27487, 27488, 27489, 27496, 27497, 27499, 27500, 27501, 27502, 27503, 27504, 27505, 27506, 27507, 27508, 27509, 27510, 27511, 27512, 27514, 27517, 27518, 27519, 27520, 27525, 27528, 27532, 27534, 27535, 27536, 27537, 27540, 27541, 27543, 27544, 27545, 27548, 27549, 27550, 27551, 27552, 27554, 27555, 27556, 27557, 27558, 27559, 27560, 27561, 27563, 27564, 27565, 27566, 27567, 27568, 27569, 27570, 27574, 27576, 27577, 27578, 27579, 27580, 27581, 27582, 27584, 27587, 27588, 27590, 27591, 27592, 27593, 27594, 27596, 27598, 27600, 27601, 27608, 27610, 27612, 27613, 27614, 27615, 27616, 27618, 27619, 27620, 27621, 27622, 27623, 27624, 27625, 27628, 27629, 27630, 27632, 27633, 27634, 27636, 27638, 27639, 27640, 27642, 27643, 27644, 27646, 27647, 27648, 27649, 27650, 27651, 27652, 27656, 27657, 27658, 27659, 27660, 27662, 27666, 27671, 27676, 27677, 27678, 27680, 27683, 27685, 27691, 27692, 27693, 27697, 27699, 27702, 27703, 27705, 27706, 27707, 27708, 27710, 27711, 27715, 27716, 27717, 27720, 27723, 27724, 27725, 27726, 27727, 27729, 27730, 27731, 27734, 27736, 27737, 27738, 27746, 27747, 27749, 27750, 27751, 27755, 27756, 27757, 27758, 27759, 27761, 27763, 27765, 27767, 27768, 27770, 27771, 27772, 27775, 27776, 27780, 27783, 27786, 27787, 27789, 27790, 27793, 27794, 27797, 27798, 27799, 27800, 27802, 27804, 27805, 27806, 27808, 27810, 27816, 27820, 27823, 27824, 27828, 27829, 27830, 27831, 27834, 27840, 27841, 27842, 27843, 27846, 27847, 27848, 27851, 27853, 27854, 27855, 27857, 27858, 27864, 27865, 27866, 27868, 27869, 27871, 27876, 27878, 27879, 27881, 27884, 27885, 27890, 27892, 27897, 27903, 27904, 27906, 27907, 27909, 27910, 27912, 27913, 27914, 27917, 27919, 27920, 27921, 27923, 27924, 27925, 27926, 27928, 27932, 27933, 27935, 27936, 27937, 27938, 27939, 27940, 27942, 27944, 27945, 27948, 27949, 27951, 27952, 27956, 27958, 27959, 27960, 27962, 27967, 27968, 27970, 27972, 27977, 27980, 27984, 27989, 27990, 27991, 27992, 27995, 27997, 27999, 28001, 28002, 28004, 28005, 28007, 28008, 28011, 28012, 28013, 28016, 28017, 28018, 28019, 28021, 28022, 28025, 28026, 28027, 28029, 28030, 28031, 28032, 28033, 28035, 28036, 28038, 28039, 28042, 28043, 28045, 28047, 28048, 28050, 28054, 28055, 28056, 28057, 28058, 28060, 28066, 28069, 28076, 28077, 28080, 28081, 28083, 28084, 28086, 28087, 28089, 28090, 28091, 28092, 28093, 28094, 28097, 28098, 28099, 28104, 28105, 28106, 28109, 28110, 28111, 28112, 28114, 28115, 28116, 28117, 28119, 28122, 28123, 28124, 28127, 28130, 28131, 28133, 28135, 28136, 28137, 28138, 28141, 28143, 28144, 28146, 28148, 28149, 28150, 28152, 28154, 28157, 28158, 28159, 28160, 28161, 28162, 28163, 28164, 28166, 28167, 28168, 28169, 28171, 28175, 28178, 28179, 28181, 28184, 28185, 28187, 28188, 28190, 28191, 28194, 28198, 28199, 28200, 28202, 28204, 28206, 28208, 28209, 28211, 28213, 28214, 28215, 28217, 28219, 28220, 28221, 28222, 28223, 28224, 28225, 28226, 28229, 28230, 28231, 28232, 28233, 28234, 28235, 28236, 28239, 28240, 28241, 28242, 28245, 28247, 28249, 28250, 28252, 28253, 28254, 28256, 28257, 28258, 28259, 28260, 28261, 28262, 28263, 28264, 28265, 28266, 28268, 28269, 28271, 28272, 28273, 28274, 28275, 28276, 28277, 28278, 28279, 28280, 28281, 28282, 28283, 28284, 28285, 28288, 28289, 28290, 28292, 28295, 28296, 28298, 28299, 28300, 28301, 28302, 28305, 28306, 28307, 28308, 28309, 28310, 28311, 28313, 28314, 28315, 28317, 28318, 28320, 28321, 28323, 28324, 28326, 28328, 28329, 28331, 28332, 28333, 28334, 28336, 28339, 28341, 28344, 28345, 28348, 28350, 28351, 28352, 28355, 28356, 28357, 28358, 28360, 28361, 28362, 28364, 28365, 28366, 28368, 28370, 28374, 28376, 28377, 28379, 28380, 28381, 28387, 28391, 28394, 28395, 28396, 28397, 28398, 28399, 28400, 28401, 28402, 28403, 28405, 28406, 28407, 28408, 28410, 28411, 28412, 28413, 28414, 28415, 28416, 28417, 28419, 28420, 28421, 28423, 28424, 28426, 28427, 28428, 28429, 28430, 28432, 28433, 28434, 28438, 28439, 28440, 28441, 28442, 28443, 28444, 28445, 28446, 28447, 28449, 28450, 28451, 28453, 28454, 28455, 28456, 28460, 28462, 28464, 28466, 28468, 28469, 28471, 28472, 28473, 28474, 28475, 28476, 28477, 28479, 28480, 28481, 28482, 28483, 28484, 28485, 28488, 28489, 28490, 28492, 28494, 28495, 28496, 28497, 28498, 28499, 28500, 28501, 28502, 28503, 28505, 28506, 28507, 28509, 28511, 28512, 28513, 28515, 28516, 28517, 28519, 28520, 28521, 28522, 28523, 28524, 28527, 28528, 28529, 28531, 28533, 28534, 28535, 28537, 28539, 28541, 28542, 28543, 28544, 28545, 28546, 28547, 28549, 28550, 28551, 28554, 28555, 28559, 28560, 28561, 28562, 28563, 28564, 28565, 28566, 28567, 28568, 28569, 28570, 28571, 28573, 28574, 28575, 28576, 28578, 28579, 28580, 28581, 28582, 28584, 28585, 28586, 28587, 28588, 28589, 28590, 28591, 28592, 28593, 28594, 28596, 28597, 28599, 28600, 28602, 28603, 28604, 28605, 28606, 28607, 28609, 28611, 28612, 28613, 28614, 28615, 28616, 28618, 28619, 28620, 28621, 28622, 28623, 28624, 28627, 28628, 28629, 28630, 28631, 28632, 28633, 28634, 28635, 28636, 28637, 28639, 28642, 28643, 28644, 28645, 28646, 28647, 28648, 28649, 28650, 28651, 28652, 28653, 28656, 28657, 28658, 28659, 28660, 28661, 28662, 28663, 28664, 28665, 28666, 28667, 28668, 28669, 28670, 28671, 28672, 28673, 28674, 28675, 28676, 28677, 28678, 28679, 28680, 28681, 28682, 28683, 28684, 28685, 28686, 28687, 28688, 28690, 28691, 28692, 28693, 28694, 28695, 28696, 28697, 28700, 28701, 28702, 28703, 28704, 28705, 28706, 28708, 28709, 28710, 28711, 28712, 28713, 28714, 28715, 28716, 28717, 28718, 28719, 28720, 28721, 28722, 28723, 28724, 28726, 28727, 28728, 28730, 28731, 28732, 28733, 28734, 28735, 28736, 28737, 28738, 28739, 28740, 28741, 28742, 28743, 28744, 28745, 28746, 28747, 28749, 28750, 28752, 28753, 28754, 28755, 28756, 28757, 28758, 28759, 28760, 28761, 28762, 28763, 28764, 28765, 28767, 28768, 28769, 28770, 28771, 28772, 28773, 28774, 28775, 28776, 28777, 28778, 28782, 28785, 28786, 28787, 28788, 28791, 28793, 28794, 28795, 28797, 28801, 28802, 28803, 28804, 28806, 28807, 28808, 28811, 28812, 28813, 28815, 28816, 28817, 28819, 28823, 28824, 28826, 28827, 28830, 28831, 28832, 28833, 28834, 28835, 28836, 28837, 28838, 28839, 28840, 28841, 28842, 28848, 28850, 28852, 28853, 28854, 28858, 28862, 28863, 28868, 28869, 28870, 28871, 28873, 28875, 28876, 28877, 28878, 28879, 28880, 28881, 28882, 28883, 28884, 28885, 28886, 28887, 28890, 28892, 28893, 28894, 28896, 28897, 28898, 28899, 28901, 28906, 28910, 28912, 28913, 28914, 28915, 28916, 28917, 28918, 28920, 28922, 28923, 28924, 28926, 28927, 28928, 28929, 28930, 28931, 28932, 28933, 28934, 28935, 28936, 28939, 28940, 28941, 28942, 28943, 28945, 28946, 28948, 28951, 28955, 28956, 28957, 28958, 28959, 28960, 28961, 28962, 28963, 28964, 28965, 28967, 28968, 28969, 28970, 28971, 28972, 28973, 28974, 28978, 28979, 28980, 28981, 28983, 28984, 28985, 28986, 28987, 28988, 28989, 28990, 28991, 28992, 28993, 28994, 28995, 28996, 28998, 28999, 29e3, 29001, 29003, 29005, 29007, 29008, 29009, 29010, 29011, 29012, 29013, 29014, 29015, 29016, 29017, 29018, 29019, 29021, 29023, 29024, 29025, 29026, 29027, 29029, 29033, 29034, 29035, 29036, 29037, 29039, 29040, 29041, 29044, 29045, 29046, 29047, 29049, 29051, 29052, 29054, 29055, 29056, 29057, 29058, 29059, 29061, 29062, 29063, 29064, 29065, 29067, 29068, 29069, 29070, 29072, 29073, 29074, 29075, 29077, 29078, 29079, 29082, 29083, 29084, 29085, 29086, 29089, 29090, 29091, 29092, 29093, 29094, 29095, 29097, 29098, 29099, 29101, 29102, 29103, 29104, 29105, 29106, 29108, 29110, 29111, 29112, 29114, 29115, 29116, 29117, 29118, 29119, 29120, 29121, 29122, 29124, 29125, 29126, 29127, 29128, 29129, 29130, 29131, 29132, 29133, 29135, 29136, 29137, 29138, 29139, 29142, 29143, 29144, 29145, 29146, 29147, 29148, 29149, 29150, 29151, 29153, 29154, 29155, 29156, 29158, 29160, 29161, 29162, 29163, 29164, 29165, 29167, 29168, 29169, 29170, 29171, 29172, 29173, 29174, 29175, 29176, 29178, 29179, 29180, 29181, 29182, 29183, 29184, 29185, 29186, 29187, 29188, 29189, 29191, 29192, 29193, 29194, 29195, 29196, 29197, 29198, 29199, 29200, 29201, 29202, 29203, 29204, 29205, 29206, 29207, 29208, 29209, 29210, 29211, 29212, 29214, 29215, 29216, 29217, 29218, 29219, 29220, 29221, 29222, 29223, 29225, 29227, 29229, 29230, 29231, 29234, 29235, 29236, 29242, 29244, 29246, 29248, 29249, 29250, 29251, 29252, 29253, 29254, 29257, 29258, 29259, 29262, 29263, 29264, 29265, 29267, 29268, 29269, 29271, 29272, 29274, 29276, 29278, 29280, 29283, 29284, 29285, 29288, 29290, 29291, 29292, 29293, 29296, 29297, 29299, 29300, 29302, 29303, 29304, 29307, 29308, 29309, 29314, 29315, 29317, 29318, 29319, 29320, 29321, 29324, 29326, 29328, 29329, 29331, 29332, 29333, 29334, 29335, 29336, 29337, 29338, 29339, 29340, 29341, 29342, 29344, 29345, 29346, 29347, 29348, 29349, 29350, 29351, 29352, 29353, 29354, 29355, 29358, 29361, 29362, 29363, 29365, 29370, 29371, 29372, 29373, 29374, 29375, 29376, 29381, 29382, 29383, 29385, 29386, 29387, 29388, 29391, 29393, 29395, 29396, 29397, 29398, 29400, 29402, 29403, 58566, 58567, 58568, 58569, 58570, 58571, 58572, 58573, 58574, 58575, 58576, 58577, 58578, 58579, 58580, 58581, 58582, 58583, 58584, 58585, 58586, 58587, 58588, 58589, 58590, 58591, 58592, 58593, 58594, 58595, 58596, 58597, 58598, 58599, 58600, 58601, 58602, 58603, 58604, 58605, 58606, 58607, 58608, 58609, 58610, 58611, 58612, 58613, 58614, 58615, 58616, 58617, 58618, 58619, 58620, 58621, 58622, 58623, 58624, 58625, 58626, 58627, 58628, 58629, 58630, 58631, 58632, 58633, 58634, 58635, 58636, 58637, 58638, 58639, 58640, 58641, 58642, 58643, 58644, 58645, 58646, 58647, 58648, 58649, 58650, 58651, 58652, 58653, 58654, 58655, 58656, 58657, 58658, 58659, 58660, 58661, 12288, 12289, 12290, 183, 713, 711, 168, 12291, 12293, 8212, 65374, 8214, 8230, 8216, 8217, 8220, 8221, 12308, 12309, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12310, 12311, 12304, 12305, 177, 215, 247, 8758, 8743, 8744, 8721, 8719, 8746, 8745, 8712, 8759, 8730, 8869, 8741, 8736, 8978, 8857, 8747, 8750, 8801, 8780, 8776, 8765, 8733, 8800, 8814, 8815, 8804, 8805, 8734, 8757, 8756, 9794, 9792, 176, 8242, 8243, 8451, 65284, 164, 65504, 65505, 8240, 167, 8470, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 8251, 8594, 8592, 8593, 8595, 12307, 58662, 58663, 58664, 58665, 58666, 58667, 58668, 58669, 58670, 58671, 58672, 58673, 58674, 58675, 58676, 58677, 58678, 58679, 58680, 58681, 58682, 58683, 58684, 58685, 58686, 58687, 58688, 58689, 58690, 58691, 58692, 58693, 58694, 58695, 58696, 58697, 58698, 58699, 58700, 58701, 58702, 58703, 58704, 58705, 58706, 58707, 58708, 58709, 58710, 58711, 58712, 58713, 58714, 58715, 58716, 58717, 58718, 58719, 58720, 58721, 58722, 58723, 58724, 58725, 58726, 58727, 58728, 58729, 58730, 58731, 58732, 58733, 58734, 58735, 58736, 58737, 58738, 58739, 58740, 58741, 58742, 58743, 58744, 58745, 58746, 58747, 58748, 58749, 58750, 58751, 58752, 58753, 58754, 58755, 58756, 58757, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 59238, 59239, 59240, 59241, 59242, 59243, 9352, 9353, 9354, 9355, 9356, 9357, 9358, 9359, 9360, 9361, 9362, 9363, 9364, 9365, 9366, 9367, 9368, 9369, 9370, 9371, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349, 9350, 9351, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 8364, 59245, 12832, 12833, 12834, 12835, 12836, 12837, 12838, 12839, 12840, 12841, 59246, 59247, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 8554, 8555, 59248, 59249, 58758, 58759, 58760, 58761, 58762, 58763, 58764, 58765, 58766, 58767, 58768, 58769, 58770, 58771, 58772, 58773, 58774, 58775, 58776, 58777, 58778, 58779, 58780, 58781, 58782, 58783, 58784, 58785, 58786, 58787, 58788, 58789, 58790, 58791, 58792, 58793, 58794, 58795, 58796, 58797, 58798, 58799, 58800, 58801, 58802, 58803, 58804, 58805, 58806, 58807, 58808, 58809, 58810, 58811, 58812, 58813, 58814, 58815, 58816, 58817, 58818, 58819, 58820, 58821, 58822, 58823, 58824, 58825, 58826, 58827, 58828, 58829, 58830, 58831, 58832, 58833, 58834, 58835, 58836, 58837, 58838, 58839, 58840, 58841, 58842, 58843, 58844, 58845, 58846, 58847, 58848, 58849, 58850, 58851, 58852, 12288, 65281, 65282, 65283, 65509, 65285, 65286, 65287, 65288, 65289, 65290, 65291, 65292, 65293, 65294, 65295, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, 65306, 65307, 65308, 65309, 65310, 65311, 65312, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65339, 65340, 65341, 65342, 65343, 65344, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 65371, 65372, 65373, 65507, 58854, 58855, 58856, 58857, 58858, 58859, 58860, 58861, 58862, 58863, 58864, 58865, 58866, 58867, 58868, 58869, 58870, 58871, 58872, 58873, 58874, 58875, 58876, 58877, 58878, 58879, 58880, 58881, 58882, 58883, 58884, 58885, 58886, 58887, 58888, 58889, 58890, 58891, 58892, 58893, 58894, 58895, 58896, 58897, 58898, 58899, 58900, 58901, 58902, 58903, 58904, 58905, 58906, 58907, 58908, 58909, 58910, 58911, 58912, 58913, 58914, 58915, 58916, 58917, 58918, 58919, 58920, 58921, 58922, 58923, 58924, 58925, 58926, 58927, 58928, 58929, 58930, 58931, 58932, 58933, 58934, 58935, 58936, 58937, 58938, 58939, 58940, 58941, 58942, 58943, 58944, 58945, 58946, 58947, 58948, 58949, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, 59250, 59251, 59252, 59253, 59254, 59255, 59256, 59257, 59258, 59259, 59260, 58950, 58951, 58952, 58953, 58954, 58955, 58956, 58957, 58958, 58959, 58960, 58961, 58962, 58963, 58964, 58965, 58966, 58967, 58968, 58969, 58970, 58971, 58972, 58973, 58974, 58975, 58976, 58977, 58978, 58979, 58980, 58981, 58982, 58983, 58984, 58985, 58986, 58987, 58988, 58989, 58990, 58991, 58992, 58993, 58994, 58995, 58996, 58997, 58998, 58999, 59e3, 59001, 59002, 59003, 59004, 59005, 59006, 59007, 59008, 59009, 59010, 59011, 59012, 59013, 59014, 59015, 59016, 59017, 59018, 59019, 59020, 59021, 59022, 59023, 59024, 59025, 59026, 59027, 59028, 59029, 59030, 59031, 59032, 59033, 59034, 59035, 59036, 59037, 59038, 59039, 59040, 59041, 59042, 59043, 59044, 59045, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, 59261, 59262, 59263, 59264, 59265, 59266, 59267, 59268, 59046, 59047, 59048, 59049, 59050, 59051, 59052, 59053, 59054, 59055, 59056, 59057, 59058, 59059, 59060, 59061, 59062, 59063, 59064, 59065, 59066, 59067, 59068, 59069, 59070, 59071, 59072, 59073, 59074, 59075, 59076, 59077, 59078, 59079, 59080, 59081, 59082, 59083, 59084, 59085, 59086, 59087, 59088, 59089, 59090, 59091, 59092, 59093, 59094, 59095, 59096, 59097, 59098, 59099, 59100, 59101, 59102, 59103, 59104, 59105, 59106, 59107, 59108, 59109, 59110, 59111, 59112, 59113, 59114, 59115, 59116, 59117, 59118, 59119, 59120, 59121, 59122, 59123, 59124, 59125, 59126, 59127, 59128, 59129, 59130, 59131, 59132, 59133, 59134, 59135, 59136, 59137, 59138, 59139, 59140, 59141, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 59269, 59270, 59271, 59272, 59273, 59274, 59275, 59276, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, 59277, 59278, 59279, 59280, 59281, 59282, 59283, 65077, 65078, 65081, 65082, 65087, 65088, 65085, 65086, 65089, 65090, 65091, 65092, 59284, 59285, 65083, 65084, 65079, 65080, 65073, 59286, 65075, 65076, 59287, 59288, 59289, 59290, 59291, 59292, 59293, 59294, 59295, 59142, 59143, 59144, 59145, 59146, 59147, 59148, 59149, 59150, 59151, 59152, 59153, 59154, 59155, 59156, 59157, 59158, 59159, 59160, 59161, 59162, 59163, 59164, 59165, 59166, 59167, 59168, 59169, 59170, 59171, 59172, 59173, 59174, 59175, 59176, 59177, 59178, 59179, 59180, 59181, 59182, 59183, 59184, 59185, 59186, 59187, 59188, 59189, 59190, 59191, 59192, 59193, 59194, 59195, 59196, 59197, 59198, 59199, 59200, 59201, 59202, 59203, 59204, 59205, 59206, 59207, 59208, 59209, 59210, 59211, 59212, 59213, 59214, 59215, 59216, 59217, 59218, 59219, 59220, 59221, 59222, 59223, 59224, 59225, 59226, 59227, 59228, 59229, 59230, 59231, 59232, 59233, 59234, 59235, 59236, 59237, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 59296, 59297, 59298, 59299, 59300, 59301, 59302, 59303, 59304, 59305, 59306, 59307, 59308, 59309, 59310, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 59311, 59312, 59313, 59314, 59315, 59316, 59317, 59318, 59319, 59320, 59321, 59322, 59323, 714, 715, 729, 8211, 8213, 8229, 8245, 8453, 8457, 8598, 8599, 8600, 8601, 8725, 8735, 8739, 8786, 8806, 8807, 8895, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9581, 9582, 9583, 9584, 9585, 9586, 9587, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9609, 9610, 9611, 9612, 9613, 9614, 9615, 9619, 9620, 9621, 9660, 9661, 9698, 9699, 9700, 9701, 9737, 8853, 12306, 12317, 12318, 59324, 59325, 59326, 59327, 59328, 59329, 59330, 59331, 59332, 59333, 59334, 257, 225, 462, 224, 275, 233, 283, 232, 299, 237, 464, 236, 333, 243, 466, 242, 363, 250, 468, 249, 470, 472, 474, 476, 252, 234, 593, 7743, 324, 328, 505, 609, 59337, 59338, 59339, 59340, 12549, 12550, 12551, 12552, 12553, 12554, 12555, 12556, 12557, 12558, 12559, 12560, 12561, 12562, 12563, 12564, 12565, 12566, 12567, 12568, 12569, 12570, 12571, 12572, 12573, 12574, 12575, 12576, 12577, 12578, 12579, 12580, 12581, 12582, 12583, 12584, 12585, 59341, 59342, 59343, 59344, 59345, 59346, 59347, 59348, 59349, 59350, 59351, 59352, 59353, 59354, 59355, 59356, 59357, 59358, 59359, 59360, 59361, 12321, 12322, 12323, 12324, 12325, 12326, 12327, 12328, 12329, 12963, 13198, 13199, 13212, 13213, 13214, 13217, 13252, 13262, 13265, 13266, 13269, 65072, 65506, 65508, 59362, 8481, 12849, 59363, 8208, 59364, 59365, 59366, 12540, 12443, 12444, 12541, 12542, 12294, 12445, 12446, 65097, 65098, 65099, 65100, 65101, 65102, 65103, 65104, 65105, 65106, 65108, 65109, 65110, 65111, 65113, 65114, 65115, 65116, 65117, 65118, 65119, 65120, 65121, 65122, 65123, 65124, 65125, 65126, 65128, 65129, 65130, 65131, 12350, 12272, 12273, 12274, 12275, 12276, 12277, 12278, 12279, 12280, 12281, 12282, 12283, 12295, 59380, 59381, 59382, 59383, 59384, 59385, 59386, 59387, 59388, 59389, 59390, 59391, 59392, 9472, 9473, 9474, 9475, 9476, 9477, 9478, 9479, 9480, 9481, 9482, 9483, 9484, 9485, 9486, 9487, 9488, 9489, 9490, 9491, 9492, 9493, 9494, 9495, 9496, 9497, 9498, 9499, 9500, 9501, 9502, 9503, 9504, 9505, 9506, 9507, 9508, 9509, 9510, 9511, 9512, 9513, 9514, 9515, 9516, 9517, 9518, 9519, 9520, 9521, 9522, 9523, 9524, 9525, 9526, 9527, 9528, 9529, 9530, 9531, 9532, 9533, 9534, 9535, 9536, 9537, 9538, 9539, 9540, 9541, 9542, 9543, 9544, 9545, 9546, 9547, 59393, 59394, 59395, 59396, 59397, 59398, 59399, 59400, 59401, 59402, 59403, 59404, 59405, 59406, 59407, 29404, 29405, 29407, 29410, 29411, 29412, 29413, 29414, 29415, 29418, 29419, 29429, 29430, 29433, 29437, 29438, 29439, 29440, 29442, 29444, 29445, 29446, 29447, 29448, 29449, 29451, 29452, 29453, 29455, 29456, 29457, 29458, 29460, 29464, 29465, 29466, 29471, 29472, 29475, 29476, 29478, 29479, 29480, 29485, 29487, 29488, 29490, 29491, 29493, 29494, 29498, 29499, 29500, 29501, 29504, 29505, 29506, 29507, 29508, 29509, 29510, 29511, 29512, 29513, 29514, 29515, 29516, 29518, 29519, 29521, 29523, 29524, 29525, 29526, 29528, 29529, 29530, 29531, 29532, 29533, 29534, 29535, 29537, 29538, 29539, 29540, 29541, 29542, 29543, 29544, 29545, 29546, 29547, 29550, 29552, 29553, 57344, 57345, 57346, 57347, 57348, 57349, 57350, 57351, 57352, 57353, 57354, 57355, 57356, 57357, 57358, 57359, 57360, 57361, 57362, 57363, 57364, 57365, 57366, 57367, 57368, 57369, 57370, 57371, 57372, 57373, 57374, 57375, 57376, 57377, 57378, 57379, 57380, 57381, 57382, 57383, 57384, 57385, 57386, 57387, 57388, 57389, 57390, 57391, 57392, 57393, 57394, 57395, 57396, 57397, 57398, 57399, 57400, 57401, 57402, 57403, 57404, 57405, 57406, 57407, 57408, 57409, 57410, 57411, 57412, 57413, 57414, 57415, 57416, 57417, 57418, 57419, 57420, 57421, 57422, 57423, 57424, 57425, 57426, 57427, 57428, 57429, 57430, 57431, 57432, 57433, 57434, 57435, 57436, 57437, 29554, 29555, 29556, 29557, 29558, 29559, 29560, 29561, 29562, 29563, 29564, 29565, 29567, 29568, 29569, 29570, 29571, 29573, 29574, 29576, 29578, 29580, 29581, 29583, 29584, 29586, 29587, 29588, 29589, 29591, 29592, 29593, 29594, 29596, 29597, 29598, 29600, 29601, 29603, 29604, 29605, 29606, 29607, 29608, 29610, 29612, 29613, 29617, 29620, 29621, 29622, 29624, 29625, 29628, 29629, 29630, 29631, 29633, 29635, 29636, 29637, 29638, 29639, 29643, 29644, 29646, 29650, 29651, 29652, 29653, 29654, 29655, 29656, 29658, 29659, 29660, 29661, 29663, 29665, 29666, 29667, 29668, 29670, 29672, 29674, 29675, 29676, 29678, 29679, 29680, 29681, 29683, 29684, 29685, 29686, 29687, 57438, 57439, 57440, 57441, 57442, 57443, 57444, 57445, 57446, 57447, 57448, 57449, 57450, 57451, 57452, 57453, 57454, 57455, 57456, 57457, 57458, 57459, 57460, 57461, 57462, 57463, 57464, 57465, 57466, 57467, 57468, 57469, 57470, 57471, 57472, 57473, 57474, 57475, 57476, 57477, 57478, 57479, 57480, 57481, 57482, 57483, 57484, 57485, 57486, 57487, 57488, 57489, 57490, 57491, 57492, 57493, 57494, 57495, 57496, 57497, 57498, 57499, 57500, 57501, 57502, 57503, 57504, 57505, 57506, 57507, 57508, 57509, 57510, 57511, 57512, 57513, 57514, 57515, 57516, 57517, 57518, 57519, 57520, 57521, 57522, 57523, 57524, 57525, 57526, 57527, 57528, 57529, 57530, 57531, 29688, 29689, 29690, 29691, 29692, 29693, 29694, 29695, 29696, 29697, 29698, 29700, 29703, 29704, 29707, 29708, 29709, 29710, 29713, 29714, 29715, 29716, 29717, 29718, 29719, 29720, 29721, 29724, 29725, 29726, 29727, 29728, 29729, 29731, 29732, 29735, 29737, 29739, 29741, 29743, 29745, 29746, 29751, 29752, 29753, 29754, 29755, 29757, 29758, 29759, 29760, 29762, 29763, 29764, 29765, 29766, 29767, 29768, 29769, 29770, 29771, 29772, 29773, 29774, 29775, 29776, 29777, 29778, 29779, 29780, 29782, 29784, 29789, 29792, 29793, 29794, 29795, 29796, 29797, 29798, 29799, 29800, 29801, 29802, 29803, 29804, 29806, 29807, 29809, 29810, 29811, 29812, 29813, 29816, 29817, 29818, 57532, 57533, 57534, 57535, 57536, 57537, 57538, 57539, 57540, 57541, 57542, 57543, 57544, 57545, 57546, 57547, 57548, 57549, 57550, 57551, 57552, 57553, 57554, 57555, 57556, 57557, 57558, 57559, 57560, 57561, 57562, 57563, 57564, 57565, 57566, 57567, 57568, 57569, 57570, 57571, 57572, 57573, 57574, 57575, 57576, 57577, 57578, 57579, 57580, 57581, 57582, 57583, 57584, 57585, 57586, 57587, 57588, 57589, 57590, 57591, 57592, 57593, 57594, 57595, 57596, 57597, 57598, 57599, 57600, 57601, 57602, 57603, 57604, 57605, 57606, 57607, 57608, 57609, 57610, 57611, 57612, 57613, 57614, 57615, 57616, 57617, 57618, 57619, 57620, 57621, 57622, 57623, 57624, 57625, 29819, 29820, 29821, 29823, 29826, 29828, 29829, 29830, 29832, 29833, 29834, 29836, 29837, 29839, 29841, 29842, 29843, 29844, 29845, 29846, 29847, 29848, 29849, 29850, 29851, 29853, 29855, 29856, 29857, 29858, 29859, 29860, 29861, 29862, 29866, 29867, 29868, 29869, 29870, 29871, 29872, 29873, 29874, 29875, 29876, 29877, 29878, 29879, 29880, 29881, 29883, 29884, 29885, 29886, 29887, 29888, 29889, 29890, 29891, 29892, 29893, 29894, 29895, 29896, 29897, 29898, 29899, 29900, 29901, 29902, 29903, 29904, 29905, 29907, 29908, 29909, 29910, 29911, 29912, 29913, 29914, 29915, 29917, 29919, 29921, 29925, 29927, 29928, 29929, 29930, 29931, 29932, 29933, 29936, 29937, 29938, 57626, 57627, 57628, 57629, 57630, 57631, 57632, 57633, 57634, 57635, 57636, 57637, 57638, 57639, 57640, 57641, 57642, 57643, 57644, 57645, 57646, 57647, 57648, 57649, 57650, 57651, 57652, 57653, 57654, 57655, 57656, 57657, 57658, 57659, 57660, 57661, 57662, 57663, 57664, 57665, 57666, 57667, 57668, 57669, 57670, 57671, 57672, 57673, 57674, 57675, 57676, 57677, 57678, 57679, 57680, 57681, 57682, 57683, 57684, 57685, 57686, 57687, 57688, 57689, 57690, 57691, 57692, 57693, 57694, 57695, 57696, 57697, 57698, 57699, 57700, 57701, 57702, 57703, 57704, 57705, 57706, 57707, 57708, 57709, 57710, 57711, 57712, 57713, 57714, 57715, 57716, 57717, 57718, 57719, 29939, 29941, 29944, 29945, 29946, 29947, 29948, 29949, 29950, 29952, 29953, 29954, 29955, 29957, 29958, 29959, 29960, 29961, 29962, 29963, 29964, 29966, 29968, 29970, 29972, 29973, 29974, 29975, 29979, 29981, 29982, 29984, 29985, 29986, 29987, 29988, 29990, 29991, 29994, 29998, 30004, 30006, 30009, 30012, 30013, 30015, 30017, 30018, 30019, 30020, 30022, 30023, 30025, 30026, 30029, 30032, 30033, 30034, 30035, 30037, 30038, 30039, 30040, 30045, 30046, 30047, 30048, 30049, 30050, 30051, 30052, 30055, 30056, 30057, 30059, 30060, 30061, 30062, 30063, 30064, 30065, 30067, 30069, 30070, 30071, 30074, 30075, 30076, 30077, 30078, 30080, 30081, 30082, 30084, 30085, 30087, 57720, 57721, 57722, 57723, 57724, 57725, 57726, 57727, 57728, 57729, 57730, 57731, 57732, 57733, 57734, 57735, 57736, 57737, 57738, 57739, 57740, 57741, 57742, 57743, 57744, 57745, 57746, 57747, 57748, 57749, 57750, 57751, 57752, 57753, 57754, 57755, 57756, 57757, 57758, 57759, 57760, 57761, 57762, 57763, 57764, 57765, 57766, 57767, 57768, 57769, 57770, 57771, 57772, 57773, 57774, 57775, 57776, 57777, 57778, 57779, 57780, 57781, 57782, 57783, 57784, 57785, 57786, 57787, 57788, 57789, 57790, 57791, 57792, 57793, 57794, 57795, 57796, 57797, 57798, 57799, 57800, 57801, 57802, 57803, 57804, 57805, 57806, 57807, 57808, 57809, 57810, 57811, 57812, 57813, 30088, 30089, 30090, 30092, 30093, 30094, 30096, 30099, 30101, 30104, 30107, 30108, 30110, 30114, 30118, 30119, 30120, 30121, 30122, 30125, 30134, 30135, 30138, 30139, 30143, 30144, 30145, 30150, 30155, 30156, 30158, 30159, 30160, 30161, 30163, 30167, 30169, 30170, 30172, 30173, 30175, 30176, 30177, 30181, 30185, 30188, 30189, 30190, 30191, 30194, 30195, 30197, 30198, 30199, 30200, 30202, 30203, 30205, 30206, 30210, 30212, 30214, 30215, 30216, 30217, 30219, 30221, 30222, 30223, 30225, 30226, 30227, 30228, 30230, 30234, 30236, 30237, 30238, 30241, 30243, 30247, 30248, 30252, 30254, 30255, 30257, 30258, 30262, 30263, 30265, 30266, 30267, 30269, 30273, 30274, 30276, 57814, 57815, 57816, 57817, 57818, 57819, 57820, 57821, 57822, 57823, 57824, 57825, 57826, 57827, 57828, 57829, 57830, 57831, 57832, 57833, 57834, 57835, 57836, 57837, 57838, 57839, 57840, 57841, 57842, 57843, 57844, 57845, 57846, 57847, 57848, 57849, 57850, 57851, 57852, 57853, 57854, 57855, 57856, 57857, 57858, 57859, 57860, 57861, 57862, 57863, 57864, 57865, 57866, 57867, 57868, 57869, 57870, 57871, 57872, 57873, 57874, 57875, 57876, 57877, 57878, 57879, 57880, 57881, 57882, 57883, 57884, 57885, 57886, 57887, 57888, 57889, 57890, 57891, 57892, 57893, 57894, 57895, 57896, 57897, 57898, 57899, 57900, 57901, 57902, 57903, 57904, 57905, 57906, 57907, 30277, 30278, 30279, 30280, 30281, 30282, 30283, 30286, 30287, 30288, 30289, 30290, 30291, 30293, 30295, 30296, 30297, 30298, 30299, 30301, 30303, 30304, 30305, 30306, 30308, 30309, 30310, 30311, 30312, 30313, 30314, 30316, 30317, 30318, 30320, 30321, 30322, 30323, 30324, 30325, 30326, 30327, 30329, 30330, 30332, 30335, 30336, 30337, 30339, 30341, 30345, 30346, 30348, 30349, 30351, 30352, 30354, 30356, 30357, 30359, 30360, 30362, 30363, 30364, 30365, 30366, 30367, 30368, 30369, 30370, 30371, 30373, 30374, 30375, 30376, 30377, 30378, 30379, 30380, 30381, 30383, 30384, 30387, 30389, 30390, 30391, 30392, 30393, 30394, 30395, 30396, 30397, 30398, 30400, 30401, 30403, 21834, 38463, 22467, 25384, 21710, 21769, 21696, 30353, 30284, 34108, 30702, 33406, 30861, 29233, 38552, 38797, 27688, 23433, 20474, 25353, 26263, 23736, 33018, 26696, 32942, 26114, 30414, 20985, 25942, 29100, 32753, 34948, 20658, 22885, 25034, 28595, 33453, 25420, 25170, 21485, 21543, 31494, 20843, 30116, 24052, 25300, 36299, 38774, 25226, 32793, 22365, 38712, 32610, 29240, 30333, 26575, 30334, 25670, 20336, 36133, 25308, 31255, 26001, 29677, 25644, 25203, 33324, 39041, 26495, 29256, 25198, 25292, 20276, 29923, 21322, 21150, 32458, 37030, 24110, 26758, 27036, 33152, 32465, 26834, 30917, 34444, 38225, 20621, 35876, 33502, 32990, 21253, 35090, 21093, 30404, 30407, 30409, 30411, 30412, 30419, 30421, 30425, 30426, 30428, 30429, 30430, 30432, 30433, 30434, 30435, 30436, 30438, 30439, 30440, 30441, 30442, 30443, 30444, 30445, 30448, 30451, 30453, 30454, 30455, 30458, 30459, 30461, 30463, 30464, 30466, 30467, 30469, 30470, 30474, 30476, 30478, 30479, 30480, 30481, 30482, 30483, 30484, 30485, 30486, 30487, 30488, 30491, 30492, 30493, 30494, 30497, 30499, 30500, 30501, 30503, 30506, 30507, 30508, 30510, 30512, 30513, 30514, 30515, 30516, 30521, 30523, 30525, 30526, 30527, 30530, 30532, 30533, 30534, 30536, 30537, 30538, 30539, 30540, 30541, 30542, 30543, 30546, 30547, 30548, 30549, 30550, 30551, 30552, 30553, 30556, 34180, 38649, 20445, 22561, 39281, 23453, 25265, 25253, 26292, 35961, 40077, 29190, 26479, 30865, 24754, 21329, 21271, 36744, 32972, 36125, 38049, 20493, 29384, 22791, 24811, 28953, 34987, 22868, 33519, 26412, 31528, 23849, 32503, 29997, 27893, 36454, 36856, 36924, 40763, 27604, 37145, 31508, 24444, 30887, 34006, 34109, 27605, 27609, 27606, 24065, 24199, 30201, 38381, 25949, 24330, 24517, 36767, 22721, 33218, 36991, 38491, 38829, 36793, 32534, 36140, 25153, 20415, 21464, 21342, 36776, 36777, 36779, 36941, 26631, 24426, 33176, 34920, 40150, 24971, 21035, 30250, 24428, 25996, 28626, 28392, 23486, 25672, 20853, 20912, 26564, 19993, 31177, 39292, 28851, 30557, 30558, 30559, 30560, 30564, 30567, 30569, 30570, 30573, 30574, 30575, 30576, 30577, 30578, 30579, 30580, 30581, 30582, 30583, 30584, 30586, 30587, 30588, 30593, 30594, 30595, 30598, 30599, 30600, 30601, 30602, 30603, 30607, 30608, 30611, 30612, 30613, 30614, 30615, 30616, 30617, 30618, 30619, 30620, 30621, 30622, 30625, 30627, 30628, 30630, 30632, 30635, 30637, 30638, 30639, 30641, 30642, 30644, 30646, 30647, 30648, 30649, 30650, 30652, 30654, 30656, 30657, 30658, 30659, 30660, 30661, 30662, 30663, 30664, 30665, 30666, 30667, 30668, 30670, 30671, 30672, 30673, 30674, 30675, 30676, 30677, 30678, 30680, 30681, 30682, 30685, 30686, 30687, 30688, 30689, 30692, 30149, 24182, 29627, 33760, 25773, 25320, 38069, 27874, 21338, 21187, 25615, 38082, 31636, 20271, 24091, 33334, 33046, 33162, 28196, 27850, 39539, 25429, 21340, 21754, 34917, 22496, 19981, 24067, 27493, 31807, 37096, 24598, 25830, 29468, 35009, 26448, 25165, 36130, 30572, 36393, 37319, 24425, 33756, 34081, 39184, 21442, 34453, 27531, 24813, 24808, 28799, 33485, 33329, 20179, 27815, 34255, 25805, 31961, 27133, 26361, 33609, 21397, 31574, 20391, 20876, 27979, 23618, 36461, 25554, 21449, 33580, 33590, 26597, 30900, 25661, 23519, 23700, 24046, 35815, 25286, 26612, 35962, 25600, 25530, 34633, 39307, 35863, 32544, 38130, 20135, 38416, 39076, 26124, 29462, 30694, 30696, 30698, 30703, 30704, 30705, 30706, 30708, 30709, 30711, 30713, 30714, 30715, 30716, 30723, 30724, 30725, 30726, 30727, 30728, 30730, 30731, 30734, 30735, 30736, 30739, 30741, 30745, 30747, 30750, 30752, 30753, 30754, 30756, 30760, 30762, 30763, 30766, 30767, 30769, 30770, 30771, 30773, 30774, 30781, 30783, 30785, 30786, 30787, 30788, 30790, 30792, 30793, 30794, 30795, 30797, 30799, 30801, 30803, 30804, 30808, 30809, 30810, 30811, 30812, 30814, 30815, 30816, 30817, 30818, 30819, 30820, 30821, 30822, 30823, 30824, 30825, 30831, 30832, 30833, 30834, 30835, 30836, 30837, 30838, 30840, 30841, 30842, 30843, 30845, 30846, 30847, 30848, 30849, 30850, 30851, 22330, 23581, 24120, 38271, 20607, 32928, 21378, 25950, 30021, 21809, 20513, 36229, 25220, 38046, 26397, 22066, 28526, 24034, 21557, 28818, 36710, 25199, 25764, 25507, 24443, 28552, 37108, 33251, 36784, 23576, 26216, 24561, 27785, 38472, 36225, 34924, 25745, 31216, 22478, 27225, 25104, 21576, 20056, 31243, 24809, 28548, 35802, 25215, 36894, 39563, 31204, 21507, 30196, 25345, 21273, 27744, 36831, 24347, 39536, 32827, 40831, 20360, 23610, 36196, 32709, 26021, 28861, 20805, 20914, 34411, 23815, 23456, 25277, 37228, 30068, 36364, 31264, 24833, 31609, 20167, 32504, 30597, 19985, 33261, 21021, 20986, 27249, 21416, 36487, 38148, 38607, 28353, 38500, 26970, 30852, 30853, 30854, 30856, 30858, 30859, 30863, 30864, 30866, 30868, 30869, 30870, 30873, 30877, 30878, 30880, 30882, 30884, 30886, 30888, 30889, 30890, 30891, 30892, 30893, 30894, 30895, 30901, 30902, 30903, 30904, 30906, 30907, 30908, 30909, 30911, 30912, 30914, 30915, 30916, 30918, 30919, 30920, 30924, 30925, 30926, 30927, 30929, 30930, 30931, 30934, 30935, 30936, 30938, 30939, 30940, 30941, 30942, 30943, 30944, 30945, 30946, 30947, 30948, 30949, 30950, 30951, 30953, 30954, 30955, 30957, 30958, 30959, 30960, 30961, 30963, 30965, 30966, 30968, 30969, 30971, 30972, 30973, 30974, 30975, 30976, 30978, 30979, 30980, 30982, 30983, 30984, 30985, 30986, 30987, 30988, 30784, 20648, 30679, 25616, 35302, 22788, 25571, 24029, 31359, 26941, 20256, 33337, 21912, 20018, 30126, 31383, 24162, 24202, 38383, 21019, 21561, 28810, 25462, 38180, 22402, 26149, 26943, 37255, 21767, 28147, 32431, 34850, 25139, 32496, 30133, 33576, 30913, 38604, 36766, 24904, 29943, 35789, 27492, 21050, 36176, 27425, 32874, 33905, 22257, 21254, 20174, 19995, 20945, 31895, 37259, 31751, 20419, 36479, 31713, 31388, 25703, 23828, 20652, 33030, 30209, 31929, 28140, 32736, 26449, 23384, 23544, 30923, 25774, 25619, 25514, 25387, 38169, 25645, 36798, 31572, 30249, 25171, 22823, 21574, 27513, 20643, 25140, 24102, 27526, 20195, 36151, 34955, 24453, 36910, 30989, 30990, 30991, 30992, 30993, 30994, 30996, 30997, 30998, 30999, 31e3, 31001, 31002, 31003, 31004, 31005, 31007, 31008, 31009, 31010, 31011, 31013, 31014, 31015, 31016, 31017, 31018, 31019, 31020, 31021, 31022, 31023, 31024, 31025, 31026, 31027, 31029, 31030, 31031, 31032, 31033, 31037, 31039, 31042, 31043, 31044, 31045, 31047, 31050, 31051, 31052, 31053, 31054, 31055, 31056, 31057, 31058, 31060, 31061, 31064, 31065, 31073, 31075, 31076, 31078, 31081, 31082, 31083, 31084, 31086, 31088, 31089, 31090, 31091, 31092, 31093, 31094, 31097, 31099, 31100, 31101, 31102, 31103, 31106, 31107, 31110, 31111, 31112, 31113, 31115, 31116, 31117, 31118, 31120, 31121, 31122, 24608, 32829, 25285, 20025, 21333, 37112, 25528, 32966, 26086, 27694, 20294, 24814, 28129, 35806, 24377, 34507, 24403, 25377, 20826, 33633, 26723, 20992, 25443, 36424, 20498, 23707, 31095, 23548, 21040, 31291, 24764, 36947, 30423, 24503, 24471, 30340, 36460, 28783, 30331, 31561, 30634, 20979, 37011, 22564, 20302, 28404, 36842, 25932, 31515, 29380, 28068, 32735, 23265, 25269, 24213, 22320, 33922, 31532, 24093, 24351, 36882, 32532, 39072, 25474, 28359, 30872, 28857, 20856, 38747, 22443, 30005, 20291, 30008, 24215, 24806, 22880, 28096, 27583, 30857, 21500, 38613, 20939, 20993, 25481, 21514, 38035, 35843, 36300, 29241, 30879, 34678, 36845, 35853, 21472, 31123, 31124, 31125, 31126, 31127, 31128, 31129, 31131, 31132, 31133, 31134, 31135, 31136, 31137, 31138, 31139, 31140, 31141, 31142, 31144, 31145, 31146, 31147, 31148, 31149, 31150, 31151, 31152, 31153, 31154, 31156, 31157, 31158, 31159, 31160, 31164, 31167, 31170, 31172, 31173, 31175, 31176, 31178, 31180, 31182, 31183, 31184, 31187, 31188, 31190, 31191, 31193, 31194, 31195, 31196, 31197, 31198, 31200, 31201, 31202, 31205, 31208, 31210, 31212, 31214, 31217, 31218, 31219, 31220, 31221, 31222, 31223, 31225, 31226, 31228, 31230, 31231, 31233, 31236, 31237, 31239, 31240, 31241, 31242, 31244, 31247, 31248, 31249, 31250, 31251, 31253, 31254, 31256, 31257, 31259, 31260, 19969, 30447, 21486, 38025, 39030, 40718, 38189, 23450, 35746, 20002, 19996, 20908, 33891, 25026, 21160, 26635, 20375, 24683, 20923, 27934, 20828, 25238, 26007, 38497, 35910, 36887, 30168, 37117, 30563, 27602, 29322, 29420, 35835, 22581, 30585, 36172, 26460, 38208, 32922, 24230, 28193, 22930, 31471, 30701, 38203, 27573, 26029, 32526, 22534, 20817, 38431, 23545, 22697, 21544, 36466, 25958, 39039, 22244, 38045, 30462, 36929, 25479, 21702, 22810, 22842, 22427, 36530, 26421, 36346, 33333, 21057, 24816, 22549, 34558, 23784, 40517, 20420, 39069, 35769, 23077, 24694, 21380, 25212, 36943, 37122, 39295, 24681, 32780, 20799, 32819, 23572, 39285, 27953, 20108, 31261, 31263, 31265, 31266, 31268, 31269, 31270, 31271, 31272, 31273, 31274, 31275, 31276, 31277, 31278, 31279, 31280, 31281, 31282, 31284, 31285, 31286, 31288, 31290, 31294, 31296, 31297, 31298, 31299, 31300, 31301, 31303, 31304, 31305, 31306, 31307, 31308, 31309, 31310, 31311, 31312, 31314, 31315, 31316, 31317, 31318, 31320, 31321, 31322, 31323, 31324, 31325, 31326, 31327, 31328, 31329, 31330, 31331, 31332, 31333, 31334, 31335, 31336, 31337, 31338, 31339, 31340, 31341, 31342, 31343, 31345, 31346, 31347, 31349, 31355, 31356, 31357, 31358, 31362, 31365, 31367, 31369, 31370, 31371, 31372, 31374, 31375, 31376, 31379, 31380, 31385, 31386, 31387, 31390, 31393, 31394, 36144, 21457, 32602, 31567, 20240, 20047, 38400, 27861, 29648, 34281, 24070, 30058, 32763, 27146, 30718, 38034, 32321, 20961, 28902, 21453, 36820, 33539, 36137, 29359, 39277, 27867, 22346, 33459, 26041, 32938, 25151, 38450, 22952, 20223, 35775, 32442, 25918, 33778, 38750, 21857, 39134, 32933, 21290, 35837, 21536, 32954, 24223, 27832, 36153, 33452, 37210, 21545, 27675, 20998, 32439, 22367, 28954, 27774, 31881, 22859, 20221, 24575, 24868, 31914, 20016, 23553, 26539, 34562, 23792, 38155, 39118, 30127, 28925, 36898, 20911, 32541, 35773, 22857, 20964, 20315, 21542, 22827, 25975, 32932, 23413, 25206, 25282, 36752, 24133, 27679, 31526, 20239, 20440, 26381, 31395, 31396, 31399, 31401, 31402, 31403, 31406, 31407, 31408, 31409, 31410, 31412, 31413, 31414, 31415, 31416, 31417, 31418, 31419, 31420, 31421, 31422, 31424, 31425, 31426, 31427, 31428, 31429, 31430, 31431, 31432, 31433, 31434, 31436, 31437, 31438, 31439, 31440, 31441, 31442, 31443, 31444, 31445, 31447, 31448, 31450, 31451, 31452, 31453, 31457, 31458, 31460, 31463, 31464, 31465, 31466, 31467, 31468, 31470, 31472, 31473, 31474, 31475, 31476, 31477, 31478, 31479, 31480, 31483, 31484, 31486, 31488, 31489, 31490, 31493, 31495, 31497, 31500, 31501, 31502, 31504, 31506, 31507, 31510, 31511, 31512, 31514, 31516, 31517, 31519, 31521, 31522, 31523, 31527, 31529, 31533, 28014, 28074, 31119, 34993, 24343, 29995, 25242, 36741, 20463, 37340, 26023, 33071, 33105, 24220, 33104, 36212, 21103, 35206, 36171, 22797, 20613, 20184, 38428, 29238, 33145, 36127, 23500, 35747, 38468, 22919, 32538, 21648, 22134, 22030, 35813, 25913, 27010, 38041, 30422, 28297, 24178, 29976, 26438, 26577, 31487, 32925, 36214, 24863, 31174, 25954, 36195, 20872, 21018, 38050, 32568, 32923, 32434, 23703, 28207, 26464, 31705, 30347, 39640, 33167, 32660, 31957, 25630, 38224, 31295, 21578, 21733, 27468, 25601, 25096, 40509, 33011, 30105, 21106, 38761, 33883, 26684, 34532, 38401, 38548, 38124, 20010, 21508, 32473, 26681, 36319, 32789, 26356, 24218, 32697, 31535, 31536, 31538, 31540, 31541, 31542, 31543, 31545, 31547, 31549, 31551, 31552, 31553, 31554, 31555, 31556, 31558, 31560, 31562, 31565, 31566, 31571, 31573, 31575, 31577, 31580, 31582, 31583, 31585, 31587, 31588, 31589, 31590, 31591, 31592, 31593, 31594, 31595, 31596, 31597, 31599, 31600, 31603, 31604, 31606, 31608, 31610, 31612, 31613, 31615, 31617, 31618, 31619, 31620, 31622, 31623, 31624, 31625, 31626, 31627, 31628, 31630, 31631, 31633, 31634, 31635, 31638, 31640, 31641, 31642, 31643, 31646, 31647, 31648, 31651, 31652, 31653, 31662, 31663, 31664, 31666, 31667, 31669, 31670, 31671, 31673, 31674, 31675, 31676, 31677, 31678, 31679, 31680, 31682, 31683, 31684, 22466, 32831, 26775, 24037, 25915, 21151, 24685, 40858, 20379, 36524, 20844, 23467, 24339, 24041, 27742, 25329, 36129, 20849, 38057, 21246, 27807, 33503, 29399, 22434, 26500, 36141, 22815, 36764, 33735, 21653, 31629, 20272, 27837, 23396, 22993, 40723, 21476, 34506, 39592, 35895, 32929, 25925, 39038, 22266, 38599, 21038, 29916, 21072, 23521, 25346, 35074, 20054, 25296, 24618, 26874, 20851, 23448, 20896, 35266, 31649, 39302, 32592, 24815, 28748, 36143, 20809, 24191, 36891, 29808, 35268, 22317, 30789, 24402, 40863, 38394, 36712, 39740, 35809, 30328, 26690, 26588, 36330, 36149, 21053, 36746, 28378, 26829, 38149, 37101, 22269, 26524, 35065, 36807, 21704, 31685, 31688, 31689, 31690, 31691, 31693, 31694, 31695, 31696, 31698, 31700, 31701, 31702, 31703, 31704, 31707, 31708, 31710, 31711, 31712, 31714, 31715, 31716, 31719, 31720, 31721, 31723, 31724, 31725, 31727, 31728, 31730, 31731, 31732, 31733, 31734, 31736, 31737, 31738, 31739, 31741, 31743, 31744, 31745, 31746, 31747, 31748, 31749, 31750, 31752, 31753, 31754, 31757, 31758, 31760, 31761, 31762, 31763, 31764, 31765, 31767, 31768, 31769, 31770, 31771, 31772, 31773, 31774, 31776, 31777, 31778, 31779, 31780, 31781, 31784, 31785, 31787, 31788, 31789, 31790, 31791, 31792, 31793, 31794, 31795, 31796, 31797, 31798, 31799, 31801, 31802, 31803, 31804, 31805, 31806, 31810, 39608, 23401, 28023, 27686, 20133, 23475, 39559, 37219, 25e3, 37039, 38889, 21547, 28085, 23506, 20989, 21898, 32597, 32752, 25788, 25421, 26097, 25022, 24717, 28938, 27735, 27721, 22831, 26477, 33322, 22741, 22158, 35946, 27627, 37085, 22909, 32791, 21495, 28009, 21621, 21917, 33655, 33743, 26680, 31166, 21644, 20309, 21512, 30418, 35977, 38402, 27827, 28088, 36203, 35088, 40548, 36154, 22079, 40657, 30165, 24456, 29408, 24680, 21756, 20136, 27178, 34913, 24658, 36720, 21700, 28888, 34425, 40511, 27946, 23439, 24344, 32418, 21897, 20399, 29492, 21564, 21402, 20505, 21518, 21628, 20046, 24573, 29786, 22774, 33899, 32993, 34676, 29392, 31946, 28246, 31811, 31812, 31813, 31814, 31815, 31816, 31817, 31818, 31819, 31820, 31822, 31823, 31824, 31825, 31826, 31827, 31828, 31829, 31830, 31831, 31832, 31833, 31834, 31835, 31836, 31837, 31838, 31839, 31840, 31841, 31842, 31843, 31844, 31845, 31846, 31847, 31848, 31849, 31850, 31851, 31852, 31853, 31854, 31855, 31856, 31857, 31858, 31861, 31862, 31863, 31864, 31865, 31866, 31870, 31871, 31872, 31873, 31874, 31875, 31876, 31877, 31878, 31879, 31880, 31882, 31883, 31884, 31885, 31886, 31887, 31888, 31891, 31892, 31894, 31897, 31898, 31899, 31904, 31905, 31907, 31910, 31911, 31912, 31913, 31915, 31916, 31917, 31919, 31920, 31924, 31925, 31926, 31927, 31928, 31930, 31931, 24359, 34382, 21804, 25252, 20114, 27818, 25143, 33457, 21719, 21326, 29502, 28369, 30011, 21010, 21270, 35805, 27088, 24458, 24576, 28142, 22351, 27426, 29615, 26707, 36824, 32531, 25442, 24739, 21796, 30186, 35938, 28949, 28067, 23462, 24187, 33618, 24908, 40644, 30970, 34647, 31783, 30343, 20976, 24822, 29004, 26179, 24140, 24653, 35854, 28784, 25381, 36745, 24509, 24674, 34516, 22238, 27585, 24724, 24935, 21321, 24800, 26214, 36159, 31229, 20250, 28905, 27719, 35763, 35826, 32472, 33636, 26127, 23130, 39746, 27985, 28151, 35905, 27963, 20249, 28779, 33719, 25110, 24785, 38669, 36135, 31096, 20987, 22334, 22522, 26426, 30072, 31293, 31215, 31637, 31935, 31936, 31938, 31939, 31940, 31942, 31945, 31947, 31950, 31951, 31952, 31953, 31954, 31955, 31956, 31960, 31962, 31963, 31965, 31966, 31969, 31970, 31971, 31972, 31973, 31974, 31975, 31977, 31978, 31979, 31980, 31981, 31982, 31984, 31985, 31986, 31987, 31988, 31989, 31990, 31991, 31993, 31994, 31996, 31997, 31998, 31999, 32e3, 32001, 32002, 32003, 32004, 32005, 32006, 32007, 32008, 32009, 32011, 32012, 32013, 32014, 32015, 32016, 32017, 32018, 32019, 32020, 32021, 32022, 32023, 32024, 32025, 32026, 32027, 32028, 32029, 32030, 32031, 32033, 32035, 32036, 32037, 32038, 32040, 32041, 32042, 32044, 32045, 32046, 32048, 32049, 32050, 32051, 32052, 32053, 32054, 32908, 39269, 36857, 28608, 35749, 40481, 23020, 32489, 32521, 21513, 26497, 26840, 36753, 31821, 38598, 21450, 24613, 30142, 27762, 21363, 23241, 32423, 25380, 20960, 33034, 24049, 34015, 25216, 20864, 23395, 20238, 31085, 21058, 24760, 27982, 23492, 23490, 35745, 35760, 26082, 24524, 38469, 22931, 32487, 32426, 22025, 26551, 22841, 20339, 23478, 21152, 33626, 39050, 36158, 30002, 38078, 20551, 31292, 20215, 26550, 39550, 23233, 27516, 30417, 22362, 23574, 31546, 38388, 29006, 20860, 32937, 33392, 22904, 32516, 33575, 26816, 26604, 30897, 30839, 25315, 25441, 31616, 20461, 21098, 20943, 33616, 27099, 37492, 36341, 36145, 35265, 38190, 31661, 20214, 32055, 32056, 32057, 32058, 32059, 32060, 32061, 32062, 32063, 32064, 32065, 32066, 32067, 32068, 32069, 32070, 32071, 32072, 32073, 32074, 32075, 32076, 32077, 32078, 32079, 32080, 32081, 32082, 32083, 32084, 32085, 32086, 32087, 32088, 32089, 32090, 32091, 32092, 32093, 32094, 32095, 32096, 32097, 32098, 32099, 32100, 32101, 32102, 32103, 32104, 32105, 32106, 32107, 32108, 32109, 32111, 32112, 32113, 32114, 32115, 32116, 32117, 32118, 32120, 32121, 32122, 32123, 32124, 32125, 32126, 32127, 32128, 32129, 32130, 32131, 32132, 32133, 32134, 32135, 32136, 32137, 32138, 32139, 32140, 32141, 32142, 32143, 32144, 32145, 32146, 32147, 32148, 32149, 32150, 32151, 32152, 20581, 33328, 21073, 39279, 28176, 28293, 28071, 24314, 20725, 23004, 23558, 27974, 27743, 30086, 33931, 26728, 22870, 35762, 21280, 37233, 38477, 34121, 26898, 30977, 28966, 33014, 20132, 37066, 27975, 39556, 23047, 22204, 25605, 38128, 30699, 20389, 33050, 29409, 35282, 39290, 32564, 32478, 21119, 25945, 37237, 36735, 36739, 21483, 31382, 25581, 25509, 30342, 31224, 34903, 38454, 25130, 21163, 33410, 26708, 26480, 25463, 30571, 31469, 27905, 32467, 35299, 22992, 25106, 34249, 33445, 30028, 20511, 20171, 30117, 35819, 23626, 24062, 31563, 26020, 37329, 20170, 27941, 35167, 32039, 38182, 20165, 35880, 36827, 38771, 26187, 31105, 36817, 28908, 28024, 32153, 32154, 32155, 32156, 32157, 32158, 32159, 32160, 32161, 32162, 32163, 32164, 32165, 32167, 32168, 32169, 32170, 32171, 32172, 32173, 32175, 32176, 32177, 32178, 32179, 32180, 32181, 32182, 32183, 32184, 32185, 32186, 32187, 32188, 32189, 32190, 32191, 32192, 32193, 32194, 32195, 32196, 32197, 32198, 32199, 32200, 32201, 32202, 32203, 32204, 32205, 32206, 32207, 32208, 32209, 32210, 32211, 32212, 32213, 32214, 32215, 32216, 32217, 32218, 32219, 32220, 32221, 32222, 32223, 32224, 32225, 32226, 32227, 32228, 32229, 32230, 32231, 32232, 32233, 32234, 32235, 32236, 32237, 32238, 32239, 32240, 32241, 32242, 32243, 32244, 32245, 32246, 32247, 32248, 32249, 32250, 23613, 21170, 33606, 20834, 33550, 30555, 26230, 40120, 20140, 24778, 31934, 31923, 32463, 20117, 35686, 26223, 39048, 38745, 22659, 25964, 38236, 24452, 30153, 38742, 31455, 31454, 20928, 28847, 31384, 25578, 31350, 32416, 29590, 38893, 20037, 28792, 20061, 37202, 21417, 25937, 26087, 33276, 33285, 21646, 23601, 30106, 38816, 25304, 29401, 30141, 23621, 39545, 33738, 23616, 21632, 30697, 20030, 27822, 32858, 25298, 25454, 24040, 20855, 36317, 36382, 38191, 20465, 21477, 24807, 28844, 21095, 25424, 40515, 23071, 20518, 30519, 21367, 32482, 25733, 25899, 25225, 25496, 20500, 29237, 35273, 20915, 35776, 32477, 22343, 33740, 38055, 20891, 21531, 23803, 32251, 32252, 32253, 32254, 32255, 32256, 32257, 32258, 32259, 32260, 32261, 32262, 32263, 32264, 32265, 32266, 32267, 32268, 32269, 32270, 32271, 32272, 32273, 32274, 32275, 32276, 32277, 32278, 32279, 32280, 32281, 32282, 32283, 32284, 32285, 32286, 32287, 32288, 32289, 32290, 32291, 32292, 32293, 32294, 32295, 32296, 32297, 32298, 32299, 32300, 32301, 32302, 32303, 32304, 32305, 32306, 32307, 32308, 32309, 32310, 32311, 32312, 32313, 32314, 32316, 32317, 32318, 32319, 32320, 32322, 32323, 32324, 32325, 32326, 32328, 32329, 32330, 32331, 32332, 32333, 32334, 32335, 32336, 32337, 32338, 32339, 32340, 32341, 32342, 32343, 32344, 32345, 32346, 32347, 32348, 32349, 20426, 31459, 27994, 37089, 39567, 21888, 21654, 21345, 21679, 24320, 25577, 26999, 20975, 24936, 21002, 22570, 21208, 22350, 30733, 30475, 24247, 24951, 31968, 25179, 25239, 20130, 28821, 32771, 25335, 28900, 38752, 22391, 33499, 26607, 26869, 30933, 39063, 31185, 22771, 21683, 21487, 28212, 20811, 21051, 23458, 35838, 32943, 21827, 22438, 24691, 22353, 21549, 31354, 24656, 23380, 25511, 25248, 21475, 25187, 23495, 26543, 21741, 31391, 33510, 37239, 24211, 35044, 22840, 22446, 25358, 36328, 33007, 22359, 31607, 20393, 24555, 23485, 27454, 21281, 31568, 29378, 26694, 30719, 30518, 26103, 20917, 20111, 30420, 23743, 31397, 33909, 22862, 39745, 20608, 32350, 32351, 32352, 32353, 32354, 32355, 32356, 32357, 32358, 32359, 32360, 32361, 32362, 32363, 32364, 32365, 32366, 32367, 32368, 32369, 32370, 32371, 32372, 32373, 32374, 32375, 32376, 32377, 32378, 32379, 32380, 32381, 32382, 32383, 32384, 32385, 32387, 32388, 32389, 32390, 32391, 32392, 32393, 32394, 32395, 32396, 32397, 32398, 32399, 32400, 32401, 32402, 32403, 32404, 32405, 32406, 32407, 32408, 32409, 32410, 32412, 32413, 32414, 32430, 32436, 32443, 32444, 32470, 32484, 32492, 32505, 32522, 32528, 32542, 32567, 32569, 32571, 32572, 32573, 32574, 32575, 32576, 32577, 32579, 32582, 32583, 32584, 32585, 32586, 32587, 32588, 32589, 32590, 32591, 32594, 32595, 39304, 24871, 28291, 22372, 26118, 25414, 22256, 25324, 25193, 24275, 38420, 22403, 25289, 21895, 34593, 33098, 36771, 21862, 33713, 26469, 36182, 34013, 23146, 26639, 25318, 31726, 38417, 20848, 28572, 35888, 25597, 35272, 25042, 32518, 28866, 28389, 29701, 27028, 29436, 24266, 37070, 26391, 28010, 25438, 21171, 29282, 32769, 20332, 23013, 37226, 28889, 28061, 21202, 20048, 38647, 38253, 34174, 30922, 32047, 20769, 22418, 25794, 32907, 31867, 27882, 26865, 26974, 20919, 21400, 26792, 29313, 40654, 31729, 29432, 31163, 28435, 29702, 26446, 37324, 40100, 31036, 33673, 33620, 21519, 26647, 20029, 21385, 21169, 30782, 21382, 21033, 20616, 20363, 20432, 32598, 32601, 32603, 32604, 32605, 32606, 32608, 32611, 32612, 32613, 32614, 32615, 32619, 32620, 32621, 32623, 32624, 32627, 32629, 32630, 32631, 32632, 32634, 32635, 32636, 32637, 32639, 32640, 32642, 32643, 32644, 32645, 32646, 32647, 32648, 32649, 32651, 32653, 32655, 32656, 32657, 32658, 32659, 32661, 32662, 32663, 32664, 32665, 32667, 32668, 32672, 32674, 32675, 32677, 32678, 32680, 32681, 32682, 32683, 32684, 32685, 32686, 32689, 32691, 32692, 32693, 32694, 32695, 32698, 32699, 32702, 32704, 32706, 32707, 32708, 32710, 32711, 32712, 32713, 32715, 32717, 32719, 32720, 32721, 32722, 32723, 32726, 32727, 32729, 32730, 32731, 32732, 32733, 32734, 32738, 32739, 30178, 31435, 31890, 27813, 38582, 21147, 29827, 21737, 20457, 32852, 33714, 36830, 38256, 24265, 24604, 28063, 24088, 25947, 33080, 38142, 24651, 28860, 32451, 31918, 20937, 26753, 31921, 33391, 20004, 36742, 37327, 26238, 20142, 35845, 25769, 32842, 20698, 30103, 29134, 23525, 36797, 28518, 20102, 25730, 38243, 24278, 26009, 21015, 35010, 28872, 21155, 29454, 29747, 26519, 30967, 38678, 20020, 37051, 40158, 28107, 20955, 36161, 21533, 25294, 29618, 33777, 38646, 40836, 38083, 20278, 32666, 20940, 28789, 38517, 23725, 39046, 21478, 20196, 28316, 29705, 27060, 30827, 39311, 30041, 21016, 30244, 27969, 26611, 20845, 40857, 32843, 21657, 31548, 31423, 32740, 32743, 32744, 32746, 32747, 32748, 32749, 32751, 32754, 32756, 32757, 32758, 32759, 32760, 32761, 32762, 32765, 32766, 32767, 32770, 32775, 32776, 32777, 32778, 32782, 32783, 32785, 32787, 32794, 32795, 32797, 32798, 32799, 32801, 32803, 32804, 32811, 32812, 32813, 32814, 32815, 32816, 32818, 32820, 32825, 32826, 32828, 32830, 32832, 32833, 32836, 32837, 32839, 32840, 32841, 32846, 32847, 32848, 32849, 32851, 32853, 32854, 32855, 32857, 32859, 32860, 32861, 32862, 32863, 32864, 32865, 32866, 32867, 32868, 32869, 32870, 32871, 32872, 32875, 32876, 32877, 32878, 32879, 32880, 32882, 32883, 32884, 32885, 32886, 32887, 32888, 32889, 32890, 32891, 32892, 32893, 38534, 22404, 25314, 38471, 27004, 23044, 25602, 31699, 28431, 38475, 33446, 21346, 39045, 24208, 28809, 25523, 21348, 34383, 40065, 40595, 30860, 38706, 36335, 36162, 40575, 28510, 31108, 24405, 38470, 25134, 39540, 21525, 38109, 20387, 26053, 23653, 23649, 32533, 34385, 27695, 24459, 29575, 28388, 32511, 23782, 25371, 23402, 28390, 21365, 20081, 25504, 30053, 25249, 36718, 20262, 20177, 27814, 32438, 35770, 33821, 34746, 32599, 36923, 38179, 31657, 39585, 35064, 33853, 27931, 39558, 32476, 22920, 40635, 29595, 30721, 34434, 39532, 39554, 22043, 21527, 22475, 20080, 40614, 21334, 36808, 33033, 30610, 39314, 34542, 28385, 34067, 26364, 24930, 28459, 32894, 32897, 32898, 32901, 32904, 32906, 32909, 32910, 32911, 32912, 32913, 32914, 32916, 32917, 32919, 32921, 32926, 32931, 32934, 32935, 32936, 32940, 32944, 32947, 32949, 32950, 32952, 32953, 32955, 32965, 32967, 32968, 32969, 32970, 32971, 32975, 32976, 32977, 32978, 32979, 32980, 32981, 32984, 32991, 32992, 32994, 32995, 32998, 33006, 33013, 33015, 33017, 33019, 33022, 33023, 33024, 33025, 33027, 33028, 33029, 33031, 33032, 33035, 33036, 33045, 33047, 33049, 33051, 33052, 33053, 33055, 33056, 33057, 33058, 33059, 33060, 33061, 33062, 33063, 33064, 33065, 33066, 33067, 33069, 33070, 33072, 33075, 33076, 33077, 33079, 33081, 33082, 33083, 33084, 33085, 33087, 35881, 33426, 33579, 30450, 27667, 24537, 33725, 29483, 33541, 38170, 27611, 30683, 38086, 21359, 33538, 20882, 24125, 35980, 36152, 20040, 29611, 26522, 26757, 37238, 38665, 29028, 27809, 30473, 23186, 38209, 27599, 32654, 26151, 23504, 22969, 23194, 38376, 38391, 20204, 33804, 33945, 27308, 30431, 38192, 29467, 26790, 23391, 30511, 37274, 38753, 31964, 36855, 35868, 24357, 31859, 31192, 35269, 27852, 34588, 23494, 24130, 26825, 30496, 32501, 20885, 20813, 21193, 23081, 32517, 38754, 33495, 25551, 30596, 34256, 31186, 28218, 24217, 22937, 34065, 28781, 27665, 25279, 30399, 25935, 24751, 38397, 26126, 34719, 40483, 38125, 21517, 21629, 35884, 25720, 33088, 33089, 33090, 33091, 33092, 33093, 33095, 33097, 33101, 33102, 33103, 33106, 33110, 33111, 33112, 33115, 33116, 33117, 33118, 33119, 33121, 33122, 33123, 33124, 33126, 33128, 33130, 33131, 33132, 33135, 33138, 33139, 33141, 33142, 33143, 33144, 33153, 33155, 33156, 33157, 33158, 33159, 33161, 33163, 33164, 33165, 33166, 33168, 33170, 33171, 33172, 33173, 33174, 33175, 33177, 33178, 33182, 33183, 33184, 33185, 33186, 33188, 33189, 33191, 33193, 33195, 33196, 33197, 33198, 33199, 33200, 33201, 33202, 33204, 33205, 33206, 33207, 33208, 33209, 33212, 33213, 33214, 33215, 33220, 33221, 33223, 33224, 33225, 33227, 33229, 33230, 33231, 33232, 33233, 33234, 33235, 25721, 34321, 27169, 33180, 30952, 25705, 39764, 25273, 26411, 33707, 22696, 40664, 27819, 28448, 23518, 38476, 35851, 29279, 26576, 25287, 29281, 20137, 22982, 27597, 22675, 26286, 24149, 21215, 24917, 26408, 30446, 30566, 29287, 31302, 25343, 21738, 21584, 38048, 37027, 23068, 32435, 27670, 20035, 22902, 32784, 22856, 21335, 30007, 38590, 22218, 25376, 33041, 24700, 38393, 28118, 21602, 39297, 20869, 23273, 33021, 22958, 38675, 20522, 27877, 23612, 25311, 20320, 21311, 33147, 36870, 28346, 34091, 25288, 24180, 30910, 25781, 25467, 24565, 23064, 37247, 40479, 23615, 25423, 32834, 23421, 21870, 38218, 38221, 28037, 24744, 26592, 29406, 20957, 23425, 33236, 33237, 33238, 33239, 33240, 33241, 33242, 33243, 33244, 33245, 33246, 33247, 33248, 33249, 33250, 33252, 33253, 33254, 33256, 33257, 33259, 33262, 33263, 33264, 33265, 33266, 33269, 33270, 33271, 33272, 33273, 33274, 33277, 33279, 33283, 33287, 33288, 33289, 33290, 33291, 33294, 33295, 33297, 33299, 33301, 33302, 33303, 33304, 33305, 33306, 33309, 33312, 33316, 33317, 33318, 33319, 33321, 33326, 33330, 33338, 33340, 33341, 33343, 33344, 33345, 33346, 33347, 33349, 33350, 33352, 33354, 33356, 33357, 33358, 33360, 33361, 33362, 33363, 33364, 33365, 33366, 33367, 33369, 33371, 33372, 33373, 33374, 33376, 33377, 33378, 33379, 33380, 33381, 33382, 33383, 33385, 25319, 27870, 29275, 25197, 38062, 32445, 33043, 27987, 20892, 24324, 22900, 21162, 24594, 22899, 26262, 34384, 30111, 25386, 25062, 31983, 35834, 21734, 27431, 40485, 27572, 34261, 21589, 20598, 27812, 21866, 36276, 29228, 24085, 24597, 29750, 25293, 25490, 29260, 24472, 28227, 27966, 25856, 28504, 30424, 30928, 30460, 30036, 21028, 21467, 20051, 24222, 26049, 32810, 32982, 25243, 21638, 21032, 28846, 34957, 36305, 27873, 21624, 32986, 22521, 35060, 36180, 38506, 37197, 20329, 27803, 21943, 30406, 30768, 25256, 28921, 28558, 24429, 34028, 26842, 30844, 31735, 33192, 26379, 40527, 25447, 30896, 22383, 30738, 38713, 25209, 25259, 21128, 29749, 27607, 33386, 33387, 33388, 33389, 33393, 33397, 33398, 33399, 33400, 33403, 33404, 33408, 33409, 33411, 33413, 33414, 33415, 33417, 33420, 33424, 33427, 33428, 33429, 33430, 33434, 33435, 33438, 33440, 33442, 33443, 33447, 33458, 33461, 33462, 33466, 33467, 33468, 33471, 33472, 33474, 33475, 33477, 33478, 33481, 33488, 33494, 33497, 33498, 33501, 33506, 33511, 33512, 33513, 33514, 33516, 33517, 33518, 33520, 33522, 33523, 33525, 33526, 33528, 33530, 33532, 33533, 33534, 33535, 33536, 33546, 33547, 33549, 33552, 33554, 33555, 33558, 33560, 33561, 33565, 33566, 33567, 33568, 33569, 33570, 33571, 33572, 33573, 33574, 33577, 33578, 33582, 33584, 33586, 33591, 33595, 33597, 21860, 33086, 30130, 30382, 21305, 30174, 20731, 23617, 35692, 31687, 20559, 29255, 39575, 39128, 28418, 29922, 31080, 25735, 30629, 25340, 39057, 36139, 21697, 32856, 20050, 22378, 33529, 33805, 24179, 20973, 29942, 35780, 23631, 22369, 27900, 39047, 23110, 30772, 39748, 36843, 31893, 21078, 25169, 38138, 20166, 33670, 33889, 33769, 33970, 22484, 26420, 22275, 26222, 28006, 35889, 26333, 28689, 26399, 27450, 26646, 25114, 22971, 19971, 20932, 28422, 26578, 27791, 20854, 26827, 22855, 27495, 30054, 23822, 33040, 40784, 26071, 31048, 31041, 39569, 36215, 23682, 20062, 20225, 21551, 22865, 30732, 22120, 27668, 36804, 24323, 27773, 27875, 35755, 25488, 33598, 33599, 33601, 33602, 33604, 33605, 33608, 33610, 33611, 33612, 33613, 33614, 33619, 33621, 33622, 33623, 33624, 33625, 33629, 33634, 33648, 33649, 33650, 33651, 33652, 33653, 33654, 33657, 33658, 33662, 33663, 33664, 33665, 33666, 33667, 33668, 33671, 33672, 33674, 33675, 33676, 33677, 33679, 33680, 33681, 33684, 33685, 33686, 33687, 33689, 33690, 33693, 33695, 33697, 33698, 33699, 33700, 33701, 33702, 33703, 33708, 33709, 33710, 33711, 33717, 33723, 33726, 33727, 33730, 33731, 33732, 33734, 33736, 33737, 33739, 33741, 33742, 33744, 33745, 33746, 33747, 33749, 33751, 33753, 33754, 33755, 33758, 33762, 33763, 33764, 33766, 33767, 33768, 33771, 33772, 33773, 24688, 27965, 29301, 25190, 38030, 38085, 21315, 36801, 31614, 20191, 35878, 20094, 40660, 38065, 38067, 21069, 28508, 36963, 27973, 35892, 22545, 23884, 27424, 27465, 26538, 21595, 33108, 32652, 22681, 34103, 24378, 25250, 27207, 38201, 25970, 24708, 26725, 30631, 20052, 20392, 24039, 38808, 25772, 32728, 23789, 20431, 31373, 20999, 33540, 19988, 24623, 31363, 38054, 20405, 20146, 31206, 29748, 21220, 33465, 25810, 31165, 23517, 27777, 38738, 36731, 27682, 20542, 21375, 28165, 25806, 26228, 27696, 24773, 39031, 35831, 24198, 29756, 31351, 31179, 19992, 37041, 29699, 27714, 22234, 37195, 27845, 36235, 21306, 34502, 26354, 36527, 23624, 39537, 28192, 33774, 33775, 33779, 33780, 33781, 33782, 33783, 33786, 33787, 33788, 33790, 33791, 33792, 33794, 33797, 33799, 33800, 33801, 33802, 33808, 33810, 33811, 33812, 33813, 33814, 33815, 33817, 33818, 33819, 33822, 33823, 33824, 33825, 33826, 33827, 33833, 33834, 33835, 33836, 33837, 33838, 33839, 33840, 33842, 33843, 33844, 33845, 33846, 33847, 33849, 33850, 33851, 33854, 33855, 33856, 33857, 33858, 33859, 33860, 33861, 33863, 33864, 33865, 33866, 33867, 33868, 33869, 33870, 33871, 33872, 33874, 33875, 33876, 33877, 33878, 33880, 33885, 33886, 33887, 33888, 33890, 33892, 33893, 33894, 33895, 33896, 33898, 33902, 33903, 33904, 33906, 33908, 33911, 33913, 33915, 33916, 21462, 23094, 40843, 36259, 21435, 22280, 39079, 26435, 37275, 27849, 20840, 30154, 25331, 29356, 21048, 21149, 32570, 28820, 30264, 21364, 40522, 27063, 30830, 38592, 35033, 32676, 28982, 29123, 20873, 26579, 29924, 22756, 25880, 22199, 35753, 39286, 25200, 32469, 24825, 28909, 22764, 20161, 20154, 24525, 38887, 20219, 35748, 20995, 22922, 32427, 25172, 20173, 26085, 25102, 33592, 33993, 33635, 34701, 29076, 28342, 23481, 32466, 20887, 25545, 26580, 32905, 33593, 34837, 20754, 23418, 22914, 36785, 20083, 27741, 20837, 35109, 36719, 38446, 34122, 29790, 38160, 38384, 28070, 33509, 24369, 25746, 27922, 33832, 33134, 40131, 22622, 36187, 19977, 21441, 33917, 33918, 33919, 33920, 33921, 33923, 33924, 33925, 33926, 33930, 33933, 33935, 33936, 33937, 33938, 33939, 33940, 33941, 33942, 33944, 33946, 33947, 33949, 33950, 33951, 33952, 33954, 33955, 33956, 33957, 33958, 33959, 33960, 33961, 33962, 33963, 33964, 33965, 33966, 33968, 33969, 33971, 33973, 33974, 33975, 33979, 33980, 33982, 33984, 33986, 33987, 33989, 33990, 33991, 33992, 33995, 33996, 33998, 33999, 34002, 34004, 34005, 34007, 34008, 34009, 34010, 34011, 34012, 34014, 34017, 34018, 34020, 34023, 34024, 34025, 34026, 34027, 34029, 34030, 34031, 34033, 34034, 34035, 34036, 34037, 34038, 34039, 34040, 34041, 34042, 34043, 34045, 34046, 34048, 34049, 34050, 20254, 25955, 26705, 21971, 20007, 25620, 39578, 25195, 23234, 29791, 33394, 28073, 26862, 20711, 33678, 30722, 26432, 21049, 27801, 32433, 20667, 21861, 29022, 31579, 26194, 29642, 33515, 26441, 23665, 21024, 29053, 34923, 38378, 38485, 25797, 36193, 33203, 21892, 27733, 25159, 32558, 22674, 20260, 21830, 36175, 26188, 19978, 23578, 35059, 26786, 25422, 31245, 28903, 33421, 21242, 38902, 23569, 21736, 37045, 32461, 22882, 36170, 34503, 33292, 33293, 36198, 25668, 23556, 24913, 28041, 31038, 35774, 30775, 30003, 21627, 20280, 36523, 28145, 23072, 32453, 31070, 27784, 23457, 23158, 29978, 32958, 24910, 28183, 22768, 29983, 29989, 29298, 21319, 32499, 34051, 34052, 34053, 34054, 34055, 34056, 34057, 34058, 34059, 34061, 34062, 34063, 34064, 34066, 34068, 34069, 34070, 34072, 34073, 34075, 34076, 34077, 34078, 34080, 34082, 34083, 34084, 34085, 34086, 34087, 34088, 34089, 34090, 34093, 34094, 34095, 34096, 34097, 34098, 34099, 34100, 34101, 34102, 34110, 34111, 34112, 34113, 34114, 34116, 34117, 34118, 34119, 34123, 34124, 34125, 34126, 34127, 34128, 34129, 34130, 34131, 34132, 34133, 34135, 34136, 34138, 34139, 34140, 34141, 34143, 34144, 34145, 34146, 34147, 34149, 34150, 34151, 34153, 34154, 34155, 34156, 34157, 34158, 34159, 34160, 34161, 34163, 34165, 34166, 34167, 34168, 34172, 34173, 34175, 34176, 34177, 30465, 30427, 21097, 32988, 22307, 24072, 22833, 29422, 26045, 28287, 35799, 23608, 34417, 21313, 30707, 25342, 26102, 20160, 39135, 34432, 23454, 35782, 21490, 30690, 20351, 23630, 39542, 22987, 24335, 31034, 22763, 19990, 26623, 20107, 25325, 35475, 36893, 21183, 26159, 21980, 22124, 36866, 20181, 20365, 37322, 39280, 27663, 24066, 24643, 23460, 35270, 35797, 25910, 25163, 39318, 23432, 23551, 25480, 21806, 21463, 30246, 20861, 34092, 26530, 26803, 27530, 25234, 36755, 21460, 33298, 28113, 30095, 20070, 36174, 23408, 29087, 34223, 26257, 26329, 32626, 34560, 40653, 40736, 23646, 26415, 36848, 26641, 26463, 25101, 31446, 22661, 24246, 25968, 28465, 34178, 34179, 34182, 34184, 34185, 34186, 34187, 34188, 34189, 34190, 34192, 34193, 34194, 34195, 34196, 34197, 34198, 34199, 34200, 34201, 34202, 34205, 34206, 34207, 34208, 34209, 34210, 34211, 34213, 34214, 34215, 34217, 34219, 34220, 34221, 34225, 34226, 34227, 34228, 34229, 34230, 34232, 34234, 34235, 34236, 34237, 34238, 34239, 34240, 34242, 34243, 34244, 34245, 34246, 34247, 34248, 34250, 34251, 34252, 34253, 34254, 34257, 34258, 34260, 34262, 34263, 34264, 34265, 34266, 34267, 34269, 34270, 34271, 34272, 34273, 34274, 34275, 34277, 34278, 34279, 34280, 34282, 34283, 34284, 34285, 34286, 34287, 34288, 34289, 34290, 34291, 34292, 34293, 34294, 34295, 34296, 24661, 21047, 32781, 25684, 34928, 29993, 24069, 26643, 25332, 38684, 21452, 29245, 35841, 27700, 30561, 31246, 21550, 30636, 39034, 33308, 35828, 30805, 26388, 28865, 26031, 25749, 22070, 24605, 31169, 21496, 19997, 27515, 32902, 23546, 21987, 22235, 20282, 20284, 39282, 24051, 26494, 32824, 24578, 39042, 36865, 23435, 35772, 35829, 25628, 33368, 25822, 22013, 33487, 37221, 20439, 32032, 36895, 31903, 20723, 22609, 28335, 23487, 35785, 32899, 37240, 33948, 31639, 34429, 38539, 38543, 32485, 39635, 30862, 23681, 31319, 36930, 38567, 31071, 23385, 25439, 31499, 34001, 26797, 21766, 32553, 29712, 32034, 38145, 25152, 22604, 20182, 23427, 22905, 22612, 34297, 34298, 34300, 34301, 34302, 34304, 34305, 34306, 34307, 34308, 34310, 34311, 34312, 34313, 34314, 34315, 34316, 34317, 34318, 34319, 34320, 34322, 34323, 34324, 34325, 34327, 34328, 34329, 34330, 34331, 34332, 34333, 34334, 34335, 34336, 34337, 34338, 34339, 34340, 34341, 34342, 34344, 34346, 34347, 34348, 34349, 34350, 34351, 34352, 34353, 34354, 34355, 34356, 34357, 34358, 34359, 34361, 34362, 34363, 34365, 34366, 34367, 34368, 34369, 34370, 34371, 34372, 34373, 34374, 34375, 34376, 34377, 34378, 34379, 34380, 34386, 34387, 34389, 34390, 34391, 34392, 34393, 34395, 34396, 34397, 34399, 34400, 34401, 34403, 34404, 34405, 34406, 34407, 34408, 34409, 34410, 29549, 25374, 36427, 36367, 32974, 33492, 25260, 21488, 27888, 37214, 22826, 24577, 27760, 22349, 25674, 36138, 30251, 28393, 22363, 27264, 30192, 28525, 35885, 35848, 22374, 27631, 34962, 30899, 25506, 21497, 28845, 27748, 22616, 25642, 22530, 26848, 33179, 21776, 31958, 20504, 36538, 28108, 36255, 28907, 25487, 28059, 28372, 32486, 33796, 26691, 36867, 28120, 38518, 35752, 22871, 29305, 34276, 33150, 30140, 35466, 26799, 21076, 36386, 38161, 25552, 39064, 36420, 21884, 20307, 26367, 22159, 24789, 28053, 21059, 23625, 22825, 28155, 22635, 3e4, 29980, 24684, 33300, 33094, 25361, 26465, 36834, 30522, 36339, 36148, 38081, 24086, 21381, 21548, 28867, 34413, 34415, 34416, 34418, 34419, 34420, 34421, 34422, 34423, 34424, 34435, 34436, 34437, 34438, 34439, 34440, 34441, 34446, 34447, 34448, 34449, 34450, 34452, 34454, 34455, 34456, 34457, 34458, 34459, 34462, 34463, 34464, 34465, 34466, 34469, 34470, 34475, 34477, 34478, 34482, 34483, 34487, 34488, 34489, 34491, 34492, 34493, 34494, 34495, 34497, 34498, 34499, 34501, 34504, 34508, 34509, 34514, 34515, 34517, 34518, 34519, 34522, 34524, 34525, 34528, 34529, 34530, 34531, 34533, 34534, 34535, 34536, 34538, 34539, 34540, 34543, 34549, 34550, 34551, 34554, 34555, 34556, 34557, 34559, 34561, 34564, 34565, 34566, 34571, 34572, 34574, 34575, 34576, 34577, 34580, 34582, 27712, 24311, 20572, 20141, 24237, 25402, 33351, 36890, 26704, 37230, 30643, 21516, 38108, 24420, 31461, 26742, 25413, 31570, 32479, 30171, 20599, 25237, 22836, 36879, 20984, 31171, 31361, 22270, 24466, 36884, 28034, 23648, 22303, 21520, 20820, 28237, 22242, 25512, 39059, 33151, 34581, 35114, 36864, 21534, 23663, 33216, 25302, 25176, 33073, 40501, 38464, 39534, 39548, 26925, 22949, 25299, 21822, 25366, 21703, 34521, 27964, 23043, 29926, 34972, 27498, 22806, 35916, 24367, 28286, 29609, 39037, 20024, 28919, 23436, 30871, 25405, 26202, 30358, 24779, 23451, 23113, 19975, 33109, 27754, 29579, 20129, 26505, 32593, 24448, 26106, 26395, 24536, 22916, 23041, 34585, 34587, 34589, 34591, 34592, 34596, 34598, 34599, 34600, 34602, 34603, 34604, 34605, 34607, 34608, 34610, 34611, 34613, 34614, 34616, 34617, 34618, 34620, 34621, 34624, 34625, 34626, 34627, 34628, 34629, 34630, 34634, 34635, 34637, 34639, 34640, 34641, 34642, 34644, 34645, 34646, 34648, 34650, 34651, 34652, 34653, 34654, 34655, 34657, 34658, 34662, 34663, 34664, 34665, 34666, 34667, 34668, 34669, 34671, 34673, 34674, 34675, 34677, 34679, 34680, 34681, 34682, 34687, 34688, 34689, 34692, 34694, 34695, 34697, 34698, 34700, 34702, 34703, 34704, 34705, 34706, 34708, 34709, 34710, 34712, 34713, 34714, 34715, 34716, 34717, 34718, 34720, 34721, 34722, 34723, 34724, 24013, 24494, 21361, 38886, 36829, 26693, 22260, 21807, 24799, 20026, 28493, 32500, 33479, 33806, 22996, 20255, 20266, 23614, 32428, 26410, 34074, 21619, 30031, 32963, 21890, 39759, 20301, 28205, 35859, 23561, 24944, 21355, 30239, 28201, 34442, 25991, 38395, 32441, 21563, 31283, 32010, 38382, 21985, 32705, 29934, 25373, 34583, 28065, 31389, 25105, 26017, 21351, 25569, 27779, 24043, 21596, 38056, 20044, 27745, 35820, 23627, 26080, 33436, 26791, 21566, 21556, 27595, 27494, 20116, 25410, 21320, 33310, 20237, 20398, 22366, 25098, 38654, 26212, 29289, 21247, 21153, 24735, 35823, 26132, 29081, 26512, 35199, 30802, 30717, 26224, 22075, 21560, 38177, 29306, 34725, 34726, 34727, 34729, 34730, 34734, 34736, 34737, 34738, 34740, 34742, 34743, 34744, 34745, 34747, 34748, 34750, 34751, 34753, 34754, 34755, 34756, 34757, 34759, 34760, 34761, 34764, 34765, 34766, 34767, 34768, 34772, 34773, 34774, 34775, 34776, 34777, 34778, 34780, 34781, 34782, 34783, 34785, 34786, 34787, 34788, 34790, 34791, 34792, 34793, 34795, 34796, 34797, 34799, 34800, 34801, 34802, 34803, 34804, 34805, 34806, 34807, 34808, 34810, 34811, 34812, 34813, 34815, 34816, 34817, 34818, 34820, 34821, 34822, 34823, 34824, 34825, 34827, 34828, 34829, 34830, 34831, 34832, 34833, 34834, 34836, 34839, 34840, 34841, 34842, 34844, 34845, 34846, 34847, 34848, 34851, 31232, 24687, 24076, 24713, 33181, 22805, 24796, 29060, 28911, 28330, 27728, 29312, 27268, 34989, 24109, 20064, 23219, 21916, 38115, 27927, 31995, 38553, 25103, 32454, 30606, 34430, 21283, 38686, 36758, 26247, 23777, 20384, 29421, 19979, 21414, 22799, 21523, 25472, 38184, 20808, 20185, 40092, 32420, 21688, 36132, 34900, 33335, 38386, 28046, 24358, 23244, 26174, 38505, 29616, 29486, 21439, 33146, 39301, 32673, 23466, 38519, 38480, 32447, 30456, 21410, 38262, 39321, 31665, 35140, 28248, 20065, 32724, 31077, 35814, 24819, 21709, 20139, 39033, 24055, 27233, 20687, 21521, 35937, 33831, 30813, 38660, 21066, 21742, 22179, 38144, 28040, 23477, 28102, 26195, 34852, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34867, 34868, 34869, 34870, 34871, 34872, 34874, 34875, 34877, 34878, 34879, 34881, 34882, 34883, 34886, 34887, 34888, 34889, 34890, 34891, 34894, 34895, 34896, 34897, 34898, 34899, 34901, 34902, 34904, 34906, 34907, 34908, 34909, 34910, 34911, 34912, 34918, 34919, 34922, 34925, 34927, 34929, 34931, 34932, 34933, 34934, 34936, 34937, 34938, 34939, 34940, 34944, 34947, 34950, 34951, 34953, 34954, 34956, 34958, 34959, 34960, 34961, 34963, 34964, 34965, 34967, 34968, 34969, 34970, 34971, 34973, 34974, 34975, 34976, 34977, 34979, 34981, 34982, 34983, 34984, 34985, 34986, 23567, 23389, 26657, 32918, 21880, 31505, 25928, 26964, 20123, 27463, 34638, 38795, 21327, 25375, 25658, 37034, 26012, 32961, 35856, 20889, 26800, 21368, 34809, 25032, 27844, 27899, 35874, 23633, 34218, 33455, 38156, 27427, 36763, 26032, 24571, 24515, 20449, 34885, 26143, 33125, 29481, 24826, 20852, 21009, 22411, 24418, 37026, 34892, 37266, 24184, 26447, 24615, 22995, 20804, 20982, 33016, 21256, 27769, 38596, 29066, 20241, 20462, 32670, 26429, 21957, 38152, 31168, 34966, 32483, 22687, 25100, 38656, 34394, 22040, 39035, 24464, 35768, 33988, 37207, 21465, 26093, 24207, 30044, 24676, 32110, 23167, 32490, 32493, 36713, 21927, 23459, 24748, 26059, 29572, 34988, 34990, 34991, 34992, 34994, 34995, 34996, 34997, 34998, 35e3, 35001, 35002, 35003, 35005, 35006, 35007, 35008, 35011, 35012, 35015, 35016, 35018, 35019, 35020, 35021, 35023, 35024, 35025, 35027, 35030, 35031, 35034, 35035, 35036, 35037, 35038, 35040, 35041, 35046, 35047, 35049, 35050, 35051, 35052, 35053, 35054, 35055, 35058, 35061, 35062, 35063, 35066, 35067, 35069, 35071, 35072, 35073, 35075, 35076, 35077, 35078, 35079, 35080, 35081, 35083, 35084, 35085, 35086, 35087, 35089, 35092, 35093, 35094, 35095, 35096, 35100, 35101, 35102, 35103, 35104, 35106, 35107, 35108, 35110, 35111, 35112, 35113, 35116, 35117, 35118, 35119, 35121, 35122, 35123, 35125, 35127, 36873, 30307, 30505, 32474, 38772, 34203, 23398, 31348, 38634, 34880, 21195, 29071, 24490, 26092, 35810, 23547, 39535, 24033, 27529, 27739, 35757, 35759, 36874, 36805, 21387, 25276, 40486, 40493, 21568, 20011, 33469, 29273, 34460, 23830, 34905, 28079, 38597, 21713, 20122, 35766, 28937, 21693, 38409, 28895, 28153, 30416, 20005, 30740, 34578, 23721, 24310, 35328, 39068, 38414, 28814, 27839, 22852, 25513, 30524, 34893, 28436, 33395, 22576, 29141, 21388, 30746, 38593, 21761, 24422, 28976, 23476, 35866, 39564, 27523, 22830, 40495, 31207, 26472, 25196, 20335, 30113, 32650, 27915, 38451, 27687, 20208, 30162, 20859, 26679, 28478, 36992, 33136, 22934, 29814, 35128, 35129, 35130, 35131, 35132, 35133, 35134, 35135, 35136, 35138, 35139, 35141, 35142, 35143, 35144, 35145, 35146, 35147, 35148, 35149, 35150, 35151, 35152, 35153, 35154, 35155, 35156, 35157, 35158, 35159, 35160, 35161, 35162, 35163, 35164, 35165, 35168, 35169, 35170, 35171, 35172, 35173, 35175, 35176, 35177, 35178, 35179, 35180, 35181, 35182, 35183, 35184, 35185, 35186, 35187, 35188, 35189, 35190, 35191, 35192, 35193, 35194, 35196, 35197, 35198, 35200, 35202, 35204, 35205, 35207, 35208, 35209, 35210, 35211, 35212, 35213, 35214, 35215, 35216, 35217, 35218, 35219, 35220, 35221, 35222, 35223, 35224, 35225, 35226, 35227, 35228, 35229, 35230, 35231, 35232, 35233, 25671, 23591, 36965, 31377, 35875, 23002, 21676, 33280, 33647, 35201, 32768, 26928, 22094, 32822, 29239, 37326, 20918, 20063, 39029, 25494, 19994, 21494, 26355, 33099, 22812, 28082, 19968, 22777, 21307, 25558, 38129, 20381, 20234, 34915, 39056, 22839, 36951, 31227, 20202, 33008, 30097, 27778, 23452, 23016, 24413, 26885, 34433, 20506, 24050, 20057, 30691, 20197, 33402, 25233, 26131, 37009, 23673, 20159, 24441, 33222, 36920, 32900, 30123, 20134, 35028, 24847, 27589, 24518, 20041, 30410, 28322, 35811, 35758, 35850, 35793, 24322, 32764, 32716, 32462, 33589, 33643, 22240, 27575, 38899, 38452, 23035, 21535, 38134, 28139, 23493, 39278, 23609, 24341, 38544, 35234, 35235, 35236, 35237, 35238, 35239, 35240, 35241, 35242, 35243, 35244, 35245, 35246, 35247, 35248, 35249, 35250, 35251, 35252, 35253, 35254, 35255, 35256, 35257, 35258, 35259, 35260, 35261, 35262, 35263, 35264, 35267, 35277, 35283, 35284, 35285, 35287, 35288, 35289, 35291, 35293, 35295, 35296, 35297, 35298, 35300, 35303, 35304, 35305, 35306, 35308, 35309, 35310, 35312, 35313, 35314, 35316, 35317, 35318, 35319, 35320, 35321, 35322, 35323, 35324, 35325, 35326, 35327, 35329, 35330, 35331, 35332, 35333, 35334, 35336, 35337, 35338, 35339, 35340, 35341, 35342, 35343, 35344, 35345, 35346, 35347, 35348, 35349, 35350, 35351, 35352, 35353, 35354, 35355, 35356, 35357, 21360, 33521, 27185, 23156, 40560, 24212, 32552, 33721, 33828, 33829, 33639, 34631, 36814, 36194, 30408, 24433, 39062, 30828, 26144, 21727, 25317, 20323, 33219, 30152, 24248, 38605, 36362, 34553, 21647, 27891, 28044, 27704, 24703, 21191, 29992, 24189, 20248, 24736, 24551, 23588, 30001, 37038, 38080, 29369, 27833, 28216, 37193, 26377, 21451, 21491, 20305, 37321, 35825, 21448, 24188, 36802, 28132, 20110, 30402, 27014, 34398, 24858, 33286, 20313, 20446, 36926, 40060, 24841, 28189, 28180, 38533, 20104, 23089, 38632, 19982, 23679, 31161, 23431, 35821, 32701, 29577, 22495, 33419, 37057, 21505, 36935, 21947, 23786, 24481, 24840, 27442, 29425, 32946, 35465, 35358, 35359, 35360, 35361, 35362, 35363, 35364, 35365, 35366, 35367, 35368, 35369, 35370, 35371, 35372, 35373, 35374, 35375, 35376, 35377, 35378, 35379, 35380, 35381, 35382, 35383, 35384, 35385, 35386, 35387, 35388, 35389, 35391, 35392, 35393, 35394, 35395, 35396, 35397, 35398, 35399, 35401, 35402, 35403, 35404, 35405, 35406, 35407, 35408, 35409, 35410, 35411, 35412, 35413, 35414, 35415, 35416, 35417, 35418, 35419, 35420, 35421, 35422, 35423, 35424, 35425, 35426, 35427, 35428, 35429, 35430, 35431, 35432, 35433, 35434, 35435, 35436, 35437, 35438, 35439, 35440, 35441, 35442, 35443, 35444, 35445, 35446, 35447, 35448, 35450, 35451, 35452, 35453, 35454, 35455, 35456, 28020, 23507, 35029, 39044, 35947, 39533, 40499, 28170, 20900, 20803, 22435, 34945, 21407, 25588, 36757, 22253, 21592, 22278, 29503, 28304, 32536, 36828, 33489, 24895, 24616, 38498, 26352, 32422, 36234, 36291, 38053, 23731, 31908, 26376, 24742, 38405, 32792, 20113, 37095, 21248, 38504, 20801, 36816, 34164, 37213, 26197, 38901, 23381, 21277, 30776, 26434, 26685, 21705, 28798, 23472, 36733, 20877, 22312, 21681, 25874, 26242, 36190, 36163, 33039, 33900, 36973, 31967, 20991, 34299, 26531, 26089, 28577, 34468, 36481, 22122, 36896, 30338, 28790, 29157, 36131, 25321, 21017, 27901, 36156, 24590, 22686, 24974, 26366, 36192, 25166, 21939, 28195, 26413, 36711, 35457, 35458, 35459, 35460, 35461, 35462, 35463, 35464, 35467, 35468, 35469, 35470, 35471, 35472, 35473, 35474, 35476, 35477, 35478, 35479, 35480, 35481, 35482, 35483, 35484, 35485, 35486, 35487, 35488, 35489, 35490, 35491, 35492, 35493, 35494, 35495, 35496, 35497, 35498, 35499, 35500, 35501, 35502, 35503, 35504, 35505, 35506, 35507, 35508, 35509, 35510, 35511, 35512, 35513, 35514, 35515, 35516, 35517, 35518, 35519, 35520, 35521, 35522, 35523, 35524, 35525, 35526, 35527, 35528, 35529, 35530, 35531, 35532, 35533, 35534, 35535, 35536, 35537, 35538, 35539, 35540, 35541, 35542, 35543, 35544, 35545, 35546, 35547, 35548, 35549, 35550, 35551, 35552, 35553, 35554, 35555, 38113, 38392, 30504, 26629, 27048, 21643, 20045, 28856, 35784, 25688, 25995, 23429, 31364, 20538, 23528, 30651, 27617, 35449, 31896, 27838, 30415, 26025, 36759, 23853, 23637, 34360, 26632, 21344, 25112, 31449, 28251, 32509, 27167, 31456, 24432, 28467, 24352, 25484, 28072, 26454, 19976, 24080, 36134, 20183, 32960, 30260, 38556, 25307, 26157, 25214, 27836, 36213, 29031, 32617, 20806, 32903, 21484, 36974, 25240, 21746, 34544, 36761, 32773, 38167, 34071, 36825, 27993, 29645, 26015, 30495, 29956, 30759, 33275, 36126, 38024, 20390, 26517, 30137, 35786, 38663, 25391, 38215, 38453, 33976, 25379, 30529, 24449, 29424, 20105, 24596, 25972, 25327, 27491, 25919, 35556, 35557, 35558, 35559, 35560, 35561, 35562, 35563, 35564, 35565, 35566, 35567, 35568, 35569, 35570, 35571, 35572, 35573, 35574, 35575, 35576, 35577, 35578, 35579, 35580, 35581, 35582, 35583, 35584, 35585, 35586, 35587, 35588, 35589, 35590, 35592, 35593, 35594, 35595, 35596, 35597, 35598, 35599, 35600, 35601, 35602, 35603, 35604, 35605, 35606, 35607, 35608, 35609, 35610, 35611, 35612, 35613, 35614, 35615, 35616, 35617, 35618, 35619, 35620, 35621, 35623, 35624, 35625, 35626, 35627, 35628, 35629, 35630, 35631, 35632, 35633, 35634, 35635, 35636, 35637, 35638, 35639, 35640, 35641, 35642, 35643, 35644, 35645, 35646, 35647, 35648, 35649, 35650, 35651, 35652, 35653, 24103, 30151, 37073, 35777, 33437, 26525, 25903, 21553, 34584, 30693, 32930, 33026, 27713, 20043, 32455, 32844, 30452, 26893, 27542, 25191, 20540, 20356, 22336, 25351, 27490, 36286, 21482, 26088, 32440, 24535, 25370, 25527, 33267, 33268, 32622, 24092, 23769, 21046, 26234, 31209, 31258, 36136, 28825, 30164, 28382, 27835, 31378, 20013, 30405, 24544, 38047, 34935, 32456, 31181, 32959, 37325, 20210, 20247, 33311, 21608, 24030, 27954, 35788, 31909, 36724, 32920, 24090, 21650, 30385, 23449, 26172, 39588, 29664, 26666, 34523, 26417, 29482, 35832, 35803, 36880, 31481, 28891, 29038, 25284, 30633, 22065, 20027, 33879, 26609, 21161, 34496, 36142, 38136, 31569, 35654, 35655, 35656, 35657, 35658, 35659, 35660, 35661, 35662, 35663, 35664, 35665, 35666, 35667, 35668, 35669, 35670, 35671, 35672, 35673, 35674, 35675, 35676, 35677, 35678, 35679, 35680, 35681, 35682, 35683, 35684, 35685, 35687, 35688, 35689, 35690, 35691, 35693, 35694, 35695, 35696, 35697, 35698, 35699, 35700, 35701, 35702, 35703, 35704, 35705, 35706, 35707, 35708, 35709, 35710, 35711, 35712, 35713, 35714, 35715, 35716, 35717, 35718, 35719, 35720, 35721, 35722, 35723, 35724, 35725, 35726, 35727, 35728, 35729, 35730, 35731, 35732, 35733, 35734, 35735, 35736, 35737, 35738, 35739, 35740, 35741, 35742, 35743, 35756, 35761, 35771, 35783, 35792, 35818, 35849, 35870, 20303, 27880, 31069, 39547, 25235, 29226, 25341, 19987, 30742, 36716, 25776, 36186, 31686, 26729, 24196, 35013, 22918, 25758, 22766, 29366, 26894, 38181, 36861, 36184, 22368, 32512, 35846, 20934, 25417, 25305, 21331, 26700, 29730, 33537, 37196, 21828, 30528, 28796, 27978, 20857, 21672, 36164, 23039, 28363, 28100, 23388, 32043, 20180, 31869, 28371, 23376, 33258, 28173, 23383, 39683, 26837, 36394, 23447, 32508, 24635, 32437, 37049, 36208, 22863, 25549, 31199, 36275, 21330, 26063, 31062, 35781, 38459, 32452, 38075, 32386, 22068, 37257, 26368, 32618, 23562, 36981, 26152, 24038, 20304, 26590, 20570, 20316, 22352, 24231, 59408, 59409, 59410, 59411, 59412, 35896, 35897, 35898, 35899, 35900, 35901, 35902, 35903, 35904, 35906, 35907, 35908, 35909, 35912, 35914, 35915, 35917, 35918, 35919, 35920, 35921, 35922, 35923, 35924, 35926, 35927, 35928, 35929, 35931, 35932, 35933, 35934, 35935, 35936, 35939, 35940, 35941, 35942, 35943, 35944, 35945, 35948, 35949, 35950, 35951, 35952, 35953, 35954, 35956, 35957, 35958, 35959, 35963, 35964, 35965, 35966, 35967, 35968, 35969, 35971, 35972, 35974, 35975, 35976, 35979, 35981, 35982, 35983, 35984, 35985, 35986, 35987, 35989, 35990, 35991, 35993, 35994, 35995, 35996, 35997, 35998, 35999, 36e3, 36001, 36002, 36003, 36004, 36005, 36006, 36007, 36008, 36009, 36010, 36011, 36012, 36013, 20109, 19980, 20800, 19984, 24319, 21317, 19989, 20120, 19998, 39730, 23404, 22121, 20008, 31162, 20031, 21269, 20039, 22829, 29243, 21358, 27664, 22239, 32996, 39319, 27603, 30590, 40727, 20022, 20127, 40720, 20060, 20073, 20115, 33416, 23387, 21868, 22031, 20164, 21389, 21405, 21411, 21413, 21422, 38757, 36189, 21274, 21493, 21286, 21294, 21310, 36188, 21350, 21347, 20994, 21e3, 21006, 21037, 21043, 21055, 21056, 21068, 21086, 21089, 21084, 33967, 21117, 21122, 21121, 21136, 21139, 20866, 32596, 20155, 20163, 20169, 20162, 20200, 20193, 20203, 20190, 20251, 20211, 20258, 20324, 20213, 20261, 20263, 20233, 20267, 20318, 20327, 25912, 20314, 20317, 36014, 36015, 36016, 36017, 36018, 36019, 36020, 36021, 36022, 36023, 36024, 36025, 36026, 36027, 36028, 36029, 36030, 36031, 36032, 36033, 36034, 36035, 36036, 36037, 36038, 36039, 36040, 36041, 36042, 36043, 36044, 36045, 36046, 36047, 36048, 36049, 36050, 36051, 36052, 36053, 36054, 36055, 36056, 36057, 36058, 36059, 36060, 36061, 36062, 36063, 36064, 36065, 36066, 36067, 36068, 36069, 36070, 36071, 36072, 36073, 36074, 36075, 36076, 36077, 36078, 36079, 36080, 36081, 36082, 36083, 36084, 36085, 36086, 36087, 36088, 36089, 36090, 36091, 36092, 36093, 36094, 36095, 36096, 36097, 36098, 36099, 36100, 36101, 36102, 36103, 36104, 36105, 36106, 36107, 36108, 36109, 20319, 20311, 20274, 20285, 20342, 20340, 20369, 20361, 20355, 20367, 20350, 20347, 20394, 20348, 20396, 20372, 20454, 20456, 20458, 20421, 20442, 20451, 20444, 20433, 20447, 20472, 20521, 20556, 20467, 20524, 20495, 20526, 20525, 20478, 20508, 20492, 20517, 20520, 20606, 20547, 20565, 20552, 20558, 20588, 20603, 20645, 20647, 20649, 20666, 20694, 20742, 20717, 20716, 20710, 20718, 20743, 20747, 20189, 27709, 20312, 20325, 20430, 40864, 27718, 31860, 20846, 24061, 40649, 39320, 20865, 22804, 21241, 21261, 35335, 21264, 20971, 22809, 20821, 20128, 20822, 20147, 34926, 34980, 20149, 33044, 35026, 31104, 23348, 34819, 32696, 20907, 20913, 20925, 20924, 36110, 36111, 36112, 36113, 36114, 36115, 36116, 36117, 36118, 36119, 36120, 36121, 36122, 36123, 36124, 36128, 36177, 36178, 36183, 36191, 36197, 36200, 36201, 36202, 36204, 36206, 36207, 36209, 36210, 36216, 36217, 36218, 36219, 36220, 36221, 36222, 36223, 36224, 36226, 36227, 36230, 36231, 36232, 36233, 36236, 36237, 36238, 36239, 36240, 36242, 36243, 36245, 36246, 36247, 36248, 36249, 36250, 36251, 36252, 36253, 36254, 36256, 36257, 36258, 36260, 36261, 36262, 36263, 36264, 36265, 36266, 36267, 36268, 36269, 36270, 36271, 36272, 36274, 36278, 36279, 36281, 36283, 36285, 36288, 36289, 36290, 36293, 36295, 36296, 36297, 36298, 36301, 36304, 36306, 36307, 36308, 20935, 20886, 20898, 20901, 35744, 35750, 35751, 35754, 35764, 35765, 35767, 35778, 35779, 35787, 35791, 35790, 35794, 35795, 35796, 35798, 35800, 35801, 35804, 35807, 35808, 35812, 35816, 35817, 35822, 35824, 35827, 35830, 35833, 35836, 35839, 35840, 35842, 35844, 35847, 35852, 35855, 35857, 35858, 35860, 35861, 35862, 35865, 35867, 35864, 35869, 35871, 35872, 35873, 35877, 35879, 35882, 35883, 35886, 35887, 35890, 35891, 35893, 35894, 21353, 21370, 38429, 38434, 38433, 38449, 38442, 38461, 38460, 38466, 38473, 38484, 38495, 38503, 38508, 38514, 38516, 38536, 38541, 38551, 38576, 37015, 37019, 37021, 37017, 37036, 37025, 37044, 37043, 37046, 37050, 36309, 36312, 36313, 36316, 36320, 36321, 36322, 36325, 36326, 36327, 36329, 36333, 36334, 36336, 36337, 36338, 36340, 36342, 36348, 36350, 36351, 36352, 36353, 36354, 36355, 36356, 36358, 36359, 36360, 36363, 36365, 36366, 36368, 36369, 36370, 36371, 36373, 36374, 36375, 36376, 36377, 36378, 36379, 36380, 36384, 36385, 36388, 36389, 36390, 36391, 36392, 36395, 36397, 36400, 36402, 36403, 36404, 36406, 36407, 36408, 36411, 36412, 36414, 36415, 36419, 36421, 36422, 36428, 36429, 36430, 36431, 36432, 36435, 36436, 36437, 36438, 36439, 36440, 36442, 36443, 36444, 36445, 36446, 36447, 36448, 36449, 36450, 36451, 36452, 36453, 36455, 36456, 36458, 36459, 36462, 36465, 37048, 37040, 37071, 37061, 37054, 37072, 37060, 37063, 37075, 37094, 37090, 37084, 37079, 37083, 37099, 37103, 37118, 37124, 37154, 37150, 37155, 37169, 37167, 37177, 37187, 37190, 21005, 22850, 21154, 21164, 21165, 21182, 21759, 21200, 21206, 21232, 21471, 29166, 30669, 24308, 20981, 20988, 39727, 21430, 24321, 30042, 24047, 22348, 22441, 22433, 22654, 22716, 22725, 22737, 22313, 22316, 22314, 22323, 22329, 22318, 22319, 22364, 22331, 22338, 22377, 22405, 22379, 22406, 22396, 22395, 22376, 22381, 22390, 22387, 22445, 22436, 22412, 22450, 22479, 22439, 22452, 22419, 22432, 22485, 22488, 22490, 22489, 22482, 22456, 22516, 22511, 22520, 22500, 22493, 36467, 36469, 36471, 36472, 36473, 36474, 36475, 36477, 36478, 36480, 36482, 36483, 36484, 36486, 36488, 36489, 36490, 36491, 36492, 36493, 36494, 36497, 36498, 36499, 36501, 36502, 36503, 36504, 36505, 36506, 36507, 36509, 36511, 36512, 36513, 36514, 36515, 36516, 36517, 36518, 36519, 36520, 36521, 36522, 36525, 36526, 36528, 36529, 36531, 36532, 36533, 36534, 36535, 36536, 36537, 36539, 36540, 36541, 36542, 36543, 36544, 36545, 36546, 36547, 36548, 36549, 36550, 36551, 36552, 36553, 36554, 36555, 36556, 36557, 36559, 36560, 36561, 36562, 36563, 36564, 36565, 36566, 36567, 36568, 36569, 36570, 36571, 36572, 36573, 36574, 36575, 36576, 36577, 36578, 36579, 36580, 22539, 22541, 22525, 22509, 22528, 22558, 22553, 22596, 22560, 22629, 22636, 22657, 22665, 22682, 22656, 39336, 40729, 25087, 33401, 33405, 33407, 33423, 33418, 33448, 33412, 33422, 33425, 33431, 33433, 33451, 33464, 33470, 33456, 33480, 33482, 33507, 33432, 33463, 33454, 33483, 33484, 33473, 33449, 33460, 33441, 33450, 33439, 33476, 33486, 33444, 33505, 33545, 33527, 33508, 33551, 33543, 33500, 33524, 33490, 33496, 33548, 33531, 33491, 33553, 33562, 33542, 33556, 33557, 33504, 33493, 33564, 33617, 33627, 33628, 33544, 33682, 33596, 33588, 33585, 33691, 33630, 33583, 33615, 33607, 33603, 33631, 33600, 33559, 33632, 33581, 33594, 33587, 33638, 33637, 36581, 36582, 36583, 36584, 36585, 36586, 36587, 36588, 36589, 36590, 36591, 36592, 36593, 36594, 36595, 36596, 36597, 36598, 36599, 36600, 36601, 36602, 36603, 36604, 36605, 36606, 36607, 36608, 36609, 36610, 36611, 36612, 36613, 36614, 36615, 36616, 36617, 36618, 36619, 36620, 36621, 36622, 36623, 36624, 36625, 36626, 36627, 36628, 36629, 36630, 36631, 36632, 36633, 36634, 36635, 36636, 36637, 36638, 36639, 36640, 36641, 36642, 36643, 36644, 36645, 36646, 36647, 36648, 36649, 36650, 36651, 36652, 36653, 36654, 36655, 36656, 36657, 36658, 36659, 36660, 36661, 36662, 36663, 36664, 36665, 36666, 36667, 36668, 36669, 36670, 36671, 36672, 36673, 36674, 36675, 36676, 33640, 33563, 33641, 33644, 33642, 33645, 33646, 33712, 33656, 33715, 33716, 33696, 33706, 33683, 33692, 33669, 33660, 33718, 33705, 33661, 33720, 33659, 33688, 33694, 33704, 33722, 33724, 33729, 33793, 33765, 33752, 22535, 33816, 33803, 33757, 33789, 33750, 33820, 33848, 33809, 33798, 33748, 33759, 33807, 33795, 33784, 33785, 33770, 33733, 33728, 33830, 33776, 33761, 33884, 33873, 33882, 33881, 33907, 33927, 33928, 33914, 33929, 33912, 33852, 33862, 33897, 33910, 33932, 33934, 33841, 33901, 33985, 33997, 34e3, 34022, 33981, 34003, 33994, 33983, 33978, 34016, 33953, 33977, 33972, 33943, 34021, 34019, 34060, 29965, 34104, 34032, 34105, 34079, 34106, 36677, 36678, 36679, 36680, 36681, 36682, 36683, 36684, 36685, 36686, 36687, 36688, 36689, 36690, 36691, 36692, 36693, 36694, 36695, 36696, 36697, 36698, 36699, 36700, 36701, 36702, 36703, 36704, 36705, 36706, 36707, 36708, 36709, 36714, 36736, 36748, 36754, 36765, 36768, 36769, 36770, 36772, 36773, 36774, 36775, 36778, 36780, 36781, 36782, 36783, 36786, 36787, 36788, 36789, 36791, 36792, 36794, 36795, 36796, 36799, 36800, 36803, 36806, 36809, 36810, 36811, 36812, 36813, 36815, 36818, 36822, 36823, 36826, 36832, 36833, 36835, 36839, 36844, 36847, 36849, 36850, 36852, 36853, 36854, 36858, 36859, 36860, 36862, 36863, 36871, 36872, 36876, 36878, 36883, 36885, 36888, 34134, 34107, 34047, 34044, 34137, 34120, 34152, 34148, 34142, 34170, 30626, 34115, 34162, 34171, 34212, 34216, 34183, 34191, 34169, 34222, 34204, 34181, 34233, 34231, 34224, 34259, 34241, 34268, 34303, 34343, 34309, 34345, 34326, 34364, 24318, 24328, 22844, 22849, 32823, 22869, 22874, 22872, 21263, 23586, 23589, 23596, 23604, 25164, 25194, 25247, 25275, 25290, 25306, 25303, 25326, 25378, 25334, 25401, 25419, 25411, 25517, 25590, 25457, 25466, 25486, 25524, 25453, 25516, 25482, 25449, 25518, 25532, 25586, 25592, 25568, 25599, 25540, 25566, 25550, 25682, 25542, 25534, 25669, 25665, 25611, 25627, 25632, 25612, 25638, 25633, 25694, 25732, 25709, 25750, 36889, 36892, 36899, 36900, 36901, 36903, 36904, 36905, 36906, 36907, 36908, 36912, 36913, 36914, 36915, 36916, 36919, 36921, 36922, 36925, 36927, 36928, 36931, 36933, 36934, 36936, 36937, 36938, 36939, 36940, 36942, 36948, 36949, 36950, 36953, 36954, 36956, 36957, 36958, 36959, 36960, 36961, 36964, 36966, 36967, 36969, 36970, 36971, 36972, 36975, 36976, 36977, 36978, 36979, 36982, 36983, 36984, 36985, 36986, 36987, 36988, 36990, 36993, 36996, 36997, 36998, 36999, 37001, 37002, 37004, 37005, 37006, 37007, 37008, 37010, 37012, 37014, 37016, 37018, 37020, 37022, 37023, 37024, 37028, 37029, 37031, 37032, 37033, 37035, 37037, 37042, 37047, 37052, 37053, 37055, 37056, 25722, 25783, 25784, 25753, 25786, 25792, 25808, 25815, 25828, 25826, 25865, 25893, 25902, 24331, 24530, 29977, 24337, 21343, 21489, 21501, 21481, 21480, 21499, 21522, 21526, 21510, 21579, 21586, 21587, 21588, 21590, 21571, 21537, 21591, 21593, 21539, 21554, 21634, 21652, 21623, 21617, 21604, 21658, 21659, 21636, 21622, 21606, 21661, 21712, 21677, 21698, 21684, 21714, 21671, 21670, 21715, 21716, 21618, 21667, 21717, 21691, 21695, 21708, 21721, 21722, 21724, 21673, 21674, 21668, 21725, 21711, 21726, 21787, 21735, 21792, 21757, 21780, 21747, 21794, 21795, 21775, 21777, 21799, 21802, 21863, 21903, 21941, 21833, 21869, 21825, 21845, 21823, 21840, 21820, 37058, 37059, 37062, 37064, 37065, 37067, 37068, 37069, 37074, 37076, 37077, 37078, 37080, 37081, 37082, 37086, 37087, 37088, 37091, 37092, 37093, 37097, 37098, 37100, 37102, 37104, 37105, 37106, 37107, 37109, 37110, 37111, 37113, 37114, 37115, 37116, 37119, 37120, 37121, 37123, 37125, 37126, 37127, 37128, 37129, 37130, 37131, 37132, 37133, 37134, 37135, 37136, 37137, 37138, 37139, 37140, 37141, 37142, 37143, 37144, 37146, 37147, 37148, 37149, 37151, 37152, 37153, 37156, 37157, 37158, 37159, 37160, 37161, 37162, 37163, 37164, 37165, 37166, 37168, 37170, 37171, 37172, 37173, 37174, 37175, 37176, 37178, 37179, 37180, 37181, 37182, 37183, 37184, 37185, 37186, 37188, 21815, 21846, 21877, 21878, 21879, 21811, 21808, 21852, 21899, 21970, 21891, 21937, 21945, 21896, 21889, 21919, 21886, 21974, 21905, 21883, 21983, 21949, 21950, 21908, 21913, 21994, 22007, 21961, 22047, 21969, 21995, 21996, 21972, 21990, 21981, 21956, 21999, 21989, 22002, 22003, 21964, 21965, 21992, 22005, 21988, 36756, 22046, 22024, 22028, 22017, 22052, 22051, 22014, 22016, 22055, 22061, 22104, 22073, 22103, 22060, 22093, 22114, 22105, 22108, 22092, 22100, 22150, 22116, 22129, 22123, 22139, 22140, 22149, 22163, 22191, 22228, 22231, 22237, 22241, 22261, 22251, 22265, 22271, 22276, 22282, 22281, 22300, 24079, 24089, 24084, 24081, 24113, 24123, 24124, 37189, 37191, 37192, 37201, 37203, 37204, 37205, 37206, 37208, 37209, 37211, 37212, 37215, 37216, 37222, 37223, 37224, 37227, 37229, 37235, 37242, 37243, 37244, 37248, 37249, 37250, 37251, 37252, 37254, 37256, 37258, 37262, 37263, 37267, 37268, 37269, 37270, 37271, 37272, 37273, 37276, 37277, 37278, 37279, 37280, 37281, 37284, 37285, 37286, 37287, 37288, 37289, 37291, 37292, 37296, 37297, 37298, 37299, 37302, 37303, 37304, 37305, 37307, 37308, 37309, 37310, 37311, 37312, 37313, 37314, 37315, 37316, 37317, 37318, 37320, 37323, 37328, 37330, 37331, 37332, 37333, 37334, 37335, 37336, 37337, 37338, 37339, 37341, 37342, 37343, 37344, 37345, 37346, 37347, 37348, 37349, 24119, 24132, 24148, 24155, 24158, 24161, 23692, 23674, 23693, 23696, 23702, 23688, 23704, 23705, 23697, 23706, 23708, 23733, 23714, 23741, 23724, 23723, 23729, 23715, 23745, 23735, 23748, 23762, 23780, 23755, 23781, 23810, 23811, 23847, 23846, 23854, 23844, 23838, 23814, 23835, 23896, 23870, 23860, 23869, 23916, 23899, 23919, 23901, 23915, 23883, 23882, 23913, 23924, 23938, 23961, 23965, 35955, 23991, 24005, 24435, 24439, 24450, 24455, 24457, 24460, 24469, 24473, 24476, 24488, 24493, 24501, 24508, 34914, 24417, 29357, 29360, 29364, 29367, 29368, 29379, 29377, 29390, 29389, 29394, 29416, 29423, 29417, 29426, 29428, 29431, 29441, 29427, 29443, 29434, 37350, 37351, 37352, 37353, 37354, 37355, 37356, 37357, 37358, 37359, 37360, 37361, 37362, 37363, 37364, 37365, 37366, 37367, 37368, 37369, 37370, 37371, 37372, 37373, 37374, 37375, 37376, 37377, 37378, 37379, 37380, 37381, 37382, 37383, 37384, 37385, 37386, 37387, 37388, 37389, 37390, 37391, 37392, 37393, 37394, 37395, 37396, 37397, 37398, 37399, 37400, 37401, 37402, 37403, 37404, 37405, 37406, 37407, 37408, 37409, 37410, 37411, 37412, 37413, 37414, 37415, 37416, 37417, 37418, 37419, 37420, 37421, 37422, 37423, 37424, 37425, 37426, 37427, 37428, 37429, 37430, 37431, 37432, 37433, 37434, 37435, 37436, 37437, 37438, 37439, 37440, 37441, 37442, 37443, 37444, 37445, 29435, 29463, 29459, 29473, 29450, 29470, 29469, 29461, 29474, 29497, 29477, 29484, 29496, 29489, 29520, 29517, 29527, 29536, 29548, 29551, 29566, 33307, 22821, 39143, 22820, 22786, 39267, 39271, 39272, 39273, 39274, 39275, 39276, 39284, 39287, 39293, 39296, 39300, 39303, 39306, 39309, 39312, 39313, 39315, 39316, 39317, 24192, 24209, 24203, 24214, 24229, 24224, 24249, 24245, 24254, 24243, 36179, 24274, 24273, 24283, 24296, 24298, 33210, 24516, 24521, 24534, 24527, 24579, 24558, 24580, 24545, 24548, 24574, 24581, 24582, 24554, 24557, 24568, 24601, 24629, 24614, 24603, 24591, 24589, 24617, 24619, 24586, 24639, 24609, 24696, 24697, 24699, 24698, 24642, 37446, 37447, 37448, 37449, 37450, 37451, 37452, 37453, 37454, 37455, 37456, 37457, 37458, 37459, 37460, 37461, 37462, 37463, 37464, 37465, 37466, 37467, 37468, 37469, 37470, 37471, 37472, 37473, 37474, 37475, 37476, 37477, 37478, 37479, 37480, 37481, 37482, 37483, 37484, 37485, 37486, 37487, 37488, 37489, 37490, 37491, 37493, 37494, 37495, 37496, 37497, 37498, 37499, 37500, 37501, 37502, 37503, 37504, 37505, 37506, 37507, 37508, 37509, 37510, 37511, 37512, 37513, 37514, 37515, 37516, 37517, 37519, 37520, 37521, 37522, 37523, 37524, 37525, 37526, 37527, 37528, 37529, 37530, 37531, 37532, 37533, 37534, 37535, 37536, 37537, 37538, 37539, 37540, 37541, 37542, 37543, 24682, 24701, 24726, 24730, 24749, 24733, 24707, 24722, 24716, 24731, 24812, 24763, 24753, 24797, 24792, 24774, 24794, 24756, 24864, 24870, 24853, 24867, 24820, 24832, 24846, 24875, 24906, 24949, 25004, 24980, 24999, 25015, 25044, 25077, 24541, 38579, 38377, 38379, 38385, 38387, 38389, 38390, 38396, 38398, 38403, 38404, 38406, 38408, 38410, 38411, 38412, 38413, 38415, 38418, 38421, 38422, 38423, 38425, 38426, 20012, 29247, 25109, 27701, 27732, 27740, 27722, 27811, 27781, 27792, 27796, 27788, 27752, 27753, 27764, 27766, 27782, 27817, 27856, 27860, 27821, 27895, 27896, 27889, 27863, 27826, 27872, 27862, 27898, 27883, 27886, 27825, 27859, 27887, 27902, 37544, 37545, 37546, 37547, 37548, 37549, 37551, 37552, 37553, 37554, 37555, 37556, 37557, 37558, 37559, 37560, 37561, 37562, 37563, 37564, 37565, 37566, 37567, 37568, 37569, 37570, 37571, 37572, 37573, 37574, 37575, 37577, 37578, 37579, 37580, 37581, 37582, 37583, 37584, 37585, 37586, 37587, 37588, 37589, 37590, 37591, 37592, 37593, 37594, 37595, 37596, 37597, 37598, 37599, 37600, 37601, 37602, 37603, 37604, 37605, 37606, 37607, 37608, 37609, 37610, 37611, 37612, 37613, 37614, 37615, 37616, 37617, 37618, 37619, 37620, 37621, 37622, 37623, 37624, 37625, 37626, 37627, 37628, 37629, 37630, 37631, 37632, 37633, 37634, 37635, 37636, 37637, 37638, 37639, 37640, 37641, 27961, 27943, 27916, 27971, 27976, 27911, 27908, 27929, 27918, 27947, 27981, 27950, 27957, 27930, 27983, 27986, 27988, 27955, 28049, 28015, 28062, 28064, 27998, 28051, 28052, 27996, 28e3, 28028, 28003, 28186, 28103, 28101, 28126, 28174, 28095, 28128, 28177, 28134, 28125, 28121, 28182, 28075, 28172, 28078, 28203, 28270, 28238, 28267, 28338, 28255, 28294, 28243, 28244, 28210, 28197, 28228, 28383, 28337, 28312, 28384, 28461, 28386, 28325, 28327, 28349, 28347, 28343, 28375, 28340, 28367, 28303, 28354, 28319, 28514, 28486, 28487, 28452, 28437, 28409, 28463, 28470, 28491, 28532, 28458, 28425, 28457, 28553, 28557, 28556, 28536, 28530, 28540, 28538, 28625, 37642, 37643, 37644, 37645, 37646, 37647, 37648, 37649, 37650, 37651, 37652, 37653, 37654, 37655, 37656, 37657, 37658, 37659, 37660, 37661, 37662, 37663, 37664, 37665, 37666, 37667, 37668, 37669, 37670, 37671, 37672, 37673, 37674, 37675, 37676, 37677, 37678, 37679, 37680, 37681, 37682, 37683, 37684, 37685, 37686, 37687, 37688, 37689, 37690, 37691, 37692, 37693, 37695, 37696, 37697, 37698, 37699, 37700, 37701, 37702, 37703, 37704, 37705, 37706, 37707, 37708, 37709, 37710, 37711, 37712, 37713, 37714, 37715, 37716, 37717, 37718, 37719, 37720, 37721, 37722, 37723, 37724, 37725, 37726, 37727, 37728, 37729, 37730, 37731, 37732, 37733, 37734, 37735, 37736, 37737, 37739, 28617, 28583, 28601, 28598, 28610, 28641, 28654, 28638, 28640, 28655, 28698, 28707, 28699, 28729, 28725, 28751, 28766, 23424, 23428, 23445, 23443, 23461, 23480, 29999, 39582, 25652, 23524, 23534, 35120, 23536, 36423, 35591, 36790, 36819, 36821, 36837, 36846, 36836, 36841, 36838, 36851, 36840, 36869, 36868, 36875, 36902, 36881, 36877, 36886, 36897, 36917, 36918, 36909, 36911, 36932, 36945, 36946, 36944, 36968, 36952, 36962, 36955, 26297, 36980, 36989, 36994, 37e3, 36995, 37003, 24400, 24407, 24406, 24408, 23611, 21675, 23632, 23641, 23409, 23651, 23654, 32700, 24362, 24361, 24365, 33396, 24380, 39739, 23662, 22913, 22915, 22925, 22953, 22954, 22947, 37740, 37741, 37742, 37743, 37744, 37745, 37746, 37747, 37748, 37749, 37750, 37751, 37752, 37753, 37754, 37755, 37756, 37757, 37758, 37759, 37760, 37761, 37762, 37763, 37764, 37765, 37766, 37767, 37768, 37769, 37770, 37771, 37772, 37773, 37774, 37776, 37777, 37778, 37779, 37780, 37781, 37782, 37783, 37784, 37785, 37786, 37787, 37788, 37789, 37790, 37791, 37792, 37793, 37794, 37795, 37796, 37797, 37798, 37799, 37800, 37801, 37802, 37803, 37804, 37805, 37806, 37807, 37808, 37809, 37810, 37811, 37812, 37813, 37814, 37815, 37816, 37817, 37818, 37819, 37820, 37821, 37822, 37823, 37824, 37825, 37826, 37827, 37828, 37829, 37830, 37831, 37832, 37833, 37835, 37836, 37837, 22935, 22986, 22955, 22942, 22948, 22994, 22962, 22959, 22999, 22974, 23045, 23046, 23005, 23048, 23011, 23e3, 23033, 23052, 23049, 23090, 23092, 23057, 23075, 23059, 23104, 23143, 23114, 23125, 23100, 23138, 23157, 33004, 23210, 23195, 23159, 23162, 23230, 23275, 23218, 23250, 23252, 23224, 23264, 23267, 23281, 23254, 23270, 23256, 23260, 23305, 23319, 23318, 23346, 23351, 23360, 23573, 23580, 23386, 23397, 23411, 23377, 23379, 23394, 39541, 39543, 39544, 39546, 39551, 39549, 39552, 39553, 39557, 39560, 39562, 39568, 39570, 39571, 39574, 39576, 39579, 39580, 39581, 39583, 39584, 39586, 39587, 39589, 39591, 32415, 32417, 32419, 32421, 32424, 32425, 37838, 37839, 37840, 37841, 37842, 37843, 37844, 37845, 37847, 37848, 37849, 37850, 37851, 37852, 37853, 37854, 37855, 37856, 37857, 37858, 37859, 37860, 37861, 37862, 37863, 37864, 37865, 37866, 37867, 37868, 37869, 37870, 37871, 37872, 37873, 37874, 37875, 37876, 37877, 37878, 37879, 37880, 37881, 37882, 37883, 37884, 37885, 37886, 37887, 37888, 37889, 37890, 37891, 37892, 37893, 37894, 37895, 37896, 37897, 37898, 37899, 37900, 37901, 37902, 37903, 37904, 37905, 37906, 37907, 37908, 37909, 37910, 37911, 37912, 37913, 37914, 37915, 37916, 37917, 37918, 37919, 37920, 37921, 37922, 37923, 37924, 37925, 37926, 37927, 37928, 37929, 37930, 37931, 37932, 37933, 37934, 32429, 32432, 32446, 32448, 32449, 32450, 32457, 32459, 32460, 32464, 32468, 32471, 32475, 32480, 32481, 32488, 32491, 32494, 32495, 32497, 32498, 32525, 32502, 32506, 32507, 32510, 32513, 32514, 32515, 32519, 32520, 32523, 32524, 32527, 32529, 32530, 32535, 32537, 32540, 32539, 32543, 32545, 32546, 32547, 32548, 32549, 32550, 32551, 32554, 32555, 32556, 32557, 32559, 32560, 32561, 32562, 32563, 32565, 24186, 30079, 24027, 30014, 37013, 29582, 29585, 29614, 29602, 29599, 29647, 29634, 29649, 29623, 29619, 29632, 29641, 29640, 29669, 29657, 39036, 29706, 29673, 29671, 29662, 29626, 29682, 29711, 29738, 29787, 29734, 29733, 29736, 29744, 29742, 29740, 37935, 37936, 37937, 37938, 37939, 37940, 37941, 37942, 37943, 37944, 37945, 37946, 37947, 37948, 37949, 37951, 37952, 37953, 37954, 37955, 37956, 37957, 37958, 37959, 37960, 37961, 37962, 37963, 37964, 37965, 37966, 37967, 37968, 37969, 37970, 37971, 37972, 37973, 37974, 37975, 37976, 37977, 37978, 37979, 37980, 37981, 37982, 37983, 37984, 37985, 37986, 37987, 37988, 37989, 37990, 37991, 37992, 37993, 37994, 37996, 37997, 37998, 37999, 38e3, 38001, 38002, 38003, 38004, 38005, 38006, 38007, 38008, 38009, 38010, 38011, 38012, 38013, 38014, 38015, 38016, 38017, 38018, 38019, 38020, 38033, 38038, 38040, 38087, 38095, 38099, 38100, 38106, 38118, 38139, 38172, 38176, 29723, 29722, 29761, 29788, 29783, 29781, 29785, 29815, 29805, 29822, 29852, 29838, 29824, 29825, 29831, 29835, 29854, 29864, 29865, 29840, 29863, 29906, 29882, 38890, 38891, 38892, 26444, 26451, 26462, 26440, 26473, 26533, 26503, 26474, 26483, 26520, 26535, 26485, 26536, 26526, 26541, 26507, 26487, 26492, 26608, 26633, 26584, 26634, 26601, 26544, 26636, 26585, 26549, 26586, 26547, 26589, 26624, 26563, 26552, 26594, 26638, 26561, 26621, 26674, 26675, 26720, 26721, 26702, 26722, 26692, 26724, 26755, 26653, 26709, 26726, 26689, 26727, 26688, 26686, 26698, 26697, 26665, 26805, 26767, 26740, 26743, 26771, 26731, 26818, 26990, 26876, 26911, 26912, 26873, 38183, 38195, 38205, 38211, 38216, 38219, 38229, 38234, 38240, 38254, 38260, 38261, 38263, 38264, 38265, 38266, 38267, 38268, 38269, 38270, 38272, 38273, 38274, 38275, 38276, 38277, 38278, 38279, 38280, 38281, 38282, 38283, 38284, 38285, 38286, 38287, 38288, 38289, 38290, 38291, 38292, 38293, 38294, 38295, 38296, 38297, 38298, 38299, 38300, 38301, 38302, 38303, 38304, 38305, 38306, 38307, 38308, 38309, 38310, 38311, 38312, 38313, 38314, 38315, 38316, 38317, 38318, 38319, 38320, 38321, 38322, 38323, 38324, 38325, 38326, 38327, 38328, 38329, 38330, 38331, 38332, 38333, 38334, 38335, 38336, 38337, 38338, 38339, 38340, 38341, 38342, 38343, 38344, 38345, 38346, 38347, 26916, 26864, 26891, 26881, 26967, 26851, 26896, 26993, 26937, 26976, 26946, 26973, 27012, 26987, 27008, 27032, 27e3, 26932, 27084, 27015, 27016, 27086, 27017, 26982, 26979, 27001, 27035, 27047, 27067, 27051, 27053, 27092, 27057, 27073, 27082, 27103, 27029, 27104, 27021, 27135, 27183, 27117, 27159, 27160, 27237, 27122, 27204, 27198, 27296, 27216, 27227, 27189, 27278, 27257, 27197, 27176, 27224, 27260, 27281, 27280, 27305, 27287, 27307, 29495, 29522, 27521, 27522, 27527, 27524, 27538, 27539, 27533, 27546, 27547, 27553, 27562, 36715, 36717, 36721, 36722, 36723, 36725, 36726, 36728, 36727, 36729, 36730, 36732, 36734, 36737, 36738, 36740, 36743, 36747, 38348, 38349, 38350, 38351, 38352, 38353, 38354, 38355, 38356, 38357, 38358, 38359, 38360, 38361, 38362, 38363, 38364, 38365, 38366, 38367, 38368, 38369, 38370, 38371, 38372, 38373, 38374, 38375, 38380, 38399, 38407, 38419, 38424, 38427, 38430, 38432, 38435, 38436, 38437, 38438, 38439, 38440, 38441, 38443, 38444, 38445, 38447, 38448, 38455, 38456, 38457, 38458, 38462, 38465, 38467, 38474, 38478, 38479, 38481, 38482, 38483, 38486, 38487, 38488, 38489, 38490, 38492, 38493, 38494, 38496, 38499, 38501, 38502, 38507, 38509, 38510, 38511, 38512, 38513, 38515, 38520, 38521, 38522, 38523, 38524, 38525, 38526, 38527, 38528, 38529, 38530, 38531, 38532, 38535, 38537, 38538, 36749, 36750, 36751, 36760, 36762, 36558, 25099, 25111, 25115, 25119, 25122, 25121, 25125, 25124, 25132, 33255, 29935, 29940, 29951, 29967, 29969, 29971, 25908, 26094, 26095, 26096, 26122, 26137, 26482, 26115, 26133, 26112, 28805, 26359, 26141, 26164, 26161, 26166, 26165, 32774, 26207, 26196, 26177, 26191, 26198, 26209, 26199, 26231, 26244, 26252, 26279, 26269, 26302, 26331, 26332, 26342, 26345, 36146, 36147, 36150, 36155, 36157, 36160, 36165, 36166, 36168, 36169, 36167, 36173, 36181, 36185, 35271, 35274, 35275, 35276, 35278, 35279, 35280, 35281, 29294, 29343, 29277, 29286, 29295, 29310, 29311, 29316, 29323, 29325, 29327, 29330, 25352, 25394, 25520, 38540, 38542, 38545, 38546, 38547, 38549, 38550, 38554, 38555, 38557, 38558, 38559, 38560, 38561, 38562, 38563, 38564, 38565, 38566, 38568, 38569, 38570, 38571, 38572, 38573, 38574, 38575, 38577, 38578, 38580, 38581, 38583, 38584, 38586, 38587, 38591, 38594, 38595, 38600, 38602, 38603, 38608, 38609, 38611, 38612, 38614, 38615, 38616, 38617, 38618, 38619, 38620, 38621, 38622, 38623, 38625, 38626, 38627, 38628, 38629, 38630, 38631, 38635, 38636, 38637, 38638, 38640, 38641, 38642, 38644, 38645, 38648, 38650, 38651, 38652, 38653, 38655, 38658, 38659, 38661, 38666, 38667, 38668, 38672, 38673, 38674, 38676, 38677, 38679, 38680, 38681, 38682, 38683, 38685, 38687, 38688, 25663, 25816, 32772, 27626, 27635, 27645, 27637, 27641, 27653, 27655, 27654, 27661, 27669, 27672, 27673, 27674, 27681, 27689, 27684, 27690, 27698, 25909, 25941, 25963, 29261, 29266, 29270, 29232, 34402, 21014, 32927, 32924, 32915, 32956, 26378, 32957, 32945, 32939, 32941, 32948, 32951, 32999, 33e3, 33001, 33002, 32987, 32962, 32964, 32985, 32973, 32983, 26384, 32989, 33003, 33009, 33012, 33005, 33037, 33038, 33010, 33020, 26389, 33042, 35930, 33078, 33054, 33068, 33048, 33074, 33096, 33100, 33107, 33140, 33113, 33114, 33137, 33120, 33129, 33148, 33149, 33133, 33127, 22605, 23221, 33160, 33154, 33169, 28373, 33187, 33194, 33228, 26406, 33226, 33211, 38689, 38690, 38691, 38692, 38693, 38694, 38695, 38696, 38697, 38699, 38700, 38702, 38703, 38705, 38707, 38708, 38709, 38710, 38711, 38714, 38715, 38716, 38717, 38719, 38720, 38721, 38722, 38723, 38724, 38725, 38726, 38727, 38728, 38729, 38730, 38731, 38732, 38733, 38734, 38735, 38736, 38737, 38740, 38741, 38743, 38744, 38746, 38748, 38749, 38751, 38755, 38756, 38758, 38759, 38760, 38762, 38763, 38764, 38765, 38766, 38767, 38768, 38769, 38770, 38773, 38775, 38776, 38777, 38778, 38779, 38781, 38782, 38783, 38784, 38785, 38786, 38787, 38788, 38790, 38791, 38792, 38793, 38794, 38796, 38798, 38799, 38800, 38803, 38805, 38806, 38807, 38809, 38810, 38811, 38812, 38813, 33217, 33190, 27428, 27447, 27449, 27459, 27462, 27481, 39121, 39122, 39123, 39125, 39129, 39130, 27571, 24384, 27586, 35315, 26e3, 40785, 26003, 26044, 26054, 26052, 26051, 26060, 26062, 26066, 26070, 28800, 28828, 28822, 28829, 28859, 28864, 28855, 28843, 28849, 28904, 28874, 28944, 28947, 28950, 28975, 28977, 29043, 29020, 29032, 28997, 29042, 29002, 29048, 29050, 29080, 29107, 29109, 29096, 29088, 29152, 29140, 29159, 29177, 29213, 29224, 28780, 28952, 29030, 29113, 25150, 25149, 25155, 25160, 25161, 31035, 31040, 31046, 31049, 31067, 31068, 31059, 31066, 31074, 31063, 31072, 31087, 31079, 31098, 31109, 31114, 31130, 31143, 31155, 24529, 24528, 38814, 38815, 38817, 38818, 38820, 38821, 38822, 38823, 38824, 38825, 38826, 38828, 38830, 38832, 38833, 38835, 38837, 38838, 38839, 38840, 38841, 38842, 38843, 38844, 38845, 38846, 38847, 38848, 38849, 38850, 38851, 38852, 38853, 38854, 38855, 38856, 38857, 38858, 38859, 38860, 38861, 38862, 38863, 38864, 38865, 38866, 38867, 38868, 38869, 38870, 38871, 38872, 38873, 38874, 38875, 38876, 38877, 38878, 38879, 38880, 38881, 38882, 38883, 38884, 38885, 38888, 38894, 38895, 38896, 38897, 38898, 38900, 38903, 38904, 38905, 38906, 38907, 38908, 38909, 38910, 38911, 38912, 38913, 38914, 38915, 38916, 38917, 38918, 38919, 38920, 38921, 38922, 38923, 38924, 38925, 38926, 24636, 24669, 24666, 24679, 24641, 24665, 24675, 24747, 24838, 24845, 24925, 25001, 24989, 25035, 25041, 25094, 32896, 32895, 27795, 27894, 28156, 30710, 30712, 30720, 30729, 30743, 30744, 30737, 26027, 30765, 30748, 30749, 30777, 30778, 30779, 30751, 30780, 30757, 30764, 30755, 30761, 30798, 30829, 30806, 30807, 30758, 30800, 30791, 30796, 30826, 30875, 30867, 30874, 30855, 30876, 30881, 30883, 30898, 30905, 30885, 30932, 30937, 30921, 30956, 30962, 30981, 30964, 30995, 31012, 31006, 31028, 40859, 40697, 40699, 40700, 30449, 30468, 30477, 30457, 30471, 30472, 30490, 30498, 30489, 30509, 30502, 30517, 30520, 30544, 30545, 30535, 30531, 30554, 30568, 38927, 38928, 38929, 38930, 38931, 38932, 38933, 38934, 38935, 38936, 38937, 38938, 38939, 38940, 38941, 38942, 38943, 38944, 38945, 38946, 38947, 38948, 38949, 38950, 38951, 38952, 38953, 38954, 38955, 38956, 38957, 38958, 38959, 38960, 38961, 38962, 38963, 38964, 38965, 38966, 38967, 38968, 38969, 38970, 38971, 38972, 38973, 38974, 38975, 38976, 38977, 38978, 38979, 38980, 38981, 38982, 38983, 38984, 38985, 38986, 38987, 38988, 38989, 38990, 38991, 38992, 38993, 38994, 38995, 38996, 38997, 38998, 38999, 39e3, 39001, 39002, 39003, 39004, 39005, 39006, 39007, 39008, 39009, 39010, 39011, 39012, 39013, 39014, 39015, 39016, 39017, 39018, 39019, 39020, 39021, 39022, 30562, 30565, 30591, 30605, 30589, 30592, 30604, 30609, 30623, 30624, 30640, 30645, 30653, 30010, 30016, 30030, 30027, 30024, 30043, 30066, 30073, 30083, 32600, 32609, 32607, 35400, 32616, 32628, 32625, 32633, 32641, 32638, 30413, 30437, 34866, 38021, 38022, 38023, 38027, 38026, 38028, 38029, 38031, 38032, 38036, 38039, 38037, 38042, 38043, 38044, 38051, 38052, 38059, 38058, 38061, 38060, 38063, 38064, 38066, 38068, 38070, 38071, 38072, 38073, 38074, 38076, 38077, 38079, 38084, 38088, 38089, 38090, 38091, 38092, 38093, 38094, 38096, 38097, 38098, 38101, 38102, 38103, 38105, 38104, 38107, 38110, 38111, 38112, 38114, 38116, 38117, 38119, 38120, 38122, 39023, 39024, 39025, 39026, 39027, 39028, 39051, 39054, 39058, 39061, 39065, 39075, 39080, 39081, 39082, 39083, 39084, 39085, 39086, 39087, 39088, 39089, 39090, 39091, 39092, 39093, 39094, 39095, 39096, 39097, 39098, 39099, 39100, 39101, 39102, 39103, 39104, 39105, 39106, 39107, 39108, 39109, 39110, 39111, 39112, 39113, 39114, 39115, 39116, 39117, 39119, 39120, 39124, 39126, 39127, 39131, 39132, 39133, 39136, 39137, 39138, 39139, 39140, 39141, 39142, 39145, 39146, 39147, 39148, 39149, 39150, 39151, 39152, 39153, 39154, 39155, 39156, 39157, 39158, 39159, 39160, 39161, 39162, 39163, 39164, 39165, 39166, 39167, 39168, 39169, 39170, 39171, 39172, 39173, 39174, 39175, 38121, 38123, 38126, 38127, 38131, 38132, 38133, 38135, 38137, 38140, 38141, 38143, 38147, 38146, 38150, 38151, 38153, 38154, 38157, 38158, 38159, 38162, 38163, 38164, 38165, 38166, 38168, 38171, 38173, 38174, 38175, 38178, 38186, 38187, 38185, 38188, 38193, 38194, 38196, 38198, 38199, 38200, 38204, 38206, 38207, 38210, 38197, 38212, 38213, 38214, 38217, 38220, 38222, 38223, 38226, 38227, 38228, 38230, 38231, 38232, 38233, 38235, 38238, 38239, 38237, 38241, 38242, 38244, 38245, 38246, 38247, 38248, 38249, 38250, 38251, 38252, 38255, 38257, 38258, 38259, 38202, 30695, 30700, 38601, 31189, 31213, 31203, 31211, 31238, 23879, 31235, 31234, 31262, 31252, 39176, 39177, 39178, 39179, 39180, 39182, 39183, 39185, 39186, 39187, 39188, 39189, 39190, 39191, 39192, 39193, 39194, 39195, 39196, 39197, 39198, 39199, 39200, 39201, 39202, 39203, 39204, 39205, 39206, 39207, 39208, 39209, 39210, 39211, 39212, 39213, 39215, 39216, 39217, 39218, 39219, 39220, 39221, 39222, 39223, 39224, 39225, 39226, 39227, 39228, 39229, 39230, 39231, 39232, 39233, 39234, 39235, 39236, 39237, 39238, 39239, 39240, 39241, 39242, 39243, 39244, 39245, 39246, 39247, 39248, 39249, 39250, 39251, 39254, 39255, 39256, 39257, 39258, 39259, 39260, 39261, 39262, 39263, 39264, 39265, 39266, 39268, 39270, 39283, 39288, 39289, 39291, 39294, 39298, 39299, 39305, 31289, 31287, 31313, 40655, 39333, 31344, 30344, 30350, 30355, 30361, 30372, 29918, 29920, 29996, 40480, 40482, 40488, 40489, 40490, 40491, 40492, 40498, 40497, 40502, 40504, 40503, 40505, 40506, 40510, 40513, 40514, 40516, 40518, 40519, 40520, 40521, 40523, 40524, 40526, 40529, 40533, 40535, 40538, 40539, 40540, 40542, 40547, 40550, 40551, 40552, 40553, 40554, 40555, 40556, 40561, 40557, 40563, 30098, 30100, 30102, 30112, 30109, 30124, 30115, 30131, 30132, 30136, 30148, 30129, 30128, 30147, 30146, 30166, 30157, 30179, 30184, 30182, 30180, 30187, 30183, 30211, 30193, 30204, 30207, 30224, 30208, 30213, 30220, 30231, 30218, 30245, 30232, 30229, 30233, 39308, 39310, 39322, 39323, 39324, 39325, 39326, 39327, 39328, 39329, 39330, 39331, 39332, 39334, 39335, 39337, 39338, 39339, 39340, 39341, 39342, 39343, 39344, 39345, 39346, 39347, 39348, 39349, 39350, 39351, 39352, 39353, 39354, 39355, 39356, 39357, 39358, 39359, 39360, 39361, 39362, 39363, 39364, 39365, 39366, 39367, 39368, 39369, 39370, 39371, 39372, 39373, 39374, 39375, 39376, 39377, 39378, 39379, 39380, 39381, 39382, 39383, 39384, 39385, 39386, 39387, 39388, 39389, 39390, 39391, 39392, 39393, 39394, 39395, 39396, 39397, 39398, 39399, 39400, 39401, 39402, 39403, 39404, 39405, 39406, 39407, 39408, 39409, 39410, 39411, 39412, 39413, 39414, 39415, 39416, 39417, 30235, 30268, 30242, 30240, 30272, 30253, 30256, 30271, 30261, 30275, 30270, 30259, 30285, 30302, 30292, 30300, 30294, 30315, 30319, 32714, 31462, 31352, 31353, 31360, 31366, 31368, 31381, 31398, 31392, 31404, 31400, 31405, 31411, 34916, 34921, 34930, 34941, 34943, 34946, 34978, 35014, 34999, 35004, 35017, 35042, 35022, 35043, 35045, 35057, 35098, 35068, 35048, 35070, 35056, 35105, 35097, 35091, 35099, 35082, 35124, 35115, 35126, 35137, 35174, 35195, 30091, 32997, 30386, 30388, 30684, 32786, 32788, 32790, 32796, 32800, 32802, 32805, 32806, 32807, 32809, 32808, 32817, 32779, 32821, 32835, 32838, 32845, 32850, 32873, 32881, 35203, 39032, 39040, 39043, 39418, 39419, 39420, 39421, 39422, 39423, 39424, 39425, 39426, 39427, 39428, 39429, 39430, 39431, 39432, 39433, 39434, 39435, 39436, 39437, 39438, 39439, 39440, 39441, 39442, 39443, 39444, 39445, 39446, 39447, 39448, 39449, 39450, 39451, 39452, 39453, 39454, 39455, 39456, 39457, 39458, 39459, 39460, 39461, 39462, 39463, 39464, 39465, 39466, 39467, 39468, 39469, 39470, 39471, 39472, 39473, 39474, 39475, 39476, 39477, 39478, 39479, 39480, 39481, 39482, 39483, 39484, 39485, 39486, 39487, 39488, 39489, 39490, 39491, 39492, 39493, 39494, 39495, 39496, 39497, 39498, 39499, 39500, 39501, 39502, 39503, 39504, 39505, 39506, 39507, 39508, 39509, 39510, 39511, 39512, 39513, 39049, 39052, 39053, 39055, 39060, 39066, 39067, 39070, 39071, 39073, 39074, 39077, 39078, 34381, 34388, 34412, 34414, 34431, 34426, 34428, 34427, 34472, 34445, 34443, 34476, 34461, 34471, 34467, 34474, 34451, 34473, 34486, 34500, 34485, 34510, 34480, 34490, 34481, 34479, 34505, 34511, 34484, 34537, 34545, 34546, 34541, 34547, 34512, 34579, 34526, 34548, 34527, 34520, 34513, 34563, 34567, 34552, 34568, 34570, 34573, 34569, 34595, 34619, 34590, 34597, 34606, 34586, 34622, 34632, 34612, 34609, 34601, 34615, 34623, 34690, 34594, 34685, 34686, 34683, 34656, 34672, 34636, 34670, 34699, 34643, 34659, 34684, 34660, 34649, 34661, 34707, 34735, 34728, 34770, 39514, 39515, 39516, 39517, 39518, 39519, 39520, 39521, 39522, 39523, 39524, 39525, 39526, 39527, 39528, 39529, 39530, 39531, 39538, 39555, 39561, 39565, 39566, 39572, 39573, 39577, 39590, 39593, 39594, 39595, 39596, 39597, 39598, 39599, 39602, 39603, 39604, 39605, 39609, 39611, 39613, 39614, 39615, 39619, 39620, 39622, 39623, 39624, 39625, 39626, 39629, 39630, 39631, 39632, 39634, 39636, 39637, 39638, 39639, 39641, 39642, 39643, 39644, 39645, 39646, 39648, 39650, 39651, 39652, 39653, 39655, 39656, 39657, 39658, 39660, 39662, 39664, 39665, 39666, 39667, 39668, 39669, 39670, 39671, 39672, 39674, 39676, 39677, 39678, 39679, 39680, 39681, 39682, 39684, 39685, 39686, 34758, 34696, 34693, 34733, 34711, 34691, 34731, 34789, 34732, 34741, 34739, 34763, 34771, 34749, 34769, 34752, 34762, 34779, 34794, 34784, 34798, 34838, 34835, 34814, 34826, 34843, 34849, 34873, 34876, 32566, 32578, 32580, 32581, 33296, 31482, 31485, 31496, 31491, 31492, 31509, 31498, 31531, 31503, 31559, 31544, 31530, 31513, 31534, 31537, 31520, 31525, 31524, 31539, 31550, 31518, 31576, 31578, 31557, 31605, 31564, 31581, 31584, 31598, 31611, 31586, 31602, 31601, 31632, 31654, 31655, 31672, 31660, 31645, 31656, 31621, 31658, 31644, 31650, 31659, 31668, 31697, 31681, 31692, 31709, 31706, 31717, 31718, 31722, 31756, 31742, 31740, 31759, 31766, 31755, 39687, 39689, 39690, 39691, 39692, 39693, 39694, 39696, 39697, 39698, 39700, 39701, 39702, 39703, 39704, 39705, 39706, 39707, 39708, 39709, 39710, 39712, 39713, 39714, 39716, 39717, 39718, 39719, 39720, 39721, 39722, 39723, 39724, 39725, 39726, 39728, 39729, 39731, 39732, 39733, 39734, 39735, 39736, 39737, 39738, 39741, 39742, 39743, 39744, 39750, 39754, 39755, 39756, 39758, 39760, 39762, 39763, 39765, 39766, 39767, 39768, 39769, 39770, 39771, 39772, 39773, 39774, 39775, 39776, 39777, 39778, 39779, 39780, 39781, 39782, 39783, 39784, 39785, 39786, 39787, 39788, 39789, 39790, 39791, 39792, 39793, 39794, 39795, 39796, 39797, 39798, 39799, 39800, 39801, 39802, 39803, 31775, 31786, 31782, 31800, 31809, 31808, 33278, 33281, 33282, 33284, 33260, 34884, 33313, 33314, 33315, 33325, 33327, 33320, 33323, 33336, 33339, 33331, 33332, 33342, 33348, 33353, 33355, 33359, 33370, 33375, 33384, 34942, 34949, 34952, 35032, 35039, 35166, 32669, 32671, 32679, 32687, 32688, 32690, 31868, 25929, 31889, 31901, 31900, 31902, 31906, 31922, 31932, 31933, 31937, 31943, 31948, 31949, 31944, 31941, 31959, 31976, 33390, 26280, 32703, 32718, 32725, 32741, 32737, 32742, 32745, 32750, 32755, 31992, 32119, 32166, 32174, 32327, 32411, 40632, 40628, 36211, 36228, 36244, 36241, 36273, 36199, 36205, 35911, 35913, 37194, 37200, 37198, 37199, 37220, 39804, 39805, 39806, 39807, 39808, 39809, 39810, 39811, 39812, 39813, 39814, 39815, 39816, 39817, 39818, 39819, 39820, 39821, 39822, 39823, 39824, 39825, 39826, 39827, 39828, 39829, 39830, 39831, 39832, 39833, 39834, 39835, 39836, 39837, 39838, 39839, 39840, 39841, 39842, 39843, 39844, 39845, 39846, 39847, 39848, 39849, 39850, 39851, 39852, 39853, 39854, 39855, 39856, 39857, 39858, 39859, 39860, 39861, 39862, 39863, 39864, 39865, 39866, 39867, 39868, 39869, 39870, 39871, 39872, 39873, 39874, 39875, 39876, 39877, 39878, 39879, 39880, 39881, 39882, 39883, 39884, 39885, 39886, 39887, 39888, 39889, 39890, 39891, 39892, 39893, 39894, 39895, 39896, 39897, 39898, 39899, 37218, 37217, 37232, 37225, 37231, 37245, 37246, 37234, 37236, 37241, 37260, 37253, 37264, 37261, 37265, 37282, 37283, 37290, 37293, 37294, 37295, 37301, 37300, 37306, 35925, 40574, 36280, 36331, 36357, 36441, 36457, 36277, 36287, 36284, 36282, 36292, 36310, 36311, 36314, 36318, 36302, 36303, 36315, 36294, 36332, 36343, 36344, 36323, 36345, 36347, 36324, 36361, 36349, 36372, 36381, 36383, 36396, 36398, 36387, 36399, 36410, 36416, 36409, 36405, 36413, 36401, 36425, 36417, 36418, 36433, 36434, 36426, 36464, 36470, 36476, 36463, 36468, 36485, 36495, 36500, 36496, 36508, 36510, 35960, 35970, 35978, 35973, 35992, 35988, 26011, 35286, 35294, 35290, 35292, 39900, 39901, 39902, 39903, 39904, 39905, 39906, 39907, 39908, 39909, 39910, 39911, 39912, 39913, 39914, 39915, 39916, 39917, 39918, 39919, 39920, 39921, 39922, 39923, 39924, 39925, 39926, 39927, 39928, 39929, 39930, 39931, 39932, 39933, 39934, 39935, 39936, 39937, 39938, 39939, 39940, 39941, 39942, 39943, 39944, 39945, 39946, 39947, 39948, 39949, 39950, 39951, 39952, 39953, 39954, 39955, 39956, 39957, 39958, 39959, 39960, 39961, 39962, 39963, 39964, 39965, 39966, 39967, 39968, 39969, 39970, 39971, 39972, 39973, 39974, 39975, 39976, 39977, 39978, 39979, 39980, 39981, 39982, 39983, 39984, 39985, 39986, 39987, 39988, 39989, 39990, 39991, 39992, 39993, 39994, 39995, 35301, 35307, 35311, 35390, 35622, 38739, 38633, 38643, 38639, 38662, 38657, 38664, 38671, 38670, 38698, 38701, 38704, 38718, 40832, 40835, 40837, 40838, 40839, 40840, 40841, 40842, 40844, 40702, 40715, 40717, 38585, 38588, 38589, 38606, 38610, 30655, 38624, 37518, 37550, 37576, 37694, 37738, 37834, 37775, 37950, 37995, 40063, 40066, 40069, 40070, 40071, 40072, 31267, 40075, 40078, 40080, 40081, 40082, 40084, 40085, 40090, 40091, 40094, 40095, 40096, 40097, 40098, 40099, 40101, 40102, 40103, 40104, 40105, 40107, 40109, 40110, 40112, 40113, 40114, 40115, 40116, 40117, 40118, 40119, 40122, 40123, 40124, 40125, 40132, 40133, 40134, 40135, 40138, 40139, 39996, 39997, 39998, 39999, 4e4, 40001, 40002, 40003, 40004, 40005, 40006, 40007, 40008, 40009, 40010, 40011, 40012, 40013, 40014, 40015, 40016, 40017, 40018, 40019, 40020, 40021, 40022, 40023, 40024, 40025, 40026, 40027, 40028, 40029, 40030, 40031, 40032, 40033, 40034, 40035, 40036, 40037, 40038, 40039, 40040, 40041, 40042, 40043, 40044, 40045, 40046, 40047, 40048, 40049, 40050, 40051, 40052, 40053, 40054, 40055, 40056, 40057, 40058, 40059, 40061, 40062, 40064, 40067, 40068, 40073, 40074, 40076, 40079, 40083, 40086, 40087, 40088, 40089, 40093, 40106, 40108, 40111, 40121, 40126, 40127, 40128, 40129, 40130, 40136, 40137, 40145, 40146, 40154, 40155, 40160, 40161, 40140, 40141, 40142, 40143, 40144, 40147, 40148, 40149, 40151, 40152, 40153, 40156, 40157, 40159, 40162, 38780, 38789, 38801, 38802, 38804, 38831, 38827, 38819, 38834, 38836, 39601, 39600, 39607, 40536, 39606, 39610, 39612, 39617, 39616, 39621, 39618, 39627, 39628, 39633, 39749, 39747, 39751, 39753, 39752, 39757, 39761, 39144, 39181, 39214, 39253, 39252, 39647, 39649, 39654, 39663, 39659, 39675, 39661, 39673, 39688, 39695, 39699, 39711, 39715, 40637, 40638, 32315, 40578, 40583, 40584, 40587, 40594, 37846, 40605, 40607, 40667, 40668, 40669, 40672, 40671, 40674, 40681, 40679, 40677, 40682, 40687, 40738, 40748, 40751, 40761, 40759, 40765, 40766, 40772, 40163, 40164, 40165, 40166, 40167, 40168, 40169, 40170, 40171, 40172, 40173, 40174, 40175, 40176, 40177, 40178, 40179, 40180, 40181, 40182, 40183, 40184, 40185, 40186, 40187, 40188, 40189, 40190, 40191, 40192, 40193, 40194, 40195, 40196, 40197, 40198, 40199, 40200, 40201, 40202, 40203, 40204, 40205, 40206, 40207, 40208, 40209, 40210, 40211, 40212, 40213, 40214, 40215, 40216, 40217, 40218, 40219, 40220, 40221, 40222, 40223, 40224, 40225, 40226, 40227, 40228, 40229, 40230, 40231, 40232, 40233, 40234, 40235, 40236, 40237, 40238, 40239, 40240, 40241, 40242, 40243, 40244, 40245, 40246, 40247, 40248, 40249, 40250, 40251, 40252, 40253, 40254, 40255, 40256, 40257, 40258, 57908, 57909, 57910, 57911, 57912, 57913, 57914, 57915, 57916, 57917, 57918, 57919, 57920, 57921, 57922, 57923, 57924, 57925, 57926, 57927, 57928, 57929, 57930, 57931, 57932, 57933, 57934, 57935, 57936, 57937, 57938, 57939, 57940, 57941, 57942, 57943, 57944, 57945, 57946, 57947, 57948, 57949, 57950, 57951, 57952, 57953, 57954, 57955, 57956, 57957, 57958, 57959, 57960, 57961, 57962, 57963, 57964, 57965, 57966, 57967, 57968, 57969, 57970, 57971, 57972, 57973, 57974, 57975, 57976, 57977, 57978, 57979, 57980, 57981, 57982, 57983, 57984, 57985, 57986, 57987, 57988, 57989, 57990, 57991, 57992, 57993, 57994, 57995, 57996, 57997, 57998, 57999, 58e3, 58001, 40259, 40260, 40261, 40262, 40263, 40264, 40265, 40266, 40267, 40268, 40269, 40270, 40271, 40272, 40273, 40274, 40275, 40276, 40277, 40278, 40279, 40280, 40281, 40282, 40283, 40284, 40285, 40286, 40287, 40288, 40289, 40290, 40291, 40292, 40293, 40294, 40295, 40296, 40297, 40298, 40299, 40300, 40301, 40302, 40303, 40304, 40305, 40306, 40307, 40308, 40309, 40310, 40311, 40312, 40313, 40314, 40315, 40316, 40317, 40318, 40319, 40320, 40321, 40322, 40323, 40324, 40325, 40326, 40327, 40328, 40329, 40330, 40331, 40332, 40333, 40334, 40335, 40336, 40337, 40338, 40339, 40340, 40341, 40342, 40343, 40344, 40345, 40346, 40347, 40348, 40349, 40350, 40351, 40352, 40353, 40354, 58002, 58003, 58004, 58005, 58006, 58007, 58008, 58009, 58010, 58011, 58012, 58013, 58014, 58015, 58016, 58017, 58018, 58019, 58020, 58021, 58022, 58023, 58024, 58025, 58026, 58027, 58028, 58029, 58030, 58031, 58032, 58033, 58034, 58035, 58036, 58037, 58038, 58039, 58040, 58041, 58042, 58043, 58044, 58045, 58046, 58047, 58048, 58049, 58050, 58051, 58052, 58053, 58054, 58055, 58056, 58057, 58058, 58059, 58060, 58061, 58062, 58063, 58064, 58065, 58066, 58067, 58068, 58069, 58070, 58071, 58072, 58073, 58074, 58075, 58076, 58077, 58078, 58079, 58080, 58081, 58082, 58083, 58084, 58085, 58086, 58087, 58088, 58089, 58090, 58091, 58092, 58093, 58094, 58095, 40355, 40356, 40357, 40358, 40359, 40360, 40361, 40362, 40363, 40364, 40365, 40366, 40367, 40368, 40369, 40370, 40371, 40372, 40373, 40374, 40375, 40376, 40377, 40378, 40379, 40380, 40381, 40382, 40383, 40384, 40385, 40386, 40387, 40388, 40389, 40390, 40391, 40392, 40393, 40394, 40395, 40396, 40397, 40398, 40399, 40400, 40401, 40402, 40403, 40404, 40405, 40406, 40407, 40408, 40409, 40410, 40411, 40412, 40413, 40414, 40415, 40416, 40417, 40418, 40419, 40420, 40421, 40422, 40423, 40424, 40425, 40426, 40427, 40428, 40429, 40430, 40431, 40432, 40433, 40434, 40435, 40436, 40437, 40438, 40439, 40440, 40441, 40442, 40443, 40444, 40445, 40446, 40447, 40448, 40449, 40450, 58096, 58097, 58098, 58099, 58100, 58101, 58102, 58103, 58104, 58105, 58106, 58107, 58108, 58109, 58110, 58111, 58112, 58113, 58114, 58115, 58116, 58117, 58118, 58119, 58120, 58121, 58122, 58123, 58124, 58125, 58126, 58127, 58128, 58129, 58130, 58131, 58132, 58133, 58134, 58135, 58136, 58137, 58138, 58139, 58140, 58141, 58142, 58143, 58144, 58145, 58146, 58147, 58148, 58149, 58150, 58151, 58152, 58153, 58154, 58155, 58156, 58157, 58158, 58159, 58160, 58161, 58162, 58163, 58164, 58165, 58166, 58167, 58168, 58169, 58170, 58171, 58172, 58173, 58174, 58175, 58176, 58177, 58178, 58179, 58180, 58181, 58182, 58183, 58184, 58185, 58186, 58187, 58188, 58189, 40451, 40452, 40453, 40454, 40455, 40456, 40457, 40458, 40459, 40460, 40461, 40462, 40463, 40464, 40465, 40466, 40467, 40468, 40469, 40470, 40471, 40472, 40473, 40474, 40475, 40476, 40477, 40478, 40484, 40487, 40494, 40496, 40500, 40507, 40508, 40512, 40525, 40528, 40530, 40531, 40532, 40534, 40537, 40541, 40543, 40544, 40545, 40546, 40549, 40558, 40559, 40562, 40564, 40565, 40566, 40567, 40568, 40569, 40570, 40571, 40572, 40573, 40576, 40577, 40579, 40580, 40581, 40582, 40585, 40586, 40588, 40589, 40590, 40591, 40592, 40593, 40596, 40597, 40598, 40599, 40600, 40601, 40602, 40603, 40604, 40606, 40608, 40609, 40610, 40611, 40612, 40613, 40615, 40616, 40617, 40618, 58190, 58191, 58192, 58193, 58194, 58195, 58196, 58197, 58198, 58199, 58200, 58201, 58202, 58203, 58204, 58205, 58206, 58207, 58208, 58209, 58210, 58211, 58212, 58213, 58214, 58215, 58216, 58217, 58218, 58219, 58220, 58221, 58222, 58223, 58224, 58225, 58226, 58227, 58228, 58229, 58230, 58231, 58232, 58233, 58234, 58235, 58236, 58237, 58238, 58239, 58240, 58241, 58242, 58243, 58244, 58245, 58246, 58247, 58248, 58249, 58250, 58251, 58252, 58253, 58254, 58255, 58256, 58257, 58258, 58259, 58260, 58261, 58262, 58263, 58264, 58265, 58266, 58267, 58268, 58269, 58270, 58271, 58272, 58273, 58274, 58275, 58276, 58277, 58278, 58279, 58280, 58281, 58282, 58283, 40619, 40620, 40621, 40622, 40623, 40624, 40625, 40626, 40627, 40629, 40630, 40631, 40633, 40634, 40636, 40639, 40640, 40641, 40642, 40643, 40645, 40646, 40647, 40648, 40650, 40651, 40652, 40656, 40658, 40659, 40661, 40662, 40663, 40665, 40666, 40670, 40673, 40675, 40676, 40678, 40680, 40683, 40684, 40685, 40686, 40688, 40689, 40690, 40691, 40692, 40693, 40694, 40695, 40696, 40698, 40701, 40703, 40704, 40705, 40706, 40707, 40708, 40709, 40710, 40711, 40712, 40713, 40714, 40716, 40719, 40721, 40722, 40724, 40725, 40726, 40728, 40730, 40731, 40732, 40733, 40734, 40735, 40737, 40739, 40740, 40741, 40742, 40743, 40744, 40745, 40746, 40747, 40749, 40750, 40752, 40753, 58284, 58285, 58286, 58287, 58288, 58289, 58290, 58291, 58292, 58293, 58294, 58295, 58296, 58297, 58298, 58299, 58300, 58301, 58302, 58303, 58304, 58305, 58306, 58307, 58308, 58309, 58310, 58311, 58312, 58313, 58314, 58315, 58316, 58317, 58318, 58319, 58320, 58321, 58322, 58323, 58324, 58325, 58326, 58327, 58328, 58329, 58330, 58331, 58332, 58333, 58334, 58335, 58336, 58337, 58338, 58339, 58340, 58341, 58342, 58343, 58344, 58345, 58346, 58347, 58348, 58349, 58350, 58351, 58352, 58353, 58354, 58355, 58356, 58357, 58358, 58359, 58360, 58361, 58362, 58363, 58364, 58365, 58366, 58367, 58368, 58369, 58370, 58371, 58372, 58373, 58374, 58375, 58376, 58377, 40754, 40755, 40756, 40757, 40758, 40760, 40762, 40764, 40767, 40768, 40769, 40770, 40771, 40773, 40774, 40775, 40776, 40777, 40778, 40779, 40780, 40781, 40782, 40783, 40786, 40787, 40788, 40789, 40790, 40791, 40792, 40793, 40794, 40795, 40796, 40797, 40798, 40799, 40800, 40801, 40802, 40803, 40804, 40805, 40806, 40807, 40808, 40809, 40810, 40811, 40812, 40813, 40814, 40815, 40816, 40817, 40818, 40819, 40820, 40821, 40822, 40823, 40824, 40825, 40826, 40827, 40828, 40829, 40830, 40833, 40834, 40845, 40846, 40847, 40848, 40849, 40850, 40851, 40852, 40853, 40854, 40855, 40856, 40860, 40861, 40862, 40865, 40866, 40867, 40868, 40869, 63788, 63865, 63893, 63975, 63985, 58378, 58379, 58380, 58381, 58382, 58383, 58384, 58385, 58386, 58387, 58388, 58389, 58390, 58391, 58392, 58393, 58394, 58395, 58396, 58397, 58398, 58399, 58400, 58401, 58402, 58403, 58404, 58405, 58406, 58407, 58408, 58409, 58410, 58411, 58412, 58413, 58414, 58415, 58416, 58417, 58418, 58419, 58420, 58421, 58422, 58423, 58424, 58425, 58426, 58427, 58428, 58429, 58430, 58431, 58432, 58433, 58434, 58435, 58436, 58437, 58438, 58439, 58440, 58441, 58442, 58443, 58444, 58445, 58446, 58447, 58448, 58449, 58450, 58451, 58452, 58453, 58454, 58455, 58456, 58457, 58458, 58459, 58460, 58461, 58462, 58463, 58464, 58465, 58466, 58467, 58468, 58469, 58470, 58471, 64012, 64013, 64014, 64015, 64017, 64019, 64020, 64024, 64031, 64032, 64033, 64035, 64036, 64039, 64040, 64041, 11905, 59414, 59415, 59416, 11908, 13427, 13383, 11912, 11915, 59422, 13726, 13850, 13838, 11916, 11927, 14702, 14616, 59430, 14799, 14815, 14963, 14800, 59435, 59436, 15182, 15470, 15584, 11943, 59441, 59442, 11946, 16470, 16735, 11950, 17207, 11955, 11958, 11959, 59451, 17329, 17324, 11963, 17373, 17622, 18017, 17996, 59459, 18211, 18217, 18300, 18317, 11978, 18759, 18810, 18813, 18818, 18819, 18821, 18822, 18847, 18843, 18871, 18870, 59476, 59477, 19619, 19615, 19616, 19617, 19575, 19618, 19731, 19732, 19733, 19734, 19735, 19736, 19737, 19886, 59492, 58472, 58473, 58474, 58475, 58476, 58477, 58478, 58479, 58480, 58481, 58482, 58483, 58484, 58485, 58486, 58487, 58488, 58489, 58490, 58491, 58492, 58493, 58494, 58495, 58496, 58497, 58498, 58499, 58500, 58501, 58502, 58503, 58504, 58505, 58506, 58507, 58508, 58509, 58510, 58511, 58512, 58513, 58514, 58515, 58516, 58517, 58518, 58519, 58520, 58521, 58522, 58523, 58524, 58525, 58526, 58527, 58528, 58529, 58530, 58531, 58532, 58533, 58534, 58535, 58536, 58537, 58538, 58539, 58540, 58541, 58542, 58543, 58544, 58545, 58546, 58547, 58548, 58549, 58550, 58551, 58552, 58553, 58554, 58555, 58556, 58557, 58558, 58559, 58560, 58561, 58562, 58563, 58564, 58565],
        "gb18030-ranges": [[0, 128], [36, 165], [38, 169], [45, 178], [50, 184], [81, 216], [89, 226], [95, 235], [96, 238], [100, 244], [103, 248], [104, 251], [105, 253], [109, 258], [126, 276], [133, 284], [148, 300], [172, 325], [175, 329], [179, 334], [208, 364], [306, 463], [307, 465], [308, 467], [309, 469], [310, 471], [311, 473], [312, 475], [313, 477], [341, 506], [428, 594], [443, 610], [544, 712], [545, 716], [558, 730], [741, 930], [742, 938], [749, 962], [750, 970], [805, 1026], [819, 1104], [820, 1106], [7922, 8209], [7924, 8215], [7925, 8218], [7927, 8222], [7934, 8231], [7943, 8241], [7944, 8244], [7945, 8246], [7950, 8252], [8062, 8365], [8148, 8452], [8149, 8454], [8152, 8458], [8164, 8471], [8174, 8482], [8236, 8556], [8240, 8570], [8262, 8596], [8264, 8602], [8374, 8713], [8380, 8720], [8381, 8722], [8384, 8726], [8388, 8731], [8390, 8737], [8392, 8740], [8393, 8742], [8394, 8748], [8396, 8751], [8401, 8760], [8406, 8766], [8416, 8777], [8419, 8781], [8424, 8787], [8437, 8802], [8439, 8808], [8445, 8816], [8482, 8854], [8485, 8858], [8496, 8870], [8521, 8896], [8603, 8979], [8936, 9322], [8946, 9372], [9046, 9548], [9050, 9588], [9063, 9616], [9066, 9622], [9076, 9634], [9092, 9652], [9100, 9662], [9108, 9672], [9111, 9676], [9113, 9680], [9131, 9702], [9162, 9735], [9164, 9738], [9218, 9793], [9219, 9795], [11329, 11906], [11331, 11909], [11334, 11913], [11336, 11917], [11346, 11928], [11361, 11944], [11363, 11947], [11366, 11951], [11370, 11956], [11372, 11960], [11375, 11964], [11389, 11979], [11682, 12284], [11686, 12292], [11687, 12312], [11692, 12319], [11694, 12330], [11714, 12351], [11716, 12436], [11723, 12447], [11725, 12535], [11730, 12543], [11736, 12586], [11982, 12842], [11989, 12850], [12102, 12964], [12336, 13200], [12348, 13215], [12350, 13218], [12384, 13253], [12393, 13263], [12395, 13267], [12397, 13270], [12510, 13384], [12553, 13428], [12851, 13727], [12962, 13839], [12973, 13851], [13738, 14617], [13823, 14703], [13919, 14801], [13933, 14816], [14080, 14964], [14298, 15183], [14585, 15471], [14698, 15585], [15583, 16471], [15847, 16736], [16318, 17208], [16434, 17325], [16438, 17330], [16481, 17374], [16729, 17623], [17102, 17997], [17122, 18018], [17315, 18212], [17320, 18218], [17402, 18301], [17418, 18318], [17859, 18760], [17909, 18811], [17911, 18814], [17915, 18820], [17916, 18823], [17936, 18844], [17939, 18848], [17961, 18872], [18664, 19576], [18703, 19620], [18814, 19738], [18962, 19887], [19043, 40870], [33469, 59244], [33470, 59336], [33471, 59367], [33484, 59413], [33485, 59417], [33490, 59423], [33497, 59431], [33501, 59437], [33505, 59443], [33513, 59452], [33520, 59460], [33536, 59478], [33550, 59493], [37845, 63789], [37921, 63866], [37948, 63894], [38029, 63976], [38038, 63986], [38064, 64016], [38065, 64018], [38066, 64021], [38069, 64025], [38075, 64034], [38076, 64037], [38078, 64042], [39108, 65074], [39109, 65093], [39113, 65107], [39114, 65112], [39115, 65127], [39116, 65132], [39265, 65375], [39394, 65510], [189e3, 65536]],
        "jis0208": [12288, 12289, 12290, 65292, 65294, 12539, 65306, 65307, 65311, 65281, 12443, 12444, 180, 65344, 168, 65342, 65507, 65343, 12541, 12542, 12445, 12446, 12291, 20189, 12293, 12294, 12295, 12540, 8213, 8208, 65295, 65340, 65374, 8741, 65372, 8230, 8229, 8216, 8217, 8220, 8221, 65288, 65289, 12308, 12309, 65339, 65341, 65371, 65373, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12304, 12305, 65291, 65293, 177, 215, 247, 65309, 8800, 65308, 65310, 8806, 8807, 8734, 8756, 9794, 9792, 176, 8242, 8243, 8451, 65509, 65284, 65504, 65505, 65285, 65283, 65286, 65290, 65312, 167, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 9661, 9660, 8251, 12306, 8594, 8592, 8593, 8595, 12307, null, null, null, null, null, null, null, null, null, null, null, 8712, 8715, 8838, 8839, 8834, 8835, 8746, 8745, null, null, null, null, null, null, null, null, 8743, 8744, 65506, 8658, 8660, 8704, 8707, null, null, null, null, null, null, null, null, null, null, null, 8736, 8869, 8978, 8706, 8711, 8801, 8786, 8810, 8811, 8730, 8765, 8733, 8757, 8747, 8748, null, null, null, null, null, null, null, 8491, 8240, 9839, 9837, 9834, 8224, 8225, 182, null, null, null, null, 9711, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, null, null, null, null, null, null, null, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, null, null, null, null, null, null, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, null, null, null, null, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, null, null, null, null, null, null, null, null, null, null, null, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, null, null, null, null, null, null, null, null, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, null, null, null, null, null, null, null, null, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, null, null, null, null, null, null, null, null, null, null, null, null, null, 9472, 9474, 9484, 9488, 9496, 9492, 9500, 9516, 9508, 9524, 9532, 9473, 9475, 9487, 9491, 9499, 9495, 9507, 9523, 9515, 9531, 9547, 9504, 9519, 9512, 9527, 9535, 9501, 9520, 9509, 9528, 9538, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, null, 13129, 13076, 13090, 13133, 13080, 13095, 13059, 13110, 13137, 13143, 13069, 13094, 13091, 13099, 13130, 13115, 13212, 13213, 13214, 13198, 13199, 13252, 13217, null, null, null, null, null, null, null, null, 13179, 12317, 12319, 8470, 13261, 8481, 12964, 12965, 12966, 12967, 12968, 12849, 12850, 12857, 13182, 13181, 13180, 8786, 8801, 8747, 8750, 8721, 8730, 8869, 8736, 8735, 8895, 8757, 8745, 8746, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20124, 21782, 23043, 38463, 21696, 24859, 25384, 23030, 36898, 33909, 33564, 31312, 24746, 25569, 28197, 26093, 33894, 33446, 39925, 26771, 22311, 26017, 25201, 23451, 22992, 34427, 39156, 32098, 32190, 39822, 25110, 31903, 34999, 23433, 24245, 25353, 26263, 26696, 38343, 38797, 26447, 20197, 20234, 20301, 20381, 20553, 22258, 22839, 22996, 23041, 23561, 24799, 24847, 24944, 26131, 26885, 28858, 30031, 30064, 31227, 32173, 32239, 32963, 33806, 34915, 35586, 36949, 36986, 21307, 20117, 20133, 22495, 32946, 37057, 30959, 19968, 22769, 28322, 36920, 31282, 33576, 33419, 39983, 20801, 21360, 21693, 21729, 22240, 23035, 24341, 39154, 28139, 32996, 34093, 38498, 38512, 38560, 38907, 21515, 21491, 23431, 28879, 32701, 36802, 38632, 21359, 40284, 31418, 19985, 30867, 33276, 28198, 22040, 21764, 27421, 34074, 39995, 23013, 21417, 28006, 29916, 38287, 22082, 20113, 36939, 38642, 33615, 39180, 21473, 21942, 23344, 24433, 26144, 26355, 26628, 27704, 27891, 27945, 29787, 30408, 31310, 38964, 33521, 34907, 35424, 37613, 28082, 30123, 30410, 39365, 24742, 35585, 36234, 38322, 27022, 21421, 20870, 22290, 22576, 22852, 23476, 24310, 24616, 25513, 25588, 27839, 28436, 28814, 28948, 29017, 29141, 29503, 32257, 33398, 33489, 34199, 36960, 37467, 40219, 22633, 26044, 27738, 29989, 20985, 22830, 22885, 24448, 24540, 25276, 26106, 27178, 27431, 27572, 29579, 32705, 35158, 40236, 40206, 40644, 23713, 27798, 33659, 20740, 23627, 25014, 33222, 26742, 29281, 20057, 20474, 21368, 24681, 28201, 31311, 38899, 19979, 21270, 20206, 20309, 20285, 20385, 20339, 21152, 21487, 22025, 22799, 23233, 23478, 23521, 31185, 26247, 26524, 26550, 27468, 27827, 28779, 29634, 31117, 31166, 31292, 31623, 33457, 33499, 33540, 33655, 33775, 33747, 34662, 35506, 22057, 36008, 36838, 36942, 38686, 34442, 20420, 23784, 25105, 29273, 30011, 33253, 33469, 34558, 36032, 38597, 39187, 39381, 20171, 20250, 35299, 22238, 22602, 22730, 24315, 24555, 24618, 24724, 24674, 25040, 25106, 25296, 25913, 39745, 26214, 26800, 28023, 28784, 30028, 30342, 32117, 33445, 34809, 38283, 38542, 35997, 20977, 21182, 22806, 21683, 23475, 23830, 24936, 27010, 28079, 30861, 33995, 34903, 35442, 37799, 39608, 28012, 39336, 34521, 22435, 26623, 34510, 37390, 21123, 22151, 21508, 24275, 25313, 25785, 26684, 26680, 27579, 29554, 30906, 31339, 35226, 35282, 36203, 36611, 37101, 38307, 38548, 38761, 23398, 23731, 27005, 38989, 38990, 25499, 31520, 27179, 27263, 26806, 39949, 28511, 21106, 21917, 24688, 25324, 27963, 28167, 28369, 33883, 35088, 36676, 19988, 39993, 21494, 26907, 27194, 38788, 26666, 20828, 31427, 33970, 37340, 37772, 22107, 40232, 26658, 33541, 33841, 31909, 21e3, 33477, 29926, 20094, 20355, 20896, 23506, 21002, 21208, 21223, 24059, 21914, 22570, 23014, 23436, 23448, 23515, 24178, 24185, 24739, 24863, 24931, 25022, 25563, 25954, 26577, 26707, 26874, 27454, 27475, 27735, 28450, 28567, 28485, 29872, 29976, 30435, 30475, 31487, 31649, 31777, 32233, 32566, 32752, 32925, 33382, 33694, 35251, 35532, 36011, 36996, 37969, 38291, 38289, 38306, 38501, 38867, 39208, 33304, 20024, 21547, 23736, 24012, 29609, 30284, 30524, 23721, 32747, 36107, 38593, 38929, 38996, 39e3, 20225, 20238, 21361, 21916, 22120, 22522, 22855, 23305, 23492, 23696, 24076, 24190, 24524, 25582, 26426, 26071, 26082, 26399, 26827, 26820, 27231, 24112, 27589, 27671, 27773, 30079, 31048, 23395, 31232, 32e3, 24509, 35215, 35352, 36020, 36215, 36556, 36637, 39138, 39438, 39740, 20096, 20605, 20736, 22931, 23452, 25135, 25216, 25836, 27450, 29344, 30097, 31047, 32681, 34811, 35516, 35696, 25516, 33738, 38816, 21513, 21507, 21931, 26708, 27224, 35440, 30759, 26485, 40653, 21364, 23458, 33050, 34384, 36870, 19992, 20037, 20167, 20241, 21450, 21560, 23470, 24339, 24613, 25937, 26429, 27714, 27762, 27875, 28792, 29699, 31350, 31406, 31496, 32026, 31998, 32102, 26087, 29275, 21435, 23621, 24040, 25298, 25312, 25369, 28192, 34394, 35377, 36317, 37624, 28417, 31142, 39770, 20136, 20139, 20140, 20379, 20384, 20689, 20807, 31478, 20849, 20982, 21332, 21281, 21375, 21483, 21932, 22659, 23777, 24375, 24394, 24623, 24656, 24685, 25375, 25945, 27211, 27841, 29378, 29421, 30703, 33016, 33029, 33288, 34126, 37111, 37857, 38911, 39255, 39514, 20208, 20957, 23597, 26241, 26989, 23616, 26354, 26997, 29577, 26704, 31873, 20677, 21220, 22343, 24062, 37670, 26020, 27427, 27453, 29748, 31105, 31165, 31563, 32202, 33465, 33740, 34943, 35167, 35641, 36817, 37329, 21535, 37504, 20061, 20534, 21477, 21306, 29399, 29590, 30697, 33510, 36527, 39366, 39368, 39378, 20855, 24858, 34398, 21936, 31354, 20598, 23507, 36935, 38533, 20018, 27355, 37351, 23633, 23624, 25496, 31391, 27795, 38772, 36705, 31402, 29066, 38536, 31874, 26647, 32368, 26705, 37740, 21234, 21531, 34219, 35347, 32676, 36557, 37089, 21350, 34952, 31041, 20418, 20670, 21009, 20804, 21843, 22317, 29674, 22411, 22865, 24418, 24452, 24693, 24950, 24935, 25001, 25522, 25658, 25964, 26223, 26690, 28179, 30054, 31293, 31995, 32076, 32153, 32331, 32619, 33550, 33610, 34509, 35336, 35427, 35686, 36605, 38938, 40335, 33464, 36814, 39912, 21127, 25119, 25731, 28608, 38553, 26689, 20625, 27424, 27770, 28500, 31348, 32080, 34880, 35363, 26376, 20214, 20537, 20518, 20581, 20860, 21048, 21091, 21927, 22287, 22533, 23244, 24314, 25010, 25080, 25331, 25458, 26908, 27177, 29309, 29356, 29486, 30740, 30831, 32121, 30476, 32937, 35211, 35609, 36066, 36562, 36963, 37749, 38522, 38997, 39443, 40568, 20803, 21407, 21427, 24187, 24358, 28187, 28304, 29572, 29694, 32067, 33335, 35328, 35578, 38480, 20046, 20491, 21476, 21628, 22266, 22993, 23396, 24049, 24235, 24359, 25144, 25925, 26543, 28246, 29392, 31946, 34996, 32929, 32993, 33776, 34382, 35463, 36328, 37431, 38599, 39015, 40723, 20116, 20114, 20237, 21320, 21577, 21566, 23087, 24460, 24481, 24735, 26791, 27278, 29786, 30849, 35486, 35492, 35703, 37264, 20062, 39881, 20132, 20348, 20399, 20505, 20502, 20809, 20844, 21151, 21177, 21246, 21402, 21475, 21521, 21518, 21897, 22353, 22434, 22909, 23380, 23389, 23439, 24037, 24039, 24055, 24184, 24195, 24218, 24247, 24344, 24658, 24908, 25239, 25304, 25511, 25915, 26114, 26179, 26356, 26477, 26657, 26775, 27083, 27743, 27946, 28009, 28207, 28317, 30002, 30343, 30828, 31295, 31968, 32005, 32024, 32094, 32177, 32789, 32771, 32943, 32945, 33108, 33167, 33322, 33618, 34892, 34913, 35611, 36002, 36092, 37066, 37237, 37489, 30783, 37628, 38308, 38477, 38917, 39321, 39640, 40251, 21083, 21163, 21495, 21512, 22741, 25335, 28640, 35946, 36703, 40633, 20811, 21051, 21578, 22269, 31296, 37239, 40288, 40658, 29508, 28425, 33136, 29969, 24573, 24794, 39592, 29403, 36796, 27492, 38915, 20170, 22256, 22372, 22718, 23130, 24680, 25031, 26127, 26118, 26681, 26801, 28151, 30165, 32058, 33390, 39746, 20123, 20304, 21449, 21766, 23919, 24038, 24046, 26619, 27801, 29811, 30722, 35408, 37782, 35039, 22352, 24231, 25387, 20661, 20652, 20877, 26368, 21705, 22622, 22971, 23472, 24425, 25165, 25505, 26685, 27507, 28168, 28797, 37319, 29312, 30741, 30758, 31085, 25998, 32048, 33756, 35009, 36617, 38555, 21092, 22312, 26448, 32618, 36001, 20916, 22338, 38442, 22586, 27018, 32948, 21682, 23822, 22524, 30869, 40442, 20316, 21066, 21643, 25662, 26152, 26388, 26613, 31364, 31574, 32034, 37679, 26716, 39853, 31545, 21273, 20874, 21047, 23519, 25334, 25774, 25830, 26413, 27578, 34217, 38609, 30352, 39894, 25420, 37638, 39851, 30399, 26194, 19977, 20632, 21442, 23665, 24808, 25746, 25955, 26719, 29158, 29642, 29987, 31639, 32386, 34453, 35715, 36059, 37240, 39184, 26028, 26283, 27531, 20181, 20180, 20282, 20351, 21050, 21496, 21490, 21987, 22235, 22763, 22987, 22985, 23039, 23376, 23629, 24066, 24107, 24535, 24605, 25351, 25903, 23388, 26031, 26045, 26088, 26525, 27490, 27515, 27663, 29509, 31049, 31169, 31992, 32025, 32043, 32930, 33026, 33267, 35222, 35422, 35433, 35430, 35468, 35566, 36039, 36060, 38604, 39164, 27503, 20107, 20284, 20365, 20816, 23383, 23546, 24904, 25345, 26178, 27425, 28363, 27835, 29246, 29885, 30164, 30913, 31034, 32780, 32819, 33258, 33940, 36766, 27728, 40575, 24335, 35672, 40235, 31482, 36600, 23437, 38635, 19971, 21489, 22519, 22833, 23241, 23460, 24713, 28287, 28422, 30142, 36074, 23455, 34048, 31712, 20594, 26612, 33437, 23649, 34122, 32286, 33294, 20889, 23556, 25448, 36198, 26012, 29038, 31038, 32023, 32773, 35613, 36554, 36974, 34503, 37034, 20511, 21242, 23610, 26451, 28796, 29237, 37196, 37320, 37675, 33509, 23490, 24369, 24825, 20027, 21462, 23432, 25163, 26417, 27530, 29417, 29664, 31278, 33131, 36259, 37202, 39318, 20754, 21463, 21610, 23551, 25480, 27193, 32172, 38656, 22234, 21454, 21608, 23447, 23601, 24030, 20462, 24833, 25342, 27954, 31168, 31179, 32066, 32333, 32722, 33261, 33311, 33936, 34886, 35186, 35728, 36468, 36655, 36913, 37195, 37228, 38598, 37276, 20160, 20303, 20805, 21313, 24467, 25102, 26580, 27713, 28171, 29539, 32294, 37325, 37507, 21460, 22809, 23487, 28113, 31069, 32302, 31899, 22654, 29087, 20986, 34899, 36848, 20426, 23803, 26149, 30636, 31459, 33308, 39423, 20934, 24490, 26092, 26991, 27529, 28147, 28310, 28516, 30462, 32020, 24033, 36981, 37255, 38918, 20966, 21021, 25152, 26257, 26329, 28186, 24246, 32210, 32626, 26360, 34223, 34295, 35576, 21161, 21465, 22899, 24207, 24464, 24661, 37604, 38500, 20663, 20767, 21213, 21280, 21319, 21484, 21736, 21830, 21809, 22039, 22888, 22974, 23100, 23477, 23558, 23567, 23569, 23578, 24196, 24202, 24288, 24432, 25215, 25220, 25307, 25484, 25463, 26119, 26124, 26157, 26230, 26494, 26786, 27167, 27189, 27836, 28040, 28169, 28248, 28988, 28966, 29031, 30151, 30465, 30813, 30977, 31077, 31216, 31456, 31505, 31911, 32057, 32918, 33750, 33931, 34121, 34909, 35059, 35359, 35388, 35412, 35443, 35937, 36062, 37284, 37478, 37758, 37912, 38556, 38808, 19978, 19976, 19998, 20055, 20887, 21104, 22478, 22580, 22732, 23330, 24120, 24773, 25854, 26465, 26454, 27972, 29366, 30067, 31331, 33976, 35698, 37304, 37664, 22065, 22516, 39166, 25325, 26893, 27542, 29165, 32340, 32887, 33394, 35302, 39135, 34645, 36785, 23611, 20280, 20449, 20405, 21767, 23072, 23517, 23529, 24515, 24910, 25391, 26032, 26187, 26862, 27035, 28024, 28145, 30003, 30137, 30495, 31070, 31206, 32051, 33251, 33455, 34218, 35242, 35386, 36523, 36763, 36914, 37341, 38663, 20154, 20161, 20995, 22645, 22764, 23563, 29978, 23613, 33102, 35338, 36805, 38499, 38765, 31525, 35535, 38920, 37218, 22259, 21416, 36887, 21561, 22402, 24101, 25512, 27700, 28810, 30561, 31883, 32736, 34928, 36930, 37204, 37648, 37656, 38543, 29790, 39620, 23815, 23913, 25968, 26530, 36264, 38619, 25454, 26441, 26905, 33733, 38935, 38592, 35070, 28548, 25722, 23544, 19990, 28716, 30045, 26159, 20932, 21046, 21218, 22995, 24449, 24615, 25104, 25919, 25972, 26143, 26228, 26866, 26646, 27491, 28165, 29298, 29983, 30427, 31934, 32854, 22768, 35069, 35199, 35488, 35475, 35531, 36893, 37266, 38738, 38745, 25993, 31246, 33030, 38587, 24109, 24796, 25114, 26021, 26132, 26512, 30707, 31309, 31821, 32318, 33034, 36012, 36196, 36321, 36447, 30889, 20999, 25305, 25509, 25666, 25240, 35373, 31363, 31680, 35500, 38634, 32118, 33292, 34633, 20185, 20808, 21315, 21344, 23459, 23554, 23574, 24029, 25126, 25159, 25776, 26643, 26676, 27849, 27973, 27927, 26579, 28508, 29006, 29053, 26059, 31359, 31661, 32218, 32330, 32680, 33146, 33307, 33337, 34214, 35438, 36046, 36341, 36984, 36983, 37549, 37521, 38275, 39854, 21069, 21892, 28472, 28982, 20840, 31109, 32341, 33203, 31950, 22092, 22609, 23720, 25514, 26366, 26365, 26970, 29401, 30095, 30094, 30990, 31062, 31199, 31895, 32032, 32068, 34311, 35380, 38459, 36961, 40736, 20711, 21109, 21452, 21474, 20489, 21930, 22766, 22863, 29245, 23435, 23652, 21277, 24803, 24819, 25436, 25475, 25407, 25531, 25805, 26089, 26361, 24035, 27085, 27133, 28437, 29157, 20105, 30185, 30456, 31379, 31967, 32207, 32156, 32865, 33609, 33624, 33900, 33980, 34299, 35013, 36208, 36865, 36973, 37783, 38684, 39442, 20687, 22679, 24974, 33235, 34101, 36104, 36896, 20419, 20596, 21063, 21363, 24687, 25417, 26463, 28204, 36275, 36895, 20439, 23646, 36042, 26063, 32154, 21330, 34966, 20854, 25539, 23384, 23403, 23562, 25613, 26449, 36956, 20182, 22810, 22826, 27760, 35409, 21822, 22549, 22949, 24816, 25171, 26561, 33333, 26965, 38464, 39364, 39464, 20307, 22534, 23550, 32784, 23729, 24111, 24453, 24608, 24907, 25140, 26367, 27888, 28382, 32974, 33151, 33492, 34955, 36024, 36864, 36910, 38538, 40667, 39899, 20195, 21488, 22823, 31532, 37261, 38988, 40441, 28381, 28711, 21331, 21828, 23429, 25176, 25246, 25299, 27810, 28655, 29730, 35351, 37944, 28609, 35582, 33592, 20967, 34552, 21482, 21481, 20294, 36948, 36784, 22890, 33073, 24061, 31466, 36799, 26842, 35895, 29432, 40008, 27197, 35504, 20025, 21336, 22022, 22374, 25285, 25506, 26086, 27470, 28129, 28251, 28845, 30701, 31471, 31658, 32187, 32829, 32966, 34507, 35477, 37723, 22243, 22727, 24382, 26029, 26262, 27264, 27573, 30007, 35527, 20516, 30693, 22320, 24347, 24677, 26234, 27744, 30196, 31258, 32622, 33268, 34584, 36933, 39347, 31689, 30044, 31481, 31569, 33988, 36880, 31209, 31378, 33590, 23265, 30528, 20013, 20210, 23449, 24544, 25277, 26172, 26609, 27880, 34411, 34935, 35387, 37198, 37619, 39376, 27159, 28710, 29482, 33511, 33879, 36015, 19969, 20806, 20939, 21899, 23541, 24086, 24115, 24193, 24340, 24373, 24427, 24500, 25074, 25361, 26274, 26397, 28526, 29266, 30010, 30522, 32884, 33081, 33144, 34678, 35519, 35548, 36229, 36339, 37530, 38263, 38914, 40165, 21189, 25431, 30452, 26389, 27784, 29645, 36035, 37806, 38515, 27941, 22684, 26894, 27084, 36861, 37786, 30171, 36890, 22618, 26626, 25524, 27131, 20291, 28460, 26584, 36795, 34086, 32180, 37716, 26943, 28528, 22378, 22775, 23340, 32044, 29226, 21514, 37347, 40372, 20141, 20302, 20572, 20597, 21059, 35998, 21576, 22564, 23450, 24093, 24213, 24237, 24311, 24351, 24716, 25269, 25402, 25552, 26799, 27712, 30855, 31118, 31243, 32224, 33351, 35330, 35558, 36420, 36883, 37048, 37165, 37336, 40718, 27877, 25688, 25826, 25973, 28404, 30340, 31515, 36969, 37841, 28346, 21746, 24505, 25764, 36685, 36845, 37444, 20856, 22635, 22825, 23637, 24215, 28155, 32399, 29980, 36028, 36578, 39003, 28857, 20253, 27583, 28593, 3e4, 38651, 20814, 21520, 22581, 22615, 22956, 23648, 24466, 26007, 26460, 28193, 30331, 33759, 36077, 36884, 37117, 37709, 30757, 30778, 21162, 24230, 22303, 22900, 24594, 20498, 20826, 20908, 20941, 20992, 21776, 22612, 22616, 22871, 23445, 23798, 23947, 24764, 25237, 25645, 26481, 26691, 26812, 26847, 30423, 28120, 28271, 28059, 28783, 29128, 24403, 30168, 31095, 31561, 31572, 31570, 31958, 32113, 21040, 33891, 34153, 34276, 35342, 35588, 35910, 36367, 36867, 36879, 37913, 38518, 38957, 39472, 38360, 20685, 21205, 21516, 22530, 23566, 24999, 25758, 27934, 30643, 31461, 33012, 33796, 36947, 37509, 23776, 40199, 21311, 24471, 24499, 28060, 29305, 30563, 31167, 31716, 27602, 29420, 35501, 26627, 27233, 20984, 31361, 26932, 23626, 40182, 33515, 23493, 37193, 28702, 22136, 23663, 24775, 25958, 27788, 35930, 36929, 38931, 21585, 26311, 37389, 22856, 37027, 20869, 20045, 20970, 34201, 35598, 28760, 25466, 37707, 26978, 39348, 32260, 30071, 21335, 26976, 36575, 38627, 27741, 20108, 23612, 24336, 36841, 21250, 36049, 32905, 34425, 24319, 26085, 20083, 20837, 22914, 23615, 38894, 20219, 22922, 24525, 35469, 28641, 31152, 31074, 23527, 33905, 29483, 29105, 24180, 24565, 25467, 25754, 29123, 31896, 20035, 24316, 20043, 22492, 22178, 24745, 28611, 32013, 33021, 33075, 33215, 36786, 35223, 34468, 24052, 25226, 25773, 35207, 26487, 27874, 27966, 29750, 30772, 23110, 32629, 33453, 39340, 20467, 24259, 25309, 25490, 25943, 26479, 30403, 29260, 32972, 32954, 36649, 37197, 20493, 22521, 23186, 26757, 26995, 29028, 29437, 36023, 22770, 36064, 38506, 36889, 34687, 31204, 30695, 33833, 20271, 21093, 21338, 25293, 26575, 27850, 30333, 31636, 31893, 33334, 34180, 36843, 26333, 28448, 29190, 32283, 33707, 39361, 40614, 20989, 31665, 30834, 31672, 32903, 31560, 27368, 24161, 32908, 30033, 30048, 20843, 37474, 28300, 30330, 37271, 39658, 20240, 32624, 25244, 31567, 38309, 40169, 22138, 22617, 34532, 38588, 20276, 21028, 21322, 21453, 21467, 24070, 25644, 26001, 26495, 27710, 27726, 29256, 29359, 29677, 30036, 32321, 33324, 34281, 36009, 31684, 37318, 29033, 38930, 39151, 25405, 26217, 30058, 30436, 30928, 34115, 34542, 21290, 21329, 21542, 22915, 24199, 24444, 24754, 25161, 25209, 25259, 26e3, 27604, 27852, 30130, 30382, 30865, 31192, 32203, 32631, 32933, 34987, 35513, 36027, 36991, 38750, 39131, 27147, 31800, 20633, 23614, 24494, 26503, 27608, 29749, 30473, 32654, 40763, 26570, 31255, 21305, 30091, 39661, 24422, 33181, 33777, 32920, 24380, 24517, 30050, 31558, 36924, 26727, 23019, 23195, 32016, 30334, 35628, 20469, 24426, 27161, 27703, 28418, 29922, 31080, 34920, 35413, 35961, 24287, 25551, 30149, 31186, 33495, 37672, 37618, 33948, 34541, 39981, 21697, 24428, 25996, 27996, 28693, 36007, 36051, 38971, 25935, 29942, 19981, 20184, 22496, 22827, 23142, 23500, 20904, 24067, 24220, 24598, 25206, 25975, 26023, 26222, 28014, 29238, 31526, 33104, 33178, 33433, 35676, 36e3, 36070, 36212, 38428, 38468, 20398, 25771, 27494, 33310, 33889, 34154, 37096, 23553, 26963, 39080, 33914, 34135, 20239, 21103, 24489, 24133, 26381, 31119, 33145, 35079, 35206, 28149, 24343, 25173, 27832, 20175, 29289, 39826, 20998, 21563, 22132, 22707, 24996, 25198, 28954, 22894, 31881, 31966, 32027, 38640, 25991, 32862, 19993, 20341, 20853, 22592, 24163, 24179, 24330, 26564, 20006, 34109, 38281, 38491, 31859, 38913, 20731, 22721, 30294, 30887, 21029, 30629, 34065, 31622, 20559, 22793, 29255, 31687, 32232, 36794, 36820, 36941, 20415, 21193, 23081, 24321, 38829, 20445, 33303, 37610, 22275, 25429, 27497, 29995, 35036, 36628, 31298, 21215, 22675, 24917, 25098, 26286, 27597, 31807, 33769, 20515, 20472, 21253, 21574, 22577, 22857, 23453, 23792, 23791, 23849, 24214, 25265, 25447, 25918, 26041, 26379, 27861, 27873, 28921, 30770, 32299, 32990, 33459, 33804, 34028, 34562, 35090, 35370, 35914, 37030, 37586, 39165, 40179, 40300, 20047, 20129, 20621, 21078, 22346, 22952, 24125, 24536, 24537, 25151, 26292, 26395, 26576, 26834, 20882, 32033, 32938, 33192, 35584, 35980, 36031, 37502, 38450, 21536, 38956, 21271, 20693, 21340, 22696, 25778, 26420, 29287, 30566, 31302, 37350, 21187, 27809, 27526, 22528, 24140, 22868, 26412, 32763, 20961, 30406, 25705, 30952, 39764, 40635, 22475, 22969, 26151, 26522, 27598, 21737, 27097, 24149, 33180, 26517, 39850, 26622, 40018, 26717, 20134, 20451, 21448, 25273, 26411, 27819, 36804, 20397, 32365, 40639, 19975, 24930, 28288, 28459, 34067, 21619, 26410, 39749, 24051, 31637, 23724, 23494, 34588, 28234, 34001, 31252, 33032, 22937, 31885, 27665, 30496, 21209, 22818, 28961, 29279, 30683, 38695, 40289, 26891, 23167, 23064, 20901, 21517, 21629, 26126, 30431, 36855, 37528, 40180, 23018, 29277, 28357, 20813, 26825, 32191, 32236, 38754, 40634, 25720, 27169, 33538, 22916, 23391, 27611, 29467, 30450, 32178, 32791, 33945, 20786, 26408, 40665, 30446, 26466, 21247, 39173, 23588, 25147, 31870, 36016, 21839, 24758, 32011, 38272, 21249, 20063, 20918, 22812, 29242, 32822, 37326, 24357, 30690, 21380, 24441, 32004, 34220, 35379, 36493, 38742, 26611, 34222, 37971, 24841, 24840, 27833, 30290, 35565, 36664, 21807, 20305, 20778, 21191, 21451, 23461, 24189, 24736, 24962, 25558, 26377, 26586, 28263, 28044, 29494, 29495, 30001, 31056, 35029, 35480, 36938, 37009, 37109, 38596, 34701, 22805, 20104, 20313, 19982, 35465, 36671, 38928, 20653, 24188, 22934, 23481, 24248, 25562, 25594, 25793, 26332, 26954, 27096, 27915, 28342, 29076, 29992, 31407, 32650, 32768, 33865, 33993, 35201, 35617, 36362, 36965, 38525, 39178, 24958, 25233, 27442, 27779, 28020, 32716, 32764, 28096, 32645, 34746, 35064, 26469, 33713, 38972, 38647, 27931, 32097, 33853, 37226, 20081, 21365, 23888, 27396, 28651, 34253, 34349, 35239, 21033, 21519, 23653, 26446, 26792, 29702, 29827, 30178, 35023, 35041, 37324, 38626, 38520, 24459, 29575, 31435, 33870, 25504, 30053, 21129, 27969, 28316, 29705, 30041, 30827, 31890, 38534, 31452, 40845, 20406, 24942, 26053, 34396, 20102, 20142, 20698, 20001, 20940, 23534, 26009, 26753, 28092, 29471, 30274, 30637, 31260, 31975, 33391, 35538, 36988, 37327, 38517, 38936, 21147, 32209, 20523, 21400, 26519, 28107, 29136, 29747, 33256, 36650, 38563, 40023, 40607, 29792, 22593, 28057, 32047, 39006, 20196, 20278, 20363, 20919, 21169, 23994, 24604, 29618, 31036, 33491, 37428, 38583, 38646, 38666, 40599, 40802, 26278, 27508, 21015, 21155, 28872, 35010, 24265, 24651, 24976, 28451, 29001, 31806, 32244, 32879, 34030, 36899, 37676, 21570, 39791, 27347, 28809, 36034, 36335, 38706, 21172, 23105, 24266, 24324, 26391, 27004, 27028, 28010, 28431, 29282, 29436, 31725, 32769, 32894, 34635, 37070, 20845, 40595, 31108, 32907, 37682, 35542, 20525, 21644, 35441, 27498, 36036, 33031, 24785, 26528, 40434, 20121, 20120, 39952, 35435, 34241, 34152, 26880, 28286, 30871, 33109, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 24332, 19984, 19989, 20010, 20017, 20022, 20028, 20031, 20034, 20054, 20056, 20098, 20101, 35947, 20106, 33298, 24333, 20110, 20126, 20127, 20128, 20130, 20144, 20147, 20150, 20174, 20173, 20164, 20166, 20162, 20183, 20190, 20205, 20191, 20215, 20233, 20314, 20272, 20315, 20317, 20311, 20295, 20342, 20360, 20367, 20376, 20347, 20329, 20336, 20369, 20335, 20358, 20374, 20760, 20436, 20447, 20430, 20440, 20443, 20433, 20442, 20432, 20452, 20453, 20506, 20520, 20500, 20522, 20517, 20485, 20252, 20470, 20513, 20521, 20524, 20478, 20463, 20497, 20486, 20547, 20551, 26371, 20565, 20560, 20552, 20570, 20566, 20588, 20600, 20608, 20634, 20613, 20660, 20658, 20681, 20682, 20659, 20674, 20694, 20702, 20709, 20717, 20707, 20718, 20729, 20725, 20745, 20737, 20738, 20758, 20757, 20756, 20762, 20769, 20794, 20791, 20796, 20795, 20799, 20800, 20818, 20812, 20820, 20834, 31480, 20841, 20842, 20846, 20864, 20866, 22232, 20876, 20873, 20879, 20881, 20883, 20885, 20886, 20900, 20902, 20898, 20905, 20906, 20907, 20915, 20913, 20914, 20912, 20917, 20925, 20933, 20937, 20955, 20960, 34389, 20969, 20973, 20976, 20981, 20990, 20996, 21003, 21012, 21006, 21031, 21034, 21038, 21043, 21049, 21071, 21060, 21067, 21068, 21086, 21076, 21098, 21108, 21097, 21107, 21119, 21117, 21133, 21140, 21138, 21105, 21128, 21137, 36776, 36775, 21164, 21165, 21180, 21173, 21185, 21197, 21207, 21214, 21219, 21222, 39149, 21216, 21235, 21237, 21240, 21241, 21254, 21256, 30008, 21261, 21264, 21263, 21269, 21274, 21283, 21295, 21297, 21299, 21304, 21312, 21318, 21317, 19991, 21321, 21325, 20950, 21342, 21353, 21358, 22808, 21371, 21367, 21378, 21398, 21408, 21414, 21413, 21422, 21424, 21430, 21443, 31762, 38617, 21471, 26364, 29166, 21486, 21480, 21485, 21498, 21505, 21565, 21568, 21548, 21549, 21564, 21550, 21558, 21545, 21533, 21582, 21647, 21621, 21646, 21599, 21617, 21623, 21616, 21650, 21627, 21632, 21622, 21636, 21648, 21638, 21703, 21666, 21688, 21669, 21676, 21700, 21704, 21672, 21675, 21698, 21668, 21694, 21692, 21720, 21733, 21734, 21775, 21780, 21757, 21742, 21741, 21754, 21730, 21817, 21824, 21859, 21836, 21806, 21852, 21829, 21846, 21847, 21816, 21811, 21853, 21913, 21888, 21679, 21898, 21919, 21883, 21886, 21912, 21918, 21934, 21884, 21891, 21929, 21895, 21928, 21978, 21957, 21983, 21956, 21980, 21988, 21972, 22036, 22007, 22038, 22014, 22013, 22043, 22009, 22094, 22096, 29151, 22068, 22070, 22066, 22072, 22123, 22116, 22063, 22124, 22122, 22150, 22144, 22154, 22176, 22164, 22159, 22181, 22190, 22198, 22196, 22210, 22204, 22209, 22211, 22208, 22216, 22222, 22225, 22227, 22231, 22254, 22265, 22272, 22271, 22276, 22281, 22280, 22283, 22285, 22291, 22296, 22294, 21959, 22300, 22310, 22327, 22328, 22350, 22331, 22336, 22351, 22377, 22464, 22408, 22369, 22399, 22409, 22419, 22432, 22451, 22436, 22442, 22448, 22467, 22470, 22484, 22482, 22483, 22538, 22486, 22499, 22539, 22553, 22557, 22642, 22561, 22626, 22603, 22640, 27584, 22610, 22589, 22649, 22661, 22713, 22687, 22699, 22714, 22750, 22715, 22712, 22702, 22725, 22739, 22737, 22743, 22745, 22744, 22757, 22748, 22756, 22751, 22767, 22778, 22777, 22779, 22780, 22781, 22786, 22794, 22800, 22811, 26790, 22821, 22828, 22829, 22834, 22840, 22846, 31442, 22869, 22864, 22862, 22874, 22872, 22882, 22880, 22887, 22892, 22889, 22904, 22913, 22941, 20318, 20395, 22947, 22962, 22982, 23016, 23004, 22925, 23001, 23002, 23077, 23071, 23057, 23068, 23049, 23066, 23104, 23148, 23113, 23093, 23094, 23138, 23146, 23194, 23228, 23230, 23243, 23234, 23229, 23267, 23255, 23270, 23273, 23254, 23290, 23291, 23308, 23307, 23318, 23346, 23248, 23338, 23350, 23358, 23363, 23365, 23360, 23377, 23381, 23386, 23387, 23397, 23401, 23408, 23411, 23413, 23416, 25992, 23418, 23424, 23427, 23462, 23480, 23491, 23495, 23497, 23508, 23504, 23524, 23526, 23522, 23518, 23525, 23531, 23536, 23542, 23539, 23557, 23559, 23560, 23565, 23571, 23584, 23586, 23592, 23608, 23609, 23617, 23622, 23630, 23635, 23632, 23631, 23409, 23660, 23662, 20066, 23670, 23673, 23692, 23697, 23700, 22939, 23723, 23739, 23734, 23740, 23735, 23749, 23742, 23751, 23769, 23785, 23805, 23802, 23789, 23948, 23786, 23819, 23829, 23831, 23900, 23839, 23835, 23825, 23828, 23842, 23834, 23833, 23832, 23884, 23890, 23886, 23883, 23916, 23923, 23926, 23943, 23940, 23938, 23970, 23965, 23980, 23982, 23997, 23952, 23991, 23996, 24009, 24013, 24019, 24018, 24022, 24027, 24043, 24050, 24053, 24075, 24090, 24089, 24081, 24091, 24118, 24119, 24132, 24131, 24128, 24142, 24151, 24148, 24159, 24162, 24164, 24135, 24181, 24182, 24186, 40636, 24191, 24224, 24257, 24258, 24264, 24272, 24271, 24278, 24291, 24285, 24282, 24283, 24290, 24289, 24296, 24297, 24300, 24305, 24307, 24304, 24308, 24312, 24318, 24323, 24329, 24413, 24412, 24331, 24337, 24342, 24361, 24365, 24376, 24385, 24392, 24396, 24398, 24367, 24401, 24406, 24407, 24409, 24417, 24429, 24435, 24439, 24451, 24450, 24447, 24458, 24456, 24465, 24455, 24478, 24473, 24472, 24480, 24488, 24493, 24508, 24534, 24571, 24548, 24568, 24561, 24541, 24755, 24575, 24609, 24672, 24601, 24592, 24617, 24590, 24625, 24603, 24597, 24619, 24614, 24591, 24634, 24666, 24641, 24682, 24695, 24671, 24650, 24646, 24653, 24675, 24643, 24676, 24642, 24684, 24683, 24665, 24705, 24717, 24807, 24707, 24730, 24708, 24731, 24726, 24727, 24722, 24743, 24715, 24801, 24760, 24800, 24787, 24756, 24560, 24765, 24774, 24757, 24792, 24909, 24853, 24838, 24822, 24823, 24832, 24820, 24826, 24835, 24865, 24827, 24817, 24845, 24846, 24903, 24894, 24872, 24871, 24906, 24895, 24892, 24876, 24884, 24893, 24898, 24900, 24947, 24951, 24920, 24921, 24922, 24939, 24948, 24943, 24933, 24945, 24927, 24925, 24915, 24949, 24985, 24982, 24967, 25004, 24980, 24986, 24970, 24977, 25003, 25006, 25036, 25034, 25033, 25079, 25032, 25027, 25030, 25018, 25035, 32633, 25037, 25062, 25059, 25078, 25082, 25076, 25087, 25085, 25084, 25086, 25088, 25096, 25097, 25101, 25100, 25108, 25115, 25118, 25121, 25130, 25134, 25136, 25138, 25139, 25153, 25166, 25182, 25187, 25179, 25184, 25192, 25212, 25218, 25225, 25214, 25234, 25235, 25238, 25300, 25219, 25236, 25303, 25297, 25275, 25295, 25343, 25286, 25812, 25288, 25308, 25292, 25290, 25282, 25287, 25243, 25289, 25356, 25326, 25329, 25383, 25346, 25352, 25327, 25333, 25424, 25406, 25421, 25628, 25423, 25494, 25486, 25472, 25515, 25462, 25507, 25487, 25481, 25503, 25525, 25451, 25449, 25534, 25577, 25536, 25542, 25571, 25545, 25554, 25590, 25540, 25622, 25652, 25606, 25619, 25638, 25654, 25885, 25623, 25640, 25615, 25703, 25711, 25718, 25678, 25898, 25749, 25747, 25765, 25769, 25736, 25788, 25818, 25810, 25797, 25799, 25787, 25816, 25794, 25841, 25831, 33289, 25824, 25825, 25260, 25827, 25839, 25900, 25846, 25844, 25842, 25850, 25856, 25853, 25880, 25884, 25861, 25892, 25891, 25899, 25908, 25909, 25911, 25910, 25912, 30027, 25928, 25942, 25941, 25933, 25944, 25950, 25949, 25970, 25976, 25986, 25987, 35722, 26011, 26015, 26027, 26039, 26051, 26054, 26049, 26052, 26060, 26066, 26075, 26073, 26080, 26081, 26097, 26482, 26122, 26115, 26107, 26483, 26165, 26166, 26164, 26140, 26191, 26180, 26185, 26177, 26206, 26205, 26212, 26215, 26216, 26207, 26210, 26224, 26243, 26248, 26254, 26249, 26244, 26264, 26269, 26305, 26297, 26313, 26302, 26300, 26308, 26296, 26326, 26330, 26336, 26175, 26342, 26345, 26352, 26357, 26359, 26383, 26390, 26398, 26406, 26407, 38712, 26414, 26431, 26422, 26433, 26424, 26423, 26438, 26462, 26464, 26457, 26467, 26468, 26505, 26480, 26537, 26492, 26474, 26508, 26507, 26534, 26529, 26501, 26551, 26607, 26548, 26604, 26547, 26601, 26552, 26596, 26590, 26589, 26594, 26606, 26553, 26574, 26566, 26599, 27292, 26654, 26694, 26665, 26688, 26701, 26674, 26702, 26803, 26667, 26713, 26723, 26743, 26751, 26783, 26767, 26797, 26772, 26781, 26779, 26755, 27310, 26809, 26740, 26805, 26784, 26810, 26895, 26765, 26750, 26881, 26826, 26888, 26840, 26914, 26918, 26849, 26892, 26829, 26836, 26855, 26837, 26934, 26898, 26884, 26839, 26851, 26917, 26873, 26848, 26863, 26920, 26922, 26906, 26915, 26913, 26822, 27001, 26999, 26972, 27e3, 26987, 26964, 27006, 26990, 26937, 26996, 26941, 26969, 26928, 26977, 26974, 26973, 27009, 26986, 27058, 27054, 27088, 27071, 27073, 27091, 27070, 27086, 23528, 27082, 27101, 27067, 27075, 27047, 27182, 27025, 27040, 27036, 27029, 27060, 27102, 27112, 27138, 27163, 27135, 27402, 27129, 27122, 27111, 27141, 27057, 27166, 27117, 27156, 27115, 27146, 27154, 27329, 27171, 27155, 27204, 27148, 27250, 27190, 27256, 27207, 27234, 27225, 27238, 27208, 27192, 27170, 27280, 27277, 27296, 27268, 27298, 27299, 27287, 34327, 27323, 27331, 27330, 27320, 27315, 27308, 27358, 27345, 27359, 27306, 27354, 27370, 27387, 27397, 34326, 27386, 27410, 27414, 39729, 27423, 27448, 27447, 30428, 27449, 39150, 27463, 27459, 27465, 27472, 27481, 27476, 27483, 27487, 27489, 27512, 27513, 27519, 27520, 27524, 27523, 27533, 27544, 27541, 27550, 27556, 27562, 27563, 27567, 27570, 27569, 27571, 27575, 27580, 27590, 27595, 27603, 27615, 27628, 27627, 27635, 27631, 40638, 27656, 27667, 27668, 27675, 27684, 27683, 27742, 27733, 27746, 27754, 27778, 27789, 27802, 27777, 27803, 27774, 27752, 27763, 27794, 27792, 27844, 27889, 27859, 27837, 27863, 27845, 27869, 27822, 27825, 27838, 27834, 27867, 27887, 27865, 27882, 27935, 34893, 27958, 27947, 27965, 27960, 27929, 27957, 27955, 27922, 27916, 28003, 28051, 28004, 27994, 28025, 27993, 28046, 28053, 28644, 28037, 28153, 28181, 28170, 28085, 28103, 28134, 28088, 28102, 28140, 28126, 28108, 28136, 28114, 28101, 28154, 28121, 28132, 28117, 28138, 28142, 28205, 28270, 28206, 28185, 28274, 28255, 28222, 28195, 28267, 28203, 28278, 28237, 28191, 28227, 28218, 28238, 28196, 28415, 28189, 28216, 28290, 28330, 28312, 28361, 28343, 28371, 28349, 28335, 28356, 28338, 28372, 28373, 28303, 28325, 28354, 28319, 28481, 28433, 28748, 28396, 28408, 28414, 28479, 28402, 28465, 28399, 28466, 28364, 28478, 28435, 28407, 28550, 28538, 28536, 28545, 28544, 28527, 28507, 28659, 28525, 28546, 28540, 28504, 28558, 28561, 28610, 28518, 28595, 28579, 28577, 28580, 28601, 28614, 28586, 28639, 28629, 28652, 28628, 28632, 28657, 28654, 28635, 28681, 28683, 28666, 28689, 28673, 28687, 28670, 28699, 28698, 28532, 28701, 28696, 28703, 28720, 28734, 28722, 28753, 28771, 28825, 28818, 28847, 28913, 28844, 28856, 28851, 28846, 28895, 28875, 28893, 28889, 28937, 28925, 28956, 28953, 29029, 29013, 29064, 29030, 29026, 29004, 29014, 29036, 29071, 29179, 29060, 29077, 29096, 29100, 29143, 29113, 29118, 29138, 29129, 29140, 29134, 29152, 29164, 29159, 29173, 29180, 29177, 29183, 29197, 29200, 29211, 29224, 29229, 29228, 29232, 29234, 29243, 29244, 29247, 29248, 29254, 29259, 29272, 29300, 29310, 29314, 29313, 29319, 29330, 29334, 29346, 29351, 29369, 29362, 29379, 29382, 29380, 29390, 29394, 29410, 29408, 29409, 29433, 29431, 20495, 29463, 29450, 29468, 29462, 29469, 29492, 29487, 29481, 29477, 29502, 29518, 29519, 40664, 29527, 29546, 29544, 29552, 29560, 29557, 29563, 29562, 29640, 29619, 29646, 29627, 29632, 29669, 29678, 29662, 29858, 29701, 29807, 29733, 29688, 29746, 29754, 29781, 29759, 29791, 29785, 29761, 29788, 29801, 29808, 29795, 29802, 29814, 29822, 29835, 29854, 29863, 29898, 29903, 29908, 29681, 29920, 29923, 29927, 29929, 29934, 29938, 29936, 29937, 29944, 29943, 29956, 29955, 29957, 29964, 29966, 29965, 29973, 29971, 29982, 29990, 29996, 30012, 30020, 30029, 30026, 30025, 30043, 30022, 30042, 30057, 30052, 30055, 30059, 30061, 30072, 30070, 30086, 30087, 30068, 30090, 30089, 30082, 30100, 30106, 30109, 30117, 30115, 30146, 30131, 30147, 30133, 30141, 30136, 30140, 30129, 30157, 30154, 30162, 30169, 30179, 30174, 30206, 30207, 30204, 30209, 30192, 30202, 30194, 30195, 30219, 30221, 30217, 30239, 30247, 30240, 30241, 30242, 30244, 30260, 30256, 30267, 30279, 30280, 30278, 30300, 30296, 30305, 30306, 30312, 30313, 30314, 30311, 30316, 30320, 30322, 30326, 30328, 30332, 30336, 30339, 30344, 30347, 30350, 30358, 30355, 30361, 30362, 30384, 30388, 30392, 30393, 30394, 30402, 30413, 30422, 30418, 30430, 30433, 30437, 30439, 30442, 34351, 30459, 30472, 30471, 30468, 30505, 30500, 30494, 30501, 30502, 30491, 30519, 30520, 30535, 30554, 30568, 30571, 30555, 30565, 30591, 30590, 30585, 30606, 30603, 30609, 30624, 30622, 30640, 30646, 30649, 30655, 30652, 30653, 30651, 30663, 30669, 30679, 30682, 30684, 30691, 30702, 30716, 30732, 30738, 31014, 30752, 31018, 30789, 30862, 30836, 30854, 30844, 30874, 30860, 30883, 30901, 30890, 30895, 30929, 30918, 30923, 30932, 30910, 30908, 30917, 30922, 30956, 30951, 30938, 30973, 30964, 30983, 30994, 30993, 31001, 31020, 31019, 31040, 31072, 31063, 31071, 31066, 31061, 31059, 31098, 31103, 31114, 31133, 31143, 40779, 31146, 31150, 31155, 31161, 31162, 31177, 31189, 31207, 31212, 31201, 31203, 31240, 31245, 31256, 31257, 31264, 31263, 31104, 31281, 31291, 31294, 31287, 31299, 31319, 31305, 31329, 31330, 31337, 40861, 31344, 31353, 31357, 31368, 31383, 31381, 31384, 31382, 31401, 31432, 31408, 31414, 31429, 31428, 31423, 36995, 31431, 31434, 31437, 31439, 31445, 31443, 31449, 31450, 31453, 31457, 31458, 31462, 31469, 31472, 31490, 31503, 31498, 31494, 31539, 31512, 31513, 31518, 31541, 31528, 31542, 31568, 31610, 31492, 31565, 31499, 31564, 31557, 31605, 31589, 31604, 31591, 31600, 31601, 31596, 31598, 31645, 31640, 31647, 31629, 31644, 31642, 31627, 31634, 31631, 31581, 31641, 31691, 31681, 31692, 31695, 31668, 31686, 31709, 31721, 31761, 31764, 31718, 31717, 31840, 31744, 31751, 31763, 31731, 31735, 31767, 31757, 31734, 31779, 31783, 31786, 31775, 31799, 31787, 31805, 31820, 31811, 31828, 31823, 31808, 31824, 31832, 31839, 31844, 31830, 31845, 31852, 31861, 31875, 31888, 31908, 31917, 31906, 31915, 31905, 31912, 31923, 31922, 31921, 31918, 31929, 31933, 31936, 31941, 31938, 31960, 31954, 31964, 31970, 39739, 31983, 31986, 31988, 31990, 31994, 32006, 32002, 32028, 32021, 32010, 32069, 32075, 32046, 32050, 32063, 32053, 32070, 32115, 32086, 32078, 32114, 32104, 32110, 32079, 32099, 32147, 32137, 32091, 32143, 32125, 32155, 32186, 32174, 32163, 32181, 32199, 32189, 32171, 32317, 32162, 32175, 32220, 32184, 32159, 32176, 32216, 32221, 32228, 32222, 32251, 32242, 32225, 32261, 32266, 32291, 32289, 32274, 32305, 32287, 32265, 32267, 32290, 32326, 32358, 32315, 32309, 32313, 32323, 32311, 32306, 32314, 32359, 32349, 32342, 32350, 32345, 32346, 32377, 32362, 32361, 32380, 32379, 32387, 32213, 32381, 36782, 32383, 32392, 32393, 32396, 32402, 32400, 32403, 32404, 32406, 32398, 32411, 32412, 32568, 32570, 32581, 32588, 32589, 32590, 32592, 32593, 32597, 32596, 32600, 32607, 32608, 32616, 32617, 32615, 32632, 32642, 32646, 32643, 32648, 32647, 32652, 32660, 32670, 32669, 32666, 32675, 32687, 32690, 32697, 32686, 32694, 32696, 35697, 32709, 32710, 32714, 32725, 32724, 32737, 32742, 32745, 32755, 32761, 39132, 32774, 32772, 32779, 32786, 32792, 32793, 32796, 32801, 32808, 32831, 32827, 32842, 32838, 32850, 32856, 32858, 32863, 32866, 32872, 32883, 32882, 32880, 32886, 32889, 32893, 32895, 32900, 32902, 32901, 32923, 32915, 32922, 32941, 20880, 32940, 32987, 32997, 32985, 32989, 32964, 32986, 32982, 33033, 33007, 33009, 33051, 33065, 33059, 33071, 33099, 38539, 33094, 33086, 33107, 33105, 33020, 33137, 33134, 33125, 33126, 33140, 33155, 33160, 33162, 33152, 33154, 33184, 33173, 33188, 33187, 33119, 33171, 33193, 33200, 33205, 33214, 33208, 33213, 33216, 33218, 33210, 33225, 33229, 33233, 33241, 33240, 33224, 33242, 33247, 33248, 33255, 33274, 33275, 33278, 33281, 33282, 33285, 33287, 33290, 33293, 33296, 33302, 33321, 33323, 33336, 33331, 33344, 33369, 33368, 33373, 33370, 33375, 33380, 33378, 33384, 33386, 33387, 33326, 33393, 33399, 33400, 33406, 33421, 33426, 33451, 33439, 33467, 33452, 33505, 33507, 33503, 33490, 33524, 33523, 33530, 33683, 33539, 33531, 33529, 33502, 33542, 33500, 33545, 33497, 33589, 33588, 33558, 33586, 33585, 33600, 33593, 33616, 33605, 33583, 33579, 33559, 33560, 33669, 33690, 33706, 33695, 33698, 33686, 33571, 33678, 33671, 33674, 33660, 33717, 33651, 33653, 33696, 33673, 33704, 33780, 33811, 33771, 33742, 33789, 33795, 33752, 33803, 33729, 33783, 33799, 33760, 33778, 33805, 33826, 33824, 33725, 33848, 34054, 33787, 33901, 33834, 33852, 34138, 33924, 33911, 33899, 33965, 33902, 33922, 33897, 33862, 33836, 33903, 33913, 33845, 33994, 33890, 33977, 33983, 33951, 34009, 33997, 33979, 34010, 34e3, 33985, 33990, 34006, 33953, 34081, 34047, 34036, 34071, 34072, 34092, 34079, 34069, 34068, 34044, 34112, 34147, 34136, 34120, 34113, 34306, 34123, 34133, 34176, 34212, 34184, 34193, 34186, 34216, 34157, 34196, 34203, 34282, 34183, 34204, 34167, 34174, 34192, 34249, 34234, 34255, 34233, 34256, 34261, 34269, 34277, 34268, 34297, 34314, 34323, 34315, 34302, 34298, 34310, 34338, 34330, 34352, 34367, 34381, 20053, 34388, 34399, 34407, 34417, 34451, 34467, 34473, 34474, 34443, 34444, 34486, 34479, 34500, 34502, 34480, 34505, 34851, 34475, 34516, 34526, 34537, 34540, 34527, 34523, 34543, 34578, 34566, 34568, 34560, 34563, 34555, 34577, 34569, 34573, 34553, 34570, 34612, 34623, 34615, 34619, 34597, 34601, 34586, 34656, 34655, 34680, 34636, 34638, 34676, 34647, 34664, 34670, 34649, 34643, 34659, 34666, 34821, 34722, 34719, 34690, 34735, 34763, 34749, 34752, 34768, 38614, 34731, 34756, 34739, 34759, 34758, 34747, 34799, 34802, 34784, 34831, 34829, 34814, 34806, 34807, 34830, 34770, 34833, 34838, 34837, 34850, 34849, 34865, 34870, 34873, 34855, 34875, 34884, 34882, 34898, 34905, 34910, 34914, 34923, 34945, 34942, 34974, 34933, 34941, 34997, 34930, 34946, 34967, 34962, 34990, 34969, 34978, 34957, 34980, 34992, 35007, 34993, 35011, 35012, 35028, 35032, 35033, 35037, 35065, 35074, 35068, 35060, 35048, 35058, 35076, 35084, 35082, 35091, 35139, 35102, 35109, 35114, 35115, 35137, 35140, 35131, 35126, 35128, 35148, 35101, 35168, 35166, 35174, 35172, 35181, 35178, 35183, 35188, 35191, 35198, 35203, 35208, 35210, 35219, 35224, 35233, 35241, 35238, 35244, 35247, 35250, 35258, 35261, 35263, 35264, 35290, 35292, 35293, 35303, 35316, 35320, 35331, 35350, 35344, 35340, 35355, 35357, 35365, 35382, 35393, 35419, 35410, 35398, 35400, 35452, 35437, 35436, 35426, 35461, 35458, 35460, 35496, 35489, 35473, 35493, 35494, 35482, 35491, 35524, 35533, 35522, 35546, 35563, 35571, 35559, 35556, 35569, 35604, 35552, 35554, 35575, 35550, 35547, 35596, 35591, 35610, 35553, 35606, 35600, 35607, 35616, 35635, 38827, 35622, 35627, 35646, 35624, 35649, 35660, 35663, 35662, 35657, 35670, 35675, 35674, 35691, 35679, 35692, 35695, 35700, 35709, 35712, 35724, 35726, 35730, 35731, 35734, 35737, 35738, 35898, 35905, 35903, 35912, 35916, 35918, 35920, 35925, 35938, 35948, 35960, 35962, 35970, 35977, 35973, 35978, 35981, 35982, 35988, 35964, 35992, 25117, 36013, 36010, 36029, 36018, 36019, 36014, 36022, 36040, 36033, 36068, 36067, 36058, 36093, 36090, 36091, 36100, 36101, 36106, 36103, 36111, 36109, 36112, 40782, 36115, 36045, 36116, 36118, 36199, 36205, 36209, 36211, 36225, 36249, 36290, 36286, 36282, 36303, 36314, 36310, 36300, 36315, 36299, 36330, 36331, 36319, 36323, 36348, 36360, 36361, 36351, 36381, 36382, 36368, 36383, 36418, 36405, 36400, 36404, 36426, 36423, 36425, 36428, 36432, 36424, 36441, 36452, 36448, 36394, 36451, 36437, 36470, 36466, 36476, 36481, 36487, 36485, 36484, 36491, 36490, 36499, 36497, 36500, 36505, 36522, 36513, 36524, 36528, 36550, 36529, 36542, 36549, 36552, 36555, 36571, 36579, 36604, 36603, 36587, 36606, 36618, 36613, 36629, 36626, 36633, 36627, 36636, 36639, 36635, 36620, 36646, 36659, 36667, 36665, 36677, 36674, 36670, 36684, 36681, 36678, 36686, 36695, 36700, 36706, 36707, 36708, 36764, 36767, 36771, 36781, 36783, 36791, 36826, 36837, 36834, 36842, 36847, 36999, 36852, 36869, 36857, 36858, 36881, 36885, 36897, 36877, 36894, 36886, 36875, 36903, 36918, 36917, 36921, 36856, 36943, 36944, 36945, 36946, 36878, 36937, 36926, 36950, 36952, 36958, 36968, 36975, 36982, 38568, 36978, 36994, 36989, 36993, 36992, 37002, 37001, 37007, 37032, 37039, 37041, 37045, 37090, 37092, 25160, 37083, 37122, 37138, 37145, 37170, 37168, 37194, 37206, 37208, 37219, 37221, 37225, 37235, 37234, 37259, 37257, 37250, 37282, 37291, 37295, 37290, 37301, 37300, 37306, 37312, 37313, 37321, 37323, 37328, 37334, 37343, 37345, 37339, 37372, 37365, 37366, 37406, 37375, 37396, 37420, 37397, 37393, 37470, 37463, 37445, 37449, 37476, 37448, 37525, 37439, 37451, 37456, 37532, 37526, 37523, 37531, 37466, 37583, 37561, 37559, 37609, 37647, 37626, 37700, 37678, 37657, 37666, 37658, 37667, 37690, 37685, 37691, 37724, 37728, 37756, 37742, 37718, 37808, 37804, 37805, 37780, 37817, 37846, 37847, 37864, 37861, 37848, 37827, 37853, 37840, 37832, 37860, 37914, 37908, 37907, 37891, 37895, 37904, 37942, 37931, 37941, 37921, 37946, 37953, 37970, 37956, 37979, 37984, 37986, 37982, 37994, 37417, 38e3, 38005, 38007, 38013, 37978, 38012, 38014, 38017, 38015, 38274, 38279, 38282, 38292, 38294, 38296, 38297, 38304, 38312, 38311, 38317, 38332, 38331, 38329, 38334, 38346, 28662, 38339, 38349, 38348, 38357, 38356, 38358, 38364, 38369, 38373, 38370, 38433, 38440, 38446, 38447, 38466, 38476, 38479, 38475, 38519, 38492, 38494, 38493, 38495, 38502, 38514, 38508, 38541, 38552, 38549, 38551, 38570, 38567, 38577, 38578, 38576, 38580, 38582, 38584, 38585, 38606, 38603, 38601, 38605, 35149, 38620, 38669, 38613, 38649, 38660, 38662, 38664, 38675, 38670, 38673, 38671, 38678, 38681, 38692, 38698, 38704, 38713, 38717, 38718, 38724, 38726, 38728, 38722, 38729, 38748, 38752, 38756, 38758, 38760, 21202, 38763, 38769, 38777, 38789, 38780, 38785, 38778, 38790, 38795, 38799, 38800, 38812, 38824, 38822, 38819, 38835, 38836, 38851, 38854, 38856, 38859, 38876, 38893, 40783, 38898, 31455, 38902, 38901, 38927, 38924, 38968, 38948, 38945, 38967, 38973, 38982, 38991, 38987, 39019, 39023, 39024, 39025, 39028, 39027, 39082, 39087, 39089, 39094, 39108, 39107, 39110, 39145, 39147, 39171, 39177, 39186, 39188, 39192, 39201, 39197, 39198, 39204, 39200, 39212, 39214, 39229, 39230, 39234, 39241, 39237, 39248, 39243, 39249, 39250, 39244, 39253, 39319, 39320, 39333, 39341, 39342, 39356, 39391, 39387, 39389, 39384, 39377, 39405, 39406, 39409, 39410, 39419, 39416, 39425, 39439, 39429, 39394, 39449, 39467, 39479, 39493, 39490, 39488, 39491, 39486, 39509, 39501, 39515, 39511, 39519, 39522, 39525, 39524, 39529, 39531, 39530, 39597, 39600, 39612, 39616, 39631, 39633, 39635, 39636, 39646, 39647, 39650, 39651, 39654, 39663, 39659, 39662, 39668, 39665, 39671, 39675, 39686, 39704, 39706, 39711, 39714, 39715, 39717, 39719, 39720, 39721, 39722, 39726, 39727, 39730, 39748, 39747, 39759, 39757, 39758, 39761, 39768, 39796, 39827, 39811, 39825, 39830, 39831, 39839, 39840, 39848, 39860, 39872, 39882, 39865, 39878, 39887, 39889, 39890, 39907, 39906, 39908, 39892, 39905, 39994, 39922, 39921, 39920, 39957, 39956, 39945, 39955, 39948, 39942, 39944, 39954, 39946, 39940, 39982, 39963, 39973, 39972, 39969, 39984, 40007, 39986, 40006, 39998, 40026, 40032, 40039, 40054, 40056, 40167, 40172, 40176, 40201, 40200, 40171, 40195, 40198, 40234, 40230, 40367, 40227, 40223, 40260, 40213, 40210, 40257, 40255, 40254, 40262, 40264, 40285, 40286, 40292, 40273, 40272, 40281, 40306, 40329, 40327, 40363, 40303, 40314, 40346, 40356, 40361, 40370, 40388, 40385, 40379, 40376, 40378, 40390, 40399, 40386, 40409, 40403, 40440, 40422, 40429, 40431, 40445, 40474, 40475, 40478, 40565, 40569, 40573, 40577, 40584, 40587, 40588, 40594, 40597, 40593, 40605, 40613, 40617, 40632, 40618, 40621, 38753, 40652, 40654, 40655, 40656, 40660, 40668, 40670, 40669, 40672, 40677, 40680, 40687, 40692, 40694, 40695, 40697, 40699, 40700, 40701, 40711, 40712, 30391, 40725, 40737, 40748, 40766, 40778, 40786, 40788, 40803, 40799, 40800, 40801, 40806, 40807, 40812, 40810, 40823, 40818, 40822, 40853, 40860, 40864, 22575, 27079, 36953, 29796, 20956, 29081, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32394, 35100, 37704, 37512, 34012, 20425, 28859, 26161, 26824, 37625, 26363, 24389, 20008, 20193, 20220, 20224, 20227, 20281, 20310, 20370, 20362, 20378, 20372, 20429, 20544, 20514, 20479, 20510, 20550, 20592, 20546, 20628, 20724, 20696, 20810, 20836, 20893, 20926, 20972, 21013, 21148, 21158, 21184, 21211, 21248, 21255, 21284, 21362, 21395, 21426, 21469, 64014, 21660, 21642, 21673, 21759, 21894, 22361, 22373, 22444, 22472, 22471, 64015, 64016, 22686, 22706, 22795, 22867, 22875, 22877, 22883, 22948, 22970, 23382, 23488, 29999, 23512, 23532, 23582, 23718, 23738, 23797, 23847, 23891, 64017, 23874, 23917, 23992, 23993, 24016, 24353, 24372, 24423, 24503, 24542, 24669, 24709, 24714, 24798, 24789, 24864, 24818, 24849, 24887, 24880, 24984, 25107, 25254, 25589, 25696, 25757, 25806, 25934, 26112, 26133, 26171, 26121, 26158, 26142, 26148, 26213, 26199, 26201, 64018, 26227, 26265, 26272, 26290, 26303, 26362, 26382, 63785, 26470, 26555, 26706, 26560, 26625, 26692, 26831, 64019, 26984, 64020, 27032, 27106, 27184, 27243, 27206, 27251, 27262, 27362, 27364, 27606, 27711, 27740, 27782, 27759, 27866, 27908, 28039, 28015, 28054, 28076, 28111, 28152, 28146, 28156, 28217, 28252, 28199, 28220, 28351, 28552, 28597, 28661, 28677, 28679, 28712, 28805, 28843, 28943, 28932, 29020, 28998, 28999, 64021, 29121, 29182, 29361, 29374, 29476, 64022, 29559, 29629, 29641, 29654, 29667, 29650, 29703, 29685, 29734, 29738, 29737, 29742, 29794, 29833, 29855, 29953, 30063, 30338, 30364, 30366, 30363, 30374, 64023, 30534, 21167, 30753, 30798, 30820, 30842, 31024, 64024, 64025, 64026, 31124, 64027, 31131, 31441, 31463, 64028, 31467, 31646, 64029, 32072, 32092, 32183, 32160, 32214, 32338, 32583, 32673, 64030, 33537, 33634, 33663, 33735, 33782, 33864, 33972, 34131, 34137, 34155, 64031, 34224, 64032, 64033, 34823, 35061, 35346, 35383, 35449, 35495, 35518, 35551, 64034, 35574, 35667, 35711, 36080, 36084, 36114, 36214, 64035, 36559, 64036, 64037, 36967, 37086, 64038, 37141, 37159, 37338, 37335, 37342, 37357, 37358, 37348, 37349, 37382, 37392, 37386, 37434, 37440, 37436, 37454, 37465, 37457, 37433, 37479, 37543, 37495, 37496, 37607, 37591, 37593, 37584, 64039, 37589, 37600, 37587, 37669, 37665, 37627, 64040, 37662, 37631, 37661, 37634, 37744, 37719, 37796, 37830, 37854, 37880, 37937, 37957, 37960, 38290, 63964, 64041, 38557, 38575, 38707, 38715, 38723, 38733, 38735, 38737, 38741, 38999, 39013, 64042, 64043, 39207, 64044, 39326, 39502, 39641, 39644, 39797, 39794, 39823, 39857, 39867, 39936, 40304, 40299, 64045, 40473, 40657, null, null, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 65506, 65508, 65287, 65282, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 65506, 65508, 65287, 65282, 12849, 8470, 8481, 8757, 32394, 35100, 37704, 37512, 34012, 20425, 28859, 26161, 26824, 37625, 26363, 24389, 20008, 20193, 20220, 20224, 20227, 20281, 20310, 20370, 20362, 20378, 20372, 20429, 20544, 20514, 20479, 20510, 20550, 20592, 20546, 20628, 20724, 20696, 20810, 20836, 20893, 20926, 20972, 21013, 21148, 21158, 21184, 21211, 21248, 21255, 21284, 21362, 21395, 21426, 21469, 64014, 21660, 21642, 21673, 21759, 21894, 22361, 22373, 22444, 22472, 22471, 64015, 64016, 22686, 22706, 22795, 22867, 22875, 22877, 22883, 22948, 22970, 23382, 23488, 29999, 23512, 23532, 23582, 23718, 23738, 23797, 23847, 23891, 64017, 23874, 23917, 23992, 23993, 24016, 24353, 24372, 24423, 24503, 24542, 24669, 24709, 24714, 24798, 24789, 24864, 24818, 24849, 24887, 24880, 24984, 25107, 25254, 25589, 25696, 25757, 25806, 25934, 26112, 26133, 26171, 26121, 26158, 26142, 26148, 26213, 26199, 26201, 64018, 26227, 26265, 26272, 26290, 26303, 26362, 26382, 63785, 26470, 26555, 26706, 26560, 26625, 26692, 26831, 64019, 26984, 64020, 27032, 27106, 27184, 27243, 27206, 27251, 27262, 27362, 27364, 27606, 27711, 27740, 27782, 27759, 27866, 27908, 28039, 28015, 28054, 28076, 28111, 28152, 28146, 28156, 28217, 28252, 28199, 28220, 28351, 28552, 28597, 28661, 28677, 28679, 28712, 28805, 28843, 28943, 28932, 29020, 28998, 28999, 64021, 29121, 29182, 29361, 29374, 29476, 64022, 29559, 29629, 29641, 29654, 29667, 29650, 29703, 29685, 29734, 29738, 29737, 29742, 29794, 29833, 29855, 29953, 30063, 30338, 30364, 30366, 30363, 30374, 64023, 30534, 21167, 30753, 30798, 30820, 30842, 31024, 64024, 64025, 64026, 31124, 64027, 31131, 31441, 31463, 64028, 31467, 31646, 64029, 32072, 32092, 32183, 32160, 32214, 32338, 32583, 32673, 64030, 33537, 33634, 33663, 33735, 33782, 33864, 33972, 34131, 34137, 34155, 64031, 34224, 64032, 64033, 34823, 35061, 35346, 35383, 35449, 35495, 35518, 35551, 64034, 35574, 35667, 35711, 36080, 36084, 36114, 36214, 64035, 36559, 64036, 64037, 36967, 37086, 64038, 37141, 37159, 37338, 37335, 37342, 37357, 37358, 37348, 37349, 37382, 37392, 37386, 37434, 37440, 37436, 37454, 37465, 37457, 37433, 37479, 37543, 37495, 37496, 37607, 37591, 37593, 37584, 64039, 37589, 37600, 37587, 37669, 37665, 37627, 64040, 37662, 37631, 37661, 37634, 37744, 37719, 37796, 37830, 37854, 37880, 37937, 37957, 37960, 38290, 63964, 64041, 38557, 38575, 38707, 38715, 38723, 38733, 38735, 38737, 38741, 38999, 39013, 64042, 64043, 39207, 64044, 39326, 39502, 39641, 39644, 39797, 39794, 39823, 39857, 39867, 39936, 40304, 40299, 64045, 40473, 40657, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "jis0212": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 728, 711, 184, 729, 733, 175, 731, 730, 65374, 900, 901, null, null, null, null, null, null, null, null, 161, 166, 191, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 186, 170, 169, 174, 8482, 164, 8470, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 902, 904, 905, 906, 938, null, 908, null, 910, 939, null, 911, null, null, null, null, 940, 941, 942, 943, 970, 912, 972, 962, 973, 971, 944, 974, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1038, 1039, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1118, 1119, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 198, 272, null, 294, null, 306, null, 321, 319, null, 330, 216, 338, null, 358, 222, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 230, 273, 240, 295, 305, 307, 312, 322, 320, 329, 331, 248, 339, 223, 359, 254, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 193, 192, 196, 194, 258, 461, 256, 260, 197, 195, 262, 264, 268, 199, 266, 270, 201, 200, 203, 202, 282, 278, 274, 280, null, 284, 286, 290, 288, 292, 205, 204, 207, 206, 463, 304, 298, 302, 296, 308, 310, 313, 317, 315, 323, 327, 325, 209, 211, 210, 214, 212, 465, 336, 332, 213, 340, 344, 342, 346, 348, 352, 350, 356, 354, 218, 217, 220, 219, 364, 467, 368, 362, 370, 366, 360, 471, 475, 473, 469, 372, 221, 376, 374, 377, 381, 379, null, null, null, null, null, null, null, 225, 224, 228, 226, 259, 462, 257, 261, 229, 227, 263, 265, 269, 231, 267, 271, 233, 232, 235, 234, 283, 279, 275, 281, 501, 285, 287, null, 289, 293, 237, 236, 239, 238, 464, null, 299, 303, 297, 309, 311, 314, 318, 316, 324, 328, 326, 241, 243, 242, 246, 244, 466, 337, 333, 245, 341, 345, 343, 347, 349, 353, 351, 357, 355, 250, 249, 252, 251, 365, 468, 369, 363, 371, 367, 361, 472, 476, 474, 470, 373, 253, 255, 375, 378, 382, 380, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 19970, 19972, 19973, 19980, 19986, 19999, 20003, 20004, 20008, 20011, 20014, 20015, 20016, 20021, 20032, 20033, 20036, 20039, 20049, 20058, 20060, 20067, 20072, 20073, 20084, 20085, 20089, 20095, 20109, 20118, 20119, 20125, 20143, 20153, 20163, 20176, 20186, 20187, 20192, 20193, 20194, 20200, 20207, 20209, 20211, 20213, 20221, 20222, 20223, 20224, 20226, 20227, 20232, 20235, 20236, 20242, 20245, 20246, 20247, 20249, 20270, 20273, 20320, 20275, 20277, 20279, 20281, 20283, 20286, 20288, 20290, 20296, 20297, 20299, 20300, 20306, 20308, 20310, 20312, 20319, 20323, 20330, 20332, 20334, 20337, 20343, 20344, 20345, 20346, 20349, 20350, 20353, 20354, 20356, 20357, 20361, 20362, 20364, 20366, 20368, 20370, 20371, 20372, 20375, 20377, 20378, 20382, 20383, 20402, 20407, 20409, 20411, 20412, 20413, 20414, 20416, 20417, 20421, 20422, 20424, 20425, 20427, 20428, 20429, 20431, 20434, 20444, 20448, 20450, 20464, 20466, 20476, 20477, 20479, 20480, 20481, 20484, 20487, 20490, 20492, 20494, 20496, 20499, 20503, 20504, 20507, 20508, 20509, 20510, 20514, 20519, 20526, 20528, 20530, 20531, 20533, 20544, 20545, 20546, 20549, 20550, 20554, 20556, 20558, 20561, 20562, 20563, 20567, 20569, 20575, 20576, 20578, 20579, 20582, 20583, 20586, 20589, 20592, 20593, 20539, 20609, 20611, 20612, 20614, 20618, 20622, 20623, 20624, 20626, 20627, 20628, 20630, 20635, 20636, 20638, 20639, 20640, 20641, 20642, 20650, 20655, 20656, 20665, 20666, 20669, 20672, 20675, 20676, 20679, 20684, 20686, 20688, 20691, 20692, 20696, 20700, 20701, 20703, 20706, 20708, 20710, 20712, 20713, 20719, 20721, 20726, 20730, 20734, 20739, 20742, 20743, 20744, 20747, 20748, 20749, 20750, 20722, 20752, 20759, 20761, 20763, 20764, 20765, 20766, 20771, 20775, 20776, 20780, 20781, 20783, 20785, 20787, 20788, 20789, 20792, 20793, 20802, 20810, 20815, 20819, 20821, 20823, 20824, 20831, 20836, 20838, 20862, 20867, 20868, 20875, 20878, 20888, 20893, 20897, 20899, 20909, 20920, 20922, 20924, 20926, 20927, 20930, 20936, 20943, 20945, 20946, 20947, 20949, 20952, 20958, 20962, 20965, 20974, 20978, 20979, 20980, 20983, 20993, 20994, 20997, 21010, 21011, 21013, 21014, 21016, 21026, 21032, 21041, 21042, 21045, 21052, 21061, 21065, 21077, 21079, 21080, 21082, 21084, 21087, 21088, 21089, 21094, 21102, 21111, 21112, 21113, 21120, 21122, 21125, 21130, 21132, 21139, 21141, 21142, 21143, 21144, 21146, 21148, 21156, 21157, 21158, 21159, 21167, 21168, 21174, 21175, 21176, 21178, 21179, 21181, 21184, 21188, 21190, 21192, 21196, 21199, 21201, 21204, 21206, 21211, 21212, 21217, 21221, 21224, 21225, 21226, 21228, 21232, 21233, 21236, 21238, 21239, 21248, 21251, 21258, 21259, 21260, 21265, 21267, 21272, 21275, 21276, 21278, 21279, 21285, 21287, 21288, 21289, 21291, 21292, 21293, 21296, 21298, 21301, 21308, 21309, 21310, 21314, 21324, 21323, 21337, 21339, 21345, 21347, 21349, 21356, 21357, 21362, 21369, 21374, 21379, 21383, 21384, 21390, 21395, 21396, 21401, 21405, 21409, 21412, 21418, 21419, 21423, 21426, 21428, 21429, 21431, 21432, 21434, 21437, 21440, 21445, 21455, 21458, 21459, 21461, 21466, 21469, 21470, 21472, 21478, 21479, 21493, 21506, 21523, 21530, 21537, 21543, 21544, 21546, 21551, 21553, 21556, 21557, 21571, 21572, 21575, 21581, 21583, 21598, 21602, 21604, 21606, 21607, 21609, 21611, 21613, 21614, 21620, 21631, 21633, 21635, 21637, 21640, 21641, 21645, 21649, 21653, 21654, 21660, 21663, 21665, 21670, 21671, 21673, 21674, 21677, 21678, 21681, 21687, 21689, 21690, 21691, 21695, 21702, 21706, 21709, 21710, 21728, 21738, 21740, 21743, 21750, 21756, 21758, 21759, 21760, 21761, 21765, 21768, 21769, 21772, 21773, 21774, 21781, 21802, 21803, 21810, 21813, 21814, 21819, 21820, 21821, 21825, 21831, 21833, 21834, 21837, 21840, 21841, 21848, 21850, 21851, 21854, 21856, 21857, 21860, 21862, 21887, 21889, 21890, 21894, 21896, 21902, 21903, 21905, 21906, 21907, 21908, 21911, 21923, 21924, 21933, 21938, 21951, 21953, 21955, 21958, 21961, 21963, 21964, 21966, 21969, 21970, 21971, 21975, 21976, 21979, 21982, 21986, 21993, 22006, 22015, 22021, 22024, 22026, 22029, 22030, 22031, 22032, 22033, 22034, 22041, 22060, 22064, 22067, 22069, 22071, 22073, 22075, 22076, 22077, 22079, 22080, 22081, 22083, 22084, 22086, 22089, 22091, 22093, 22095, 22100, 22110, 22112, 22113, 22114, 22115, 22118, 22121, 22125, 22127, 22129, 22130, 22133, 22148, 22149, 22152, 22155, 22156, 22165, 22169, 22170, 22173, 22174, 22175, 22182, 22183, 22184, 22185, 22187, 22188, 22189, 22193, 22195, 22199, 22206, 22213, 22217, 22218, 22219, 22223, 22224, 22220, 22221, 22233, 22236, 22237, 22239, 22241, 22244, 22245, 22246, 22247, 22248, 22257, 22251, 22253, 22262, 22263, 22273, 22274, 22279, 22282, 22284, 22289, 22293, 22298, 22299, 22301, 22304, 22306, 22307, 22308, 22309, 22313, 22314, 22316, 22318, 22319, 22323, 22324, 22333, 22334, 22335, 22341, 22342, 22348, 22349, 22354, 22370, 22373, 22375, 22376, 22379, 22381, 22382, 22383, 22384, 22385, 22387, 22388, 22389, 22391, 22393, 22394, 22395, 22396, 22398, 22401, 22403, 22412, 22420, 22423, 22425, 22426, 22428, 22429, 22430, 22431, 22433, 22421, 22439, 22440, 22441, 22444, 22456, 22461, 22471, 22472, 22476, 22479, 22485, 22493, 22494, 22500, 22502, 22503, 22505, 22509, 22512, 22517, 22518, 22520, 22525, 22526, 22527, 22531, 22532, 22536, 22537, 22497, 22540, 22541, 22555, 22558, 22559, 22560, 22566, 22567, 22573, 22578, 22585, 22591, 22601, 22604, 22605, 22607, 22608, 22613, 22623, 22625, 22628, 22631, 22632, 22648, 22652, 22655, 22656, 22657, 22663, 22664, 22665, 22666, 22668, 22669, 22671, 22672, 22676, 22678, 22685, 22688, 22689, 22690, 22694, 22697, 22705, 22706, 22724, 22716, 22722, 22728, 22733, 22734, 22736, 22738, 22740, 22742, 22746, 22749, 22753, 22754, 22761, 22771, 22789, 22790, 22795, 22796, 22802, 22803, 22804, 34369, 22813, 22817, 22819, 22820, 22824, 22831, 22832, 22835, 22837, 22838, 22847, 22851, 22854, 22866, 22867, 22873, 22875, 22877, 22878, 22879, 22881, 22883, 22891, 22893, 22895, 22898, 22901, 22902, 22905, 22907, 22908, 22923, 22924, 22926, 22930, 22933, 22935, 22943, 22948, 22951, 22957, 22958, 22959, 22960, 22963, 22967, 22970, 22972, 22977, 22979, 22980, 22984, 22986, 22989, 22994, 23005, 23006, 23007, 23011, 23012, 23015, 23022, 23023, 23025, 23026, 23028, 23031, 23040, 23044, 23052, 23053, 23054, 23058, 23059, 23070, 23075, 23076, 23079, 23080, 23082, 23085, 23088, 23108, 23109, 23111, 23112, 23116, 23120, 23125, 23134, 23139, 23141, 23143, 23149, 23159, 23162, 23163, 23166, 23179, 23184, 23187, 23190, 23193, 23196, 23198, 23199, 23200, 23202, 23207, 23212, 23217, 23218, 23219, 23221, 23224, 23226, 23227, 23231, 23236, 23238, 23240, 23247, 23258, 23260, 23264, 23269, 23274, 23278, 23285, 23286, 23293, 23296, 23297, 23304, 23319, 23348, 23321, 23323, 23325, 23329, 23333, 23341, 23352, 23361, 23371, 23372, 23378, 23382, 23390, 23400, 23406, 23407, 23420, 23421, 23422, 23423, 23425, 23428, 23430, 23434, 23438, 23440, 23441, 23443, 23444, 23446, 23464, 23465, 23468, 23469, 23471, 23473, 23474, 23479, 23482, 23484, 23488, 23489, 23501, 23503, 23510, 23511, 23512, 23513, 23514, 23520, 23535, 23537, 23540, 23549, 23564, 23575, 23582, 23583, 23587, 23590, 23593, 23595, 23596, 23598, 23600, 23602, 23605, 23606, 23641, 23642, 23644, 23650, 23651, 23655, 23656, 23657, 23661, 23664, 23668, 23669, 23674, 23675, 23676, 23677, 23687, 23688, 23690, 23695, 23698, 23709, 23711, 23712, 23714, 23715, 23718, 23722, 23730, 23732, 23733, 23738, 23753, 23755, 23762, 23773, 23767, 23790, 23793, 23794, 23796, 23809, 23814, 23821, 23826, 23851, 23843, 23844, 23846, 23847, 23857, 23860, 23865, 23869, 23871, 23874, 23875, 23878, 23880, 23893, 23889, 23897, 23882, 23903, 23904, 23905, 23906, 23908, 23914, 23917, 23920, 23929, 23930, 23934, 23935, 23937, 23939, 23944, 23946, 23954, 23955, 23956, 23957, 23961, 23963, 23967, 23968, 23975, 23979, 23984, 23988, 23992, 23993, 24003, 24007, 24011, 24016, 24014, 24024, 24025, 24032, 24036, 24041, 24056, 24057, 24064, 24071, 24077, 24082, 24084, 24085, 24088, 24095, 24096, 24110, 24104, 24114, 24117, 24126, 24139, 24144, 24137, 24145, 24150, 24152, 24155, 24156, 24158, 24168, 24170, 24171, 24172, 24173, 24174, 24176, 24192, 24203, 24206, 24226, 24228, 24229, 24232, 24234, 24236, 24241, 24243, 24253, 24254, 24255, 24262, 24268, 24267, 24270, 24273, 24274, 24276, 24277, 24284, 24286, 24293, 24299, 24322, 24326, 24327, 24328, 24334, 24345, 24348, 24349, 24353, 24354, 24355, 24356, 24360, 24363, 24364, 24366, 24368, 24372, 24374, 24379, 24381, 24383, 24384, 24388, 24389, 24391, 24397, 24400, 24404, 24408, 24411, 24416, 24419, 24420, 24423, 24431, 24434, 24436, 24437, 24440, 24442, 24445, 24446, 24457, 24461, 24463, 24470, 24476, 24477, 24482, 24487, 24491, 24484, 24492, 24495, 24496, 24497, 24504, 24516, 24519, 24520, 24521, 24523, 24528, 24529, 24530, 24531, 24532, 24542, 24545, 24546, 24552, 24553, 24554, 24556, 24557, 24558, 24559, 24562, 24563, 24566, 24570, 24572, 24583, 24586, 24589, 24595, 24596, 24599, 24600, 24602, 24607, 24612, 24621, 24627, 24629, 24640, 24647, 24648, 24649, 24652, 24657, 24660, 24662, 24663, 24669, 24673, 24679, 24689, 24702, 24703, 24706, 24710, 24712, 24714, 24718, 24721, 24723, 24725, 24728, 24733, 24734, 24738, 24740, 24741, 24744, 24752, 24753, 24759, 24763, 24766, 24770, 24772, 24776, 24777, 24778, 24779, 24782, 24783, 24788, 24789, 24793, 24795, 24797, 24798, 24802, 24805, 24818, 24821, 24824, 24828, 24829, 24834, 24839, 24842, 24844, 24848, 24849, 24850, 24851, 24852, 24854, 24855, 24857, 24860, 24862, 24866, 24874, 24875, 24880, 24881, 24885, 24886, 24887, 24889, 24897, 24901, 24902, 24905, 24926, 24928, 24940, 24946, 24952, 24955, 24956, 24959, 24960, 24961, 24963, 24964, 24971, 24973, 24978, 24979, 24983, 24984, 24988, 24989, 24991, 24992, 24997, 25e3, 25002, 25005, 25016, 25017, 25020, 25024, 25025, 25026, 25038, 25039, 25045, 25052, 25053, 25054, 25055, 25057, 25058, 25063, 25065, 25061, 25068, 25069, 25071, 25089, 25091, 25092, 25095, 25107, 25109, 25116, 25120, 25122, 25123, 25127, 25129, 25131, 25145, 25149, 25154, 25155, 25156, 25158, 25164, 25168, 25169, 25170, 25172, 25174, 25178, 25180, 25188, 25197, 25199, 25203, 25210, 25213, 25229, 25230, 25231, 25232, 25254, 25256, 25267, 25270, 25271, 25274, 25278, 25279, 25284, 25294, 25301, 25302, 25306, 25322, 25330, 25332, 25340, 25341, 25347, 25348, 25354, 25355, 25357, 25360, 25363, 25366, 25368, 25385, 25386, 25389, 25397, 25398, 25401, 25404, 25409, 25410, 25411, 25412, 25414, 25418, 25419, 25422, 25426, 25427, 25428, 25432, 25435, 25445, 25446, 25452, 25453, 25457, 25460, 25461, 25464, 25468, 25469, 25471, 25474, 25476, 25479, 25482, 25488, 25492, 25493, 25497, 25498, 25502, 25508, 25510, 25517, 25518, 25519, 25533, 25537, 25541, 25544, 25550, 25553, 25555, 25556, 25557, 25564, 25568, 25573, 25578, 25580, 25586, 25587, 25589, 25592, 25593, 25609, 25610, 25616, 25618, 25620, 25624, 25630, 25632, 25634, 25636, 25637, 25641, 25642, 25647, 25648, 25653, 25661, 25663, 25675, 25679, 25681, 25682, 25683, 25684, 25690, 25691, 25692, 25693, 25695, 25696, 25697, 25699, 25709, 25715, 25716, 25723, 25725, 25733, 25735, 25743, 25744, 25745, 25752, 25753, 25755, 25757, 25759, 25761, 25763, 25766, 25768, 25772, 25779, 25789, 25790, 25791, 25796, 25801, 25802, 25803, 25804, 25806, 25808, 25809, 25813, 25815, 25828, 25829, 25833, 25834, 25837, 25840, 25845, 25847, 25851, 25855, 25857, 25860, 25864, 25865, 25866, 25871, 25875, 25876, 25878, 25881, 25883, 25886, 25887, 25890, 25894, 25897, 25902, 25905, 25914, 25916, 25917, 25923, 25927, 25929, 25936, 25938, 25940, 25951, 25952, 25959, 25963, 25978, 25981, 25985, 25989, 25994, 26002, 26005, 26008, 26013, 26016, 26019, 26022, 26030, 26034, 26035, 26036, 26047, 26050, 26056, 26057, 26062, 26064, 26068, 26070, 26072, 26079, 26096, 26098, 26100, 26101, 26105, 26110, 26111, 26112, 26116, 26120, 26121, 26125, 26129, 26130, 26133, 26134, 26141, 26142, 26145, 26146, 26147, 26148, 26150, 26153, 26154, 26155, 26156, 26158, 26160, 26161, 26163, 26169, 26167, 26176, 26181, 26182, 26186, 26188, 26193, 26190, 26199, 26200, 26201, 26203, 26204, 26208, 26209, 26363, 26218, 26219, 26220, 26238, 26227, 26229, 26239, 26231, 26232, 26233, 26235, 26240, 26236, 26251, 26252, 26253, 26256, 26258, 26265, 26266, 26267, 26268, 26271, 26272, 26276, 26285, 26289, 26290, 26293, 26299, 26303, 26304, 26306, 26307, 26312, 26316, 26318, 26319, 26324, 26331, 26335, 26344, 26347, 26348, 26350, 26362, 26373, 26375, 26382, 26387, 26393, 26396, 26400, 26402, 26419, 26430, 26437, 26439, 26440, 26444, 26452, 26453, 26461, 26470, 26476, 26478, 26484, 26486, 26491, 26497, 26500, 26510, 26511, 26513, 26515, 26518, 26520, 26521, 26523, 26544, 26545, 26546, 26549, 26555, 26556, 26557, 26617, 26560, 26562, 26563, 26565, 26568, 26569, 26578, 26583, 26585, 26588, 26593, 26598, 26608, 26610, 26614, 26615, 26706, 26644, 26649, 26653, 26655, 26664, 26663, 26668, 26669, 26671, 26672, 26673, 26675, 26683, 26687, 26692, 26693, 26698, 26700, 26709, 26711, 26712, 26715, 26731, 26734, 26735, 26736, 26737, 26738, 26741, 26745, 26746, 26747, 26748, 26754, 26756, 26758, 26760, 26774, 26776, 26778, 26780, 26785, 26787, 26789, 26793, 26794, 26798, 26802, 26811, 26821, 26824, 26828, 26831, 26832, 26833, 26835, 26838, 26841, 26844, 26845, 26853, 26856, 26858, 26859, 26860, 26861, 26864, 26865, 26869, 26870, 26875, 26876, 26877, 26886, 26889, 26890, 26896, 26897, 26899, 26902, 26903, 26929, 26931, 26933, 26936, 26939, 26946, 26949, 26953, 26958, 26967, 26971, 26979, 26980, 26981, 26982, 26984, 26985, 26988, 26992, 26993, 26994, 27002, 27003, 27007, 27008, 27021, 27026, 27030, 27032, 27041, 27045, 27046, 27048, 27051, 27053, 27055, 27063, 27064, 27066, 27068, 27077, 27080, 27089, 27094, 27095, 27106, 27109, 27118, 27119, 27121, 27123, 27125, 27134, 27136, 27137, 27139, 27151, 27153, 27157, 27162, 27165, 27168, 27172, 27176, 27184, 27186, 27188, 27191, 27195, 27198, 27199, 27205, 27206, 27209, 27210, 27214, 27216, 27217, 27218, 27221, 27222, 27227, 27236, 27239, 27242, 27249, 27251, 27262, 27265, 27267, 27270, 27271, 27273, 27275, 27281, 27291, 27293, 27294, 27295, 27301, 27307, 27311, 27312, 27313, 27316, 27325, 27326, 27327, 27334, 27337, 27336, 27340, 27344, 27348, 27349, 27350, 27356, 27357, 27364, 27367, 27372, 27376, 27377, 27378, 27388, 27389, 27394, 27395, 27398, 27399, 27401, 27407, 27408, 27409, 27415, 27419, 27422, 27428, 27432, 27435, 27436, 27439, 27445, 27446, 27451, 27455, 27462, 27466, 27469, 27474, 27478, 27480, 27485, 27488, 27495, 27499, 27502, 27504, 27509, 27517, 27518, 27522, 27525, 27543, 27547, 27551, 27552, 27554, 27555, 27560, 27561, 27564, 27565, 27566, 27568, 27576, 27577, 27581, 27582, 27587, 27588, 27593, 27596, 27606, 27610, 27617, 27619, 27622, 27623, 27630, 27633, 27639, 27641, 27647, 27650, 27652, 27653, 27657, 27661, 27662, 27664, 27666, 27673, 27679, 27686, 27687, 27688, 27692, 27694, 27699, 27701, 27702, 27706, 27707, 27711, 27722, 27723, 27725, 27727, 27730, 27732, 27737, 27739, 27740, 27755, 27757, 27759, 27764, 27766, 27768, 27769, 27771, 27781, 27782, 27783, 27785, 27796, 27797, 27799, 27800, 27804, 27807, 27824, 27826, 27828, 27842, 27846, 27853, 27855, 27856, 27857, 27858, 27860, 27862, 27866, 27868, 27872, 27879, 27881, 27883, 27884, 27886, 27890, 27892, 27908, 27911, 27914, 27918, 27919, 27921, 27923, 27930, 27942, 27943, 27944, 27751, 27950, 27951, 27953, 27961, 27964, 27967, 27991, 27998, 27999, 28001, 28005, 28007, 28015, 28016, 28028, 28034, 28039, 28049, 28050, 28052, 28054, 28055, 28056, 28074, 28076, 28084, 28087, 28089, 28093, 28095, 28100, 28104, 28106, 28110, 28111, 28118, 28123, 28125, 28127, 28128, 28130, 28133, 28137, 28143, 28144, 28148, 28150, 28156, 28160, 28164, 28190, 28194, 28199, 28210, 28214, 28217, 28219, 28220, 28228, 28229, 28232, 28233, 28235, 28239, 28241, 28242, 28243, 28244, 28247, 28252, 28253, 28254, 28258, 28259, 28264, 28275, 28283, 28285, 28301, 28307, 28313, 28320, 28327, 28333, 28334, 28337, 28339, 28347, 28351, 28352, 28353, 28355, 28359, 28360, 28362, 28365, 28366, 28367, 28395, 28397, 28398, 28409, 28411, 28413, 28420, 28424, 28426, 28428, 28429, 28438, 28440, 28442, 28443, 28454, 28457, 28458, 28463, 28464, 28467, 28470, 28475, 28476, 28461, 28495, 28497, 28498, 28499, 28503, 28505, 28506, 28509, 28510, 28513, 28514, 28520, 28524, 28541, 28542, 28547, 28551, 28552, 28555, 28556, 28557, 28560, 28562, 28563, 28564, 28566, 28570, 28575, 28576, 28581, 28582, 28583, 28584, 28590, 28591, 28592, 28597, 28598, 28604, 28613, 28615, 28616, 28618, 28634, 28638, 28648, 28649, 28656, 28661, 28665, 28668, 28669, 28672, 28677, 28678, 28679, 28685, 28695, 28704, 28707, 28719, 28724, 28727, 28729, 28732, 28739, 28740, 28744, 28745, 28746, 28747, 28756, 28757, 28765, 28766, 28750, 28772, 28773, 28780, 28782, 28789, 28790, 28798, 28801, 28805, 28806, 28820, 28821, 28822, 28823, 28824, 28827, 28836, 28843, 28848, 28849, 28852, 28855, 28874, 28881, 28883, 28884, 28885, 28886, 28888, 28892, 28900, 28922, 28931, 28932, 28933, 28934, 28935, 28939, 28940, 28943, 28958, 28960, 28971, 28973, 28975, 28976, 28977, 28984, 28993, 28997, 28998, 28999, 29002, 29003, 29008, 29010, 29015, 29018, 29020, 29022, 29024, 29032, 29049, 29056, 29061, 29063, 29068, 29074, 29082, 29083, 29088, 29090, 29103, 29104, 29106, 29107, 29114, 29119, 29120, 29121, 29124, 29131, 29132, 29139, 29142, 29145, 29146, 29148, 29176, 29182, 29184, 29191, 29192, 29193, 29203, 29207, 29210, 29213, 29215, 29220, 29227, 29231, 29236, 29240, 29241, 29249, 29250, 29251, 29253, 29262, 29263, 29264, 29267, 29269, 29270, 29274, 29276, 29278, 29280, 29283, 29288, 29291, 29294, 29295, 29297, 29303, 29304, 29307, 29308, 29311, 29316, 29321, 29325, 29326, 29331, 29339, 29352, 29357, 29358, 29361, 29364, 29374, 29377, 29383, 29385, 29388, 29397, 29398, 29400, 29407, 29413, 29427, 29428, 29434, 29435, 29438, 29442, 29444, 29445, 29447, 29451, 29453, 29458, 29459, 29464, 29465, 29470, 29474, 29476, 29479, 29480, 29484, 29489, 29490, 29493, 29498, 29499, 29501, 29507, 29517, 29520, 29522, 29526, 29528, 29533, 29534, 29535, 29536, 29542, 29543, 29545, 29547, 29548, 29550, 29551, 29553, 29559, 29561, 29564, 29568, 29569, 29571, 29573, 29574, 29582, 29584, 29587, 29589, 29591, 29592, 29596, 29598, 29599, 29600, 29602, 29605, 29606, 29610, 29611, 29613, 29621, 29623, 29625, 29628, 29629, 29631, 29637, 29638, 29641, 29643, 29644, 29647, 29650, 29651, 29654, 29657, 29661, 29665, 29667, 29670, 29671, 29673, 29684, 29685, 29687, 29689, 29690, 29691, 29693, 29695, 29696, 29697, 29700, 29703, 29706, 29713, 29722, 29723, 29732, 29734, 29736, 29737, 29738, 29739, 29740, 29741, 29742, 29743, 29744, 29745, 29753, 29760, 29763, 29764, 29766, 29767, 29771, 29773, 29777, 29778, 29783, 29789, 29794, 29798, 29799, 29800, 29803, 29805, 29806, 29809, 29810, 29824, 29825, 29829, 29830, 29831, 29833, 29839, 29840, 29841, 29842, 29848, 29849, 29850, 29852, 29855, 29856, 29857, 29859, 29862, 29864, 29865, 29866, 29867, 29870, 29871, 29873, 29874, 29877, 29881, 29883, 29887, 29896, 29897, 29900, 29904, 29907, 29912, 29914, 29915, 29918, 29919, 29924, 29928, 29930, 29931, 29935, 29940, 29946, 29947, 29948, 29951, 29958, 29970, 29974, 29975, 29984, 29985, 29988, 29991, 29993, 29994, 29999, 30006, 30009, 30013, 30014, 30015, 30016, 30019, 30023, 30024, 30030, 30032, 30034, 30039, 30046, 30047, 30049, 30063, 30065, 30073, 30074, 30075, 30076, 30077, 30078, 30081, 30085, 30096, 30098, 30099, 30101, 30105, 30108, 30114, 30116, 30132, 30138, 30143, 30144, 30145, 30148, 30150, 30156, 30158, 30159, 30167, 30172, 30175, 30176, 30177, 30180, 30183, 30188, 30190, 30191, 30193, 30201, 30208, 30210, 30211, 30212, 30215, 30216, 30218, 30220, 30223, 30226, 30227, 30229, 30230, 30233, 30235, 30236, 30237, 30238, 30243, 30245, 30246, 30249, 30253, 30258, 30259, 30261, 30264, 30265, 30266, 30268, 30282, 30272, 30273, 30275, 30276, 30277, 30281, 30283, 30293, 30297, 30303, 30308, 30309, 30317, 30318, 30319, 30321, 30324, 30337, 30341, 30348, 30349, 30357, 30363, 30364, 30365, 30367, 30368, 30370, 30371, 30372, 30373, 30374, 30375, 30376, 30378, 30381, 30397, 30401, 30405, 30409, 30411, 30412, 30414, 30420, 30425, 30432, 30438, 30440, 30444, 30448, 30449, 30454, 30457, 30460, 30464, 30470, 30474, 30478, 30482, 30484, 30485, 30487, 30489, 30490, 30492, 30498, 30504, 30509, 30510, 30511, 30516, 30517, 30518, 30521, 30525, 30526, 30530, 30533, 30534, 30538, 30541, 30542, 30543, 30546, 30550, 30551, 30556, 30558, 30559, 30560, 30562, 30564, 30567, 30570, 30572, 30576, 30578, 30579, 30580, 30586, 30589, 30592, 30596, 30604, 30605, 30612, 30613, 30614, 30618, 30623, 30626, 30631, 30634, 30638, 30639, 30641, 30645, 30654, 30659, 30665, 30673, 30674, 30677, 30681, 30686, 30687, 30688, 30692, 30694, 30698, 30700, 30704, 30705, 30708, 30712, 30715, 30725, 30726, 30729, 30733, 30734, 30737, 30749, 30753, 30754, 30755, 30765, 30766, 30768, 30773, 30775, 30787, 30788, 30791, 30792, 30796, 30798, 30802, 30812, 30814, 30816, 30817, 30819, 30820, 30824, 30826, 30830, 30842, 30846, 30858, 30863, 30868, 30872, 30881, 30877, 30878, 30879, 30884, 30888, 30892, 30893, 30896, 30897, 30898, 30899, 30907, 30909, 30911, 30919, 30920, 30921, 30924, 30926, 30930, 30931, 30933, 30934, 30948, 30939, 30943, 30944, 30945, 30950, 30954, 30962, 30963, 30976, 30966, 30967, 30970, 30971, 30975, 30982, 30988, 30992, 31002, 31004, 31006, 31007, 31008, 31013, 31015, 31017, 31021, 31025, 31028, 31029, 31035, 31037, 31039, 31044, 31045, 31046, 31050, 31051, 31055, 31057, 31060, 31064, 31067, 31068, 31079, 31081, 31083, 31090, 31097, 31099, 31100, 31102, 31115, 31116, 31121, 31123, 31124, 31125, 31126, 31128, 31131, 31132, 31137, 31144, 31145, 31147, 31151, 31153, 31156, 31160, 31163, 31170, 31172, 31175, 31176, 31178, 31183, 31188, 31190, 31194, 31197, 31198, 31200, 31202, 31205, 31210, 31211, 31213, 31217, 31224, 31228, 31234, 31235, 31239, 31241, 31242, 31244, 31249, 31253, 31259, 31262, 31265, 31271, 31275, 31277, 31279, 31280, 31284, 31285, 31288, 31289, 31290, 31300, 31301, 31303, 31304, 31308, 31317, 31318, 31321, 31324, 31325, 31327, 31328, 31333, 31335, 31338, 31341, 31349, 31352, 31358, 31360, 31362, 31365, 31366, 31370, 31371, 31376, 31377, 31380, 31390, 31392, 31395, 31404, 31411, 31413, 31417, 31419, 31420, 31430, 31433, 31436, 31438, 31441, 31451, 31464, 31465, 31467, 31468, 31473, 31476, 31483, 31485, 31486, 31495, 31508, 31519, 31523, 31527, 31529, 31530, 31531, 31533, 31534, 31535, 31536, 31537, 31540, 31549, 31551, 31552, 31553, 31559, 31566, 31573, 31584, 31588, 31590, 31593, 31594, 31597, 31599, 31602, 31603, 31607, 31620, 31625, 31630, 31632, 31633, 31638, 31643, 31646, 31648, 31653, 31660, 31663, 31664, 31666, 31669, 31670, 31674, 31675, 31676, 31677, 31682, 31685, 31688, 31690, 31700, 31702, 31703, 31705, 31706, 31707, 31720, 31722, 31730, 31732, 31733, 31736, 31737, 31738, 31740, 31742, 31745, 31746, 31747, 31748, 31750, 31753, 31755, 31756, 31758, 31759, 31769, 31771, 31776, 31781, 31782, 31784, 31788, 31793, 31795, 31796, 31798, 31801, 31802, 31814, 31818, 31829, 31825, 31826, 31827, 31833, 31834, 31835, 31836, 31837, 31838, 31841, 31843, 31847, 31849, 31853, 31854, 31856, 31858, 31865, 31868, 31869, 31878, 31879, 31887, 31892, 31902, 31904, 31910, 31920, 31926, 31927, 31930, 31931, 31932, 31935, 31940, 31943, 31944, 31945, 31949, 31951, 31955, 31956, 31957, 31959, 31961, 31962, 31965, 31974, 31977, 31979, 31989, 32003, 32007, 32008, 32009, 32015, 32017, 32018, 32019, 32022, 32029, 32030, 32035, 32038, 32042, 32045, 32049, 32060, 32061, 32062, 32064, 32065, 32071, 32072, 32077, 32081, 32083, 32087, 32089, 32090, 32092, 32093, 32101, 32103, 32106, 32112, 32120, 32122, 32123, 32127, 32129, 32130, 32131, 32133, 32134, 32136, 32139, 32140, 32141, 32145, 32150, 32151, 32157, 32158, 32166, 32167, 32170, 32179, 32182, 32183, 32185, 32194, 32195, 32196, 32197, 32198, 32204, 32205, 32206, 32215, 32217, 32256, 32226, 32229, 32230, 32234, 32235, 32237, 32241, 32245, 32246, 32249, 32250, 32264, 32272, 32273, 32277, 32279, 32284, 32285, 32288, 32295, 32296, 32300, 32301, 32303, 32307, 32310, 32319, 32324, 32325, 32327, 32334, 32336, 32338, 32344, 32351, 32353, 32354, 32357, 32363, 32366, 32367, 32371, 32376, 32382, 32385, 32390, 32391, 32394, 32397, 32401, 32405, 32408, 32410, 32413, 32414, 32572, 32571, 32573, 32574, 32575, 32579, 32580, 32583, 32591, 32594, 32595, 32603, 32604, 32605, 32609, 32611, 32612, 32613, 32614, 32621, 32625, 32637, 32638, 32639, 32640, 32651, 32653, 32655, 32656, 32657, 32662, 32663, 32668, 32673, 32674, 32678, 32682, 32685, 32692, 32700, 32703, 32704, 32707, 32712, 32718, 32719, 32731, 32735, 32739, 32741, 32744, 32748, 32750, 32751, 32754, 32762, 32765, 32766, 32767, 32775, 32776, 32778, 32781, 32782, 32783, 32785, 32787, 32788, 32790, 32797, 32798, 32799, 32800, 32804, 32806, 32812, 32814, 32816, 32820, 32821, 32823, 32825, 32826, 32828, 32830, 32832, 32836, 32864, 32868, 32870, 32877, 32881, 32885, 32897, 32904, 32910, 32924, 32926, 32934, 32935, 32939, 32952, 32953, 32968, 32973, 32975, 32978, 32980, 32981, 32983, 32984, 32992, 33005, 33006, 33008, 33010, 33011, 33014, 33017, 33018, 33022, 33027, 33035, 33046, 33047, 33048, 33052, 33054, 33056, 33060, 33063, 33068, 33072, 33077, 33082, 33084, 33093, 33095, 33098, 33100, 33106, 33111, 33120, 33121, 33127, 33128, 33129, 33133, 33135, 33143, 33153, 33168, 33156, 33157, 33158, 33163, 33166, 33174, 33176, 33179, 33182, 33186, 33198, 33202, 33204, 33211, 33227, 33219, 33221, 33226, 33230, 33231, 33237, 33239, 33243, 33245, 33246, 33249, 33252, 33259, 33260, 33264, 33265, 33266, 33269, 33270, 33272, 33273, 33277, 33279, 33280, 33283, 33295, 33299, 33300, 33305, 33306, 33309, 33313, 33314, 33320, 33330, 33332, 33338, 33347, 33348, 33349, 33350, 33355, 33358, 33359, 33361, 33366, 33372, 33376, 33379, 33383, 33389, 33396, 33403, 33405, 33407, 33408, 33409, 33411, 33412, 33415, 33417, 33418, 33422, 33425, 33428, 33430, 33432, 33434, 33435, 33440, 33441, 33443, 33444, 33447, 33448, 33449, 33450, 33454, 33456, 33458, 33460, 33463, 33466, 33468, 33470, 33471, 33478, 33488, 33493, 33498, 33504, 33506, 33508, 33512, 33514, 33517, 33519, 33526, 33527, 33533, 33534, 33536, 33537, 33543, 33544, 33546, 33547, 33620, 33563, 33565, 33566, 33567, 33569, 33570, 33580, 33581, 33582, 33584, 33587, 33591, 33594, 33596, 33597, 33602, 33603, 33604, 33607, 33613, 33614, 33617, 33621, 33622, 33623, 33648, 33656, 33661, 33663, 33664, 33666, 33668, 33670, 33677, 33682, 33684, 33685, 33688, 33689, 33691, 33692, 33693, 33702, 33703, 33705, 33708, 33726, 33727, 33728, 33735, 33737, 33743, 33744, 33745, 33748, 33757, 33619, 33768, 33770, 33782, 33784, 33785, 33788, 33793, 33798, 33802, 33807, 33809, 33813, 33817, 33709, 33839, 33849, 33861, 33863, 33864, 33866, 33869, 33871, 33873, 33874, 33878, 33880, 33881, 33882, 33884, 33888, 33892, 33893, 33895, 33898, 33904, 33907, 33908, 33910, 33912, 33916, 33917, 33921, 33925, 33938, 33939, 33941, 33950, 33958, 33960, 33961, 33962, 33967, 33969, 33972, 33978, 33981, 33982, 33984, 33986, 33991, 33992, 33996, 33999, 34003, 34012, 34023, 34026, 34031, 34032, 34033, 34034, 34039, 34098, 34042, 34043, 34045, 34050, 34051, 34055, 34060, 34062, 34064, 34076, 34078, 34082, 34083, 34084, 34085, 34087, 34090, 34091, 34095, 34099, 34100, 34102, 34111, 34118, 34127, 34128, 34129, 34130, 34131, 34134, 34137, 34140, 34141, 34142, 34143, 34144, 34145, 34146, 34148, 34155, 34159, 34169, 34170, 34171, 34173, 34175, 34177, 34181, 34182, 34185, 34187, 34188, 34191, 34195, 34200, 34205, 34207, 34208, 34210, 34213, 34215, 34228, 34230, 34231, 34232, 34236, 34237, 34238, 34239, 34242, 34247, 34250, 34251, 34254, 34221, 34264, 34266, 34271, 34272, 34278, 34280, 34285, 34291, 34294, 34300, 34303, 34304, 34308, 34309, 34317, 34318, 34320, 34321, 34322, 34328, 34329, 34331, 34334, 34337, 34343, 34345, 34358, 34360, 34362, 34364, 34365, 34368, 34370, 34374, 34386, 34387, 34390, 34391, 34392, 34393, 34397, 34400, 34401, 34402, 34403, 34404, 34409, 34412, 34415, 34421, 34422, 34423, 34426, 34445, 34449, 34454, 34456, 34458, 34460, 34465, 34470, 34471, 34472, 34477, 34481, 34483, 34484, 34485, 34487, 34488, 34489, 34495, 34496, 34497, 34499, 34501, 34513, 34514, 34517, 34519, 34522, 34524, 34528, 34531, 34533, 34535, 34440, 34554, 34556, 34557, 34564, 34565, 34567, 34571, 34574, 34575, 34576, 34579, 34580, 34585, 34590, 34591, 34593, 34595, 34600, 34606, 34607, 34609, 34610, 34617, 34618, 34620, 34621, 34622, 34624, 34627, 34629, 34637, 34648, 34653, 34657, 34660, 34661, 34671, 34673, 34674, 34683, 34691, 34692, 34693, 34694, 34695, 34696, 34697, 34699, 34700, 34704, 34707, 34709, 34711, 34712, 34713, 34718, 34720, 34723, 34727, 34732, 34733, 34734, 34737, 34741, 34750, 34751, 34753, 34760, 34761, 34762, 34766, 34773, 34774, 34777, 34778, 34780, 34783, 34786, 34787, 34788, 34794, 34795, 34797, 34801, 34803, 34808, 34810, 34815, 34817, 34819, 34822, 34825, 34826, 34827, 34832, 34841, 34834, 34835, 34836, 34840, 34842, 34843, 34844, 34846, 34847, 34856, 34861, 34862, 34864, 34866, 34869, 34874, 34876, 34881, 34883, 34885, 34888, 34889, 34890, 34891, 34894, 34897, 34901, 34902, 34904, 34906, 34908, 34911, 34912, 34916, 34921, 34929, 34937, 34939, 34944, 34968, 34970, 34971, 34972, 34975, 34976, 34984, 34986, 35002, 35005, 35006, 35008, 35018, 35019, 35020, 35021, 35022, 35025, 35026, 35027, 35035, 35038, 35047, 35055, 35056, 35057, 35061, 35063, 35073, 35078, 35085, 35086, 35087, 35093, 35094, 35096, 35097, 35098, 35100, 35104, 35110, 35111, 35112, 35120, 35121, 35122, 35125, 35129, 35130, 35134, 35136, 35138, 35141, 35142, 35145, 35151, 35154, 35159, 35162, 35163, 35164, 35169, 35170, 35171, 35179, 35182, 35184, 35187, 35189, 35194, 35195, 35196, 35197, 35209, 35213, 35216, 35220, 35221, 35227, 35228, 35231, 35232, 35237, 35248, 35252, 35253, 35254, 35255, 35260, 35284, 35285, 35286, 35287, 35288, 35301, 35305, 35307, 35309, 35313, 35315, 35318, 35321, 35325, 35327, 35332, 35333, 35335, 35343, 35345, 35346, 35348, 35349, 35358, 35360, 35362, 35364, 35366, 35371, 35372, 35375, 35381, 35383, 35389, 35390, 35392, 35395, 35397, 35399, 35401, 35405, 35406, 35411, 35414, 35415, 35416, 35420, 35421, 35425, 35429, 35431, 35445, 35446, 35447, 35449, 35450, 35451, 35454, 35455, 35456, 35459, 35462, 35467, 35471, 35472, 35474, 35478, 35479, 35481, 35487, 35495, 35497, 35502, 35503, 35507, 35510, 35511, 35515, 35518, 35523, 35526, 35528, 35529, 35530, 35537, 35539, 35540, 35541, 35543, 35549, 35551, 35564, 35568, 35572, 35573, 35574, 35580, 35583, 35589, 35590, 35595, 35601, 35612, 35614, 35615, 35594, 35629, 35632, 35639, 35644, 35650, 35651, 35652, 35653, 35654, 35656, 35666, 35667, 35668, 35673, 35661, 35678, 35683, 35693, 35702, 35704, 35705, 35708, 35710, 35713, 35716, 35717, 35723, 35725, 35727, 35732, 35733, 35740, 35742, 35743, 35896, 35897, 35901, 35902, 35909, 35911, 35913, 35915, 35919, 35921, 35923, 35924, 35927, 35928, 35931, 35933, 35929, 35939, 35940, 35942, 35944, 35945, 35949, 35955, 35957, 35958, 35963, 35966, 35974, 35975, 35979, 35984, 35986, 35987, 35993, 35995, 35996, 36004, 36025, 36026, 36037, 36038, 36041, 36043, 36047, 36054, 36053, 36057, 36061, 36065, 36072, 36076, 36079, 36080, 36082, 36085, 36087, 36088, 36094, 36095, 36097, 36099, 36105, 36114, 36119, 36123, 36197, 36201, 36204, 36206, 36223, 36226, 36228, 36232, 36237, 36240, 36241, 36245, 36254, 36255, 36256, 36262, 36267, 36268, 36271, 36274, 36277, 36279, 36281, 36283, 36288, 36293, 36294, 36295, 36296, 36298, 36302, 36305, 36308, 36309, 36311, 36313, 36324, 36325, 36327, 36332, 36336, 36284, 36337, 36338, 36340, 36349, 36353, 36356, 36357, 36358, 36363, 36369, 36372, 36374, 36384, 36385, 36386, 36387, 36390, 36391, 36401, 36403, 36406, 36407, 36408, 36409, 36413, 36416, 36417, 36427, 36429, 36430, 36431, 36436, 36443, 36444, 36445, 36446, 36449, 36450, 36457, 36460, 36461, 36463, 36464, 36465, 36473, 36474, 36475, 36482, 36483, 36489, 36496, 36498, 36501, 36506, 36507, 36509, 36510, 36514, 36519, 36521, 36525, 36526, 36531, 36533, 36538, 36539, 36544, 36545, 36547, 36548, 36551, 36559, 36561, 36564, 36572, 36584, 36590, 36592, 36593, 36599, 36601, 36602, 36589, 36608, 36610, 36615, 36616, 36623, 36624, 36630, 36631, 36632, 36638, 36640, 36641, 36643, 36645, 36647, 36648, 36652, 36653, 36654, 36660, 36661, 36662, 36663, 36666, 36672, 36673, 36675, 36679, 36687, 36689, 36690, 36691, 36692, 36693, 36696, 36701, 36702, 36709, 36765, 36768, 36769, 36772, 36773, 36774, 36789, 36790, 36792, 36798, 36800, 36801, 36806, 36810, 36811, 36813, 36816, 36818, 36819, 36821, 36832, 36835, 36836, 36840, 36846, 36849, 36853, 36854, 36859, 36862, 36866, 36868, 36872, 36876, 36888, 36891, 36904, 36905, 36911, 36906, 36908, 36909, 36915, 36916, 36919, 36927, 36931, 36932, 36940, 36955, 36957, 36962, 36966, 36967, 36972, 36976, 36980, 36985, 36997, 37e3, 37003, 37004, 37006, 37008, 37013, 37015, 37016, 37017, 37019, 37024, 37025, 37026, 37029, 37040, 37042, 37043, 37044, 37046, 37053, 37068, 37054, 37059, 37060, 37061, 37063, 37064, 37077, 37079, 37080, 37081, 37084, 37085, 37087, 37093, 37074, 37110, 37099, 37103, 37104, 37108, 37118, 37119, 37120, 37124, 37125, 37126, 37128, 37133, 37136, 37140, 37142, 37143, 37144, 37146, 37148, 37150, 37152, 37157, 37154, 37155, 37159, 37161, 37166, 37167, 37169, 37172, 37174, 37175, 37177, 37178, 37180, 37181, 37187, 37191, 37192, 37199, 37203, 37207, 37209, 37210, 37211, 37217, 37220, 37223, 37229, 37236, 37241, 37242, 37243, 37249, 37251, 37253, 37254, 37258, 37262, 37265, 37267, 37268, 37269, 37272, 37278, 37281, 37286, 37288, 37292, 37293, 37294, 37296, 37297, 37298, 37299, 37302, 37307, 37308, 37309, 37311, 37314, 37315, 37317, 37331, 37332, 37335, 37337, 37338, 37342, 37348, 37349, 37353, 37354, 37356, 37357, 37358, 37359, 37360, 37361, 37367, 37369, 37371, 37373, 37376, 37377, 37380, 37381, 37382, 37383, 37385, 37386, 37388, 37392, 37394, 37395, 37398, 37400, 37404, 37405, 37411, 37412, 37413, 37414, 37416, 37422, 37423, 37424, 37427, 37429, 37430, 37432, 37433, 37434, 37436, 37438, 37440, 37442, 37443, 37446, 37447, 37450, 37453, 37454, 37455, 37457, 37464, 37465, 37468, 37469, 37472, 37473, 37477, 37479, 37480, 37481, 37486, 37487, 37488, 37493, 37494, 37495, 37496, 37497, 37499, 37500, 37501, 37503, 37512, 37513, 37514, 37517, 37518, 37522, 37527, 37529, 37535, 37536, 37540, 37541, 37543, 37544, 37547, 37551, 37554, 37558, 37560, 37562, 37563, 37564, 37565, 37567, 37568, 37569, 37570, 37571, 37573, 37574, 37575, 37576, 37579, 37580, 37581, 37582, 37584, 37587, 37589, 37591, 37592, 37593, 37596, 37597, 37599, 37600, 37601, 37603, 37605, 37607, 37608, 37612, 37614, 37616, 37625, 37627, 37631, 37632, 37634, 37640, 37645, 37649, 37652, 37653, 37660, 37661, 37662, 37663, 37665, 37668, 37669, 37671, 37673, 37674, 37683, 37684, 37686, 37687, 37703, 37704, 37705, 37712, 37713, 37714, 37717, 37719, 37720, 37722, 37726, 37732, 37733, 37735, 37737, 37738, 37741, 37743, 37744, 37745, 37747, 37748, 37750, 37754, 37757, 37759, 37760, 37761, 37762, 37768, 37770, 37771, 37773, 37775, 37778, 37781, 37784, 37787, 37790, 37793, 37795, 37796, 37798, 37800, 37803, 37812, 37813, 37814, 37818, 37801, 37825, 37828, 37829, 37830, 37831, 37833, 37834, 37835, 37836, 37837, 37843, 37849, 37852, 37854, 37855, 37858, 37862, 37863, 37881, 37879, 37880, 37882, 37883, 37885, 37889, 37890, 37892, 37896, 37897, 37901, 37902, 37903, 37909, 37910, 37911, 37919, 37934, 37935, 37937, 37938, 37939, 37940, 37947, 37951, 37949, 37955, 37957, 37960, 37962, 37964, 37973, 37977, 37980, 37983, 37985, 37987, 37992, 37995, 37997, 37998, 37999, 38001, 38002, 38020, 38019, 38264, 38265, 38270, 38276, 38280, 38284, 38285, 38286, 38301, 38302, 38303, 38305, 38310, 38313, 38315, 38316, 38324, 38326, 38330, 38333, 38335, 38342, 38344, 38345, 38347, 38352, 38353, 38354, 38355, 38361, 38362, 38365, 38366, 38367, 38368, 38372, 38374, 38429, 38430, 38434, 38436, 38437, 38438, 38444, 38449, 38451, 38455, 38456, 38457, 38458, 38460, 38461, 38465, 38482, 38484, 38486, 38487, 38488, 38497, 38510, 38516, 38523, 38524, 38526, 38527, 38529, 38530, 38531, 38532, 38537, 38545, 38550, 38554, 38557, 38559, 38564, 38565, 38566, 38569, 38574, 38575, 38579, 38586, 38602, 38610, 23986, 38616, 38618, 38621, 38622, 38623, 38633, 38639, 38641, 38650, 38658, 38659, 38661, 38665, 38682, 38683, 38685, 38689, 38690, 38691, 38696, 38705, 38707, 38721, 38723, 38730, 38734, 38735, 38741, 38743, 38744, 38746, 38747, 38755, 38759, 38762, 38766, 38771, 38774, 38775, 38776, 38779, 38781, 38783, 38784, 38793, 38805, 38806, 38807, 38809, 38810, 38814, 38815, 38818, 38828, 38830, 38833, 38834, 38837, 38838, 38840, 38841, 38842, 38844, 38846, 38847, 38849, 38852, 38853, 38855, 38857, 38858, 38860, 38861, 38862, 38864, 38865, 38868, 38871, 38872, 38873, 38877, 38878, 38880, 38875, 38881, 38884, 38895, 38897, 38900, 38903, 38904, 38906, 38919, 38922, 38937, 38925, 38926, 38932, 38934, 38940, 38942, 38944, 38947, 38950, 38955, 38958, 38959, 38960, 38962, 38963, 38965, 38949, 38974, 38980, 38983, 38986, 38993, 38994, 38995, 38998, 38999, 39001, 39002, 39010, 39011, 39013, 39014, 39018, 39020, 39083, 39085, 39086, 39088, 39092, 39095, 39096, 39098, 39099, 39103, 39106, 39109, 39112, 39116, 39137, 39139, 39141, 39142, 39143, 39146, 39155, 39158, 39170, 39175, 39176, 39185, 39189, 39190, 39191, 39194, 39195, 39196, 39199, 39202, 39206, 39207, 39211, 39217, 39218, 39219, 39220, 39221, 39225, 39226, 39227, 39228, 39232, 39233, 39238, 39239, 39240, 39245, 39246, 39252, 39256, 39257, 39259, 39260, 39262, 39263, 39264, 39323, 39325, 39327, 39334, 39344, 39345, 39346, 39349, 39353, 39354, 39357, 39359, 39363, 39369, 39379, 39380, 39385, 39386, 39388, 39390, 39399, 39402, 39403, 39404, 39408, 39412, 39413, 39417, 39421, 39422, 39426, 39427, 39428, 39435, 39436, 39440, 39441, 39446, 39454, 39456, 39458, 39459, 39460, 39463, 39469, 39470, 39475, 39477, 39478, 39480, 39495, 39489, 39492, 39498, 39499, 39500, 39502, 39505, 39508, 39510, 39517, 39594, 39596, 39598, 39599, 39602, 39604, 39605, 39606, 39609, 39611, 39614, 39615, 39617, 39619, 39622, 39624, 39630, 39632, 39634, 39637, 39638, 39639, 39643, 39644, 39648, 39652, 39653, 39655, 39657, 39660, 39666, 39667, 39669, 39673, 39674, 39677, 39679, 39680, 39681, 39682, 39683, 39684, 39685, 39688, 39689, 39691, 39692, 39693, 39694, 39696, 39698, 39702, 39705, 39707, 39708, 39712, 39718, 39723, 39725, 39731, 39732, 39733, 39735, 39737, 39738, 39741, 39752, 39755, 39756, 39765, 39766, 39767, 39771, 39774, 39777, 39779, 39781, 39782, 39784, 39786, 39787, 39788, 39789, 39790, 39795, 39797, 39799, 39800, 39801, 39807, 39808, 39812, 39813, 39814, 39815, 39817, 39818, 39819, 39821, 39823, 39824, 39828, 39834, 39837, 39838, 39846, 39847, 39849, 39852, 39856, 39857, 39858, 39863, 39864, 39867, 39868, 39870, 39871, 39873, 39879, 39880, 39886, 39888, 39895, 39896, 39901, 39903, 39909, 39911, 39914, 39915, 39919, 39923, 39927, 39928, 39929, 39930, 39933, 39935, 39936, 39938, 39947, 39951, 39953, 39958, 39960, 39961, 39962, 39964, 39966, 39970, 39971, 39974, 39975, 39976, 39977, 39978, 39985, 39989, 39990, 39991, 39997, 40001, 40003, 40004, 40005, 40009, 40010, 40014, 40015, 40016, 40019, 40020, 40022, 40024, 40027, 40029, 40030, 40031, 40035, 40041, 40042, 40028, 40043, 40040, 40046, 40048, 40050, 40053, 40055, 40059, 40166, 40178, 40183, 40185, 40203, 40194, 40209, 40215, 40216, 40220, 40221, 40222, 40239, 40240, 40242, 40243, 40244, 40250, 40252, 40261, 40253, 40258, 40259, 40263, 40266, 40275, 40276, 40287, 40291, 40290, 40293, 40297, 40298, 40299, 40304, 40310, 40311, 40315, 40316, 40318, 40323, 40324, 40326, 40330, 40333, 40334, 40338, 40339, 40341, 40342, 40343, 40344, 40353, 40362, 40364, 40366, 40369, 40373, 40377, 40380, 40383, 40387, 40391, 40393, 40394, 40404, 40405, 40406, 40407, 40410, 40414, 40415, 40416, 40421, 40423, 40425, 40427, 40430, 40432, 40435, 40436, 40446, 40458, 40450, 40455, 40462, 40464, 40465, 40466, 40469, 40470, 40473, 40476, 40477, 40570, 40571, 40572, 40576, 40578, 40579, 40580, 40581, 40583, 40590, 40591, 40598, 40600, 40603, 40606, 40612, 40616, 40620, 40622, 40623, 40624, 40627, 40628, 40629, 40646, 40648, 40651, 40661, 40671, 40676, 40679, 40684, 40685, 40686, 40688, 40689, 40690, 40693, 40696, 40703, 40706, 40707, 40713, 40719, 40720, 40721, 40722, 40724, 40726, 40727, 40729, 40730, 40731, 40735, 40738, 40742, 40746, 40747, 40751, 40753, 40754, 40756, 40759, 40761, 40762, 40764, 40765, 40767, 40769, 40771, 40772, 40773, 40774, 40775, 40787, 40789, 40790, 40791, 40792, 40794, 40797, 40798, 40808, 40809, 40813, 40814, 40815, 40816, 40817, 40819, 40821, 40826, 40829, 40847, 40848, 40849, 40850, 40852, 40854, 40855, 40862, 40865, 40866, 40867, 40869, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "ibm866": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1025, 1105, 1028, 1108, 1031, 1111, 1038, 1118, 176, 8729, 183, 8730, 8470, 164, 9632, 160],
        "iso-8859-2": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 728, 321, 164, 317, 346, 167, 168, 352, 350, 356, 377, 173, 381, 379, 176, 261, 731, 322, 180, 318, 347, 711, 184, 353, 351, 357, 378, 733, 382, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
        "iso-8859-3": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 294, 728, 163, 164, null, 292, 167, 168, 304, 350, 286, 308, 173, null, 379, 176, 295, 178, 179, 180, 181, 293, 183, 184, 305, 351, 287, 309, 189, null, 380, 192, 193, 194, null, 196, 266, 264, 199, 200, 201, 202, 203, 204, 205, 206, 207, null, 209, 210, 211, 212, 288, 214, 215, 284, 217, 218, 219, 220, 364, 348, 223, 224, 225, 226, null, 228, 267, 265, 231, 232, 233, 234, 235, 236, 237, 238, 239, null, 241, 242, 243, 244, 289, 246, 247, 285, 249, 250, 251, 252, 365, 349, 729],
        "iso-8859-4": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 312, 342, 164, 296, 315, 167, 168, 352, 274, 290, 358, 173, 381, 175, 176, 261, 731, 343, 180, 297, 316, 711, 184, 353, 275, 291, 359, 330, 382, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 298, 272, 325, 332, 310, 212, 213, 214, 215, 216, 370, 218, 219, 220, 360, 362, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 299, 273, 326, 333, 311, 244, 245, 246, 247, 248, 371, 250, 251, 252, 361, 363, 729],
        "iso-8859-5": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 173, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 8470, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 167, 1118, 1119],
        "iso-8859-6": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, null, null, 164, null, null, null, null, null, null, null, 1548, 173, null, null, null, null, null, null, null, null, null, null, null, null, null, 1563, null, null, null, 1567, null, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, null, null, null, null, null, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "iso-8859-7": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8216, 8217, 163, 8364, 8367, 166, 167, 168, 169, 890, 171, 172, 173, null, 8213, 176, 177, 178, 179, 900, 901, 902, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
        "iso-8859-8": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, 162, 163, 164, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 8215, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
        "iso-8859-10": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 274, 290, 298, 296, 310, 167, 315, 272, 352, 358, 381, 173, 362, 330, 176, 261, 275, 291, 299, 297, 311, 183, 316, 273, 353, 359, 382, 8213, 363, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 207, 208, 325, 332, 211, 212, 213, 214, 360, 216, 370, 218, 219, 220, 221, 222, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 239, 240, 326, 333, 243, 244, 245, 246, 361, 248, 371, 250, 251, 252, 253, 254, 312],
        "iso-8859-13": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8221, 162, 163, 164, 8222, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 8220, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 8217],
        "iso-8859-14": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 7682, 7683, 163, 266, 267, 7690, 167, 7808, 169, 7810, 7691, 7922, 173, 174, 376, 7710, 7711, 288, 289, 7744, 7745, 182, 7766, 7809, 7767, 7811, 7776, 7923, 7812, 7813, 7777, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 372, 209, 210, 211, 212, 213, 214, 7786, 216, 217, 218, 219, 220, 221, 374, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 373, 241, 242, 243, 244, 245, 246, 7787, 248, 249, 250, 251, 252, 253, 375, 255],
        "iso-8859-15": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 8364, 165, 352, 167, 353, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 381, 181, 182, 183, 382, 185, 186, 187, 338, 339, 376, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
        "iso-8859-16": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 261, 321, 8364, 8222, 352, 167, 353, 169, 536, 171, 377, 173, 378, 379, 176, 177, 268, 322, 381, 8221, 182, 183, 382, 269, 537, 187, 338, 339, 376, 380, 192, 193, 194, 258, 196, 262, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 272, 323, 210, 211, 212, 336, 214, 346, 368, 217, 218, 219, 220, 280, 538, 223, 224, 225, 226, 259, 228, 263, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 273, 324, 242, 243, 244, 337, 246, 347, 369, 249, 250, 251, 252, 281, 539, 255],
        "koi8-r": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 1025, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
        "koi8-u": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 1108, 9556, 1110, 1111, 9559, 9560, 9561, 9562, 9563, 1169, 1118, 9566, 9567, 9568, 9569, 1025, 1028, 9571, 1030, 1031, 9574, 9575, 9576, 9577, 9578, 1168, 1038, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
        "macintosh": [196, 197, 199, 201, 209, 214, 220, 225, 224, 226, 228, 227, 229, 231, 233, 232, 234, 235, 237, 236, 238, 239, 241, 243, 242, 244, 246, 245, 250, 249, 251, 252, 8224, 176, 162, 163, 167, 8226, 182, 223, 174, 169, 8482, 180, 168, 8800, 198, 216, 8734, 177, 8804, 8805, 165, 181, 8706, 8721, 8719, 960, 8747, 170, 186, 937, 230, 248, 191, 161, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 192, 195, 213, 338, 339, 8211, 8212, 8220, 8221, 8216, 8217, 247, 9674, 255, 376, 8260, 8364, 8249, 8250, 64257, 64258, 8225, 183, 8218, 8222, 8240, 194, 202, 193, 203, 200, 205, 206, 207, 204, 211, 212, 63743, 210, 218, 219, 217, 305, 710, 732, 175, 728, 729, 730, 184, 733, 731, 711],
        "windows-874": [8364, 129, 130, 131, 132, 8230, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 153, 154, 155, 156, 157, 158, 159, 160, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, null, null, null, null, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, null, null, null, null],
        "windows-1250": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 352, 8249, 346, 356, 381, 377, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 353, 8250, 347, 357, 382, 378, 160, 711, 728, 321, 164, 260, 166, 167, 168, 169, 350, 171, 172, 173, 174, 379, 176, 177, 731, 322, 180, 181, 182, 183, 184, 261, 351, 187, 317, 733, 318, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
        "windows-1251": [1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033, 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160, 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172, 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105, 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103],
        "windows-1252": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
        "windows-1253": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 157, 158, 159, 160, 901, 902, 163, 164, 165, 166, 167, 168, 169, null, 171, 172, 173, 174, 8213, 176, 177, 178, 179, 900, 181, 182, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
        "windows-1254": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 286, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 304, 350, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 287, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 305, 351, 255],
        "windows-1255": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 156, 157, 158, 159, 160, 161, 162, 163, 8362, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, 191, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1520, 1521, 1522, 1523, 1524, null, null, null, null, null, null, null, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
        "windows-1256": [8364, 1662, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 1657, 8249, 338, 1670, 1688, 1672, 1711, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 1705, 8482, 1681, 8250, 339, 8204, 8205, 1722, 160, 1548, 162, 163, 164, 165, 166, 167, 168, 169, 1726, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 1563, 187, 188, 189, 190, 1567, 1729, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 215, 1591, 1592, 1593, 1594, 1600, 1601, 1602, 1603, 224, 1604, 226, 1605, 1606, 1607, 1608, 231, 232, 233, 234, 235, 1609, 1610, 238, 239, 1611, 1612, 1613, 1614, 244, 1615, 1616, 247, 1617, 249, 1618, 251, 252, 8206, 8207, 1746],
        "windows-1257": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 168, 711, 184, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 175, 731, 159, 160, null, 162, 163, 164, null, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 180, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 729],
        "windows-1258": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 258, 196, 197, 198, 199, 200, 201, 202, 203, 768, 205, 206, 207, 272, 209, 777, 211, 212, 416, 214, 215, 216, 217, 218, 219, 220, 431, 771, 223, 224, 225, 226, 259, 228, 229, 230, 231, 232, 233, 234, 235, 769, 237, 238, 239, 273, 241, 803, 243, 244, 417, 246, 247, 248, 249, 250, 251, 252, 432, 8363, 255],
        "x-mac-cyrillic": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 8224, 176, 1168, 163, 167, 8226, 182, 1030, 174, 169, 8482, 1026, 1106, 8800, 1027, 1107, 8734, 177, 8804, 8805, 1110, 181, 1169, 1032, 1028, 1108, 1031, 1111, 1033, 1113, 1034, 1114, 1112, 1029, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 1035, 1115, 1036, 1116, 1109, 8211, 8212, 8220, 8221, 8216, 8217, 247, 8222, 1038, 1118, 1039, 1119, 8470, 1025, 1105, 1103, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 8364]
      };
    })(exports4 || {});
  }
});

// node_modules/azle/node_modules/@sinonjs/text-encoding/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/azle/node_modules/@sinonjs/text-encoding/lib/encoding.js"(exports4, module) {
    (function(global2) {
      "use strict";
      if (typeof module !== "undefined" && module.exports && !global2["encoding-indexes"]) {
        global2["encoding-indexes"] = require_encoding_indexes()["encoding-indexes"];
      }
      function inRange(a2, min2, max) {
        return min2 <= a2 && a2 <= max;
      }
      function includes(array, item) {
        return array.indexOf(item) !== -1;
      }
      var floor2 = Math.floor;
      function ToDictionary(o3) {
        if (o3 === void 0) return {};
        if (o3 === Object(o3)) return o3;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string) {
        var s = String(string);
        var n5 = s.length;
        var i2 = 0;
        var u2 = [];
        while (i2 < n5) {
          var c2 = s.charCodeAt(i2);
          if (c2 < 55296 || c2 > 57343) {
            u2.push(c2);
          } else if (56320 <= c2 && c2 <= 57343) {
            u2.push(65533);
          } else if (55296 <= c2 && c2 <= 56319) {
            if (i2 === n5 - 1) {
              u2.push(65533);
            } else {
              var d = s.charCodeAt(i2 + 1);
              if (56320 <= d && d <= 57343) {
                var a2 = c2 & 1023;
                var b4 = d & 1023;
                u2.push(65536 + (a2 << 10) + b4);
                i2 += 1;
              } else {
                u2.push(65533);
              }
            }
          }
          i2 += 1;
        }
        return u2;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i2 = 0; i2 < code_points.length; ++i2) {
          var cp3 = code_points[i2];
          if (cp3 <= 65535) {
            s += String.fromCharCode(cp3);
          } else {
            cp3 -= 65536;
            s += String.fromCharCode(
              (cp3 >> 10) + 55296,
              (cp3 & 1023) + 56320
            );
          }
        }
        return s;
      }
      function isASCIIByte(a2) {
        return 0 <= a2 && a2 <= 127;
      }
      var isASCIICodePoint = isASCIIByte;
      var end_of_stream = -1;
      function Stream2(tokens) {
        this.tokens = [].slice.call(tokens);
        this.tokens.reverse();
      }
      Stream2.prototype = {
        /**
         * @return {boolean} True if end-of-stream has been hit.
         */
        endOfStream: function() {
          return !this.tokens.length;
        },
        /**
         * When a token is read from a stream, the first token in the
         * stream must be returned and subsequently removed, and
         * end-of-stream must be returned otherwise.
         *
         * @return {number} Get the next token from the stream, or
         * end_of_stream.
         */
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.pop();
        },
        /**
         * When one or more tokens are prepended to a stream, those tokens
         * must be inserted, in given order, before the first token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The token(s) to prepend to the
         * stream.
         */
        prepend: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.push(tokens.pop());
          } else {
            this.tokens.push(token);
          }
        },
        /**
         * When one or more tokens are pushed to a stream, those tokens
         * must be inserted, in given order, after the last token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The tokens(s) to push to the
         * stream.
         */
        push: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.unshift(tokens.shift());
          } else {
            this.tokens.unshift(token);
          }
        }
      };
      var finished2 = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      function encoderError(code_point) {
        throw TypeError("The code point " + code_point + " could not be encoded.");
      }
      function Decoder() {
      }
      Decoder.prototype = {
        /**
         * @param {Stream} stream The stream of bytes being decoded.
         * @param {number} bite The next byte read from the stream.
         * @return {?(number|!Array.<number>)} The next code point(s)
         *     decoded, or null if not enough data exists in the input
         *     stream to decode a complete code point, or |finished|.
         */
        handler: function(stream, bite) {
        }
      };
      function Encoder() {
      }
      Encoder.prototype = {
        /**
         * @param {Stream} stream The stream of code points being encoded.
         * @param {number} code_point Next code point read from the stream.
         * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
         */
        handler: function(stream, code_point) {
        }
      };
      function getEncoding(label) {
        label = String(label).trim().toLowerCase();
        if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
          return label_to_encoding[label];
        }
        return null;
      }
      var encodings = [
        {
          "encodings": [
            {
              "labels": [
                "unicode-1-1-utf-8",
                "utf-8",
                "utf8"
              ],
              "name": "UTF-8"
            }
          ],
          "heading": "The Encoding"
        },
        {
          "encodings": [
            {
              "labels": [
                "866",
                "cp866",
                "csibm866",
                "ibm866"
              ],
              "name": "IBM866"
            },
            {
              "labels": [
                "csisolatin2",
                "iso-8859-2",
                "iso-ir-101",
                "iso8859-2",
                "iso88592",
                "iso_8859-2",
                "iso_8859-2:1987",
                "l2",
                "latin2"
              ],
              "name": "ISO-8859-2"
            },
            {
              "labels": [
                "csisolatin3",
                "iso-8859-3",
                "iso-ir-109",
                "iso8859-3",
                "iso88593",
                "iso_8859-3",
                "iso_8859-3:1988",
                "l3",
                "latin3"
              ],
              "name": "ISO-8859-3"
            },
            {
              "labels": [
                "csisolatin4",
                "iso-8859-4",
                "iso-ir-110",
                "iso8859-4",
                "iso88594",
                "iso_8859-4",
                "iso_8859-4:1988",
                "l4",
                "latin4"
              ],
              "name": "ISO-8859-4"
            },
            {
              "labels": [
                "csisolatincyrillic",
                "cyrillic",
                "iso-8859-5",
                "iso-ir-144",
                "iso8859-5",
                "iso88595",
                "iso_8859-5",
                "iso_8859-5:1988"
              ],
              "name": "ISO-8859-5"
            },
            {
              "labels": [
                "arabic",
                "asmo-708",
                "csiso88596e",
                "csiso88596i",
                "csisolatinarabic",
                "ecma-114",
                "iso-8859-6",
                "iso-8859-6-e",
                "iso-8859-6-i",
                "iso-ir-127",
                "iso8859-6",
                "iso88596",
                "iso_8859-6",
                "iso_8859-6:1987"
              ],
              "name": "ISO-8859-6"
            },
            {
              "labels": [
                "csisolatingreek",
                "ecma-118",
                "elot_928",
                "greek",
                "greek8",
                "iso-8859-7",
                "iso-ir-126",
                "iso8859-7",
                "iso88597",
                "iso_8859-7",
                "iso_8859-7:1987",
                "sun_eu_greek"
              ],
              "name": "ISO-8859-7"
            },
            {
              "labels": [
                "csiso88598e",
                "csisolatinhebrew",
                "hebrew",
                "iso-8859-8",
                "iso-8859-8-e",
                "iso-ir-138",
                "iso8859-8",
                "iso88598",
                "iso_8859-8",
                "iso_8859-8:1988",
                "visual"
              ],
              "name": "ISO-8859-8"
            },
            {
              "labels": [
                "csiso88598i",
                "iso-8859-8-i",
                "logical"
              ],
              "name": "ISO-8859-8-I"
            },
            {
              "labels": [
                "csisolatin6",
                "iso-8859-10",
                "iso-ir-157",
                "iso8859-10",
                "iso885910",
                "l6",
                "latin6"
              ],
              "name": "ISO-8859-10"
            },
            {
              "labels": [
                "iso-8859-13",
                "iso8859-13",
                "iso885913"
              ],
              "name": "ISO-8859-13"
            },
            {
              "labels": [
                "iso-8859-14",
                "iso8859-14",
                "iso885914"
              ],
              "name": "ISO-8859-14"
            },
            {
              "labels": [
                "csisolatin9",
                "iso-8859-15",
                "iso8859-15",
                "iso885915",
                "iso_8859-15",
                "l9"
              ],
              "name": "ISO-8859-15"
            },
            {
              "labels": [
                "iso-8859-16"
              ],
              "name": "ISO-8859-16"
            },
            {
              "labels": [
                "cskoi8r",
                "koi",
                "koi8",
                "koi8-r",
                "koi8_r"
              ],
              "name": "KOI8-R"
            },
            {
              "labels": [
                "koi8-ru",
                "koi8-u"
              ],
              "name": "KOI8-U"
            },
            {
              "labels": [
                "csmacintosh",
                "mac",
                "macintosh",
                "x-mac-roman"
              ],
              "name": "macintosh"
            },
            {
              "labels": [
                "dos-874",
                "iso-8859-11",
                "iso8859-11",
                "iso885911",
                "tis-620",
                "windows-874"
              ],
              "name": "windows-874"
            },
            {
              "labels": [
                "cp1250",
                "windows-1250",
                "x-cp1250"
              ],
              "name": "windows-1250"
            },
            {
              "labels": [
                "cp1251",
                "windows-1251",
                "x-cp1251"
              ],
              "name": "windows-1251"
            },
            {
              "labels": [
                "ansi_x3.4-1968",
                "ascii",
                "cp1252",
                "cp819",
                "csisolatin1",
                "ibm819",
                "iso-8859-1",
                "iso-ir-100",
                "iso8859-1",
                "iso88591",
                "iso_8859-1",
                "iso_8859-1:1987",
                "l1",
                "latin1",
                "us-ascii",
                "windows-1252",
                "x-cp1252"
              ],
              "name": "windows-1252"
            },
            {
              "labels": [
                "cp1253",
                "windows-1253",
                "x-cp1253"
              ],
              "name": "windows-1253"
            },
            {
              "labels": [
                "cp1254",
                "csisolatin5",
                "iso-8859-9",
                "iso-ir-148",
                "iso8859-9",
                "iso88599",
                "iso_8859-9",
                "iso_8859-9:1989",
                "l5",
                "latin5",
                "windows-1254",
                "x-cp1254"
              ],
              "name": "windows-1254"
            },
            {
              "labels": [
                "cp1255",
                "windows-1255",
                "x-cp1255"
              ],
              "name": "windows-1255"
            },
            {
              "labels": [
                "cp1256",
                "windows-1256",
                "x-cp1256"
              ],
              "name": "windows-1256"
            },
            {
              "labels": [
                "cp1257",
                "windows-1257",
                "x-cp1257"
              ],
              "name": "windows-1257"
            },
            {
              "labels": [
                "cp1258",
                "windows-1258",
                "x-cp1258"
              ],
              "name": "windows-1258"
            },
            {
              "labels": [
                "x-mac-cyrillic",
                "x-mac-ukrainian"
              ],
              "name": "x-mac-cyrillic"
            }
          ],
          "heading": "Legacy single-byte encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "chinese",
                "csgb2312",
                "csiso58gb231280",
                "gb2312",
                "gb_2312",
                "gb_2312-80",
                "gbk",
                "iso-ir-58",
                "x-gbk"
              ],
              "name": "GBK"
            },
            {
              "labels": [
                "gb18030"
              ],
              "name": "gb18030"
            }
          ],
          "heading": "Legacy multi-byte Chinese (simplified) encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "big5",
                "big5-hkscs",
                "cn-big5",
                "csbig5",
                "x-x-big5"
              ],
              "name": "Big5"
            }
          ],
          "heading": "Legacy multi-byte Chinese (traditional) encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "cseucpkdfmtjapanese",
                "euc-jp",
                "x-euc-jp"
              ],
              "name": "EUC-JP"
            },
            {
              "labels": [
                "csiso2022jp",
                "iso-2022-jp"
              ],
              "name": "ISO-2022-JP"
            },
            {
              "labels": [
                "csshiftjis",
                "ms932",
                "ms_kanji",
                "shift-jis",
                "shift_jis",
                "sjis",
                "windows-31j",
                "x-sjis"
              ],
              "name": "Shift_JIS"
            }
          ],
          "heading": "Legacy multi-byte Japanese encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "cseuckr",
                "csksc56011987",
                "euc-kr",
                "iso-ir-149",
                "korean",
                "ks_c_5601-1987",
                "ks_c_5601-1989",
                "ksc5601",
                "ksc_5601",
                "windows-949"
              ],
              "name": "EUC-KR"
            }
          ],
          "heading": "Legacy multi-byte Korean encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "csiso2022kr",
                "hz-gb-2312",
                "iso-2022-cn",
                "iso-2022-cn-ext",
                "iso-2022-kr"
              ],
              "name": "replacement"
            },
            {
              "labels": [
                "utf-16be"
              ],
              "name": "UTF-16BE"
            },
            {
              "labels": [
                "utf-16",
                "utf-16le"
              ],
              "name": "UTF-16LE"
            },
            {
              "labels": [
                "x-user-defined"
              ],
              "name": "x-user-defined"
            }
          ],
          "heading": "Legacy miscellaneous encodings"
        }
      ];
      var label_to_encoding = {};
      encodings.forEach(function(category) {
        category.encodings.forEach(function(encoding2) {
          encoding2.labels.forEach(function(label) {
            label_to_encoding[label] = encoding2;
          });
        });
      });
      var encoders = {};
      var decoders = {};
      function indexCodePointFor(pointer, index2) {
        if (!index2) return null;
        return index2[pointer] || null;
      }
      function indexPointerFor(code_point, index2) {
        var pointer = index2.indexOf(code_point);
        return pointer === -1 ? null : pointer;
      }
      function index(name) {
        if (!("encoding-indexes" in global2)) {
          throw Error("Indexes missing. Did you forget to include encoding-indexes.js first?");
        }
        return global2["encoding-indexes"][name];
      }
      function indexGB18030RangesCodePointFor(pointer) {
        if (pointer > 39419 && pointer < 189e3 || pointer > 1237575)
          return null;
        if (pointer === 7457) return 59335;
        var offset = 0;
        var code_point_offset = 0;
        var idx = index("gb18030-ranges");
        var i2;
        for (i2 = 0; i2 < idx.length; ++i2) {
          var entry = idx[i2];
          if (entry[0] <= pointer) {
            offset = entry[0];
            code_point_offset = entry[1];
          } else {
            break;
          }
        }
        return code_point_offset + pointer - offset;
      }
      function indexGB18030RangesPointerFor(code_point) {
        if (code_point === 59335) return 7457;
        var offset = 0;
        var pointer_offset = 0;
        var idx = index("gb18030-ranges");
        var i2;
        for (i2 = 0; i2 < idx.length; ++i2) {
          var entry = idx[i2];
          if (entry[1] <= code_point) {
            offset = entry[1];
            pointer_offset = entry[0];
          } else {
            break;
          }
        }
        return pointer_offset + code_point - offset;
      }
      function indexShiftJISPointerFor(code_point) {
        shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point2, pointer) {
          return inRange(pointer, 8272, 8835) ? null : code_point2;
        });
        var index_ = shift_jis_index;
        return index_.indexOf(code_point);
      }
      var shift_jis_index;
      function indexBig5PointerFor(code_point) {
        big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point2, pointer) {
          return pointer < (161 - 129) * 157 ? null : code_point2;
        });
        var index_ = big5_index_no_hkscs;
        if (code_point === 9552 || code_point === 9566 || code_point === 9569 || code_point === 9578 || code_point === 21313 || code_point === 21317) {
          return index_.lastIndexOf(code_point);
        }
        return indexPointerFor(code_point, index_);
      }
      var big5_index_no_hkscs;
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder8(label, options) {
        if (!(this instanceof TextDecoder8))
          throw TypeError("Called as a function. Did you forget 'new'?");
        label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
        options = ToDictionary(options);
        this._encoding = null;
        this._decoder = null;
        this._ignoreBOM = false;
        this._BOMseen = false;
        this._error_mode = "replacement";
        this._do_not_flush = false;
        var encoding2 = getEncoding(label);
        if (encoding2 === null || encoding2.name === "replacement")
          throw RangeError("Unknown encoding: " + label);
        if (!decoders[encoding2.name]) {
          throw Error("Decoder not present. Did you forget to include encoding-indexes.js first?");
        }
        var dec = this;
        dec._encoding = encoding2;
        if (Boolean(options["fatal"]))
          dec._error_mode = "fatal";
        if (Boolean(options["ignoreBOM"]))
          dec._ignoreBOM = true;
        if (!Object.defineProperty) {
          this.encoding = dec._encoding.name.toLowerCase();
          this.fatal = dec._error_mode === "fatal";
          this.ignoreBOM = dec._ignoreBOM;
        }
        return dec;
      }
      if (Object.defineProperty) {
        Object.defineProperty(TextDecoder8.prototype, "encoding", {
          /** @this {TextDecoder} */
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        });
        Object.defineProperty(TextDecoder8.prototype, "fatal", {
          /** @this {TextDecoder} */
          get: function() {
            return this._error_mode === "fatal";
          }
        });
        Object.defineProperty(TextDecoder8.prototype, "ignoreBOM", {
          /** @this {TextDecoder} */
          get: function() {
            return this._ignoreBOM;
          }
        });
      }
      TextDecoder8.prototype.decode = function decode9(input2, options) {
        var bytes4;
        if (typeof input2 === "object" && input2 instanceof ArrayBuffer) {
          bytes4 = new Uint8Array(input2);
        } else if (typeof input2 === "object" && "buffer" in input2 && input2.buffer instanceof ArrayBuffer) {
          bytes4 = new Uint8Array(
            input2.buffer,
            input2.byteOffset,
            input2.byteLength
          );
        } else {
          bytes4 = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._do_not_flush) {
          this._decoder = decoders[this._encoding.name]({
            fatal: this._error_mode === "fatal"
          });
          this._BOMseen = false;
        }
        this._do_not_flush = Boolean(options["stream"]);
        var input_stream = new Stream2(bytes4);
        var output3 = [];
        var result2;
        while (true) {
          var token = input_stream.read();
          if (token === end_of_stream)
            break;
          result2 = this._decoder.handler(input_stream, token);
          if (result2 === finished2)
            break;
          if (result2 !== null) {
            if (Array.isArray(result2))
              output3.push.apply(
                output3,
                /**@type {!Array.<number>}*/
                result2
              );
            else
              output3.push(result2);
          }
        }
        if (!this._do_not_flush) {
          do {
            result2 = this._decoder.handler(input_stream, input_stream.read());
            if (result2 === finished2)
              break;
            if (result2 === null)
              continue;
            if (Array.isArray(result2))
              output3.push.apply(
                output3,
                /**@type {!Array.<number>}*/
                result2
              );
            else
              output3.push(result2);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        function serializeStream(stream) {
          if (includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {
            if (stream.length > 0 && stream[0] === 65279) {
              this._BOMseen = true;
              stream.shift();
            } else if (stream.length > 0) {
              this._BOMseen = true;
            } else {
            }
          }
          return codePointsToString(stream);
        }
        return serializeStream.call(this, output3);
      };
      function TextEncoder8(label, options) {
        if (!(this instanceof TextEncoder8))
          throw TypeError("Called as a function. Did you forget 'new'?");
        options = ToDictionary(options);
        this._encoding = null;
        this._encoder = null;
        this._do_not_flush = false;
        this._fatal = Boolean(options["fatal"]) ? "fatal" : "replacement";
        var enc = this;
        if (Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
          label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
          var encoding2 = getEncoding(label);
          if (encoding2 === null || encoding2.name === "replacement")
            throw RangeError("Unknown encoding: " + label);
          if (!encoders[encoding2.name]) {
            throw Error("Encoder not present. Did you forget to include encoding-indexes.js first?");
          }
          enc._encoding = encoding2;
        } else {
          enc._encoding = getEncoding("utf-8");
          if (label !== void 0 && "console" in global2) {
            console.warn("TextEncoder constructor called with encoding label, which is ignored.");
          }
        }
        if (!Object.defineProperty)
          this.encoding = enc._encoding.name.toLowerCase();
        return enc;
      }
      if (Object.defineProperty) {
        Object.defineProperty(TextEncoder8.prototype, "encoding", {
          /** @this {TextEncoder} */
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        });
      }
      TextEncoder8.prototype.encode = function encode7(opt_string, options) {
        opt_string = opt_string === void 0 ? "" : String(opt_string);
        options = ToDictionary(options);
        if (!this._do_not_flush)
          this._encoder = encoders[this._encoding.name]({
            fatal: this._fatal === "fatal"
          });
        this._do_not_flush = Boolean(options["stream"]);
        var input2 = new Stream2(stringToCodePoints(opt_string));
        var output3 = [];
        var result2;
        while (true) {
          var token = input2.read();
          if (token === end_of_stream)
            break;
          result2 = this._encoder.handler(input2, token);
          if (result2 === finished2)
            break;
          if (Array.isArray(result2))
            output3.push.apply(
              output3,
              /**@type {!Array.<number>}*/
              result2
            );
          else
            output3.push(result2);
        }
        if (!this._do_not_flush) {
          while (true) {
            result2 = this._encoder.handler(input2, input2.read());
            if (result2 === finished2)
              break;
            if (Array.isArray(result2))
              output3.push.apply(
                output3,
                /**@type {!Array.<number>}*/
                result2
              );
            else
              output3.push(result2);
          }
          this._encoder = null;
        }
        return new Uint8Array(output3);
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished2;
          if (utf8_bytes_needed === 0) {
            if (inRange(bite, 0, 127)) {
              return bite;
            } else if (inRange(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite & 31;
            } else if (inRange(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite & 15;
            } else if (inRange(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite & 7;
            } else {
              return decoderError(fatal);
            }
            return null;
          }
          if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_code_point = utf8_code_point << 6 | bite & 63;
          utf8_bytes_seen += 1;
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          var count, offset;
          if (inRange(code_point, 128, 2047)) {
            count = 1;
            offset = 192;
          } else if (inRange(code_point, 2048, 65535)) {
            count = 2;
            offset = 224;
          } else if (inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset = 240;
          }
          var bytes4 = [(code_point >> 6 * count) + offset];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes4.push(128 | temp & 63);
            count -= 1;
          }
          return bytes4;
        };
      }
      encoders["UTF-8"] = function(options) {
        return new UTF8Encoder(options);
      };
      decoders["UTF-8"] = function(options) {
        return new UTF8Decoder(options);
      };
      function SingleByteDecoder(index2, options) {
        var fatal = options.fatal;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream)
            return finished2;
          if (isASCIIByte(bite))
            return bite;
          var code_point = index2[bite - 128];
          if (code_point === null)
            return decoderError(fatal);
          return code_point;
        };
      }
      function SingleByteEncoder(index2, options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          var pointer = indexPointerFor(code_point, index2);
          if (pointer === null)
            encoderError(code_point);
          return pointer + 128;
        };
      }
      (function() {
        if (!("encoding-indexes" in global2))
          return;
        encodings.forEach(function(category) {
          if (category.heading !== "Legacy single-byte encodings")
            return;
          category.encodings.forEach(function(encoding2) {
            var name = encoding2.name;
            var idx = index(name.toLowerCase());
            decoders[name] = function(options) {
              return new SingleByteDecoder(idx, options);
            };
            encoders[name] = function(options) {
              return new SingleByteEncoder(idx, options);
            };
          });
        });
      })();
      decoders["GBK"] = function(options) {
        return new GB18030Decoder(options);
      };
      encoders["GBK"] = function(options) {
        return new GB18030Encoder(options, true);
      };
      function GB18030Decoder(options) {
        var fatal = options.fatal;
        var gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && gb18030_first === 0 && gb18030_second === 0 && gb18030_third === 0) {
            return finished2;
          }
          if (bite === end_of_stream && (gb18030_first !== 0 || gb18030_second !== 0 || gb18030_third !== 0)) {
            gb18030_first = 0;
            gb18030_second = 0;
            gb18030_third = 0;
            decoderError(fatal);
          }
          var code_point;
          if (gb18030_third !== 0) {
            code_point = null;
            if (inRange(bite, 48, 57)) {
              code_point = indexGB18030RangesCodePointFor(
                (((gb18030_first - 129) * 10 + gb18030_second - 48) * 126 + gb18030_third - 129) * 10 + bite - 48
              );
            }
            var buffer = [gb18030_second, gb18030_third, bite];
            gb18030_first = 0;
            gb18030_second = 0;
            gb18030_third = 0;
            if (code_point === null) {
              stream.prepend(buffer);
              return decoderError(fatal);
            }
            return code_point;
          }
          if (gb18030_second !== 0) {
            if (inRange(bite, 129, 254)) {
              gb18030_third = bite;
              return null;
            }
            stream.prepend([gb18030_second, bite]);
            gb18030_first = 0;
            gb18030_second = 0;
            return decoderError(fatal);
          }
          if (gb18030_first !== 0) {
            if (inRange(bite, 48, 57)) {
              gb18030_second = bite;
              return null;
            }
            var lead = gb18030_first;
            var pointer = null;
            gb18030_first = 0;
            var offset = bite < 127 ? 64 : 65;
            if (inRange(bite, 64, 126) || inRange(bite, 128, 254))
              pointer = (lead - 129) * 190 + (bite - offset);
            code_point = pointer === null ? null : indexCodePointFor(pointer, index("gb18030"));
            if (code_point === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (bite === 128)
            return 8364;
          if (inRange(bite, 129, 254)) {
            gb18030_first = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function GB18030Encoder(options, gbk_flag) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          if (code_point === 58853)
            return encoderError(code_point);
          if (gbk_flag && code_point === 8364)
            return 128;
          var pointer = indexPointerFor(code_point, index("gb18030"));
          if (pointer !== null) {
            var lead = floor2(pointer / 190) + 129;
            var trail = pointer % 190;
            var offset = trail < 63 ? 64 : 65;
            return [lead, trail + offset];
          }
          if (gbk_flag)
            return encoderError(code_point);
          pointer = indexGB18030RangesPointerFor(code_point);
          var byte1 = floor2(pointer / 10 / 126 / 10);
          pointer = pointer - byte1 * 10 * 126 * 10;
          var byte2 = floor2(pointer / 10 / 126);
          pointer = pointer - byte2 * 10 * 126;
          var byte3 = floor2(pointer / 10);
          var byte4 = pointer - byte3 * 10;
          return [
            byte1 + 129,
            byte2 + 48,
            byte3 + 129,
            byte4 + 48
          ];
        };
      }
      encoders["gb18030"] = function(options) {
        return new GB18030Encoder(options);
      };
      decoders["gb18030"] = function(options) {
        return new GB18030Decoder(options);
      };
      function Big5Decoder(options) {
        var fatal = options.fatal;
        var Big5_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && Big5_lead !== 0) {
            Big5_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && Big5_lead === 0)
            return finished2;
          if (Big5_lead !== 0) {
            var lead = Big5_lead;
            var pointer = null;
            Big5_lead = 0;
            var offset = bite < 127 ? 64 : 98;
            if (inRange(bite, 64, 126) || inRange(bite, 161, 254))
              pointer = (lead - 129) * 157 + (bite - offset);
            switch (pointer) {
              case 1133:
                return [202, 772];
              case 1135:
                return [202, 780];
              case 1164:
                return [234, 772];
              case 1166:
                return [234, 780];
            }
            var code_point = pointer === null ? null : indexCodePointFor(pointer, index("big5"));
            if (code_point === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (inRange(bite, 129, 254)) {
            Big5_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function Big5Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          var pointer = indexBig5PointerFor(code_point);
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor2(pointer / 157) + 129;
          if (lead < 161)
            return encoderError(code_point);
          var trail = pointer % 157;
          var offset = trail < 63 ? 64 : 98;
          return [lead, trail + offset];
        };
      }
      encoders["Big5"] = function(options) {
        return new Big5Encoder(options);
      };
      decoders["Big5"] = function(options) {
        return new Big5Decoder(options);
      };
      function EUCJPDecoder(options) {
        var fatal = options.fatal;
        var eucjp_jis0212_flag = false, eucjp_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && eucjp_lead !== 0) {
            eucjp_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && eucjp_lead === 0)
            return finished2;
          if (eucjp_lead === 142 && inRange(bite, 161, 223)) {
            eucjp_lead = 0;
            return 65377 - 161 + bite;
          }
          if (eucjp_lead === 143 && inRange(bite, 161, 254)) {
            eucjp_jis0212_flag = true;
            eucjp_lead = bite;
            return null;
          }
          if (eucjp_lead !== 0) {
            var lead = eucjp_lead;
            eucjp_lead = 0;
            var code_point = null;
            if (inRange(lead, 161, 254) && inRange(bite, 161, 254)) {
              code_point = indexCodePointFor(
                (lead - 161) * 94 + (bite - 161),
                index(!eucjp_jis0212_flag ? "jis0208" : "jis0212")
              );
            }
            eucjp_jis0212_flag = false;
            if (!inRange(bite, 161, 254))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (bite === 142 || bite === 143 || inRange(bite, 161, 254)) {
            eucjp_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function EUCJPEncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          if (code_point === 165)
            return 92;
          if (code_point === 8254)
            return 126;
          if (inRange(code_point, 65377, 65439))
            return [142, code_point - 65377 + 161];
          if (code_point === 8722)
            code_point = 65293;
          var pointer = indexPointerFor(code_point, index("jis0208"));
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor2(pointer / 94) + 161;
          var trail = pointer % 94 + 161;
          return [lead, trail];
        };
      }
      encoders["EUC-JP"] = function(options) {
        return new EUCJPEncoder(options);
      };
      decoders["EUC-JP"] = function(options) {
        return new EUCJPDecoder(options);
      };
      function ISO2022JPDecoder(options) {
        var fatal = options.fatal;
        var states = {
          ASCII: 0,
          Roman: 1,
          Katakana: 2,
          LeadByte: 3,
          TrailByte: 4,
          EscapeStart: 5,
          Escape: 6
        };
        var iso2022jp_decoder_state = states.ASCII, iso2022jp_decoder_output_state = states.ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = false;
        this.handler = function(stream, bite) {
          switch (iso2022jp_decoder_state) {
            default:
            case states.ASCII:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27) {
                iso2022jp_output_flag = false;
                return bite;
              }
              if (bite === end_of_stream) {
                return finished2;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.Roman:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (bite === 92) {
                iso2022jp_output_flag = false;
                return 165;
              }
              if (bite === 126) {
                iso2022jp_output_flag = false;
                return 8254;
              }
              if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27 && bite !== 92 && bite !== 126) {
                iso2022jp_output_flag = false;
                return bite;
              }
              if (bite === end_of_stream) {
                return finished2;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.Katakana:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (inRange(bite, 33, 95)) {
                iso2022jp_output_flag = false;
                return 65377 - 33 + bite;
              }
              if (bite === end_of_stream) {
                return finished2;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.LeadByte:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (inRange(bite, 33, 126)) {
                iso2022jp_output_flag = false;
                iso2022jp_lead = bite;
                iso2022jp_decoder_state = states.TrailByte;
                return null;
              }
              if (bite === end_of_stream) {
                return finished2;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.TrailByte:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return decoderError(fatal);
              }
              if (inRange(bite, 33, 126)) {
                iso2022jp_decoder_state = states.LeadByte;
                var pointer = (iso2022jp_lead - 33) * 94 + bite - 33;
                var code_point = indexCodePointFor(pointer, index("jis0208"));
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (bite === end_of_stream) {
                iso2022jp_decoder_state = states.LeadByte;
                stream.prepend(bite);
                return decoderError(fatal);
              }
              iso2022jp_decoder_state = states.LeadByte;
              return decoderError(fatal);
            case states.EscapeStart:
              if (bite === 36 || bite === 40) {
                iso2022jp_lead = bite;
                iso2022jp_decoder_state = states.Escape;
                return null;
              }
              stream.prepend(bite);
              iso2022jp_output_flag = false;
              iso2022jp_decoder_state = iso2022jp_decoder_output_state;
              return decoderError(fatal);
            case states.Escape:
              var lead = iso2022jp_lead;
              iso2022jp_lead = 0;
              var state = null;
              if (lead === 40 && bite === 66)
                state = states.ASCII;
              if (lead === 40 && bite === 74)
                state = states.Roman;
              if (lead === 40 && bite === 73)
                state = states.Katakana;
              if (lead === 36 && (bite === 64 || bite === 66))
                state = states.LeadByte;
              if (state !== null) {
                iso2022jp_decoder_state = iso2022jp_decoder_state = state;
                var output_flag = iso2022jp_output_flag;
                iso2022jp_output_flag = true;
                return !output_flag ? null : decoderError(fatal);
              }
              stream.prepend([lead, bite]);
              iso2022jp_output_flag = false;
              iso2022jp_decoder_state = iso2022jp_decoder_output_state;
              return decoderError(fatal);
          }
        };
      }
      function ISO2022JPEncoder(options) {
        var fatal = options.fatal;
        var states = {
          ASCII: 0,
          Roman: 1,
          jis0208: 2
        };
        var iso2022jp_state = states.ASCII;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {
            stream.prepend(code_point);
            iso2022jp_state = states.ASCII;
            return [27, 40, 66];
          }
          if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
            return finished2;
          if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 14 || code_point === 15 || code_point === 27)) {
            return encoderError(65533);
          }
          if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point))
            return code_point;
          if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 92 && code_point !== 126 || (code_point == 165 || code_point == 8254))) {
            if (isASCIICodePoint(code_point))
              return code_point;
            if (code_point === 165)
              return 92;
            if (code_point === 8254)
              return 126;
          }
          if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {
            stream.prepend(code_point);
            iso2022jp_state = states.ASCII;
            return [27, 40, 66];
          }
          if ((code_point === 165 || code_point === 8254) && iso2022jp_state !== states.Roman) {
            stream.prepend(code_point);
            iso2022jp_state = states.Roman;
            return [27, 40, 74];
          }
          if (code_point === 8722)
            code_point = 65293;
          var pointer = indexPointerFor(code_point, index("jis0208"));
          if (pointer === null)
            return encoderError(code_point);
          if (iso2022jp_state !== states.jis0208) {
            stream.prepend(code_point);
            iso2022jp_state = states.jis0208;
            return [27, 36, 66];
          }
          var lead = floor2(pointer / 94) + 33;
          var trail = pointer % 94 + 33;
          return [lead, trail];
        };
      }
      encoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPEncoder(options);
      };
      decoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPDecoder(options);
      };
      function ShiftJISDecoder(options) {
        var fatal = options.fatal;
        var Shift_JIS_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && Shift_JIS_lead !== 0) {
            Shift_JIS_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && Shift_JIS_lead === 0)
            return finished2;
          if (Shift_JIS_lead !== 0) {
            var lead = Shift_JIS_lead;
            var pointer = null;
            Shift_JIS_lead = 0;
            var offset = bite < 127 ? 64 : 65;
            var lead_offset = lead < 160 ? 129 : 193;
            if (inRange(bite, 64, 126) || inRange(bite, 128, 252))
              pointer = (lead - lead_offset) * 188 + bite - offset;
            if (inRange(pointer, 8836, 10715))
              return 57344 - 8836 + pointer;
            var code_point = pointer === null ? null : indexCodePointFor(pointer, index("jis0208"));
            if (code_point === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite) || bite === 128)
            return bite;
          if (inRange(bite, 161, 223))
            return 65377 - 161 + bite;
          if (inRange(bite, 129, 159) || inRange(bite, 224, 252)) {
            Shift_JIS_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function ShiftJISEncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point) || code_point === 128)
            return code_point;
          if (code_point === 165)
            return 92;
          if (code_point === 8254)
            return 126;
          if (inRange(code_point, 65377, 65439))
            return code_point - 65377 + 161;
          if (code_point === 8722)
            code_point = 65293;
          var pointer = indexShiftJISPointerFor(code_point);
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor2(pointer / 188);
          var lead_offset = lead < 31 ? 129 : 193;
          var trail = pointer % 188;
          var offset = trail < 63 ? 64 : 65;
          return [lead + lead_offset, trail + offset];
        };
      }
      encoders["Shift_JIS"] = function(options) {
        return new ShiftJISEncoder(options);
      };
      decoders["Shift_JIS"] = function(options) {
        return new ShiftJISDecoder(options);
      };
      function EUCKRDecoder(options) {
        var fatal = options.fatal;
        var euckr_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && euckr_lead !== 0) {
            euckr_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && euckr_lead === 0)
            return finished2;
          if (euckr_lead !== 0) {
            var lead = euckr_lead;
            var pointer = null;
            euckr_lead = 0;
            if (inRange(bite, 65, 254))
              pointer = (lead - 129) * 190 + (bite - 65);
            var code_point = pointer === null ? null : indexCodePointFor(pointer, index("euc-kr"));
            if (pointer === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (inRange(bite, 129, 254)) {
            euckr_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function EUCKREncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          var pointer = indexPointerFor(code_point, index("euc-kr"));
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor2(pointer / 190) + 129;
          var trail = pointer % 190 + 65;
          return [lead, trail];
        };
      }
      encoders["EUC-KR"] = function(options) {
        return new EUCKREncoder(options);
      };
      decoders["EUC-KR"] = function(options) {
        return new EUCKRDecoder(options);
      };
      function convertCodeUnitToBytes(code_unit, utf16be) {
        var byte1 = code_unit >> 8;
        var byte2 = code_unit & 255;
        if (utf16be)
          return [byte1, byte2];
        return [byte2, byte1];
      }
      function UTF16Decoder(utf16_be, options) {
        var fatal = options.fatal;
        var utf16_lead_byte = null, utf16_lead_surrogate = null;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
            return decoderError(fatal);
          }
          if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
            return finished2;
          }
          if (utf16_lead_byte === null) {
            utf16_lead_byte = bite;
            return null;
          }
          var code_unit;
          if (utf16_be) {
            code_unit = (utf16_lead_byte << 8) + bite;
          } else {
            code_unit = (bite << 8) + utf16_lead_byte;
          }
          utf16_lead_byte = null;
          if (utf16_lead_surrogate !== null) {
            var lead_surrogate = utf16_lead_surrogate;
            utf16_lead_surrogate = null;
            if (inRange(code_unit, 56320, 57343)) {
              return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320);
            }
            stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
            return decoderError(fatal);
          }
          if (inRange(code_unit, 55296, 56319)) {
            utf16_lead_surrogate = code_unit;
            return null;
          }
          if (inRange(code_unit, 56320, 57343))
            return decoderError(fatal);
          return code_unit;
        };
      }
      function UTF16Encoder(utf16_be, options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (inRange(code_point, 0, 65535))
            return convertCodeUnitToBytes(code_point, utf16_be);
          var lead = convertCodeUnitToBytes(
            (code_point - 65536 >> 10) + 55296,
            utf16_be
          );
          var trail = convertCodeUnitToBytes(
            (code_point - 65536 & 1023) + 56320,
            utf16_be
          );
          return lead.concat(trail);
        };
      }
      encoders["UTF-16BE"] = function(options) {
        return new UTF16Encoder(true, options);
      };
      decoders["UTF-16BE"] = function(options) {
        return new UTF16Decoder(true, options);
      };
      encoders["UTF-16LE"] = function(options) {
        return new UTF16Encoder(false, options);
      };
      decoders["UTF-16LE"] = function(options) {
        return new UTF16Decoder(false, options);
      };
      function XUserDefinedDecoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream)
            return finished2;
          if (isASCIIByte(bite))
            return bite;
          return 63360 + bite - 128;
        };
      }
      function XUserDefinedEncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished2;
          if (isASCIICodePoint(code_point))
            return code_point;
          if (inRange(code_point, 63360, 63487))
            return code_point - 63360 + 128;
          return encoderError(code_point);
        };
      }
      encoders["x-user-defined"] = function(options) {
        return new XUserDefinedEncoder(options);
      };
      decoders["x-user-defined"] = function(options) {
        return new XUserDefinedDecoder(options);
      };
      if (!global2["TextEncoder"])
        global2["TextEncoder"] = TextEncoder8;
      if (!global2["TextDecoder"])
        global2["TextDecoder"] = TextDecoder8;
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          TextEncoder: global2["TextEncoder"],
          TextDecoder: global2["TextDecoder"],
          EncodingIndexes: global2["encoding-indexes"]
        };
      }
    })(exports4 || {});
  }
});

// node_modules/azle/node_modules/@sinonjs/text-encoding/index.js
var require_text_encoding = __commonJS({
  "node_modules/azle/node_modules/@sinonjs/text-encoding/index.js"(exports4, module) {
    var encoding2 = require_encoding();
    module.exports = {
      TextEncoder: encoding2.TextEncoder,
      TextDecoder: encoding2.TextDecoder
    };
  }
});

// ../../../../../../node_modules/wasmedge_quickjs/modules/buffer.js
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer2,
  FastBuffer: () => FastBuffer,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  SlowBuffer: () => SlowBuffer,
  default: () => exports,
  kMaxLength: () => kMaxLength
});
function dew$2() {
  if (_dewExec$2) {
    return exports$3;
  }
  _dewExec$2 = true;
  exports$3.byteLength = byteLength;
  exports$3.toByteArray = toByteArray;
  exports$3.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) {
      validLen = len2;
    }
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i3;
    for (i3 = 0; i3 < len2; i3 += 4) {
      tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output3 = [];
    for (var i3 = start; i3 < end; i3 += 3) {
      tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
      output3.push(tripletToBase64(tmp));
    }
    return output3.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$3;
}
function dew$1() {
  if (_dewExec$1) {
    return exports$2;
  }
  _dewExec$1 = true;
  exports$2.read = function(buffer, offset, isLE3, mLen, nBytes) {
    var e3, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE3 ? nBytes - 1 : 0;
    var d = isLE3 ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e3 = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e3 = e3 * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m2 = e3 & (1 << -nBits) - 1;
    e3 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e3 === 0) {
      e3 = 1 - eBias;
    } else if (e3 === eMax) {
      return m2 ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e3 = e3 - eBias;
    }
    return (s ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
  };
  exports$2.write = function(buffer, value, offset, isLE3, mLen, nBytes) {
    var e3, m2, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE3 ? 0 : nBytes - 1;
    var d = isLE3 ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e3 = eMax;
    } else {
      e3 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e3)) < 1) {
        e3--;
        c2 *= 2;
      }
      if (e3 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e3++;
        c2 /= 2;
      }
      if (e3 + eBias >= eMax) {
        m2 = 0;
        e3 = eMax;
      } else if (e3 + eBias >= 1) {
        m2 = (value * c2 - 1) * Math.pow(2, mLen);
        e3 = e3 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e3 = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d, m2 /= 256, mLen -= 8) {
    }
    e3 = e3 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e3 & 255, i2 += d, e3 /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s * 128;
  };
  return exports$2;
}
function dew() {
  if (_dewExec) {
    return exports$1;
  }
  _dewExec = true;
  var base64 = dew$2();
  var ieee754 = dew$1();
  var customInspectSymbol3 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer4;
  exports$1.SlowBuffer = SlowBuffer2;
  exports$1.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e3) {
      return false;
    }
  }
  Object.defineProperty(Buffer4.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer4.isBuffer(this)) {
        return void 0;
      }
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer4.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer4.isBuffer(this)) {
        return void 0;
      }
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer4.prototype);
    return buf;
  }
  function Buffer4(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer4.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer4.from(valueOf, encodingOrOffset, length);
    }
    var b4 = fromObject(value);
    if (b4) {
      return b4;
    }
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer4.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer4, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding2) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer4.alloc = function(size, fill, encoding2) {
    return alloc(size, fill, encoding2);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer4.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer4.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer4.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    var length = byteLength(string, encoding2) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding2);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy7 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy7.buffer, copy7.byteOffset, copy7.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer4.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer4.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer4.alloc(+length);
  }
  Buffer4.isBuffer = function isBuffer2(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer4.prototype;
  };
  Buffer4.compare = function compare(a2, b4) {
    if (isInstance(a2, Uint8Array)) {
      a2 = Buffer4.from(a2, a2.offset, a2.byteLength);
    }
    if (isInstance(b4, Uint8Array)) {
      b4 = Buffer4.from(b4, b4.offset, b4.byteLength);
    }
    if (!Buffer4.isBuffer(a2) || !Buffer4.isBuffer(b4)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b4) {
      return 0;
    }
    var x = a2.length;
    var y2 = b4.length;
    for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
      if (a2[i2] !== b4[i2]) {
        x = a2[i2];
        y2 = b4[i2];
        break;
      }
    }
    if (x < y2) {
      return -1;
    }
    if (y2 < x) {
      return 1;
    }
    return 0;
  };
  Buffer4.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer4.concat = function concat4(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer4.alloc(0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer = Buffer4.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer4.isBuffer(buf)) {
            buf = Buffer4.from(buf);
          }
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!Buffer4.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding2) {
    if (Buffer4.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
      return 0;
    }
    var loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes7(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes7(string).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer4.byteLength = byteLength;
  function slowToString(encoding2, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding2) {
      encoding2 = "utf8";
    }
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice2(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) {
            throw new TypeError("Unknown encoding: " + encoding2);
          }
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer4.prototype._isBuffer = true;
  function swap(b4, n5, m2) {
    var i2 = b4[n5];
    b4[n5] = b4[m2];
    b4[m2] = i2;
  }
  Buffer4.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer4.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer4.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer4.prototype.toString = function toString4() {
    var length = this.length;
    if (length === 0) {
      return "";
    }
    if (arguments.length === 0) {
      return utf8Slice(this, 0, length);
    }
    return slowToString.apply(this, arguments);
  };
  Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
  Buffer4.prototype.equals = function equals(b4) {
    if (!Buffer4.isBuffer(b4)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (this === b4) {
      return true;
    }
    return Buffer4.compare(this, b4) === 0;
  };
  Buffer4.prototype.inspect = function inspect2() {
    var str = "";
    var max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
      str += " ... ";
    }
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol3) {
    Buffer4.prototype[customInspectSymbol3] = Buffer4.prototype.inspect;
  }
  Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer4.from(target, target.offset, target.byteLength);
    }
    if (!Buffer4.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
      return 0;
    }
    var x = thisEnd - thisStart;
    var y2 = end - start;
    var len = Math.min(x, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x < y2) {
      return -1;
    }
    if (y2 < x) {
      return 1;
    }
    return 0;
  };
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding2, dir) {
    if (buffer.length === 0) {
      return -1;
    }
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0) {
      byteOffset = buffer.length + byteOffset;
    }
    if (byteOffset >= buffer.length) {
      if (dir) {
        return -1;
      } else {
        byteOffset = buffer.length - 1;
      }
    } else if (byteOffset < 0) {
      if (dir) {
        byteOffset = 0;
      } else {
        return -1;
      }
    }
    if (typeof val === "string") {
      val = Buffer4.from(val, encoding2);
    }
    if (Buffer4.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1) {
            foundIndex = i2;
          }
          if (i2 - foundIndex + 1 === valLength) {
            return foundIndex * indexSize;
          }
        } else {
          if (foundIndex !== -1) {
            i2 -= i2 - foundIndex;
          }
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) {
        byteOffset = arrLength - valLength;
      }
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) {
          return i2;
        }
      }
    }
    return -1;
  }
  Buffer4.prototype.includes = function includes(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    var i2;
    for (i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed)) {
        return i2;
      }
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes7(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer4.prototype.write = function write2(string, offset, length, encoding2) {
    if (offset === void 0) {
      encoding2 = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding2 = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding2 === void 0) {
          encoding2 = "utf8";
        }
      } else {
        encoding2 = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) {
      length = remaining;
    }
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2) {
      encoding2 = "utf8";
    }
    var loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) {
            throw new TypeError("Unknown encoding: " + encoding2);
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer4.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte = void 0, thirdByte = void 0, fourthByte = void 0, tempCodePoint = void 0;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice2(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) {
      start = 0;
    }
    if (!end || end < 0 || end > len) {
      end = len;
    }
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes4 = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes4.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes4[i2] + bytes4[i2 + 1] * 256);
    }
    return res;
  }
  Buffer4.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) {
        start = 0;
      }
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) {
        end = 0;
      }
    } else if (end > len) {
      end = len;
    }
    if (end < start) {
      end = start;
    }
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer4.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) {
      throw new RangeError("offset is not uint");
    }
    if (offset + ext > length) {
      throw new RangeError("Trying to access beyond buffer length");
    }
  }
  Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE2(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 1, this.length);
    }
    return this[offset];
  };
  Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 2, this.length);
    }
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 2, this.length);
    }
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 4, this.length);
    }
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 4, this.length);
    }
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
    var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer4.prototype.readIntLE = function readIntLE2(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul) {
      val -= Math.pow(2, 8 * byteLength2);
    }
    return val;
  };
  Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var i2 = byteLength2;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul) {
      val -= Math.pow(2, 8 * byteLength2);
    }
    return val;
  };
  Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 1, this.length);
    }
    if (!(this[offset] & 128)) {
      return this[offset];
    }
    return (255 - this[offset] + 1) * -1;
  };
  Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 2, this.length);
    }
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 2, this.length);
    }
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 4, this.length);
    }
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 4, this.length);
    }
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
  });
  Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    var val = (first << 24) + // Overflow
    this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
  });
  Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 4, this.length);
    }
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 4, this.length);
    }
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 8, this.length);
    }
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) {
      checkOffset(offset, 8, this.length);
    }
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min2) {
    if (!Buffer4.isBuffer(buf)) {
      throw new TypeError('"buffer" argument must be a Buffer instance');
    }
    if (value > max || value < min2) {
      throw new RangeError('"value" argument is out of bounds');
    }
    if (offset + ext > buf.length) {
      throw new RangeError("Index out of range");
    }
  }
  Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i2 = byteLength2 - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 1, 255, 0);
    }
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 2, 65535, 0);
    }
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 2, 65535, 0);
    }
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 4, 4294967295, 0);
    }
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 4, 4294967295, 0);
    }
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max) {
    checkIntBI(value, min2, max, buf, offset, 7);
    var lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max) {
    checkIntBI(value, min2, max, buf, offset, 7);
    var lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset) {
    if (offset === void 0) offset = 0;
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset) {
    if (offset === void 0) offset = 0;
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer4.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i2 = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 1, 127, -128);
    }
    if (value < 0) {
      value = 255 + value + 1;
    }
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 2, 32767, -32768);
    }
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 2, 32767, -32768);
    }
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    }
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    }
    if (value < 0) {
      value = 4294967295 + value + 1;
    }
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset) {
    if (offset === void 0) offset = 0;
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset) {
    if (offset === void 0) offset = 0;
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min2) {
    if (offset + ext > buf.length) {
      throw new RangeError("Index out of range");
    }
    if (offset < 0) {
      throw new RangeError("Index out of range");
    }
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer4.prototype.copy = function copy7(target, targetStart, start, end) {
    if (!Buffer4.isBuffer(target)) {
      throw new TypeError("argument should be a Buffer");
    }
    if (!start) {
      start = 0;
    }
    if (!end && end !== 0) {
      end = this.length;
    }
    if (targetStart >= target.length) {
      targetStart = target.length;
    }
    if (!targetStart) {
      targetStart = 0;
    }
    if (end > 0 && end < start) {
      end = start;
    }
    if (end === start) {
      return 0;
    }
    if (target.length === 0 || this.length === 0) {
      return 0;
    }
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) {
      throw new RangeError("Index out of range");
    }
    if (end < 0) {
      throw new RangeError("sourceEnd out of bounds");
    }
    if (end > this.length) {
      end = this.length;
    }
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer4.prototype.fill = function fill(val, start, end, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding2 = end;
        end = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer4.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (encoding2 === "utf8" && code < 128 || encoding2 === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
      val = 0;
    }
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes4 = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding2);
      var len = bytes4.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes4[i2 % len];
      }
    }
    return this;
  };
  var errors2 = {};
  function E(sym, getMessage, Base) {
    errors2[sym] = /* @__PURE__ */ function(Base2) {
      function NodeError() {
        Base2.call(this);
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = this.name + " [" + sym + "]";
        this.stack;
        delete this.name;
      }
      if (Base2) NodeError.__proto__ = Base2;
      NodeError.prototype = Object.create(Base2 && Base2.prototype);
      NodeError.prototype.constructor = NodeError;
      var prototypeAccessors = { code: { configurable: true } };
      prototypeAccessors.code.get = function() {
        return sym;
      };
      prototypeAccessors.code.set = function(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      };
      NodeError.prototype.toString = function toString4() {
        return this.name + " [" + sym + "]: " + this.message;
      };
      Object.defineProperties(NodeError.prototype, prototypeAccessors);
      return NodeError;
    }(Base);
  }
  E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) {
      return name + " is outside of buffer bounds";
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return 'The "' + name + '" argument must be of type number. Received type ' + typeof actual;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", function(str, range, input2) {
    var msg = 'The value of "' + str + '" is out of range.';
    var received = input2;
    if (Number.isInteger(input2) && Math.abs(input2) > Math.pow(2, 32)) {
      received = addNumericalSeparator2(String(input2));
    } else if (typeof input2 === "bigint") {
      received = String(input2);
      if (input2 > Math.pow(BigInt(2), BigInt(32)) || input2 < -Math.pow(BigInt(2), BigInt(32))) {
        received = addNumericalSeparator2(received);
      }
      received += "n";
    }
    msg += " It must be " + range + ". Received " + received;
    return msg;
  }, RangeError);
  function addNumericalSeparator2(val) {
    var res = "";
    var i2 = val.length;
    var start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = "_" + val.slice(i2 - 3, i2) + res;
    }
    return "" + val.slice(0, i2) + res;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min2, max, buf, offset, byteLength2) {
    if (value > max || value < min2) {
      var n5 = typeof min2 === "bigint" ? "n" : "";
      var range;
      if (byteLength2 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range = ">= 0" + n5 + " and < 2" + n5 + " ** " + (byteLength2 + 1) * 8 + n5;
        } else {
          range = ">= -(2" + n5 + " ** " + ((byteLength2 + 1) * 8 - 1) + n5 + ") and < 2 ** " + ((byteLength2 + 1) * 8 - 1) + n5;
        }
      } else {
        range = ">= " + min2 + n5 + " and <= " + max + n5;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(type || "offset", ">= " + (type ? 1 : 0) + " and <= " + length, value);
  }
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) {
      return "";
    }
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes7(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes4 = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) {
              bytes4.push(239, 191, 189);
            }
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1) {
              bytes4.push(239, 191, 189);
            }
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) {
            bytes4.push(239, 191, 189);
          }
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) {
          bytes4.push(239, 191, 189);
        }
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) {
          break;
        }
        bytes4.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) {
          break;
        }
        bytes4.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) {
          break;
        }
        bytes4.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) {
          break;
        }
        bytes4.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes4;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0) {
        break;
      }
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    var i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length) {
        break;
      }
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet3 = "0123456789abcdef";
    var table = new Array(256);
    for (var i2 = 0; i2 < 16; ++i2) {
      var i16 = i2 * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet3[i2] + alphabet3[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$1;
}
var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, SlowBuffer, INSPECT_MAX_BYTES, kMaxLength, FastBuffer;
var init_buffer = __esm({
  "../../../../../../node_modules/wasmedge_quickjs/modules/buffer.js"() {
    exports$3 = {};
    _dewExec$2 = false;
    exports$2 = {};
    _dewExec$1 = false;
    exports$1 = {};
    _dewExec = false;
    exports = dew();
    exports["Buffer"];
    exports["SlowBuffer"];
    exports["INSPECT_MAX_BYTES"];
    exports["kMaxLength"];
    Buffer2 = exports.Buffer;
    SlowBuffer = exports.SlowBuffer;
    INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
    kMaxLength = exports.kMaxLength;
    globalThis.Buffer = Buffer2;
    FastBuffer = class extends Uint8Array {
      // Using an explicit constructor here is necessary to avoid relying on
      // `Array.prototype[Symbol.iterator]`, which can be mutated by users.
      // eslint-disable-next-line no-useless-constructor
      constructor(bufferOrLength, byteOffset, length) {
        super(bufferOrLength, byteOffset, length);
      }
    };
  }
});

// node_modules/azle/node_modules/intl/lib/core.js
var require_core = __commonJS({
  "node_modules/azle/node_modules/intl/lib/core.js"(exports4, module) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    var jsx = function() {
      var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
      return function createRawReactElement(type, props, key, children) {
        var defaultProps = type && type.defaultProps;
        var childrenLength = arguments.length - 3;
        if (!props && childrenLength !== 0) {
          props = {};
        }
        if (props && defaultProps) {
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
        } else if (!props) {
          props = defaultProps || {};
        }
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i2 = 0; i2 < childrenLength; i2++) {
            childArray[i2] = arguments[i2 + 3];
          }
          props.children = childArray;
        }
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key: key === void 0 ? null : "" + key,
          ref: null,
          props,
          _owner: null
        };
      };
    }();
    var asyncToGenerator = function(fn) {
      return function() {
        var gen3 = fn.apply(this, arguments);
        return new Promise(function(resolve3, reject) {
          function step(key, arg) {
            try {
              var info = gen3[key](arg);
              var value = info.value;
            } catch (error2) {
              reject(error2);
              return;
            }
            if (info.done) {
              resolve3(value);
            } else {
              return Promise.resolve(value).then(function(value2) {
                return step("next", value2);
              }, function(err3) {
                return step("throw", err3);
              });
            }
          }
          return step("next");
        });
      };
    };
    var classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var createClass = /* @__PURE__ */ function() {
      function defineProperties3(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties3(Constructor.prototype, protoProps);
        if (staticProps) defineProperties3(Constructor, staticProps);
        return Constructor;
      };
    }();
    var defineEnumerableProperties = function(obj, descs) {
      for (var key in descs) {
        var desc = descs[key];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, key, desc);
      }
      return obj;
    };
    var defaults = function(obj, defaults2) {
      var keys = Object.getOwnPropertyNames(defaults2);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        var value = Object.getOwnPropertyDescriptor(defaults2, key);
        if (value && value.configurable && obj[key] === void 0) {
          Object.defineProperty(obj, key, value);
        }
      }
      return obj;
    };
    var defineProperty$1 = function(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    };
    var _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var get = function get2(object3, property, receiver) {
      if (object3 === null) object3 = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object3, property);
      if (desc === void 0) {
        var parent = Object.getPrototypeOf(object3);
        if (parent === null) {
          return void 0;
        } else {
          return get2(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === void 0) {
          return void 0;
        }
        return getter.call(receiver);
      }
    };
    var inherits2 = function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };
    var _instanceof = function(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return right[Symbol.hasInstance](left);
      } else {
        return left instanceof right;
      }
    };
    var interopRequireDefault = function(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    };
    var interopRequireWildcard = function(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    };
    var newArrowCheck = function(innerThis, boundThis) {
      if (innerThis !== boundThis) {
        throw new TypeError("Cannot instantiate an arrow function");
      }
    };
    var objectDestructuringEmpty = function(obj) {
      if (obj == null) throw new TypeError("Cannot destructure undefined");
    };
    var objectWithoutProperties = function(obj, keys) {
      var target = {};
      for (var i2 in obj) {
        if (keys.indexOf(i2) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i2)) continue;
        target[i2] = obj[i2];
      }
      return target;
    };
    var possibleConstructorReturn = function(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    };
    var selfGlobal = typeof global === "undefined" ? self : global;
    var set = function set2(object3, property, value, receiver) {
      var desc = Object.getOwnPropertyDescriptor(object3, property);
      if (desc === void 0) {
        var parent = Object.getPrototypeOf(object3);
        if (parent !== null) {
          set2(parent, property, value, receiver);
        }
      } else if ("value" in desc && desc.writable) {
        desc.value = value;
      } else {
        var setter = desc.set;
        if (setter !== void 0) {
          setter.call(receiver, value);
        }
      }
      return value;
    };
    var slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i2) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2) break;
          }
        } catch (err3) {
          _d = true;
          _e = err3;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i2) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i2);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var slicedToArrayLoose = function(arr, i2) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        var _arr = [];
        for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {
          _arr.push(_step.value);
          if (i2 && _arr.length === i2) break;
        }
        return _arr;
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
    var taggedTemplateLiteral = function(strings2, raw) {
      return Object.freeze(Object.defineProperties(strings2, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    };
    var taggedTemplateLiteralLoose = function(strings2, raw) {
      strings2.raw = raw;
      return strings2;
    };
    var temporalRef = function(val, name, undef) {
      if (val === undef) {
        throw new ReferenceError(name + " is not defined - temporal dead zone");
      } else {
        return val;
      }
    };
    var temporalUndefined = {};
    var toArray = function(arr) {
      return Array.isArray(arr) ? arr : Array.from(arr);
    };
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) arr2[i2] = arr[i2];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var babelHelpers$1 = Object.freeze({
      jsx,
      asyncToGenerator,
      classCallCheck,
      createClass,
      defineEnumerableProperties,
      defaults,
      defineProperty: defineProperty$1,
      get,
      inherits: inherits2,
      interopRequireDefault,
      interopRequireWildcard,
      newArrowCheck,
      objectDestructuringEmpty,
      objectWithoutProperties,
      possibleConstructorReturn,
      selfGlobal,
      set,
      slicedToArray,
      slicedToArrayLoose,
      taggedTemplateLiteral,
      taggedTemplateLiteralLoose,
      temporalRef,
      temporalUndefined,
      toArray,
      toConsumableArray,
      typeof: _typeof,
      extends: _extends,
      instanceof: _instanceof
    });
    var realDefineProp = function() {
      var sentinel = function sentinel2() {
      };
      try {
        Object.defineProperty(sentinel, "a", {
          get: function get2() {
            return 1;
          }
        });
        Object.defineProperty(sentinel, "prototype", { writable: false });
        return sentinel.a === 1 && sentinel.prototype instanceof Object;
      } catch (e3) {
        return false;
      }
    }();
    var es3 = !realDefineProp && !Object.prototype.__defineGetter__;
    var hop = Object.prototype.hasOwnProperty;
    var defineProperty = realDefineProp ? Object.defineProperty : function(obj, name, desc) {
      if ("get" in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);
      else if (!hop.call(obj, name) || "value" in desc) obj[name] = desc.value;
    };
    var arrIndexOf = Array.prototype.indexOf || function(search) {
      var t2 = this;
      if (!t2.length) return -1;
      for (var i2 = arguments[1] || 0, max = t2.length; i2 < max; i2++) {
        if (t2[i2] === search) return i2;
      }
      return -1;
    };
    var objCreate = Object.create || function(proto, props) {
      var obj = void 0;
      function F2() {
      }
      F2.prototype = proto;
      obj = new F2();
      for (var k in props) {
        if (hop.call(props, k)) defineProperty(obj, k, props[k]);
      }
      return obj;
    };
    var arrSlice = Array.prototype.slice;
    var arrConcat = Array.prototype.concat;
    var arrPush = Array.prototype.push;
    var arrJoin = Array.prototype.join;
    var arrShift = Array.prototype.shift;
    var fnBind = Function.prototype.bind || function(thisObj) {
      var fn = this, args2 = arrSlice.call(arguments, 1);
      if (fn.length === 1) {
        return function() {
          return fn.apply(thisObj, arrConcat.call(args2, arrSlice.call(arguments)));
        };
      }
      return function() {
        return fn.apply(thisObj, arrConcat.call(args2, arrSlice.call(arguments)));
      };
    };
    var internals = objCreate(null);
    var secret = Math.random();
    function log10Floor(n5) {
      if (typeof Math.log10 === "function") return Math.floor(Math.log10(n5));
      var x = Math.round(Math.log(n5) * Math.LOG10E);
      return x - (Number("1e" + x) > n5);
    }
    function Record3(obj) {
      for (var k in obj) {
        if (obj instanceof Record3 || hop.call(obj, k)) defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });
      }
    }
    Record3.prototype = objCreate(null);
    function List() {
      defineProperty(this, "length", { writable: true, value: 0 });
      if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));
    }
    List.prototype = objCreate(null);
    function createRegExpRestore() {
      if (internals.disableRegExpRestore) {
        return function() {
        };
      }
      var regExpCache = {
        lastMatch: RegExp.lastMatch || "",
        leftContext: RegExp.leftContext,
        multiline: RegExp.multiline,
        input: RegExp.input
      }, has = false;
      for (var i2 = 1; i2 <= 9; i2++) {
        has = (regExpCache["$" + i2] = RegExp["$" + i2]) || has;
      }
      return function() {
        var esc = /[.?*+^$[\]\\(){}|-]/g, lm = regExpCache.lastMatch.replace(esc, "\\$&"), reg = new List();
        if (has) {
          for (var _i = 1; _i <= 9; _i++) {
            var m2 = regExpCache["$" + _i];
            if (!m2) lm = "()" + lm;
            else {
              m2 = m2.replace(esc, "\\$&");
              lm = lm.replace(m2, "(" + m2 + ")");
            }
            arrPush.call(reg, lm.slice(0, lm.indexOf("(") + 1));
            lm = lm.slice(lm.indexOf("(") + 1);
          }
        }
        var exprStr = arrJoin.call(reg, "") + lm;
        exprStr = exprStr.replace(/(\\\(|\\\)|[^()])+/g, function(match) {
          return "[\\s\\S]{" + match.replace("\\", "").length + "}";
        });
        var expr = new RegExp(exprStr, regExpCache.multiline ? "gm" : "g");
        expr.lastIndex = regExpCache.leftContext.length;
        expr.exec(regExpCache.input);
      };
    }
    function toObject3(arg) {
      if (arg === null) throw new TypeError("Cannot convert null or undefined to object");
      if ((typeof arg === "undefined" ? "undefined" : babelHelpers$1["typeof"](arg)) === "object") return arg;
      return Object(arg);
    }
    function toNumber3(arg) {
      if (typeof arg === "number") return arg;
      return Number(arg);
    }
    function toInteger(arg) {
      var number3 = toNumber3(arg);
      if (isNaN(number3)) return 0;
      if (number3 === 0 || number3 === -0 || number3 === Infinity || number3 === -Infinity) return number3;
      if (number3 < 0) return Math.floor(Math.abs(number3)) * -1;
      return Math.floor(Math.abs(number3));
    }
    function toLength(arg) {
      var len = toInteger(arg);
      if (len <= 0) return 0;
      if (len === Infinity) return Math.pow(2, 53) - 1;
      return Math.min(len, Math.pow(2, 53) - 1);
    }
    function getInternalProperties(obj) {
      if (hop.call(obj, "__getInternalProperties")) return obj.__getInternalProperties(secret);
      return objCreate(null);
    }
    var extlang = "[a-z]{3}(?:-[a-z]{3}){0,2}";
    var language = "(?:[a-z]{2,3}(?:-" + extlang + ")?|[a-z]{4}|[a-z]{5,8})";
    var script = "[a-z]{4}";
    var region = "(?:[a-z]{2}|\\d{3})";
    var variant = "(?:[a-z0-9]{5,8}|\\d[a-z0-9]{3})";
    var singleton = "[0-9a-wy-z]";
    var extension = singleton + "(?:-[a-z0-9]{2,8})+";
    var privateuse = "x(?:-[a-z0-9]{1,8})+";
    var irregular = "(?:en-GB-oed|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)|sgn-(?:BE-FR|BE-NL|CH-DE))";
    var regular = "(?:art-lojban|cel-gaulish|no-bok|no-nyn|zh-(?:guoyu|hakka|min|min-nan|xiang))";
    var grandfathered = "(?:" + irregular + "|" + regular + ")";
    var langtag = language + "(?:-" + script + ")?(?:-" + region + ")?(?:-" + variant + ")*(?:-" + extension + ")*(?:-" + privateuse + ")?";
    var expBCP47Syntax = RegExp("^(?:" + langtag + "|" + privateuse + "|" + grandfathered + ")$", "i");
    var expVariantDupes = RegExp("^(?!x).*?-(" + variant + ")-(?:\\w{4,8}-(?!x-))*\\1\\b", "i");
    var expSingletonDupes = RegExp("^(?!x).*?-(" + singleton + ")-(?:\\w+-(?!x-))*\\1\\b", "i");
    var expExtSequences = RegExp("-" + extension, "ig");
    var defaultLocale = void 0;
    function setDefaultLocale(locale) {
      defaultLocale = locale;
    }
    var redundantTags = {
      tags: {
        "art-lojban": "jbo",
        "i-ami": "ami",
        "i-bnn": "bnn",
        "i-hak": "hak",
        "i-klingon": "tlh",
        "i-lux": "lb",
        "i-navajo": "nv",
        "i-pwn": "pwn",
        "i-tao": "tao",
        "i-tay": "tay",
        "i-tsu": "tsu",
        "no-bok": "nb",
        "no-nyn": "nn",
        "sgn-BE-FR": "sfb",
        "sgn-BE-NL": "vgt",
        "sgn-CH-DE": "sgg",
        "zh-guoyu": "cmn",
        "zh-hakka": "hak",
        "zh-min-nan": "nan",
        "zh-xiang": "hsn",
        "sgn-BR": "bzs",
        "sgn-CO": "csn",
        "sgn-DE": "gsg",
        "sgn-DK": "dsl",
        "sgn-ES": "ssp",
        "sgn-FR": "fsl",
        "sgn-GB": "bfi",
        "sgn-GR": "gss",
        "sgn-IE": "isg",
        "sgn-IT": "ise",
        "sgn-JP": "jsl",
        "sgn-MX": "mfs",
        "sgn-NI": "ncs",
        "sgn-NL": "dse",
        "sgn-NO": "nsl",
        "sgn-PT": "psr",
        "sgn-SE": "swl",
        "sgn-US": "ase",
        "sgn-ZA": "sfs",
        "zh-cmn": "cmn",
        "zh-cmn-Hans": "cmn-Hans",
        "zh-cmn-Hant": "cmn-Hant",
        "zh-gan": "gan",
        "zh-wuu": "wuu",
        "zh-yue": "yue"
      },
      subtags: {
        BU: "MM",
        DD: "DE",
        FX: "FR",
        TP: "TL",
        YD: "YE",
        ZR: "CD",
        heploc: "alalc97",
        "in": "id",
        iw: "he",
        ji: "yi",
        jw: "jv",
        mo: "ro",
        ayx: "nun",
        bjd: "drl",
        ccq: "rki",
        cjr: "mom",
        cka: "cmr",
        cmk: "xch",
        drh: "khk",
        drw: "prs",
        gav: "dev",
        hrr: "jal",
        ibi: "opa",
        kgh: "kml",
        lcq: "ppr",
        mst: "mry",
        myt: "mry",
        sca: "hle",
        tie: "ras",
        tkk: "twm",
        tlw: "weo",
        tnf: "prs",
        ybd: "rki",
        yma: "lrr"
      },
      extLang: {
        aao: ["aao", "ar"],
        abh: ["abh", "ar"],
        abv: ["abv", "ar"],
        acm: ["acm", "ar"],
        acq: ["acq", "ar"],
        acw: ["acw", "ar"],
        acx: ["acx", "ar"],
        acy: ["acy", "ar"],
        adf: ["adf", "ar"],
        ads: ["ads", "sgn"],
        aeb: ["aeb", "ar"],
        aec: ["aec", "ar"],
        aed: ["aed", "sgn"],
        aen: ["aen", "sgn"],
        afb: ["afb", "ar"],
        afg: ["afg", "sgn"],
        ajp: ["ajp", "ar"],
        apc: ["apc", "ar"],
        apd: ["apd", "ar"],
        arb: ["arb", "ar"],
        arq: ["arq", "ar"],
        ars: ["ars", "ar"],
        ary: ["ary", "ar"],
        arz: ["arz", "ar"],
        ase: ["ase", "sgn"],
        asf: ["asf", "sgn"],
        asp: ["asp", "sgn"],
        asq: ["asq", "sgn"],
        asw: ["asw", "sgn"],
        auz: ["auz", "ar"],
        avl: ["avl", "ar"],
        ayh: ["ayh", "ar"],
        ayl: ["ayl", "ar"],
        ayn: ["ayn", "ar"],
        ayp: ["ayp", "ar"],
        bbz: ["bbz", "ar"],
        bfi: ["bfi", "sgn"],
        bfk: ["bfk", "sgn"],
        bjn: ["bjn", "ms"],
        bog: ["bog", "sgn"],
        bqn: ["bqn", "sgn"],
        bqy: ["bqy", "sgn"],
        btj: ["btj", "ms"],
        bve: ["bve", "ms"],
        bvl: ["bvl", "sgn"],
        bvu: ["bvu", "ms"],
        bzs: ["bzs", "sgn"],
        cdo: ["cdo", "zh"],
        cds: ["cds", "sgn"],
        cjy: ["cjy", "zh"],
        cmn: ["cmn", "zh"],
        coa: ["coa", "ms"],
        cpx: ["cpx", "zh"],
        csc: ["csc", "sgn"],
        csd: ["csd", "sgn"],
        cse: ["cse", "sgn"],
        csf: ["csf", "sgn"],
        csg: ["csg", "sgn"],
        csl: ["csl", "sgn"],
        csn: ["csn", "sgn"],
        csq: ["csq", "sgn"],
        csr: ["csr", "sgn"],
        czh: ["czh", "zh"],
        czo: ["czo", "zh"],
        doq: ["doq", "sgn"],
        dse: ["dse", "sgn"],
        dsl: ["dsl", "sgn"],
        dup: ["dup", "ms"],
        ecs: ["ecs", "sgn"],
        esl: ["esl", "sgn"],
        esn: ["esn", "sgn"],
        eso: ["eso", "sgn"],
        eth: ["eth", "sgn"],
        fcs: ["fcs", "sgn"],
        fse: ["fse", "sgn"],
        fsl: ["fsl", "sgn"],
        fss: ["fss", "sgn"],
        gan: ["gan", "zh"],
        gds: ["gds", "sgn"],
        gom: ["gom", "kok"],
        gse: ["gse", "sgn"],
        gsg: ["gsg", "sgn"],
        gsm: ["gsm", "sgn"],
        gss: ["gss", "sgn"],
        gus: ["gus", "sgn"],
        hab: ["hab", "sgn"],
        haf: ["haf", "sgn"],
        hak: ["hak", "zh"],
        hds: ["hds", "sgn"],
        hji: ["hji", "ms"],
        hks: ["hks", "sgn"],
        hos: ["hos", "sgn"],
        hps: ["hps", "sgn"],
        hsh: ["hsh", "sgn"],
        hsl: ["hsl", "sgn"],
        hsn: ["hsn", "zh"],
        icl: ["icl", "sgn"],
        ils: ["ils", "sgn"],
        inl: ["inl", "sgn"],
        ins: ["ins", "sgn"],
        ise: ["ise", "sgn"],
        isg: ["isg", "sgn"],
        isr: ["isr", "sgn"],
        jak: ["jak", "ms"],
        jax: ["jax", "ms"],
        jcs: ["jcs", "sgn"],
        jhs: ["jhs", "sgn"],
        jls: ["jls", "sgn"],
        jos: ["jos", "sgn"],
        jsl: ["jsl", "sgn"],
        jus: ["jus", "sgn"],
        kgi: ["kgi", "sgn"],
        knn: ["knn", "kok"],
        kvb: ["kvb", "ms"],
        kvk: ["kvk", "sgn"],
        kvr: ["kvr", "ms"],
        kxd: ["kxd", "ms"],
        lbs: ["lbs", "sgn"],
        lce: ["lce", "ms"],
        lcf: ["lcf", "ms"],
        liw: ["liw", "ms"],
        lls: ["lls", "sgn"],
        lsg: ["lsg", "sgn"],
        lsl: ["lsl", "sgn"],
        lso: ["lso", "sgn"],
        lsp: ["lsp", "sgn"],
        lst: ["lst", "sgn"],
        lsy: ["lsy", "sgn"],
        ltg: ["ltg", "lv"],
        lvs: ["lvs", "lv"],
        lzh: ["lzh", "zh"],
        max: ["max", "ms"],
        mdl: ["mdl", "sgn"],
        meo: ["meo", "ms"],
        mfa: ["mfa", "ms"],
        mfb: ["mfb", "ms"],
        mfs: ["mfs", "sgn"],
        min: ["min", "ms"],
        mnp: ["mnp", "zh"],
        mqg: ["mqg", "ms"],
        mre: ["mre", "sgn"],
        msd: ["msd", "sgn"],
        msi: ["msi", "ms"],
        msr: ["msr", "sgn"],
        mui: ["mui", "ms"],
        mzc: ["mzc", "sgn"],
        mzg: ["mzg", "sgn"],
        mzy: ["mzy", "sgn"],
        nan: ["nan", "zh"],
        nbs: ["nbs", "sgn"],
        ncs: ["ncs", "sgn"],
        nsi: ["nsi", "sgn"],
        nsl: ["nsl", "sgn"],
        nsp: ["nsp", "sgn"],
        nsr: ["nsr", "sgn"],
        nzs: ["nzs", "sgn"],
        okl: ["okl", "sgn"],
        orn: ["orn", "ms"],
        ors: ["ors", "ms"],
        pel: ["pel", "ms"],
        pga: ["pga", "ar"],
        pks: ["pks", "sgn"],
        prl: ["prl", "sgn"],
        prz: ["prz", "sgn"],
        psc: ["psc", "sgn"],
        psd: ["psd", "sgn"],
        pse: ["pse", "ms"],
        psg: ["psg", "sgn"],
        psl: ["psl", "sgn"],
        pso: ["pso", "sgn"],
        psp: ["psp", "sgn"],
        psr: ["psr", "sgn"],
        pys: ["pys", "sgn"],
        rms: ["rms", "sgn"],
        rsi: ["rsi", "sgn"],
        rsl: ["rsl", "sgn"],
        sdl: ["sdl", "sgn"],
        sfb: ["sfb", "sgn"],
        sfs: ["sfs", "sgn"],
        sgg: ["sgg", "sgn"],
        sgx: ["sgx", "sgn"],
        shu: ["shu", "ar"],
        slf: ["slf", "sgn"],
        sls: ["sls", "sgn"],
        sqk: ["sqk", "sgn"],
        sqs: ["sqs", "sgn"],
        ssh: ["ssh", "ar"],
        ssp: ["ssp", "sgn"],
        ssr: ["ssr", "sgn"],
        svk: ["svk", "sgn"],
        swc: ["swc", "sw"],
        swh: ["swh", "sw"],
        swl: ["swl", "sgn"],
        syy: ["syy", "sgn"],
        tmw: ["tmw", "ms"],
        tse: ["tse", "sgn"],
        tsm: ["tsm", "sgn"],
        tsq: ["tsq", "sgn"],
        tss: ["tss", "sgn"],
        tsy: ["tsy", "sgn"],
        tza: ["tza", "sgn"],
        ugn: ["ugn", "sgn"],
        ugy: ["ugy", "sgn"],
        ukl: ["ukl", "sgn"],
        uks: ["uks", "sgn"],
        urk: ["urk", "ms"],
        uzn: ["uzn", "uz"],
        uzs: ["uzs", "uz"],
        vgt: ["vgt", "sgn"],
        vkk: ["vkk", "ms"],
        vkt: ["vkt", "ms"],
        vsi: ["vsi", "sgn"],
        vsl: ["vsl", "sgn"],
        vsv: ["vsv", "sgn"],
        wuu: ["wuu", "zh"],
        xki: ["xki", "sgn"],
        xml: ["xml", "sgn"],
        xmm: ["xmm", "ms"],
        xms: ["xms", "sgn"],
        yds: ["yds", "sgn"],
        ysl: ["ysl", "sgn"],
        yue: ["yue", "zh"],
        zib: ["zib", "sgn"],
        zlm: ["zlm", "ms"],
        zmi: ["zmi", "ms"],
        zsl: ["zsl", "sgn"],
        zsm: ["zsm", "ms"]
      }
    };
    function toLatinUpperCase(str) {
      var i2 = str.length;
      while (i2--) {
        var ch = str.charAt(i2);
        if (ch >= "a" && ch <= "z") str = str.slice(0, i2) + ch.toUpperCase() + str.slice(i2 + 1);
      }
      return str;
    }
    function IsStructurallyValidLanguageTag(locale) {
      if (!expBCP47Syntax.test(locale)) return false;
      if (expVariantDupes.test(locale)) return false;
      if (expSingletonDupes.test(locale)) return false;
      return true;
    }
    function CanonicalizeLanguageTag(locale) {
      var match = void 0, parts = void 0;
      locale = locale.toLowerCase();
      parts = locale.split("-");
      for (var i2 = 1, max = parts.length; i2 < max; i2++) {
        if (parts[i2].length === 2) parts[i2] = parts[i2].toUpperCase();
        else if (parts[i2].length === 4) parts[i2] = parts[i2].charAt(0).toUpperCase() + parts[i2].slice(1);
        else if (parts[i2].length === 1 && parts[i2] !== "x") break;
      }
      locale = arrJoin.call(parts, "-");
      if ((match = locale.match(expExtSequences)) && match.length > 1) {
        match.sort();
        locale = locale.replace(RegExp("(?:" + expExtSequences.source + ")+", "i"), arrJoin.call(match, ""));
      }
      if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale];
      parts = locale.split("-");
      for (var _i = 1, _max = parts.length; _i < _max; _i++) {
        if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];
        else if (hop.call(redundantTags.extLang, parts[_i])) {
          parts[_i] = redundantTags.extLang[parts[_i]][0];
          if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {
            parts = arrSlice.call(parts, _i++);
            _max -= 1;
          }
        }
      }
      return arrJoin.call(parts, "-");
    }
    function DefaultLocale() {
      return defaultLocale;
    }
    var expCurrencyCode = /^[A-Z]{3}$/;
    function IsWellFormedCurrencyCode(currency) {
      var c2 = String(currency);
      var normalized = toLatinUpperCase(c2);
      if (expCurrencyCode.test(normalized) === false) return false;
      return true;
    }
    var expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi;
    function CanonicalizeLocaleList(locales) {
      if (locales === void 0) return new List();
      var seen = new List();
      locales = typeof locales === "string" ? [locales] : locales;
      var O2 = toObject3(locales);
      var len = toLength(O2.length);
      var k = 0;
      while (k < len) {
        var Pk = String(k);
        var kPresent = Pk in O2;
        if (kPresent) {
          var kValue = O2[Pk];
          if (kValue === null || typeof kValue !== "string" && (typeof kValue === "undefined" ? "undefined" : babelHelpers$1["typeof"](kValue)) !== "object") throw new TypeError("String or Object type expected");
          var tag = String(kValue);
          if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError("'" + tag + "' is not a structurally valid language tag");
          tag = CanonicalizeLanguageTag(tag);
          if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);
        }
        k++;
      }
      return seen;
    }
    function BestAvailableLocale(availableLocales, locale) {
      var candidate = locale;
      while (candidate) {
        if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate;
        var pos = candidate.lastIndexOf("-");
        if (pos < 0) return;
        if (pos >= 2 && candidate.charAt(pos - 2) === "-") pos -= 2;
        candidate = candidate.substring(0, pos);
      }
    }
    function LookupMatcher(availableLocales, requestedLocales) {
      var i2 = 0;
      var len = requestedLocales.length;
      var availableLocale = void 0;
      var locale = void 0, noExtensionsLocale = void 0;
      while (i2 < len && !availableLocale) {
        locale = requestedLocales[i2];
        noExtensionsLocale = String(locale).replace(expUnicodeExSeq, "");
        availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);
        i2++;
      }
      var result2 = new Record3();
      if (availableLocale !== void 0) {
        result2["[[locale]]"] = availableLocale;
        if (String(locale) !== String(noExtensionsLocale)) {
          var extension2 = locale.match(expUnicodeExSeq)[0];
          var extensionIndex = locale.indexOf("-u-");
          result2["[[extension]]"] = extension2;
          result2["[[extensionIndex]]"] = extensionIndex;
        }
      } else
        result2["[[locale]]"] = DefaultLocale();
      return result2;
    }
    function BestFitMatcher(availableLocales, requestedLocales) {
      return LookupMatcher(availableLocales, requestedLocales);
    }
    function ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {
      if (availableLocales.length === 0) {
        throw new ReferenceError("No locale data has been provided for this object yet.");
      }
      var matcher = options["[[localeMatcher]]"];
      var r3 = void 0;
      if (matcher === "lookup")
        r3 = LookupMatcher(availableLocales, requestedLocales);
      else
        r3 = BestFitMatcher(availableLocales, requestedLocales);
      var foundLocale = r3["[[locale]]"];
      var extensionSubtags = void 0, extensionSubtagsLength = void 0;
      if (hop.call(r3, "[[extension]]")) {
        var extension2 = r3["[[extension]]"];
        var split5 = String.prototype.split;
        extensionSubtags = split5.call(extension2, "-");
        extensionSubtagsLength = extensionSubtags.length;
      }
      var result2 = new Record3();
      result2["[[dataLocale]]"] = foundLocale;
      var supportedExtension = "-u";
      var i2 = 0;
      var len = relevantExtensionKeys.length;
      while (i2 < len) {
        var key = relevantExtensionKeys[i2];
        var foundLocaleData = localeData[foundLocale];
        var keyLocaleData = foundLocaleData[key];
        var value = keyLocaleData["0"];
        var supportedExtensionAddition = "";
        var indexOf = arrIndexOf;
        if (extensionSubtags !== void 0) {
          var keyPos = indexOf.call(extensionSubtags, key);
          if (keyPos !== -1) {
            if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {
              var requestedValue = extensionSubtags[keyPos + 1];
              var valuePos = indexOf.call(keyLocaleData, requestedValue);
              if (valuePos !== -1) {
                value = requestedValue, // ii. Let supportedExtensionAddition be the
                //     concatenation of "-", key, "-", and value.
                supportedExtensionAddition = "-" + key + "-" + value;
              }
            } else {
              var _valuePos = indexOf(keyLocaleData, "true");
              if (_valuePos !== -1)
                value = "true";
            }
          }
        }
        if (hop.call(options, "[[" + key + "]]")) {
          var optionsValue = options["[[" + key + "]]"];
          if (indexOf.call(keyLocaleData, optionsValue) !== -1) {
            if (optionsValue !== value) {
              value = optionsValue;
              supportedExtensionAddition = "";
            }
          }
        }
        result2["[[" + key + "]]"] = value;
        supportedExtension += supportedExtensionAddition;
        i2++;
      }
      if (supportedExtension.length > 2) {
        var privateIndex = foundLocale.indexOf("-x-");
        if (privateIndex === -1) {
          foundLocale = foundLocale + supportedExtension;
        } else {
          var preExtension = foundLocale.substring(0, privateIndex);
          var postExtension = foundLocale.substring(privateIndex);
          foundLocale = preExtension + supportedExtension + postExtension;
        }
        foundLocale = CanonicalizeLanguageTag(foundLocale);
      }
      result2["[[locale]]"] = foundLocale;
      return result2;
    }
    function LookupSupportedLocales(availableLocales, requestedLocales) {
      var len = requestedLocales.length;
      var subset = new List();
      var k = 0;
      while (k < len) {
        var locale = requestedLocales[k];
        var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, "");
        var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);
        if (availableLocale !== void 0) arrPush.call(subset, locale);
        k++;
      }
      var subsetArray = arrSlice.call(subset);
      return subsetArray;
    }
    function BestFitSupportedLocales(availableLocales, requestedLocales) {
      return LookupSupportedLocales(availableLocales, requestedLocales);
    }
    function SupportedLocales(availableLocales, requestedLocales, options) {
      var matcher = void 0, subset = void 0;
      if (options !== void 0) {
        options = new Record3(toObject3(options));
        matcher = options.localeMatcher;
        if (matcher !== void 0) {
          matcher = String(matcher);
          if (matcher !== "lookup" && matcher !== "best fit") throw new RangeError('matcher should be "lookup" or "best fit"');
        }
      }
      if (matcher === void 0 || matcher === "best fit")
        subset = BestFitSupportedLocales(availableLocales, requestedLocales);
      else
        subset = LookupSupportedLocales(availableLocales, requestedLocales);
      for (var P2 in subset) {
        if (!hop.call(subset, P2)) continue;
        defineProperty(subset, P2, {
          writable: false,
          configurable: false,
          value: subset[P2]
        });
      }
      defineProperty(subset, "length", { writable: false });
      return subset;
    }
    function GetOption(options, property, type, values, fallback) {
      var value = options[property];
      if (value !== void 0) {
        value = type === "boolean" ? Boolean(value) : type === "string" ? String(value) : value;
        if (values !== void 0) {
          if (arrIndexOf.call(values, value) === -1) throw new RangeError("'" + value + "' is not an allowed value for `" + property + "`");
        }
        return value;
      }
      return fallback;
    }
    function GetNumberOption(options, property, minimum, maximum, fallback) {
      var value = options[property];
      if (value !== void 0) {
        value = Number(value);
        if (isNaN(value) || value < minimum || value > maximum) throw new RangeError("Value is not a number or outside accepted range");
        return Math.floor(value);
      }
      return fallback;
    }
    var Intl = {};
    function getCanonicalLocales(locales) {
      var ll = CanonicalizeLocaleList(locales);
      {
        var result2 = [];
        var len = ll.length;
        var k = 0;
        while (k < len) {
          result2[k] = ll[k];
          k++;
        }
        return result2;
      }
    }
    Object.defineProperty(Intl, "getCanonicalLocales", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: getCanonicalLocales
    });
    var currencyMinorUnits = {
      BHD: 3,
      BYR: 0,
      XOF: 0,
      BIF: 0,
      XAF: 0,
      CLF: 4,
      CLP: 0,
      KMF: 0,
      DJF: 0,
      XPF: 0,
      GNF: 0,
      ISK: 0,
      IQD: 3,
      JPY: 0,
      JOD: 3,
      KRW: 0,
      KWD: 3,
      LYD: 3,
      OMR: 3,
      PYG: 0,
      RWF: 0,
      TND: 3,
      UGX: 0,
      UYI: 0,
      VUV: 0,
      VND: 0
    };
    function NumberFormatConstructor() {
      var locales = arguments[0];
      var options = arguments[1];
      if (!this || this === Intl) {
        return new Intl.NumberFormat(locales, options);
      }
      return InitializeNumberFormat(toObject3(this), locales, options);
    }
    defineProperty(Intl, "NumberFormat", {
      configurable: true,
      writable: true,
      value: NumberFormatConstructor
    });
    defineProperty(Intl.NumberFormat, "prototype", {
      writable: false
    });
    function InitializeNumberFormat(numberFormat, locales, options) {
      var internal5 = getInternalProperties(numberFormat);
      var regexpRestore = createRegExpRestore();
      if (internal5["[[initializedIntlObject]]"] === true) throw new TypeError("`this` object has already been initialized as an Intl object");
      defineProperty(numberFormat, "__getInternalProperties", {
        value: function value() {
          if (arguments[0] === secret) return internal5;
        }
      });
      internal5["[[initializedIntlObject]]"] = true;
      var requestedLocales = CanonicalizeLocaleList(locales);
      if (options === void 0)
        options = {};
      else
        options = toObject3(options);
      var opt = new Record3(), matcher = GetOption(options, "localeMatcher", "string", new List("lookup", "best fit"), "best fit");
      opt["[[localeMatcher]]"] = matcher;
      var localeData = internals.NumberFormat["[[localeData]]"];
      var r3 = ResolveLocale(internals.NumberFormat["[[availableLocales]]"], requestedLocales, opt, internals.NumberFormat["[[relevantExtensionKeys]]"], localeData);
      internal5["[[locale]]"] = r3["[[locale]]"];
      internal5["[[numberingSystem]]"] = r3["[[nu]]"];
      internal5["[[dataLocale]]"] = r3["[[dataLocale]]"];
      var dataLocale = r3["[[dataLocale]]"];
      var s = GetOption(options, "style", "string", new List("decimal", "percent", "currency"), "decimal");
      internal5["[[style]]"] = s;
      var c2 = GetOption(options, "currency", "string");
      if (c2 !== void 0 && !IsWellFormedCurrencyCode(c2)) throw new RangeError("'" + c2 + "' is not a valid currency code");
      if (s === "currency" && c2 === void 0) throw new TypeError("Currency code is required when style is currency");
      var cDigits = void 0;
      if (s === "currency") {
        c2 = c2.toUpperCase();
        internal5["[[currency]]"] = c2;
        cDigits = CurrencyDigits(c2);
      }
      var cd = GetOption(options, "currencyDisplay", "string", new List("code", "symbol", "name"), "symbol");
      if (s === "currency") internal5["[[currencyDisplay]]"] = cd;
      var mnid = GetNumberOption(options, "minimumIntegerDigits", 1, 21, 1);
      internal5["[[minimumIntegerDigits]]"] = mnid;
      var mnfdDefault = s === "currency" ? cDigits : 0;
      var mnfd = GetNumberOption(options, "minimumFractionDigits", 0, 20, mnfdDefault);
      internal5["[[minimumFractionDigits]]"] = mnfd;
      var mxfdDefault = s === "currency" ? Math.max(mnfd, cDigits) : s === "percent" ? Math.max(mnfd, 0) : Math.max(mnfd, 3);
      var mxfd = GetNumberOption(options, "maximumFractionDigits", mnfd, 20, mxfdDefault);
      internal5["[[maximumFractionDigits]]"] = mxfd;
      var mnsd = options.minimumSignificantDigits;
      var mxsd = options.maximumSignificantDigits;
      if (mnsd !== void 0 || mxsd !== void 0) {
        mnsd = GetNumberOption(options, "minimumSignificantDigits", 1, 21, 1);
        mxsd = GetNumberOption(options, "maximumSignificantDigits", mnsd, 21, 21);
        internal5["[[minimumSignificantDigits]]"] = mnsd;
        internal5["[[maximumSignificantDigits]]"] = mxsd;
      }
      var g2 = GetOption(options, "useGrouping", "boolean", void 0, true);
      internal5["[[useGrouping]]"] = g2;
      var dataLocaleData = localeData[dataLocale];
      var patterns = dataLocaleData.patterns;
      var stylePatterns = patterns[s];
      internal5["[[positivePattern]]"] = stylePatterns.positivePattern;
      internal5["[[negativePattern]]"] = stylePatterns.negativePattern;
      internal5["[[boundFormat]]"] = void 0;
      internal5["[[initializedNumberFormat]]"] = true;
      if (es3) numberFormat.format = GetFormatNumber.call(numberFormat);
      regexpRestore();
      return numberFormat;
    }
    function CurrencyDigits(currency) {
      return currencyMinorUnits[currency] !== void 0 ? currencyMinorUnits[currency] : 2;
    }
    internals.NumberFormat = {
      "[[availableLocales]]": [],
      "[[relevantExtensionKeys]]": ["nu"],
      "[[localeData]]": {}
    };
    defineProperty(Intl.NumberFormat, "supportedLocalesOf", {
      configurable: true,
      writable: true,
      value: fnBind.call(function(locales) {
        if (!hop.call(this, "[[availableLocales]]")) throw new TypeError("supportedLocalesOf() is not a constructor");
        var regexpRestore = createRegExpRestore(), options = arguments[1], availableLocales = this["[[availableLocales]]"], requestedLocales = CanonicalizeLocaleList(locales);
        regexpRestore();
        return SupportedLocales(availableLocales, requestedLocales, options);
      }, internals.NumberFormat)
    });
    defineProperty(Intl.NumberFormat.prototype, "format", {
      configurable: true,
      get: GetFormatNumber
    });
    function GetFormatNumber() {
      var internal5 = this !== null && babelHelpers$1["typeof"](this) === "object" && getInternalProperties(this);
      if (!internal5 || !internal5["[[initializedNumberFormat]]"]) throw new TypeError("`this` value for format() is not an initialized Intl.NumberFormat object.");
      if (internal5["[[boundFormat]]"] === void 0) {
        var F2 = function F3(value) {
          return FormatNumber(
            this,
            /* x = */
            Number(value)
          );
        };
        var bf = fnBind.call(F2, this);
        internal5["[[boundFormat]]"] = bf;
      }
      return internal5["[[boundFormat]]"];
    }
    function formatToParts() {
      var value = arguments.length <= 0 || arguments[0] === void 0 ? void 0 : arguments[0];
      var internal5 = this !== null && babelHelpers$1["typeof"](this) === "object" && getInternalProperties(this);
      if (!internal5 || !internal5["[[initializedNumberFormat]]"]) throw new TypeError("`this` value for formatToParts() is not an initialized Intl.NumberFormat object.");
      var x = Number(value);
      return FormatNumberToParts(this, x);
    }
    Object.defineProperty(Intl.NumberFormat.prototype, "formatToParts", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: formatToParts
    });
    function FormatNumberToParts(numberFormat, x) {
      var parts = PartitionNumberPattern(numberFormat, x);
      var result2 = [];
      var n5 = 0;
      for (var i2 = 0; parts.length > i2; i2++) {
        var part = parts[i2];
        var O2 = {};
        O2.type = part["[[type]]"];
        O2.value = part["[[value]]"];
        result2[n5] = O2;
        n5 += 1;
      }
      return result2;
    }
    function PartitionNumberPattern(numberFormat, x) {
      var internal5 = getInternalProperties(numberFormat), locale = internal5["[[dataLocale]]"], nums = internal5["[[numberingSystem]]"], data = internals.NumberFormat["[[localeData]]"][locale], ild = data.symbols[nums] || data.symbols.latn, pattern = void 0;
      if (!isNaN(x) && x < 0) {
        x = -x;
        pattern = internal5["[[negativePattern]]"];
      } else {
        pattern = internal5["[[positivePattern]]"];
      }
      var result2 = new List();
      var beginIndex = pattern.indexOf("{", 0);
      var endIndex = 0;
      var nextIndex = 0;
      var length = pattern.length;
      while (beginIndex > -1 && beginIndex < length) {
        endIndex = pattern.indexOf("}", beginIndex);
        if (endIndex === -1) throw new Error();
        if (beginIndex > nextIndex) {
          var literal = pattern.substring(nextIndex, beginIndex);
          arrPush.call(result2, { "[[type]]": "literal", "[[value]]": literal });
        }
        var p3 = pattern.substring(beginIndex + 1, endIndex);
        if (p3 === "number") {
          if (isNaN(x)) {
            var n5 = ild.nan;
            arrPush.call(result2, { "[[type]]": "nan", "[[value]]": n5 });
          } else if (!isFinite(x)) {
            var _n = ild.infinity;
            arrPush.call(result2, { "[[type]]": "infinity", "[[value]]": _n });
          } else {
            if (internal5["[[style]]"] === "percent" && isFinite(x)) x *= 100;
            var _n2 = void 0;
            if (hop.call(internal5, "[[minimumSignificantDigits]]") && hop.call(internal5, "[[maximumSignificantDigits]]")) {
              _n2 = ToRawPrecision(x, internal5["[[minimumSignificantDigits]]"], internal5["[[maximumSignificantDigits]]"]);
            } else {
              _n2 = ToRawFixed(x, internal5["[[minimumIntegerDigits]]"], internal5["[[minimumFractionDigits]]"], internal5["[[maximumFractionDigits]]"]);
            }
            if (numSys[nums]) {
              (function() {
                var digits = numSys[nums];
                _n2 = String(_n2).replace(/\d/g, function(digit) {
                  return digits[digit];
                });
              })();
            } else _n2 = String(_n2);
            var integer = void 0;
            var fraction = void 0;
            var decimalSepIndex = _n2.indexOf(".", 0);
            if (decimalSepIndex > 0) {
              integer = _n2.substring(0, decimalSepIndex);
              fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);
            } else {
              integer = _n2;
              fraction = void 0;
            }
            if (internal5["[[useGrouping]]"] === true) {
              var groupSepSymbol = ild.group;
              var groups = [];
              var pgSize = data.patterns.primaryGroupSize || 3;
              var sgSize = data.patterns.secondaryGroupSize || pgSize;
              if (integer.length > pgSize) {
                var end = integer.length - pgSize;
                var idx = end % sgSize;
                var start = integer.slice(0, idx);
                if (start.length) arrPush.call(groups, start);
                while (idx < end) {
                  arrPush.call(groups, integer.slice(idx, idx + sgSize));
                  idx += sgSize;
                }
                arrPush.call(groups, integer.slice(end));
              } else {
                arrPush.call(groups, integer);
              }
              if (groups.length === 0) throw new Error();
              while (groups.length) {
                var integerGroup = arrShift.call(groups);
                arrPush.call(result2, { "[[type]]": "integer", "[[value]]": integerGroup });
                if (groups.length) {
                  arrPush.call(result2, { "[[type]]": "group", "[[value]]": groupSepSymbol });
                }
              }
            } else {
              arrPush.call(result2, { "[[type]]": "integer", "[[value]]": integer });
            }
            if (fraction !== void 0) {
              var decimalSepSymbol = ild.decimal;
              arrPush.call(result2, { "[[type]]": "decimal", "[[value]]": decimalSepSymbol });
              arrPush.call(result2, { "[[type]]": "fraction", "[[value]]": fraction });
            }
          }
        } else if (p3 === "plusSign") {
          var plusSignSymbol = ild.plusSign;
          arrPush.call(result2, { "[[type]]": "plusSign", "[[value]]": plusSignSymbol });
        } else if (p3 === "minusSign") {
          var minusSignSymbol = ild.minusSign;
          arrPush.call(result2, { "[[type]]": "minusSign", "[[value]]": minusSignSymbol });
        } else if (p3 === "percentSign" && internal5["[[style]]"] === "percent") {
          var percentSignSymbol = ild.percentSign;
          arrPush.call(result2, { "[[type]]": "literal", "[[value]]": percentSignSymbol });
        } else if (p3 === "currency" && internal5["[[style]]"] === "currency") {
          var currency = internal5["[[currency]]"];
          var cd = void 0;
          if (internal5["[[currencyDisplay]]"] === "code") {
            cd = currency;
          } else if (internal5["[[currencyDisplay]]"] === "symbol") {
            cd = data.currencies[currency] || currency;
          } else if (internal5["[[currencyDisplay]]"] === "name") {
            cd = currency;
          }
          arrPush.call(result2, { "[[type]]": "currency", "[[value]]": cd });
        } else {
          var _literal = pattern.substring(beginIndex, endIndex);
          arrPush.call(result2, { "[[type]]": "literal", "[[value]]": _literal });
        }
        nextIndex = endIndex + 1;
        beginIndex = pattern.indexOf("{", nextIndex);
      }
      if (nextIndex < length) {
        var _literal2 = pattern.substring(nextIndex, length);
        arrPush.call(result2, { "[[type]]": "literal", "[[value]]": _literal2 });
      }
      return result2;
    }
    function FormatNumber(numberFormat, x) {
      var parts = PartitionNumberPattern(numberFormat, x);
      var result2 = "";
      for (var i2 = 0; parts.length > i2; i2++) {
        var part = parts[i2];
        result2 += part["[[value]]"];
      }
      return result2;
    }
    function ToRawPrecision(x, minPrecision, maxPrecision) {
      var p3 = maxPrecision;
      var m2 = void 0, e3 = void 0;
      if (x === 0) {
        m2 = arrJoin.call(Array(p3 + 1), "0");
        e3 = 0;
      } else {
        e3 = log10Floor(Math.abs(x));
        var f4 = Math.round(Math.exp(Math.abs(e3 - p3 + 1) * Math.LN10));
        m2 = String(Math.round(e3 - p3 + 1 < 0 ? x * f4 : x / f4));
      }
      if (e3 >= p3)
        return m2 + arrJoin.call(Array(e3 - p3 + 1 + 1), "0");
      else if (e3 === p3 - 1)
        return m2;
      else if (e3 >= 0)
        m2 = m2.slice(0, e3 + 1) + "." + m2.slice(e3 + 1);
      else if (e3 < 0)
        m2 = "0." + arrJoin.call(Array(-(e3 + 1) + 1), "0") + m2;
      if (m2.indexOf(".") >= 0 && maxPrecision > minPrecision) {
        var cut = maxPrecision - minPrecision;
        while (cut > 0 && m2.charAt(m2.length - 1) === "0") {
          m2 = m2.slice(0, -1);
          cut--;
        }
        if (m2.charAt(m2.length - 1) === ".")
          m2 = m2.slice(0, -1);
      }
      return m2;
    }
    function ToRawFixed(x, minInteger, minFraction, maxFraction) {
      var f4 = maxFraction;
      var n5 = Math.pow(10, f4) * x;
      var m2 = n5 === 0 ? "0" : n5.toFixed(0);
      {
        var idx = void 0;
        var exp = (idx = m2.indexOf("e")) > -1 ? m2.slice(idx + 1) : 0;
        if (exp) {
          m2 = m2.slice(0, idx).replace(".", "");
          m2 += arrJoin.call(Array(exp - (m2.length - 1) + 1), "0");
        }
      }
      var int2 = void 0;
      if (f4 !== 0) {
        var k = m2.length;
        if (k <= f4) {
          var z = arrJoin.call(Array(f4 + 1 - k + 1), "0");
          m2 = z + m2;
          k = f4 + 1;
        }
        var a2 = m2.substring(0, k - f4), b4 = m2.substring(k - f4, m2.length);
        m2 = a2 + "." + b4;
        int2 = a2.length;
      } else int2 = m2.length;
      var cut = maxFraction - minFraction;
      while (cut > 0 && m2.slice(-1) === "0") {
        m2 = m2.slice(0, -1);
        cut--;
      }
      if (m2.slice(-1) === ".") {
        m2 = m2.slice(0, -1);
      }
      if (int2 < minInteger) {
        var _z = arrJoin.call(Array(minInteger - int2 + 1), "0");
        m2 = _z + m2;
      }
      return m2;
    }
    var numSys = {
      arab: ["\u0660", "\u0661", "\u0662", "\u0663", "\u0664", "\u0665", "\u0666", "\u0667", "\u0668", "\u0669"],
      arabext: ["\u06F0", "\u06F1", "\u06F2", "\u06F3", "\u06F4", "\u06F5", "\u06F6", "\u06F7", "\u06F8", "\u06F9"],
      bali: ["\u1B50", "\u1B51", "\u1B52", "\u1B53", "\u1B54", "\u1B55", "\u1B56", "\u1B57", "\u1B58", "\u1B59"],
      beng: ["\u09E6", "\u09E7", "\u09E8", "\u09E9", "\u09EA", "\u09EB", "\u09EC", "\u09ED", "\u09EE", "\u09EF"],
      deva: ["\u0966", "\u0967", "\u0968", "\u0969", "\u096A", "\u096B", "\u096C", "\u096D", "\u096E", "\u096F"],
      fullwide: ["\uFF10", "\uFF11", "\uFF12", "\uFF13", "\uFF14", "\uFF15", "\uFF16", "\uFF17", "\uFF18", "\uFF19"],
      gujr: ["\u0AE6", "\u0AE7", "\u0AE8", "\u0AE9", "\u0AEA", "\u0AEB", "\u0AEC", "\u0AED", "\u0AEE", "\u0AEF"],
      guru: ["\u0A66", "\u0A67", "\u0A68", "\u0A69", "\u0A6A", "\u0A6B", "\u0A6C", "\u0A6D", "\u0A6E", "\u0A6F"],
      hanidec: ["\u3007", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D"],
      khmr: ["\u17E0", "\u17E1", "\u17E2", "\u17E3", "\u17E4", "\u17E5", "\u17E6", "\u17E7", "\u17E8", "\u17E9"],
      knda: ["\u0CE6", "\u0CE7", "\u0CE8", "\u0CE9", "\u0CEA", "\u0CEB", "\u0CEC", "\u0CED", "\u0CEE", "\u0CEF"],
      laoo: ["\u0ED0", "\u0ED1", "\u0ED2", "\u0ED3", "\u0ED4", "\u0ED5", "\u0ED6", "\u0ED7", "\u0ED8", "\u0ED9"],
      latn: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
      limb: ["\u1946", "\u1947", "\u1948", "\u1949", "\u194A", "\u194B", "\u194C", "\u194D", "\u194E", "\u194F"],
      mlym: ["\u0D66", "\u0D67", "\u0D68", "\u0D69", "\u0D6A", "\u0D6B", "\u0D6C", "\u0D6D", "\u0D6E", "\u0D6F"],
      mong: ["\u1810", "\u1811", "\u1812", "\u1813", "\u1814", "\u1815", "\u1816", "\u1817", "\u1818", "\u1819"],
      mymr: ["\u1040", "\u1041", "\u1042", "\u1043", "\u1044", "\u1045", "\u1046", "\u1047", "\u1048", "\u1049"],
      orya: ["\u0B66", "\u0B67", "\u0B68", "\u0B69", "\u0B6A", "\u0B6B", "\u0B6C", "\u0B6D", "\u0B6E", "\u0B6F"],
      tamldec: ["\u0BE6", "\u0BE7", "\u0BE8", "\u0BE9", "\u0BEA", "\u0BEB", "\u0BEC", "\u0BED", "\u0BEE", "\u0BEF"],
      telu: ["\u0C66", "\u0C67", "\u0C68", "\u0C69", "\u0C6A", "\u0C6B", "\u0C6C", "\u0C6D", "\u0C6E", "\u0C6F"],
      thai: ["\u0E50", "\u0E51", "\u0E52", "\u0E53", "\u0E54", "\u0E55", "\u0E56", "\u0E57", "\u0E58", "\u0E59"],
      tibt: ["\u0F20", "\u0F21", "\u0F22", "\u0F23", "\u0F24", "\u0F25", "\u0F26", "\u0F27", "\u0F28", "\u0F29"]
    };
    defineProperty(Intl.NumberFormat.prototype, "resolvedOptions", {
      configurable: true,
      writable: true,
      value: function value() {
        var prop = void 0, descs = new Record3(), props = ["locale", "numberingSystem", "style", "currency", "currencyDisplay", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "useGrouping"], internal5 = this !== null && babelHelpers$1["typeof"](this) === "object" && getInternalProperties(this);
        if (!internal5 || !internal5["[[initializedNumberFormat]]"]) throw new TypeError("`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.");
        for (var i2 = 0, max = props.length; i2 < max; i2++) {
          if (hop.call(internal5, prop = "[[" + props[i2] + "]]")) descs[props[i2]] = { value: internal5[prop], writable: true, configurable: true, enumerable: true };
        }
        return objCreate({}, descs);
      }
    });
    var expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
    var expPatternTrimmer = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    var unwantedDTCs = /[rqQASjJgwWIQq]/;
    var dtKeys = ["era", "year", "month", "day", "weekday", "quarter"];
    var tmKeys = ["hour", "minute", "second", "hour12", "timeZoneName"];
    function isDateFormatOnly(obj) {
      for (var i2 = 0; i2 < tmKeys.length; i2 += 1) {
        if (obj.hasOwnProperty(tmKeys[i2])) {
          return false;
        }
      }
      return true;
    }
    function isTimeFormatOnly(obj) {
      for (var i2 = 0; i2 < dtKeys.length; i2 += 1) {
        if (obj.hasOwnProperty(dtKeys[i2])) {
          return false;
        }
      }
      return true;
    }
    function joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {
      var o3 = { _: {} };
      for (var i2 = 0; i2 < dtKeys.length; i2 += 1) {
        if (dateFormatObj[dtKeys[i2]]) {
          o3[dtKeys[i2]] = dateFormatObj[dtKeys[i2]];
        }
        if (dateFormatObj._[dtKeys[i2]]) {
          o3._[dtKeys[i2]] = dateFormatObj._[dtKeys[i2]];
        }
      }
      for (var j = 0; j < tmKeys.length; j += 1) {
        if (timeFormatObj[tmKeys[j]]) {
          o3[tmKeys[j]] = timeFormatObj[tmKeys[j]];
        }
        if (timeFormatObj._[tmKeys[j]]) {
          o3._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];
        }
      }
      return o3;
    }
    function computeFinalPatterns(formatObj) {
      formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function($0, literal) {
        return literal ? literal : "'";
      });
      formatObj.pattern = formatObj.pattern12.replace("{ampm}", "").replace(expPatternTrimmer, "");
      return formatObj;
    }
    function expDTComponentsMeta($0, formatObj) {
      switch ($0.charAt(0)) {
        // --- Era
        case "G":
          formatObj.era = ["short", "short", "short", "long", "narrow"][$0.length - 1];
          return "{era}";
        // --- Year
        case "y":
        case "Y":
        case "u":
        case "U":
        case "r":
          formatObj.year = $0.length === 2 ? "2-digit" : "numeric";
          return "{year}";
        // --- Quarter (not supported in this polyfill)
        case "Q":
        case "q":
          formatObj.quarter = ["numeric", "2-digit", "short", "long", "narrow"][$0.length - 1];
          return "{quarter}";
        // --- Month
        case "M":
        case "L":
          formatObj.month = ["numeric", "2-digit", "short", "long", "narrow"][$0.length - 1];
          return "{month}";
        // --- Week (not supported in this polyfill)
        case "w":
          formatObj.week = $0.length === 2 ? "2-digit" : "numeric";
          return "{weekday}";
        case "W":
          formatObj.week = "numeric";
          return "{weekday}";
        // --- Day
        case "d":
          formatObj.day = $0.length === 2 ? "2-digit" : "numeric";
          return "{day}";
        case "D":
        // day of the year
        case "F":
        // day of the week
        case "g":
          formatObj.day = "numeric";
          return "{day}";
        // --- Week Day
        case "E":
          formatObj.weekday = ["short", "short", "short", "long", "narrow", "short"][$0.length - 1];
          return "{weekday}";
        case "e":
          formatObj.weekday = ["numeric", "2-digit", "short", "long", "narrow", "short"][$0.length - 1];
          return "{weekday}";
        case "c":
          formatObj.weekday = ["numeric", void 0, "short", "long", "narrow", "short"][$0.length - 1];
          return "{weekday}";
        // --- Period
        case "a":
        // AM, PM
        case "b":
        // am, pm, noon, midnight
        case "B":
          formatObj.hour12 = true;
          return "{ampm}";
        // --- Hour
        case "h":
        case "H":
          formatObj.hour = $0.length === 2 ? "2-digit" : "numeric";
          return "{hour}";
        case "k":
        case "K":
          formatObj.hour12 = true;
          formatObj.hour = $0.length === 2 ? "2-digit" : "numeric";
          return "{hour}";
        // --- Minute
        case "m":
          formatObj.minute = $0.length === 2 ? "2-digit" : "numeric";
          return "{minute}";
        // --- Second
        case "s":
          formatObj.second = $0.length === 2 ? "2-digit" : "numeric";
          return "{second}";
        case "S":
        case "A":
          formatObj.second = "numeric";
          return "{second}";
        // --- Timezone
        case "z":
        // 1..3, 4: specific non-location format
        case "Z":
        // 1..3, 4, 5: The ISO8601 varios formats
        case "O":
        // 1, 4: miliseconds in day short, long
        case "v":
        // 1, 4: generic non-location format
        case "V":
        // 1, 2, 3, 4: time zone ID or city
        case "X":
        // 1, 2, 3, 4: The ISO8601 varios formats
        case "x":
          formatObj.timeZoneName = $0.length < 4 ? "short" : "long";
          return "{timeZoneName}";
      }
    }
    function createDateTimeFormat(skeleton, pattern) {
      if (unwantedDTCs.test(pattern)) return void 0;
      var formatObj = {
        originalPattern: pattern,
        _: {}
      };
      formatObj.extendedPattern = pattern.replace(expDTComponents, function($0) {
        return expDTComponentsMeta($0, formatObj._);
      });
      skeleton.replace(expDTComponents, function($0) {
        return expDTComponentsMeta($0, formatObj);
      });
      return computeFinalPatterns(formatObj);
    }
    function createDateTimeFormats(formats) {
      var availableFormats = formats.availableFormats;
      var timeFormats = formats.timeFormats;
      var dateFormats = formats.dateFormats;
      var result2 = [];
      var skeleton = void 0, pattern = void 0, computed = void 0, i2 = void 0, j = void 0;
      var timeRelatedFormats = [];
      var dateRelatedFormats = [];
      for (skeleton in availableFormats) {
        if (availableFormats.hasOwnProperty(skeleton)) {
          pattern = availableFormats[skeleton];
          computed = createDateTimeFormat(skeleton, pattern);
          if (computed) {
            result2.push(computed);
            if (isDateFormatOnly(computed)) {
              dateRelatedFormats.push(computed);
            } else if (isTimeFormatOnly(computed)) {
              timeRelatedFormats.push(computed);
            }
          }
        }
      }
      for (skeleton in timeFormats) {
        if (timeFormats.hasOwnProperty(skeleton)) {
          pattern = timeFormats[skeleton];
          computed = createDateTimeFormat(skeleton, pattern);
          if (computed) {
            result2.push(computed);
            timeRelatedFormats.push(computed);
          }
        }
      }
      for (skeleton in dateFormats) {
        if (dateFormats.hasOwnProperty(skeleton)) {
          pattern = dateFormats[skeleton];
          computed = createDateTimeFormat(skeleton, pattern);
          if (computed) {
            result2.push(computed);
            dateRelatedFormats.push(computed);
          }
        }
      }
      for (i2 = 0; i2 < timeRelatedFormats.length; i2 += 1) {
        for (j = 0; j < dateRelatedFormats.length; j += 1) {
          if (dateRelatedFormats[j].month === "long") {
            pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;
          } else if (dateRelatedFormats[j].month === "short") {
            pattern = formats.medium;
          } else {
            pattern = formats.short;
          }
          computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i2]);
          computed.originalPattern = pattern;
          computed.extendedPattern = pattern.replace("{0}", timeRelatedFormats[i2].extendedPattern).replace("{1}", dateRelatedFormats[j].extendedPattern).replace(/^[,\s]+|[,\s]+$/gi, "");
          result2.push(computeFinalPatterns(computed));
        }
      }
      return result2;
    }
    var validSyntheticProps = {
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      year: {
        numeric: "y",
        "2-digit": "yy"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      month: {
        numeric: "L",
        "2-digit": "LL",
        narrow: "LLLLL",
        short: "LLL",
        long: "LLLL"
      },
      weekday: {
        narrow: "ccccc",
        short: "ccc",
        long: "cccc"
      }
    };
    function generateSyntheticFormat(propName, propValue) {
      if (validSyntheticProps[propName] && validSyntheticProps[propName][propValue]) {
        var _ref2;
        return _ref2 = {
          originalPattern: validSyntheticProps[propName][propValue],
          _: defineProperty$1({}, propName, propValue),
          extendedPattern: "{" + propName + "}"
        }, defineProperty$1(_ref2, propName, propValue), defineProperty$1(_ref2, "pattern12", "{" + propName + "}"), defineProperty$1(_ref2, "pattern", "{" + propName + "}"), _ref2;
      }
    }
    var dateWidths = objCreate(null, { narrow: {}, short: {}, long: {} });
    function resolveDateString(data, ca, component, width, key) {
      var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component], alts = {
        narrow: ["short", "long"],
        short: ["long", "narrow"],
        long: ["short", "narrow"]
      }, resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]];
      return key !== null ? resolved[key] : resolved;
    }
    function DateTimeFormatConstructor() {
      var locales = arguments[0];
      var options = arguments[1];
      if (!this || this === Intl) {
        return new Intl.DateTimeFormat(locales, options);
      }
      return InitializeDateTimeFormat(toObject3(this), locales, options);
    }
    defineProperty(Intl, "DateTimeFormat", {
      configurable: true,
      writable: true,
      value: DateTimeFormatConstructor
    });
    defineProperty(DateTimeFormatConstructor, "prototype", {
      writable: false
    });
    function InitializeDateTimeFormat(dateTimeFormat, locales, options) {
      var internal5 = getInternalProperties(dateTimeFormat);
      var regexpRestore = createRegExpRestore();
      if (internal5["[[initializedIntlObject]]"] === true) throw new TypeError("`this` object has already been initialized as an Intl object");
      defineProperty(dateTimeFormat, "__getInternalProperties", {
        value: function value2() {
          if (arguments[0] === secret) return internal5;
        }
      });
      internal5["[[initializedIntlObject]]"] = true;
      var requestedLocales = CanonicalizeLocaleList(locales);
      options = ToDateTimeOptions(options, "any", "date");
      var opt = new Record3();
      var matcher = GetOption(options, "localeMatcher", "string", new List("lookup", "best fit"), "best fit");
      opt["[[localeMatcher]]"] = matcher;
      var DateTimeFormat = internals.DateTimeFormat;
      var localeData = DateTimeFormat["[[localeData]]"];
      var r3 = ResolveLocale(DateTimeFormat["[[availableLocales]]"], requestedLocales, opt, DateTimeFormat["[[relevantExtensionKeys]]"], localeData);
      internal5["[[locale]]"] = r3["[[locale]]"];
      internal5["[[calendar]]"] = r3["[[ca]]"];
      internal5["[[numberingSystem]]"] = r3["[[nu]]"];
      internal5["[[dataLocale]]"] = r3["[[dataLocale]]"];
      var dataLocale = r3["[[dataLocale]]"];
      var tz = options.timeZone;
      if (tz !== void 0) {
        tz = toLatinUpperCase(tz);
        if (tz !== "UTC") throw new RangeError("timeZone is not supported.");
      }
      internal5["[[timeZone]]"] = tz;
      opt = new Record3();
      for (var prop in dateTimeComponents) {
        if (!hop.call(dateTimeComponents, prop)) continue;
        var value = GetOption(options, prop, "string", dateTimeComponents[prop]);
        opt["[[" + prop + "]]"] = value;
      }
      var bestFormat = void 0;
      var dataLocaleData = localeData[dataLocale];
      var formats = ToDateTimeFormats(dataLocaleData.formats);
      matcher = GetOption(options, "formatMatcher", "string", new List("basic", "best fit"), "best fit");
      dataLocaleData.formats = formats;
      if (matcher === "basic") {
        bestFormat = BasicFormatMatcher(opt, formats);
      } else {
        {
          var _hr = GetOption(
            options,
            "hour12",
            "boolean"
            /*, undefined, undefined*/
          );
          opt.hour12 = _hr === void 0 ? dataLocaleData.hour12 : _hr;
        }
        bestFormat = BestFitFormatMatcher(opt, formats);
      }
      for (var _prop in dateTimeComponents) {
        if (!hop.call(dateTimeComponents, _prop)) continue;
        if (hop.call(bestFormat, _prop)) {
          var p3 = bestFormat[_prop];
          {
            p3 = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p3;
          }
          internal5["[[" + _prop + "]]"] = p3;
        }
      }
      var pattern = void 0;
      var hr12 = GetOption(
        options,
        "hour12",
        "boolean"
        /*, undefined, undefined*/
      );
      if (internal5["[[hour]]"]) {
        hr12 = hr12 === void 0 ? dataLocaleData.hour12 : hr12;
        internal5["[[hour12]]"] = hr12;
        if (hr12 === true) {
          var hourNo0 = dataLocaleData.hourNo0;
          internal5["[[hourNo0]]"] = hourNo0;
          pattern = bestFormat.pattern12;
        } else
          pattern = bestFormat.pattern;
      } else
        pattern = bestFormat.pattern;
      internal5["[[pattern]]"] = pattern;
      internal5["[[boundFormat]]"] = void 0;
      internal5["[[initializedDateTimeFormat]]"] = true;
      if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);
      regexpRestore();
      return dateTimeFormat;
    }
    var dateTimeComponents = {
      weekday: ["narrow", "short", "long"],
      era: ["narrow", "short", "long"],
      year: ["2-digit", "numeric"],
      month: ["2-digit", "numeric", "narrow", "short", "long"],
      day: ["2-digit", "numeric"],
      hour: ["2-digit", "numeric"],
      minute: ["2-digit", "numeric"],
      second: ["2-digit", "numeric"],
      timeZoneName: ["short", "long"]
    };
    function ToDateTimeFormats(formats) {
      if (Object.prototype.toString.call(formats) === "[object Array]") {
        return formats;
      }
      return createDateTimeFormats(formats);
    }
    function ToDateTimeOptions(options, required, defaults2) {
      if (options === void 0) options = null;
      else {
        var opt2 = toObject3(options);
        options = new Record3();
        for (var k in opt2) {
          options[k] = opt2[k];
        }
      }
      var create = objCreate;
      options = create(options);
      var needDefaults = true;
      if (required === "date" || required === "any") {
        if (options.weekday !== void 0 || options.year !== void 0 || options.month !== void 0 || options.day !== void 0) needDefaults = false;
      }
      if (required === "time" || required === "any") {
        if (options.hour !== void 0 || options.minute !== void 0 || options.second !== void 0) needDefaults = false;
      }
      if (needDefaults && (defaults2 === "date" || defaults2 === "all"))
        options.year = options.month = options.day = "numeric";
      if (needDefaults && (defaults2 === "time" || defaults2 === "all"))
        options.hour = options.minute = options.second = "numeric";
      return options;
    }
    function BasicFormatMatcher(options, formats) {
      var removalPenalty = 120;
      var additionPenalty = 20;
      var longLessPenalty = 8;
      var longMorePenalty = 6;
      var shortLessPenalty = 6;
      var shortMorePenalty = 3;
      var bestScore = -Infinity;
      var bestFormat = void 0;
      var i2 = 0;
      var len = formats.length;
      while (i2 < len) {
        var format3 = formats[i2];
        var score = 0;
        for (var property in dateTimeComponents) {
          if (!hop.call(dateTimeComponents, property)) continue;
          var optionsProp = options["[[" + property + "]]"];
          var formatProp = hop.call(format3, property) ? format3[property] : void 0;
          if (optionsProp === void 0 && formatProp !== void 0) score -= additionPenalty;
          else if (optionsProp !== void 0 && formatProp === void 0) score -= removalPenalty;
          else {
            var values = ["2-digit", "numeric", "narrow", "short", "long"];
            var optionsPropIndex = arrIndexOf.call(values, optionsProp);
            var formatPropIndex = arrIndexOf.call(values, formatProp);
            var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);
            if (delta === 2) score -= longMorePenalty;
            else if (delta === 1) score -= shortMorePenalty;
            else if (delta === -1) score -= shortLessPenalty;
            else if (delta === -2) score -= longLessPenalty;
          }
        }
        if (score > bestScore) {
          bestScore = score;
          bestFormat = format3;
        }
        i2++;
      }
      return bestFormat;
    }
    function BestFitFormatMatcher(options, formats) {
      {
        var optionsPropNames = [];
        for (var property in dateTimeComponents) {
          if (!hop.call(dateTimeComponents, property)) continue;
          if (options["[[" + property + "]]"] !== void 0) {
            optionsPropNames.push(property);
          }
        }
        if (optionsPropNames.length === 1) {
          var _bestFormat = generateSyntheticFormat(optionsPropNames[0], options["[[" + optionsPropNames[0] + "]]"]);
          if (_bestFormat) {
            return _bestFormat;
          }
        }
      }
      var removalPenalty = 120;
      var additionPenalty = 20;
      var longLessPenalty = 8;
      var longMorePenalty = 6;
      var shortLessPenalty = 6;
      var shortMorePenalty = 3;
      var patternPenalty = 2;
      var hour12Penalty = 1;
      var bestScore = -Infinity;
      var bestFormat = void 0;
      var i2 = 0;
      var len = formats.length;
      while (i2 < len) {
        var format3 = formats[i2];
        var score = 0;
        for (var _property in dateTimeComponents) {
          if (!hop.call(dateTimeComponents, _property)) continue;
          var optionsProp = options["[[" + _property + "]]"];
          var formatProp = hop.call(format3, _property) ? format3[_property] : void 0;
          var patternProp = hop.call(format3._, _property) ? format3._[_property] : void 0;
          if (optionsProp !== patternProp) {
            score -= patternPenalty;
          }
          if (optionsProp === void 0 && formatProp !== void 0) score -= additionPenalty;
          else if (optionsProp !== void 0 && formatProp === void 0) score -= removalPenalty;
          else {
            var values = ["2-digit", "numeric", "narrow", "short", "long"];
            var optionsPropIndex = arrIndexOf.call(values, optionsProp);
            var formatPropIndex = arrIndexOf.call(values, formatProp);
            var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);
            {
              if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {
                if (delta > 0) score -= longMorePenalty;
                else if (delta < 0) score -= longLessPenalty;
              } else {
                if (delta > 1) score -= shortMorePenalty;
                else if (delta < -1) score -= shortLessPenalty;
              }
            }
          }
        }
        {
          if (format3._.hour12 !== options.hour12) {
            score -= hour12Penalty;
          }
        }
        if (score > bestScore) {
          bestScore = score;
          bestFormat = format3;
        }
        i2++;
      }
      return bestFormat;
    }
    internals.DateTimeFormat = {
      "[[availableLocales]]": [],
      "[[relevantExtensionKeys]]": ["ca", "nu"],
      "[[localeData]]": {}
    };
    defineProperty(Intl.DateTimeFormat, "supportedLocalesOf", {
      configurable: true,
      writable: true,
      value: fnBind.call(function(locales) {
        if (!hop.call(this, "[[availableLocales]]")) throw new TypeError("supportedLocalesOf() is not a constructor");
        var regexpRestore = createRegExpRestore(), options = arguments[1], availableLocales = this["[[availableLocales]]"], requestedLocales = CanonicalizeLocaleList(locales);
        regexpRestore();
        return SupportedLocales(availableLocales, requestedLocales, options);
      }, internals.NumberFormat)
    });
    defineProperty(Intl.DateTimeFormat.prototype, "format", {
      configurable: true,
      get: GetFormatDateTime
    });
    function GetFormatDateTime() {
      var internal5 = this !== null && babelHelpers$1["typeof"](this) === "object" && getInternalProperties(this);
      if (!internal5 || !internal5["[[initializedDateTimeFormat]]"]) throw new TypeError("`this` value for format() is not an initialized Intl.DateTimeFormat object.");
      if (internal5["[[boundFormat]]"] === void 0) {
        var F2 = function F3() {
          var date = arguments.length <= 0 || arguments[0] === void 0 ? void 0 : arguments[0];
          var x = date === void 0 ? Date.now() : toNumber3(date);
          return FormatDateTime(this, x);
        };
        var bf = fnBind.call(F2, this);
        internal5["[[boundFormat]]"] = bf;
      }
      return internal5["[[boundFormat]]"];
    }
    function formatToParts$1() {
      var date = arguments.length <= 0 || arguments[0] === void 0 ? void 0 : arguments[0];
      var internal5 = this !== null && babelHelpers$1["typeof"](this) === "object" && getInternalProperties(this);
      if (!internal5 || !internal5["[[initializedDateTimeFormat]]"]) throw new TypeError("`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.");
      var x = date === void 0 ? Date.now() : toNumber3(date);
      return FormatToPartsDateTime(this, x);
    }
    Object.defineProperty(Intl.DateTimeFormat.prototype, "formatToParts", {
      enumerable: false,
      writable: true,
      configurable: true,
      value: formatToParts$1
    });
    function CreateDateTimeParts(dateTimeFormat, x) {
      if (!isFinite(x)) throw new RangeError("Invalid valid date passed to format");
      var internal5 = dateTimeFormat.__getInternalProperties(secret);
      createRegExpRestore();
      var locale = internal5["[[locale]]"];
      var nf = new Intl.NumberFormat([locale], { useGrouping: false });
      var nf2 = new Intl.NumberFormat([locale], { minimumIntegerDigits: 2, useGrouping: false });
      var tm = ToLocalTime(x, internal5["[[calendar]]"], internal5["[[timeZone]]"]);
      var pattern = internal5["[[pattern]]"];
      var result2 = new List();
      var index = 0;
      var beginIndex = pattern.indexOf("{");
      var endIndex = 0;
      var dataLocale = internal5["[[dataLocale]]"];
      var localeData = internals.DateTimeFormat["[[localeData]]"][dataLocale].calendars;
      var ca = internal5["[[calendar]]"];
      while (beginIndex !== -1) {
        var fv = void 0;
        endIndex = pattern.indexOf("}", beginIndex);
        if (endIndex === -1) {
          throw new Error("Unclosed pattern");
        }
        if (beginIndex > index) {
          arrPush.call(result2, {
            type: "literal",
            value: pattern.substring(index, beginIndex)
          });
        }
        var p3 = pattern.substring(beginIndex + 1, endIndex);
        if (dateTimeComponents.hasOwnProperty(p3)) {
          var f4 = internal5["[[" + p3 + "]]"];
          var v2 = tm["[[" + p3 + "]]"];
          if (p3 === "year" && v2 <= 0) {
            v2 = 1 - v2;
          } else if (p3 === "month") {
            v2++;
          } else if (p3 === "hour" && internal5["[[hour12]]"] === true) {
            v2 = v2 % 12;
            if (v2 === 0 && internal5["[[hourNo0]]"] === true) {
              v2 = 12;
            }
          }
          if (f4 === "numeric") {
            fv = FormatNumber(nf, v2);
          } else if (f4 === "2-digit") {
            fv = FormatNumber(nf2, v2);
            if (fv.length > 2) {
              fv = fv.slice(-2);
            }
          } else if (f4 in dateWidths) {
            switch (p3) {
              case "month":
                fv = resolveDateString(localeData, ca, "months", f4, tm["[[" + p3 + "]]"]);
                break;
              case "weekday":
                try {
                  fv = resolveDateString(localeData, ca, "days", f4, tm["[[" + p3 + "]]"]);
                } catch (e3) {
                  throw new Error("Could not find weekday data for locale " + locale);
                }
                break;
              case "timeZoneName":
                fv = "";
                break;
              case "era":
                try {
                  fv = resolveDateString(localeData, ca, "eras", f4, tm["[[" + p3 + "]]"]);
                } catch (e3) {
                  throw new Error("Could not find era data for locale " + locale);
                }
                break;
              default:
                fv = tm["[[" + p3 + "]]"];
            }
          }
          arrPush.call(result2, {
            type: p3,
            value: fv
          });
        } else if (p3 === "ampm") {
          var _v = tm["[[hour]]"];
          fv = resolveDateString(localeData, ca, "dayPeriods", _v > 11 ? "pm" : "am", null);
          arrPush.call(result2, {
            type: "dayPeriod",
            value: fv
          });
        } else {
          arrPush.call(result2, {
            type: "literal",
            value: pattern.substring(beginIndex, endIndex + 1)
          });
        }
        index = endIndex + 1;
        beginIndex = pattern.indexOf("{", index);
      }
      if (endIndex < pattern.length - 1) {
        arrPush.call(result2, {
          type: "literal",
          value: pattern.substr(endIndex + 1)
        });
      }
      return result2;
    }
    function FormatDateTime(dateTimeFormat, x) {
      var parts = CreateDateTimeParts(dateTimeFormat, x);
      var result2 = "";
      for (var i2 = 0; parts.length > i2; i2++) {
        var part = parts[i2];
        result2 += part.value;
      }
      return result2;
    }
    function FormatToPartsDateTime(dateTimeFormat, x) {
      var parts = CreateDateTimeParts(dateTimeFormat, x);
      var result2 = [];
      for (var i2 = 0; parts.length > i2; i2++) {
        var part = parts[i2];
        result2.push({
          type: part.type,
          value: part.value
        });
      }
      return result2;
    }
    function ToLocalTime(date, calendar, timeZone) {
      var d = new Date(date), m2 = "get" + (timeZone || "");
      return new Record3({
        "[[weekday]]": d[m2 + "Day"](),
        "[[era]]": +(d[m2 + "FullYear"]() >= 0),
        "[[year]]": d[m2 + "FullYear"](),
        "[[month]]": d[m2 + "Month"](),
        "[[day]]": d[m2 + "Date"](),
        "[[hour]]": d[m2 + "Hours"](),
        "[[minute]]": d[m2 + "Minutes"](),
        "[[second]]": d[m2 + "Seconds"](),
        "[[inDST]]": false
        // ###TODO###
      });
    }
    defineProperty(Intl.DateTimeFormat.prototype, "resolvedOptions", {
      writable: true,
      configurable: true,
      value: function value() {
        var prop = void 0, descs = new Record3(), props = ["locale", "calendar", "numberingSystem", "timeZone", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"], internal5 = this !== null && babelHelpers$1["typeof"](this) === "object" && getInternalProperties(this);
        if (!internal5 || !internal5["[[initializedDateTimeFormat]]"]) throw new TypeError("`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.");
        for (var i2 = 0, max = props.length; i2 < max; i2++) {
          if (hop.call(internal5, prop = "[[" + props[i2] + "]]")) descs[props[i2]] = { value: internal5[prop], writable: true, configurable: true, enumerable: true };
        }
        return objCreate({}, descs);
      }
    });
    var ls = Intl.__localeSensitiveProtos = {
      Number: {},
      Date: {}
    };
    ls.Number.toLocaleString = function() {
      if (Object.prototype.toString.call(this) !== "[object Number]") throw new TypeError("`this` value must be a number for Number.prototype.toLocaleString()");
      return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);
    };
    ls.Date.toLocaleString = function() {
      if (Object.prototype.toString.call(this) !== "[object Date]") throw new TypeError("`this` value must be a Date instance for Date.prototype.toLocaleString()");
      var x = +this;
      if (isNaN(x)) return "Invalid Date";
      var locales = arguments[0];
      var options = arguments[1];
      options = ToDateTimeOptions(options, "any", "all");
      var dateTimeFormat = new DateTimeFormatConstructor(locales, options);
      return FormatDateTime(dateTimeFormat, x);
    };
    ls.Date.toLocaleDateString = function() {
      if (Object.prototype.toString.call(this) !== "[object Date]") throw new TypeError("`this` value must be a Date instance for Date.prototype.toLocaleDateString()");
      var x = +this;
      if (isNaN(x)) return "Invalid Date";
      var locales = arguments[0], options = arguments[1];
      options = ToDateTimeOptions(options, "date", "date");
      var dateTimeFormat = new DateTimeFormatConstructor(locales, options);
      return FormatDateTime(dateTimeFormat, x);
    };
    ls.Date.toLocaleTimeString = function() {
      if (Object.prototype.toString.call(this) !== "[object Date]") throw new TypeError("`this` value must be a Date instance for Date.prototype.toLocaleTimeString()");
      var x = +this;
      if (isNaN(x)) return "Invalid Date";
      var locales = arguments[0];
      var options = arguments[1];
      options = ToDateTimeOptions(options, "time", "time");
      var dateTimeFormat = new DateTimeFormatConstructor(locales, options);
      return FormatDateTime(dateTimeFormat, x);
    };
    defineProperty(Intl, "__applyLocaleSensitivePrototypes", {
      writable: true,
      configurable: true,
      value: function value() {
        defineProperty(Number.prototype, "toLocaleString", { writable: true, configurable: true, value: ls.Number.toLocaleString });
        defineProperty(Date.prototype, "toLocaleString", { writable: true, configurable: true, value: ls.Date.toLocaleString });
        for (var k in ls.Date) {
          if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });
        }
      }
    });
    defineProperty(Intl, "__addLocaleData", {
      value: function value(data) {
        if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error("Object passed doesn't identify itself with a valid language tag");
        addLocaleData(data, data.locale);
      }
    });
    function addLocaleData(data, tag) {
      if (!data.number) throw new Error("Object passed doesn't contain locale data for Intl.NumberFormat");
      var locale = void 0, locales = [tag], parts = tag.split("-");
      if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + "-" + parts[2]);
      while (locale = arrShift.call(locales)) {
        arrPush.call(internals.NumberFormat["[[availableLocales]]"], locale);
        internals.NumberFormat["[[localeData]]"][locale] = data.number;
        if (data.date) {
          data.date.nu = data.number.nu;
          arrPush.call(internals.DateTimeFormat["[[availableLocales]]"], locale);
          internals.DateTimeFormat["[[localeData]]"][locale] = data.date;
        }
      }
      if (defaultLocale === void 0) setDefaultLocale(tag);
    }
    defineProperty(Intl, "__disableRegExpRestore", {
      value: function value() {
        internals.disableRegExpRestore = true;
      }
    });
    module.exports = Intl;
  }
});

// (disabled):node_modules/azle/node_modules/intl/locale-data/complete.js
var require_complete = __commonJS({
  "(disabled):node_modules/azle/node_modules/intl/locale-data/complete.js"() {
  }
});

// node_modules/azle/node_modules/intl/index.js
var require_intl = __commonJS({
  "node_modules/azle/node_modules/intl/index.js"(exports4, module) {
    global.IntlPolyfill = require_core();
    require_complete();
    if (!global.Intl) {
      global.Intl = global.IntlPolyfill;
      global.IntlPolyfill.__applyLocaleSensitivePrototypes();
    }
    module.exports = global.IntlPolyfill;
  }
});

// node_modules/azle/node_modules/intl/locale-data/jsonp/en.js
var require_en = __commonJS({
  "node_modules/azle/node_modules/intl/locale-data/jsonp/en.js"() {
    IntlPolyfill.__addLocaleData({ locale: "en", date: { ca: ["gregory", "buddhist", "chinese", "coptic", "dangi", "ethioaa", "ethiopic", "generic", "hebrew", "indian", "islamic", "islamicc", "japanese", "persian", "roc"], hourNo0: true, hour12: true, formats: { short: "{1}, {0}", medium: "{1}, {0}", full: "{1} 'at' {0}", long: "{1} 'at' {0}", availableFormats: { "d": "d", "E": "ccc", Ed: "d E", Ehm: "E h:mm a", EHm: "E HH:mm", Ehms: "E h:mm:ss a", EHms: "E HH:mm:ss", Gy: "y G", GyMMM: "MMM y G", GyMMMd: "MMM d, y G", GyMMMEd: "E, MMM d, y G", "h": "h a", "H": "HH", hm: "h:mm a", Hm: "HH:mm", hms: "h:mm:ss a", Hms: "HH:mm:ss", hmsv: "h:mm:ss a v", Hmsv: "HH:mm:ss v", hmv: "h:mm a v", Hmv: "HH:mm v", "M": "L", Md: "M/d", MEd: "E, M/d", MMM: "LLL", MMMd: "MMM d", MMMEd: "E, MMM d", MMMMd: "MMMM d", ms: "mm:ss", "y": "y", yM: "M/y", yMd: "M/d/y", yMEd: "E, M/d/y", yMMM: "MMM y", yMMMd: "MMM d, y", yMMMEd: "E, MMM d, y", yMMMM: "MMMM y", yQQQ: "QQQ y", yQQQQ: "QQQQ y" }, dateFormats: { yMMMMEEEEd: "EEEE, MMMM d, y", yMMMMd: "MMMM d, y", yMMMd: "MMM d, y", yMd: "M/d/yy" }, timeFormats: { hmmsszzzz: "h:mm:ss a zzzz", hmsz: "h:mm:ss a z", hms: "h:mm:ss a", hm: "h:mm a" } }, calendars: { buddhist: { months: { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["BE"], short: ["BE"], long: ["BE"] }, dayPeriods: { am: "AM", pm: "PM" } }, chinese: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["Mo1", "Mo2", "Mo3", "Mo4", "Mo5", "Mo6", "Mo7", "Mo8", "Mo9", "Mo10", "Mo11", "Mo12"], long: ["Month1", "Month2", "Month3", "Month4", "Month5", "Month6", "Month7", "Month8", "Month9", "Month10", "Month11", "Month12"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, dayPeriods: { am: "AM", pm: "PM" } }, coptic: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"], short: ["Tout", "Baba", "Hator", "Kiahk", "Toba", "Amshir", "Baramhat", "Baramouda", "Bashans", "Paona", "Epep", "Mesra", "Nasie"], long: ["Tout", "Baba", "Hator", "Kiahk", "Toba", "Amshir", "Baramhat", "Baramouda", "Bashans", "Paona", "Epep", "Mesra", "Nasie"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["ERA0", "ERA1"], short: ["ERA0", "ERA1"], long: ["ERA0", "ERA1"] }, dayPeriods: { am: "AM", pm: "PM" } }, dangi: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["Mo1", "Mo2", "Mo3", "Mo4", "Mo5", "Mo6", "Mo7", "Mo8", "Mo9", "Mo10", "Mo11", "Mo12"], long: ["Month1", "Month2", "Month3", "Month4", "Month5", "Month6", "Month7", "Month8", "Month9", "Month10", "Month11", "Month12"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, dayPeriods: { am: "AM", pm: "PM" } }, ethiopic: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"], short: ["Meskerem", "Tekemt", "Hedar", "Tahsas", "Ter", "Yekatit", "Megabit", "Miazia", "Genbot", "Sene", "Hamle", "Nehasse", "Pagumen"], long: ["Meskerem", "Tekemt", "Hedar", "Tahsas", "Ter", "Yekatit", "Megabit", "Miazia", "Genbot", "Sene", "Hamle", "Nehasse", "Pagumen"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["ERA0", "ERA1"], short: ["ERA0", "ERA1"], long: ["ERA0", "ERA1"] }, dayPeriods: { am: "AM", pm: "PM" } }, ethioaa: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"], short: ["Meskerem", "Tekemt", "Hedar", "Tahsas", "Ter", "Yekatit", "Megabit", "Miazia", "Genbot", "Sene", "Hamle", "Nehasse", "Pagumen"], long: ["Meskerem", "Tekemt", "Hedar", "Tahsas", "Ter", "Yekatit", "Megabit", "Miazia", "Genbot", "Sene", "Hamle", "Nehasse", "Pagumen"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["ERA0"], short: ["ERA0"], long: ["ERA0"] }, dayPeriods: { am: "AM", pm: "PM" } }, generic: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["M01", "M02", "M03", "M04", "M05", "M06", "M07", "M08", "M09", "M10", "M11", "M12"], long: ["M01", "M02", "M03", "M04", "M05", "M06", "M07", "M08", "M09", "M10", "M11", "M12"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["ERA0", "ERA1"], short: ["ERA0", "ERA1"], long: ["ERA0", "ERA1"] }, dayPeriods: { am: "AM", pm: "PM" } }, gregory: { months: { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["B", "A", "BCE", "CE"], short: ["BC", "AD", "BCE", "CE"], long: ["Before Christ", "Anno Domini", "Before Common Era", "Common Era"] }, dayPeriods: { am: "AM", pm: "PM" } }, hebrew: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "7"], short: ["Tishri", "Heshvan", "Kislev", "Tevet", "Shevat", "Adar I", "Adar", "Nisan", "Iyar", "Sivan", "Tamuz", "Av", "Elul", "Adar II"], long: ["Tishri", "Heshvan", "Kislev", "Tevet", "Shevat", "Adar I", "Adar", "Nisan", "Iyar", "Sivan", "Tamuz", "Av", "Elul", "Adar II"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["AM"], short: ["AM"], long: ["AM"] }, dayPeriods: { am: "AM", pm: "PM" } }, indian: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["Chaitra", "Vaisakha", "Jyaistha", "Asadha", "Sravana", "Bhadra", "Asvina", "Kartika", "Agrahayana", "Pausa", "Magha", "Phalguna"], long: ["Chaitra", "Vaisakha", "Jyaistha", "Asadha", "Sravana", "Bhadra", "Asvina", "Kartika", "Agrahayana", "Pausa", "Magha", "Phalguna"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["Saka"], short: ["Saka"], long: ["Saka"] }, dayPeriods: { am: "AM", pm: "PM" } }, islamic: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["Muh.", "Saf.", "Rab. I", "Rab. II", "Jum. I", "Jum. II", "Raj.", "Sha.", "Ram.", "Shaw.", "Dhu\u02BBl-Q.", "Dhu\u02BBl-H."], long: ["Muharram", "Safar", "Rabi\u02BB I", "Rabi\u02BB II", "Jumada I", "Jumada II", "Rajab", "Sha\u02BBban", "Ramadan", "Shawwal", "Dhu\u02BBl-Qi\u02BBdah", "Dhu\u02BBl-Hijjah"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["AH"], short: ["AH"], long: ["AH"] }, dayPeriods: { am: "AM", pm: "PM" } }, islamicc: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["Muh.", "Saf.", "Rab. I", "Rab. II", "Jum. I", "Jum. II", "Raj.", "Sha.", "Ram.", "Shaw.", "Dhu\u02BBl-Q.", "Dhu\u02BBl-H."], long: ["Muharram", "Safar", "Rabi\u02BB I", "Rabi\u02BB II", "Jumada I", "Jumada II", "Rajab", "Sha\u02BBban", "Ramadan", "Shawwal", "Dhu\u02BBl-Qi\u02BBdah", "Dhu\u02BBl-Hijjah"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["AH"], short: ["AH"], long: ["AH"] }, dayPeriods: { am: "AM", pm: "PM" } }, japanese: { months: { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["Taika (645\u2013650)", "Hakuchi (650\u2013671)", "Hakuh\u014D (672\u2013686)", "Shuch\u014D (686\u2013701)", "Taih\u014D (701\u2013704)", "Keiun (704\u2013708)", "Wad\u014D (708\u2013715)", "Reiki (715\u2013717)", "Y\u014Dr\u014D (717\u2013724)", "Jinki (724\u2013729)", "Tenpy\u014D (729\u2013749)", "Tenpy\u014D-kamp\u014D (749-749)", "Tenpy\u014D-sh\u014Dh\u014D (749-757)", "Tenpy\u014D-h\u014Dji (757-765)", "Tenpy\u014D-jingo (765-767)", "Jingo-keiun (767-770)", "H\u014Dki (770\u2013780)", "Ten-\u014D (781-782)", "Enryaku (782\u2013806)", "Daid\u014D (806\u2013810)", "K\u014Dnin (810\u2013824)", "Tench\u014D (824\u2013834)", "J\u014Dwa (834\u2013848)", "Kaj\u014D (848\u2013851)", "Ninju (851\u2013854)", "Saik\u014D (854\u2013857)", "Ten-an (857-859)", "J\u014Dgan (859\u2013877)", "Gangy\u014D (877\u2013885)", "Ninna (885\u2013889)", "Kanpy\u014D (889\u2013898)", "Sh\u014Dtai (898\u2013901)", "Engi (901\u2013923)", "Ench\u014D (923\u2013931)", "J\u014Dhei (931\u2013938)", "Tengy\u014D (938\u2013947)", "Tenryaku (947\u2013957)", "Tentoku (957\u2013961)", "\u014Cwa (961\u2013964)", "K\u014Dh\u014D (964\u2013968)", "Anna (968\u2013970)", "Tenroku (970\u2013973)", "Ten\u2019en (973\u2013976)", "J\u014Dgen (976\u2013978)", "Tengen (978\u2013983)", "Eikan (983\u2013985)", "Kanna (985\u2013987)", "Eien (987\u2013989)", "Eiso (989\u2013990)", "Sh\u014Dryaku (990\u2013995)", "Ch\u014Dtoku (995\u2013999)", "Ch\u014Dh\u014D (999\u20131004)", "Kank\u014D (1004\u20131012)", "Ch\u014Dwa (1012\u20131017)", "Kannin (1017\u20131021)", "Jian (1021\u20131024)", "Manju (1024\u20131028)", "Ch\u014Dgen (1028\u20131037)", "Ch\u014Dryaku (1037\u20131040)", "Ch\u014Dky\u016B (1040\u20131044)", "Kantoku (1044\u20131046)", "Eish\u014D (1046\u20131053)", "Tengi (1053\u20131058)", "K\u014Dhei (1058\u20131065)", "Jiryaku (1065\u20131069)", "Enky\u016B (1069\u20131074)", "Sh\u014Dho (1074\u20131077)", "Sh\u014Dryaku (1077\u20131081)", "Eih\u014D (1081\u20131084)", "\u014Ctoku (1084\u20131087)", "Kanji (1087\u20131094)", "Kah\u014D (1094\u20131096)", "Eich\u014D (1096\u20131097)", "J\u014Dtoku (1097\u20131099)", "K\u014Dwa (1099\u20131104)", "Ch\u014Dji (1104\u20131106)", "Kash\u014D (1106\u20131108)", "Tennin (1108\u20131110)", "Ten-ei (1110-1113)", "Eiky\u016B (1113\u20131118)", "Gen\u2019ei (1118\u20131120)", "H\u014Dan (1120\u20131124)", "Tenji (1124\u20131126)", "Daiji (1126\u20131131)", "Tensh\u014D (1131\u20131132)", "Ch\u014Dsh\u014D (1132\u20131135)", "H\u014Den (1135\u20131141)", "Eiji (1141\u20131142)", "K\u014Dji (1142\u20131144)", "Ten\u2019y\u014D (1144\u20131145)", "Ky\u016Ban (1145\u20131151)", "Ninpei (1151\u20131154)", "Ky\u016Bju (1154\u20131156)", "H\u014Dgen (1156\u20131159)", "Heiji (1159\u20131160)", "Eiryaku (1160\u20131161)", "\u014Cho (1161\u20131163)", "Ch\u014Dkan (1163\u20131165)", "Eiman (1165\u20131166)", "Nin\u2019an (1166\u20131169)", "Ka\u014D (1169\u20131171)", "Sh\u014Dan (1171\u20131175)", "Angen (1175\u20131177)", "Jish\u014D (1177\u20131181)", "Y\u014Dwa (1181\u20131182)", "Juei (1182\u20131184)", "Genryaku (1184\u20131185)", "Bunji (1185\u20131190)", "Kenky\u016B (1190\u20131199)", "Sh\u014Dji (1199\u20131201)", "Kennin (1201\u20131204)", "Genky\u016B (1204\u20131206)", "Ken\u2019ei (1206\u20131207)", "J\u014Dgen (1207\u20131211)", "Kenryaku (1211\u20131213)", "Kenp\u014D (1213\u20131219)", "J\u014Dky\u016B (1219\u20131222)", "J\u014D\u014D (1222\u20131224)", "Gennin (1224\u20131225)", "Karoku (1225\u20131227)", "Antei (1227\u20131229)", "Kanki (1229\u20131232)", "J\u014Dei (1232\u20131233)", "Tenpuku (1233\u20131234)", "Bunryaku (1234\u20131235)", "Katei (1235\u20131238)", "Ryakunin (1238\u20131239)", "En\u2019\u014D (1239\u20131240)", "Ninji (1240\u20131243)", "Kangen (1243\u20131247)", "H\u014Dji (1247\u20131249)", "Kench\u014D (1249\u20131256)", "K\u014Dgen (1256\u20131257)", "Sh\u014Dka (1257\u20131259)", "Sh\u014Dgen (1259\u20131260)", "Bun\u2019\u014D (1260\u20131261)", "K\u014Dch\u014D (1261\u20131264)", "Bun\u2019ei (1264\u20131275)", "Kenji (1275\u20131278)", "K\u014Dan (1278\u20131288)", "Sh\u014D\u014D (1288\u20131293)", "Einin (1293\u20131299)", "Sh\u014Dan (1299\u20131302)", "Kengen (1302\u20131303)", "Kagen (1303\u20131306)", "Tokuji (1306\u20131308)", "Enky\u014D (1308\u20131311)", "\u014Cch\u014D (1311\u20131312)", "Sh\u014Dwa (1312\u20131317)", "Bunp\u014D (1317\u20131319)", "Gen\u014D (1319\u20131321)", "Genk\u014D (1321\u20131324)", "Sh\u014Dch\u016B (1324\u20131326)", "Karyaku (1326\u20131329)", "Gentoku (1329\u20131331)", "Genk\u014D (1331\u20131334)", "Kenmu (1334\u20131336)", "Engen (1336\u20131340)", "K\u014Dkoku (1340\u20131346)", "Sh\u014Dhei (1346\u20131370)", "Kentoku (1370\u20131372)", "Bunch\u016B (1372\u20131375)", "Tenju (1375\u20131379)", "K\u014Dryaku (1379\u20131381)", "K\u014Dwa (1381\u20131384)", "Gench\u016B (1384\u20131392)", "Meitoku (1384\u20131387)", "Kakei (1387\u20131389)", "K\u014D\u014D (1389\u20131390)", "Meitoku (1390\u20131394)", "\u014Cei (1394\u20131428)", "Sh\u014Dch\u014D (1428\u20131429)", "Eiky\u014D (1429\u20131441)", "Kakitsu (1441\u20131444)", "Bun\u2019an (1444\u20131449)", "H\u014Dtoku (1449\u20131452)", "Ky\u014Dtoku (1452\u20131455)", "K\u014Dsh\u014D (1455\u20131457)", "Ch\u014Droku (1457\u20131460)", "Kansh\u014D (1460\u20131466)", "Bunsh\u014D (1466\u20131467)", "\u014Cnin (1467\u20131469)", "Bunmei (1469\u20131487)", "Ch\u014Dky\u014D (1487\u20131489)", "Entoku (1489\u20131492)", "Mei\u014D (1492\u20131501)", "Bunki (1501\u20131504)", "Eish\u014D (1504\u20131521)", "Taiei (1521\u20131528)", "Ky\u014Droku (1528\u20131532)", "Tenbun (1532\u20131555)", "K\u014Dji (1555\u20131558)", "Eiroku (1558\u20131570)", "Genki (1570\u20131573)", "Tensh\u014D (1573\u20131592)", "Bunroku (1592\u20131596)", "Keich\u014D (1596\u20131615)", "Genna (1615\u20131624)", "Kan\u2019ei (1624\u20131644)", "Sh\u014Dho (1644\u20131648)", "Keian (1648\u20131652)", "J\u014D\u014D (1652\u20131655)", "Meireki (1655\u20131658)", "Manji (1658\u20131661)", "Kanbun (1661\u20131673)", "Enp\u014D (1673\u20131681)", "Tenna (1681\u20131684)", "J\u014Dky\u014D (1684\u20131688)", "Genroku (1688\u20131704)", "H\u014Dei (1704\u20131711)", "Sh\u014Dtoku (1711\u20131716)", "Ky\u014Dh\u014D (1716\u20131736)", "Genbun (1736\u20131741)", "Kanp\u014D (1741\u20131744)", "Enky\u014D (1744\u20131748)", "Kan\u2019en (1748\u20131751)", "H\u014Dreki (1751\u20131764)", "Meiwa (1764\u20131772)", "An\u2019ei (1772\u20131781)", "Tenmei (1781\u20131789)", "Kansei (1789\u20131801)", "Ky\u014Dwa (1801\u20131804)", "Bunka (1804\u20131818)", "Bunsei (1818\u20131830)", "Tenp\u014D (1830\u20131844)", "K\u014Dka (1844\u20131848)", "Kaei (1848\u20131854)", "Ansei (1854\u20131860)", "Man\u2019en (1860\u20131861)", "Bunky\u016B (1861\u20131864)", "Genji (1864\u20131865)", "Kei\u014D (1865\u20131868)", "M", "T", "S", "H"], short: ["Taika (645\u2013650)", "Hakuchi (650\u2013671)", "Hakuh\u014D (672\u2013686)", "Shuch\u014D (686\u2013701)", "Taih\u014D (701\u2013704)", "Keiun (704\u2013708)", "Wad\u014D (708\u2013715)", "Reiki (715\u2013717)", "Y\u014Dr\u014D (717\u2013724)", "Jinki (724\u2013729)", "Tenpy\u014D (729\u2013749)", "Tenpy\u014D-kamp\u014D (749-749)", "Tenpy\u014D-sh\u014Dh\u014D (749-757)", "Tenpy\u014D-h\u014Dji (757-765)", "Tenpy\u014D-jingo (765-767)", "Jingo-keiun (767-770)", "H\u014Dki (770\u2013780)", "Ten-\u014D (781-782)", "Enryaku (782\u2013806)", "Daid\u014D (806\u2013810)", "K\u014Dnin (810\u2013824)", "Tench\u014D (824\u2013834)", "J\u014Dwa (834\u2013848)", "Kaj\u014D (848\u2013851)", "Ninju (851\u2013854)", "Saik\u014D (854\u2013857)", "Ten-an (857-859)", "J\u014Dgan (859\u2013877)", "Gangy\u014D (877\u2013885)", "Ninna (885\u2013889)", "Kanpy\u014D (889\u2013898)", "Sh\u014Dtai (898\u2013901)", "Engi (901\u2013923)", "Ench\u014D (923\u2013931)", "J\u014Dhei (931\u2013938)", "Tengy\u014D (938\u2013947)", "Tenryaku (947\u2013957)", "Tentoku (957\u2013961)", "\u014Cwa (961\u2013964)", "K\u014Dh\u014D (964\u2013968)", "Anna (968\u2013970)", "Tenroku (970\u2013973)", "Ten\u2019en (973\u2013976)", "J\u014Dgen (976\u2013978)", "Tengen (978\u2013983)", "Eikan (983\u2013985)", "Kanna (985\u2013987)", "Eien (987\u2013989)", "Eiso (989\u2013990)", "Sh\u014Dryaku (990\u2013995)", "Ch\u014Dtoku (995\u2013999)", "Ch\u014Dh\u014D (999\u20131004)", "Kank\u014D (1004\u20131012)", "Ch\u014Dwa (1012\u20131017)", "Kannin (1017\u20131021)", "Jian (1021\u20131024)", "Manju (1024\u20131028)", "Ch\u014Dgen (1028\u20131037)", "Ch\u014Dryaku (1037\u20131040)", "Ch\u014Dky\u016B (1040\u20131044)", "Kantoku (1044\u20131046)", "Eish\u014D (1046\u20131053)", "Tengi (1053\u20131058)", "K\u014Dhei (1058\u20131065)", "Jiryaku (1065\u20131069)", "Enky\u016B (1069\u20131074)", "Sh\u014Dho (1074\u20131077)", "Sh\u014Dryaku (1077\u20131081)", "Eih\u014D (1081\u20131084)", "\u014Ctoku (1084\u20131087)", "Kanji (1087\u20131094)", "Kah\u014D (1094\u20131096)", "Eich\u014D (1096\u20131097)", "J\u014Dtoku (1097\u20131099)", "K\u014Dwa (1099\u20131104)", "Ch\u014Dji (1104\u20131106)", "Kash\u014D (1106\u20131108)", "Tennin (1108\u20131110)", "Ten-ei (1110-1113)", "Eiky\u016B (1113\u20131118)", "Gen\u2019ei (1118\u20131120)", "H\u014Dan (1120\u20131124)", "Tenji (1124\u20131126)", "Daiji (1126\u20131131)", "Tensh\u014D (1131\u20131132)", "Ch\u014Dsh\u014D (1132\u20131135)", "H\u014Den (1135\u20131141)", "Eiji (1141\u20131142)", "K\u014Dji (1142\u20131144)", "Ten\u2019y\u014D (1144\u20131145)", "Ky\u016Ban (1145\u20131151)", "Ninpei (1151\u20131154)", "Ky\u016Bju (1154\u20131156)", "H\u014Dgen (1156\u20131159)", "Heiji (1159\u20131160)", "Eiryaku (1160\u20131161)", "\u014Cho (1161\u20131163)", "Ch\u014Dkan (1163\u20131165)", "Eiman (1165\u20131166)", "Nin\u2019an (1166\u20131169)", "Ka\u014D (1169\u20131171)", "Sh\u014Dan (1171\u20131175)", "Angen (1175\u20131177)", "Jish\u014D (1177\u20131181)", "Y\u014Dwa (1181\u20131182)", "Juei (1182\u20131184)", "Genryaku (1184\u20131185)", "Bunji (1185\u20131190)", "Kenky\u016B (1190\u20131199)", "Sh\u014Dji (1199\u20131201)", "Kennin (1201\u20131204)", "Genky\u016B (1204\u20131206)", "Ken\u2019ei (1206\u20131207)", "J\u014Dgen (1207\u20131211)", "Kenryaku (1211\u20131213)", "Kenp\u014D (1213\u20131219)", "J\u014Dky\u016B (1219\u20131222)", "J\u014D\u014D (1222\u20131224)", "Gennin (1224\u20131225)", "Karoku (1225\u20131227)", "Antei (1227\u20131229)", "Kanki (1229\u20131232)", "J\u014Dei (1232\u20131233)", "Tenpuku (1233\u20131234)", "Bunryaku (1234\u20131235)", "Katei (1235\u20131238)", "Ryakunin (1238\u20131239)", "En\u2019\u014D (1239\u20131240)", "Ninji (1240\u20131243)", "Kangen (1243\u20131247)", "H\u014Dji (1247\u20131249)", "Kench\u014D (1249\u20131256)", "K\u014Dgen (1256\u20131257)", "Sh\u014Dka (1257\u20131259)", "Sh\u014Dgen (1259\u20131260)", "Bun\u2019\u014D (1260\u20131261)", "K\u014Dch\u014D (1261\u20131264)", "Bun\u2019ei (1264\u20131275)", "Kenji (1275\u20131278)", "K\u014Dan (1278\u20131288)", "Sh\u014D\u014D (1288\u20131293)", "Einin (1293\u20131299)", "Sh\u014Dan (1299\u20131302)", "Kengen (1302\u20131303)", "Kagen (1303\u20131306)", "Tokuji (1306\u20131308)", "Enky\u014D (1308\u20131311)", "\u014Cch\u014D (1311\u20131312)", "Sh\u014Dwa (1312\u20131317)", "Bunp\u014D (1317\u20131319)", "Gen\u014D (1319\u20131321)", "Genk\u014D (1321\u20131324)", "Sh\u014Dch\u016B (1324\u20131326)", "Karyaku (1326\u20131329)", "Gentoku (1329\u20131331)", "Genk\u014D (1331\u20131334)", "Kenmu (1334\u20131336)", "Engen (1336\u20131340)", "K\u014Dkoku (1340\u20131346)", "Sh\u014Dhei (1346\u20131370)", "Kentoku (1370\u20131372)", "Bunch\u016B (1372\u20131375)", "Tenju (1375\u20131379)", "K\u014Dryaku (1379\u20131381)", "K\u014Dwa (1381\u20131384)", "Gench\u016B (1384\u20131392)", "Meitoku (1384\u20131387)", "Kakei (1387\u20131389)", "K\u014D\u014D (1389\u20131390)", "Meitoku (1390\u20131394)", "\u014Cei (1394\u20131428)", "Sh\u014Dch\u014D (1428\u20131429)", "Eiky\u014D (1429\u20131441)", "Kakitsu (1441\u20131444)", "Bun\u2019an (1444\u20131449)", "H\u014Dtoku (1449\u20131452)", "Ky\u014Dtoku (1452\u20131455)", "K\u014Dsh\u014D (1455\u20131457)", "Ch\u014Droku (1457\u20131460)", "Kansh\u014D (1460\u20131466)", "Bunsh\u014D (1466\u20131467)", "\u014Cnin (1467\u20131469)", "Bunmei (1469\u20131487)", "Ch\u014Dky\u014D (1487\u20131489)", "Entoku (1489\u20131492)", "Mei\u014D (1492\u20131501)", "Bunki (1501\u20131504)", "Eish\u014D (1504\u20131521)", "Taiei (1521\u20131528)", "Ky\u014Droku (1528\u20131532)", "Tenbun (1532\u20131555)", "K\u014Dji (1555\u20131558)", "Eiroku (1558\u20131570)", "Genki (1570\u20131573)", "Tensh\u014D (1573\u20131592)", "Bunroku (1592\u20131596)", "Keich\u014D (1596\u20131615)", "Genna (1615\u20131624)", "Kan\u2019ei (1624\u20131644)", "Sh\u014Dho (1644\u20131648)", "Keian (1648\u20131652)", "J\u014D\u014D (1652\u20131655)", "Meireki (1655\u20131658)", "Manji (1658\u20131661)", "Kanbun (1661\u20131673)", "Enp\u014D (1673\u20131681)", "Tenna (1681\u20131684)", "J\u014Dky\u014D (1684\u20131688)", "Genroku (1688\u20131704)", "H\u014Dei (1704\u20131711)", "Sh\u014Dtoku (1711\u20131716)", "Ky\u014Dh\u014D (1716\u20131736)", "Genbun (1736\u20131741)", "Kanp\u014D (1741\u20131744)", "Enky\u014D (1744\u20131748)", "Kan\u2019en (1748\u20131751)", "H\u014Dreki (1751\u20131764)", "Meiwa (1764\u20131772)", "An\u2019ei (1772\u20131781)", "Tenmei (1781\u20131789)", "Kansei (1789\u20131801)", "Ky\u014Dwa (1801\u20131804)", "Bunka (1804\u20131818)", "Bunsei (1818\u20131830)", "Tenp\u014D (1830\u20131844)", "K\u014Dka (1844\u20131848)", "Kaei (1848\u20131854)", "Ansei (1854\u20131860)", "Man\u2019en (1860\u20131861)", "Bunky\u016B (1861\u20131864)", "Genji (1864\u20131865)", "Kei\u014D (1865\u20131868)", "Meiji", "Taish\u014D", "Sh\u014Dwa", "Heisei"], long: ["Taika (645\u2013650)", "Hakuchi (650\u2013671)", "Hakuh\u014D (672\u2013686)", "Shuch\u014D (686\u2013701)", "Taih\u014D (701\u2013704)", "Keiun (704\u2013708)", "Wad\u014D (708\u2013715)", "Reiki (715\u2013717)", "Y\u014Dr\u014D (717\u2013724)", "Jinki (724\u2013729)", "Tenpy\u014D (729\u2013749)", "Tenpy\u014D-kamp\u014D (749-749)", "Tenpy\u014D-sh\u014Dh\u014D (749-757)", "Tenpy\u014D-h\u014Dji (757-765)", "Tenpy\u014D-jingo (765-767)", "Jingo-keiun (767-770)", "H\u014Dki (770\u2013780)", "Ten-\u014D (781-782)", "Enryaku (782\u2013806)", "Daid\u014D (806\u2013810)", "K\u014Dnin (810\u2013824)", "Tench\u014D (824\u2013834)", "J\u014Dwa (834\u2013848)", "Kaj\u014D (848\u2013851)", "Ninju (851\u2013854)", "Saik\u014D (854\u2013857)", "Ten-an (857-859)", "J\u014Dgan (859\u2013877)", "Gangy\u014D (877\u2013885)", "Ninna (885\u2013889)", "Kanpy\u014D (889\u2013898)", "Sh\u014Dtai (898\u2013901)", "Engi (901\u2013923)", "Ench\u014D (923\u2013931)", "J\u014Dhei (931\u2013938)", "Tengy\u014D (938\u2013947)", "Tenryaku (947\u2013957)", "Tentoku (957\u2013961)", "\u014Cwa (961\u2013964)", "K\u014Dh\u014D (964\u2013968)", "Anna (968\u2013970)", "Tenroku (970\u2013973)", "Ten\u2019en (973\u2013976)", "J\u014Dgen (976\u2013978)", "Tengen (978\u2013983)", "Eikan (983\u2013985)", "Kanna (985\u2013987)", "Eien (987\u2013989)", "Eiso (989\u2013990)", "Sh\u014Dryaku (990\u2013995)", "Ch\u014Dtoku (995\u2013999)", "Ch\u014Dh\u014D (999\u20131004)", "Kank\u014D (1004\u20131012)", "Ch\u014Dwa (1012\u20131017)", "Kannin (1017\u20131021)", "Jian (1021\u20131024)", "Manju (1024\u20131028)", "Ch\u014Dgen (1028\u20131037)", "Ch\u014Dryaku (1037\u20131040)", "Ch\u014Dky\u016B (1040\u20131044)", "Kantoku (1044\u20131046)", "Eish\u014D (1046\u20131053)", "Tengi (1053\u20131058)", "K\u014Dhei (1058\u20131065)", "Jiryaku (1065\u20131069)", "Enky\u016B (1069\u20131074)", "Sh\u014Dho (1074\u20131077)", "Sh\u014Dryaku (1077\u20131081)", "Eih\u014D (1081\u20131084)", "\u014Ctoku (1084\u20131087)", "Kanji (1087\u20131094)", "Kah\u014D (1094\u20131096)", "Eich\u014D (1096\u20131097)", "J\u014Dtoku (1097\u20131099)", "K\u014Dwa (1099\u20131104)", "Ch\u014Dji (1104\u20131106)", "Kash\u014D (1106\u20131108)", "Tennin (1108\u20131110)", "Ten-ei (1110-1113)", "Eiky\u016B (1113\u20131118)", "Gen\u2019ei (1118\u20131120)", "H\u014Dan (1120\u20131124)", "Tenji (1124\u20131126)", "Daiji (1126\u20131131)", "Tensh\u014D (1131\u20131132)", "Ch\u014Dsh\u014D (1132\u20131135)", "H\u014Den (1135\u20131141)", "Eiji (1141\u20131142)", "K\u014Dji (1142\u20131144)", "Ten\u2019y\u014D (1144\u20131145)", "Ky\u016Ban (1145\u20131151)", "Ninpei (1151\u20131154)", "Ky\u016Bju (1154\u20131156)", "H\u014Dgen (1156\u20131159)", "Heiji (1159\u20131160)", "Eiryaku (1160\u20131161)", "\u014Cho (1161\u20131163)", "Ch\u014Dkan (1163\u20131165)", "Eiman (1165\u20131166)", "Nin\u2019an (1166\u20131169)", "Ka\u014D (1169\u20131171)", "Sh\u014Dan (1171\u20131175)", "Angen (1175\u20131177)", "Jish\u014D (1177\u20131181)", "Y\u014Dwa (1181\u20131182)", "Juei (1182\u20131184)", "Genryaku (1184\u20131185)", "Bunji (1185\u20131190)", "Kenky\u016B (1190\u20131199)", "Sh\u014Dji (1199\u20131201)", "Kennin (1201\u20131204)", "Genky\u016B (1204\u20131206)", "Ken\u2019ei (1206\u20131207)", "J\u014Dgen (1207\u20131211)", "Kenryaku (1211\u20131213)", "Kenp\u014D (1213\u20131219)", "J\u014Dky\u016B (1219\u20131222)", "J\u014D\u014D (1222\u20131224)", "Gennin (1224\u20131225)", "Karoku (1225\u20131227)", "Antei (1227\u20131229)", "Kanki (1229\u20131232)", "J\u014Dei (1232\u20131233)", "Tenpuku (1233\u20131234)", "Bunryaku (1234\u20131235)", "Katei (1235\u20131238)", "Ryakunin (1238\u20131239)", "En\u2019\u014D (1239\u20131240)", "Ninji (1240\u20131243)", "Kangen (1243\u20131247)", "H\u014Dji (1247\u20131249)", "Kench\u014D (1249\u20131256)", "K\u014Dgen (1256\u20131257)", "Sh\u014Dka (1257\u20131259)", "Sh\u014Dgen (1259\u20131260)", "Bun\u2019\u014D (1260\u20131261)", "K\u014Dch\u014D (1261\u20131264)", "Bun\u2019ei (1264\u20131275)", "Kenji (1275\u20131278)", "K\u014Dan (1278\u20131288)", "Sh\u014D\u014D (1288\u20131293)", "Einin (1293\u20131299)", "Sh\u014Dan (1299\u20131302)", "Kengen (1302\u20131303)", "Kagen (1303\u20131306)", "Tokuji (1306\u20131308)", "Enky\u014D (1308\u20131311)", "\u014Cch\u014D (1311\u20131312)", "Sh\u014Dwa (1312\u20131317)", "Bunp\u014D (1317\u20131319)", "Gen\u014D (1319\u20131321)", "Genk\u014D (1321\u20131324)", "Sh\u014Dch\u016B (1324\u20131326)", "Karyaku (1326\u20131329)", "Gentoku (1329\u20131331)", "Genk\u014D (1331\u20131334)", "Kenmu (1334\u20131336)", "Engen (1336\u20131340)", "K\u014Dkoku (1340\u20131346)", "Sh\u014Dhei (1346\u20131370)", "Kentoku (1370\u20131372)", "Bunch\u016B (1372\u20131375)", "Tenju (1375\u20131379)", "K\u014Dryaku (1379\u20131381)", "K\u014Dwa (1381\u20131384)", "Gench\u016B (1384\u20131392)", "Meitoku (1384\u20131387)", "Kakei (1387\u20131389)", "K\u014D\u014D (1389\u20131390)", "Meitoku (1390\u20131394)", "\u014Cei (1394\u20131428)", "Sh\u014Dch\u014D (1428\u20131429)", "Eiky\u014D (1429\u20131441)", "Kakitsu (1441\u20131444)", "Bun\u2019an (1444\u20131449)", "H\u014Dtoku (1449\u20131452)", "Ky\u014Dtoku (1452\u20131455)", "K\u014Dsh\u014D (1455\u20131457)", "Ch\u014Droku (1457\u20131460)", "Kansh\u014D (1460\u20131466)", "Bunsh\u014D (1466\u20131467)", "\u014Cnin (1467\u20131469)", "Bunmei (1469\u20131487)", "Ch\u014Dky\u014D (1487\u20131489)", "Entoku (1489\u20131492)", "Mei\u014D (1492\u20131501)", "Bunki (1501\u20131504)", "Eish\u014D (1504\u20131521)", "Taiei (1521\u20131528)", "Ky\u014Droku (1528\u20131532)", "Tenbun (1532\u20131555)", "K\u014Dji (1555\u20131558)", "Eiroku (1558\u20131570)", "Genki (1570\u20131573)", "Tensh\u014D (1573\u20131592)", "Bunroku (1592\u20131596)", "Keich\u014D (1596\u20131615)", "Genna (1615\u20131624)", "Kan\u2019ei (1624\u20131644)", "Sh\u014Dho (1644\u20131648)", "Keian (1648\u20131652)", "J\u014D\u014D (1652\u20131655)", "Meireki (1655\u20131658)", "Manji (1658\u20131661)", "Kanbun (1661\u20131673)", "Enp\u014D (1673\u20131681)", "Tenna (1681\u20131684)", "J\u014Dky\u014D (1684\u20131688)", "Genroku (1688\u20131704)", "H\u014Dei (1704\u20131711)", "Sh\u014Dtoku (1711\u20131716)", "Ky\u014Dh\u014D (1716\u20131736)", "Genbun (1736\u20131741)", "Kanp\u014D (1741\u20131744)", "Enky\u014D (1744\u20131748)", "Kan\u2019en (1748\u20131751)", "H\u014Dreki (1751\u20131764)", "Meiwa (1764\u20131772)", "An\u2019ei (1772\u20131781)", "Tenmei (1781\u20131789)", "Kansei (1789\u20131801)", "Ky\u014Dwa (1801\u20131804)", "Bunka (1804\u20131818)", "Bunsei (1818\u20131830)", "Tenp\u014D (1830\u20131844)", "K\u014Dka (1844\u20131848)", "Kaei (1848\u20131854)", "Ansei (1854\u20131860)", "Man\u2019en (1860\u20131861)", "Bunky\u016B (1861\u20131864)", "Genji (1864\u20131865)", "Kei\u014D (1865\u20131868)", "Meiji", "Taish\u014D", "Sh\u014Dwa", "Heisei"] }, dayPeriods: { am: "AM", pm: "PM" } }, persian: { months: { narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], short: ["Farvardin", "Ordibehesht", "Khordad", "Tir", "Mordad", "Shahrivar", "Mehr", "Aban", "Azar", "Dey", "Bahman", "Esfand"], long: ["Farvardin", "Ordibehesht", "Khordad", "Tir", "Mordad", "Shahrivar", "Mehr", "Aban", "Azar", "Dey", "Bahman", "Esfand"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["AP"], short: ["AP"], long: ["AP"] }, dayPeriods: { am: "AM", pm: "PM" } }, roc: { months: { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, days: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, eras: { narrow: ["Before R.O.C.", "Minguo"], short: ["Before R.O.C.", "Minguo"], long: ["Before R.O.C.", "Minguo"] }, dayPeriods: { am: "AM", pm: "PM" } } } }, number: { nu: ["latn"], patterns: { decimal: { positivePattern: "{number}", negativePattern: "{minusSign}{number}" }, currency: { positivePattern: "{currency}{number}", negativePattern: "{minusSign}{currency}{number}" }, percent: { positivePattern: "{number}{percentSign}", negativePattern: "{minusSign}{number}{percentSign}" } }, symbols: { latn: { decimal: ".", group: ",", nan: "NaN", plusSign: "+", minusSign: "-", percentSign: "%", infinity: "\u221E" } }, currencies: { AUD: "A$", BRL: "R$", CAD: "CA$", CNY: "CN\xA5", EUR: "\u20AC", GBP: "\xA3", HKD: "HK$", ILS: "\u20AA", INR: "\u20B9", JPY: "\xA5", KRW: "\u20A9", MXN: "MX$", NZD: "NZ$", TWD: "NT$", USD: "$", VND: "\u20AB", XAF: "FCFA", XCD: "EC$", XOF: "CFA", XPF: "CFPF" } } });
  }
});

// ../../../../../node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "../../../../../node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect !== "undefined") {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        }
        function makeExporter(target, previous) {
          return function(key, value) {
            Object.defineProperty(target, key, { configurable: true, writable: true, value });
            if (previous)
              previous(key, value);
          };
        }
        function functionThis() {
          try {
            return Function("return this;")();
          } catch (_) {
          }
        }
        function indirectEvalThis() {
          try {
            return (void 0, eval)("(function() { return this; })()");
          } catch (_) {
          }
        }
        function sloppyModeThis() {
          return functionThis() || indirectEvalThis();
        }
      })(function(exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map2, key) {
            return hasOwn.call(map2, key);
          } : function(map2, key) {
            return key in map2;
          },
          get: downLevel ? function(map2, key) {
            return hasOwn.call(map2, key) ? map2[key] : void 0;
          } : function(map2, key) {
            return map2[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var provider = GetMetadataProvider(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function OrdinaryHasMetadata(MetadataKey, O2, P2) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O2);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P2);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O2, P2));
        }
        function OrdinaryGetMetadata(MetadataKey, O2, P2) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
          var parent = OrdinaryGetPrototypeOf(O2);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P2);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return;
          return provider.OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*Create*/
            true
          );
          provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2);
        }
        function OrdinaryMetadataKeys(O2, P2) {
          var ownKeys = OrdinaryOwnMetadataKeys(O2, P2);
          var parent = OrdinaryGetPrototypeOf(O2);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P2);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O2, P2) {
          var provider = GetMetadataProvider(
            O2,
            P2,
            /*create*/
            false
          );
          if (!provider) {
            return [];
          }
          return provider.OrdinaryOwnMetadataKeys(O2, P2);
        }
        function Type2(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input2, PreferredType) {
          switch (Type2(input2)) {
            case 0:
              return input2;
            case 1:
              return input2;
            case 2:
              return input2;
            case 3:
              return input2;
            case 4:
              return input2;
            case 5:
              return input2;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input2, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result2 = exoticToPrim.call(input2, hint);
            if (IsObject(result2))
              throw new TypeError();
            return result2;
          }
          return OrdinaryToPrimitive(input2, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O2, hint) {
          if (hint === "string") {
            var toString_1 = O2.toString;
            if (IsCallable(toString_1)) {
              var result2 = toString_1.call(O2);
              if (!IsObject(result2))
                return result2;
            }
            var valueOf = O2.valueOf;
            if (IsCallable(valueOf)) {
              var result2 = valueOf.call(O2);
              if (!IsObject(result2))
                return result2;
            }
          } else {
            var valueOf = O2.valueOf;
            if (IsCallable(valueOf)) {
              var result2 = valueOf.call(O2);
              if (!IsObject(result2))
                return result2;
            }
            var toString_2 = O2.toString;
            if (IsCallable(toString_2)) {
              var result2 = toString_2.call(O2);
              if (!IsObject(result2))
                return result2;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type2(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function SameValueZero(x, y2) {
          return x === y2 || x !== x && y2 !== y2;
        }
        function GetMethod(V, P2) {
          var func = V[P2];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result2 = iterator.next();
          return result2.done ? false : result2;
        }
        function IteratorClose(iterator) {
          var f4 = iterator["return"];
          if (f4)
            f4.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O2) {
          var proto = Object.getPrototypeOf(O2);
          if (typeof O2 !== "function" || O2 === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O2.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O2)
            return proto;
          return constructor;
        }
        function CreateMetadataRegistry() {
          var fallback;
          if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
            fallback = CreateFallbackProvider(root.Reflect);
          }
          var first;
          var second;
          var rest;
          var targetProviderMap = new _WeakMap();
          var registry = {
            registerProvider,
            getProvider: getProvider3,
            setProvider
          };
          return registry;
          function registerProvider(provider) {
            if (!Object.isExtensible(registry)) {
              throw new Error("Cannot add provider to a frozen registry.");
            }
            switch (true) {
              case fallback === provider:
                break;
              case IsUndefined(first):
                first = provider;
                break;
              case first === provider:
                break;
              case IsUndefined(second):
                second = provider;
                break;
              case second === provider:
                break;
              default:
                if (rest === void 0)
                  rest = new _Set();
                rest.add(provider);
                break;
            }
          }
          function getProviderNoCache(O2, P2) {
            if (!IsUndefined(first)) {
              if (first.isProviderFor(O2, P2))
                return first;
              if (!IsUndefined(second)) {
                if (second.isProviderFor(O2, P2))
                  return first;
                if (!IsUndefined(rest)) {
                  var iterator = GetIterator(rest);
                  while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                      return void 0;
                    }
                    var provider = IteratorValue(next);
                    if (provider.isProviderFor(O2, P2)) {
                      IteratorClose(iterator);
                      return provider;
                    }
                  }
                }
              }
            }
            if (!IsUndefined(fallback) && fallback.isProviderFor(O2, P2)) {
              return fallback;
            }
            return void 0;
          }
          function getProvider3(O2, P2) {
            var providerMap = targetProviderMap.get(O2);
            var provider;
            if (!IsUndefined(providerMap)) {
              provider = providerMap.get(P2);
            }
            if (!IsUndefined(provider)) {
              return provider;
            }
            provider = getProviderNoCache(O2, P2);
            if (!IsUndefined(provider)) {
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O2, providerMap);
              }
              providerMap.set(P2, provider);
            }
            return provider;
          }
          function hasProvider(provider) {
            if (IsUndefined(provider))
              throw new TypeError();
            return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
          }
          function setProvider(O2, P2, provider) {
            if (!hasProvider(provider)) {
              throw new Error("Metadata provider not registered.");
            }
            var existingProvider = getProvider3(O2, P2);
            if (existingProvider !== provider) {
              if (!IsUndefined(existingProvider)) {
                return false;
              }
              var providerMap = targetProviderMap.get(O2);
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O2, providerMap);
              }
              providerMap.set(P2, provider);
            }
            return true;
          }
        }
        function GetOrCreateMetadataRegistry() {
          var metadataRegistry2;
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            metadataRegistry2 = root.Reflect[registrySymbol];
          }
          if (IsUndefined(metadataRegistry2)) {
            metadataRegistry2 = CreateMetadataRegistry();
          }
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            Object.defineProperty(root.Reflect, registrySymbol, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: metadataRegistry2
            });
          }
          return metadataRegistry2;
        }
        function CreateMetadataProvider(registry) {
          var metadata2 = new _WeakMap();
          var provider = {
            isProviderFor: function(O2, P2) {
              var targetMetadata = metadata2.get(O2);
              if (IsUndefined(targetMetadata))
                return false;
              return targetMetadata.has(P2);
            },
            OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
            OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
            OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
            OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
            OrdinaryDeleteMetadata
          };
          metadataRegistry.registerProvider(provider);
          return provider;
          function GetOrCreateMetadataMap(O2, P2, Create) {
            var targetMetadata = metadata2.get(O2);
            var createdTargetMetadata = false;
            if (IsUndefined(targetMetadata)) {
              if (!Create)
                return void 0;
              targetMetadata = new _Map();
              metadata2.set(O2, targetMetadata);
              createdTargetMetadata = true;
            }
            var metadataMap = targetMetadata.get(P2);
            if (IsUndefined(metadataMap)) {
              if (!Create)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P2, metadataMap);
              if (!registry.setProvider(O2, P2, provider)) {
                targetMetadata.delete(P2);
                if (createdTargetMetadata) {
                  metadata2.delete(O2);
                }
                throw new Error("Wrong provider for target.");
              }
            }
            return metadataMap;
          }
          function OrdinaryHasOwnMetadata2(MetadataKey, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          function OrdinaryGetOwnMetadata2(MetadataKey, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          function OrdinaryOwnMetadataKeys2(O2, P2) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys.length = k;
                return keys;
              }
              var nextValue = IteratorValue(next);
              try {
                keys[k] = nextValue;
              } catch (e3) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e3;
                }
              }
              k++;
            }
          }
          function OrdinaryDeleteMetadata(MetadataKey, O2, P2) {
            var metadataMap = GetOrCreateMetadataMap(
              O2,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            if (!metadataMap.delete(MetadataKey))
              return false;
            if (metadataMap.size === 0) {
              var targetMetadata = metadata2.get(O2);
              if (!IsUndefined(targetMetadata)) {
                targetMetadata.delete(P2);
                if (targetMetadata.size === 0) {
                  metadata2.delete(targetMetadata);
                }
              }
            }
            return true;
          }
        }
        function CreateFallbackProvider(reflect) {
          var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
          var metadataOwner = new _WeakMap();
          var provider = {
            isProviderFor: function(O2, P2) {
              var metadataPropertySet = metadataOwner.get(O2);
              if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P2)) {
                return true;
              }
              if (getOwnMetadataKeys2(O2, P2).length) {
                if (IsUndefined(metadataPropertySet)) {
                  metadataPropertySet = new _Set();
                  metadataOwner.set(O2, metadataPropertySet);
                }
                metadataPropertySet.add(P2);
                return true;
              }
              return false;
            },
            OrdinaryDefineOwnMetadata: defineMetadata2,
            OrdinaryHasOwnMetadata: hasOwnMetadata2,
            OrdinaryGetOwnMetadata: getOwnMetadata2,
            OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
            OrdinaryDeleteMetadata: deleteMetadata2
          };
          return provider;
        }
        function GetMetadataProvider(O2, P2, Create) {
          var registeredProvider = metadataRegistry.getProvider(O2, P2);
          if (!IsUndefined(registeredProvider)) {
            return registeredProvider;
          }
          if (Create) {
            if (metadataRegistry.setProvider(O2, P2, metadataProvider)) {
              return metadataProvider;
            }
            throw new Error("Illegal state.");
          }
          return void 0;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result2 = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result2, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error2) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error2;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          var Map2 = (
            /** @class */
            function() {
              function Map3() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map3.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map3.prototype.has = function(key) {
                return this._find(
                  key,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map3.prototype.get = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map3.prototype.set = function(key, value) {
                var index = this._find(
                  key,
                  /*insert*/
                  true
                );
                this._values[index] = value;
                return this;
              };
              Map3.prototype.delete = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i2 = index + 1; i2 < size; i2++) {
                    this._keys[i2 - 1] = this._keys[i2];
                    this._values[i2 - 1] = this._values[i2];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (SameValueZero(key, this._cacheKey)) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map3.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map3.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map3.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue5);
              };
              Map3.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map3.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map3.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map3.prototype._find = function(key, insert) {
                if (!SameValueZero(this._cacheKey, key)) {
                  this._cacheIndex = -1;
                  for (var i2 = 0; i2 < this._keys.length; i2++) {
                    if (SameValueZero(this._keys[i2], key)) {
                      this._cacheIndex = i2;
                      break;
                    }
                  }
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map3;
            }()
          );
          return Map2;
          function getKey(key, _) {
            return key;
          }
          function getValue5(_, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          var Set2 = (
            /** @class */
            function() {
              function Set3() {
                this._map = new _Map();
              }
              Object.defineProperty(Set3.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set3.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set3.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set3.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set3.prototype.clear = function() {
                this._map.clear();
              };
              Set3.prototype.keys = function() {
                return this._map.keys();
              };
              Set3.prototype.values = function() {
                return this._map.keys();
              };
              Set3.prototype.entries = function() {
                return this._map.entries();
              };
              Set3.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set3.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set3;
            }()
          );
          return Set2;
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.has(table, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.get(table, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? delete table[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            }()
          );
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i2 = 0; i2 < size; ++i2)
              buffer[i2] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              var array = new Uint8Array(size);
              if (typeof crypto !== "undefined") {
                crypto.getRandomValues(array);
              } else if (typeof msCrypto !== "undefined") {
                msCrypto.getRandomValues(array);
              } else {
                FillRandomBytes(array, size);
              }
              return array;
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result2 = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result2 += "-";
              if (byte < 16)
                result2 += "0";
              result2 += byte.toString(16).toLowerCase();
            }
            return result2;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/azle/node_modules/http-message-parser/http-message-parser.js
var require_http_message_parser = __commonJS({
  "node_modules/azle/node_modules/http-message-parser/http-message-parser.js"(exports4, module) {
    var Buffer4 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
    function httpMessageParser2(message) {
      const result2 = {
        httpVersion: null,
        statusCode: null,
        statusMessage: null,
        method: null,
        url: null,
        headers: null,
        body: null,
        boundary: null,
        multipart: null
      };
      var messageString = "";
      var headerNewlineIndex = 0;
      var fullBoundary = null;
      if (httpMessageParser2._isBuffer(message)) {
        messageString = message.toString();
      } else if (typeof message === "string") {
        messageString = message;
        message = httpMessageParser2._createBuffer(messageString);
      } else {
        return result2;
      }
      messageString = messageString.replace(/\r\n/gim, "\n");
      (function() {
        const firstNonWhitespaceRegex = /[\w-]+/gim;
        const firstNonWhitespaceIndex = messageString.search(firstNonWhitespaceRegex);
        if (firstNonWhitespaceIndex > 0) {
          message = message.slice(firstNonWhitespaceIndex, message.length);
          messageString = message.toString();
        }
      })();
      (function() {
        const possibleRequestLine = messageString.split(/\n|\r\n/)[0];
        const requestLineMatch = possibleRequestLine.match(httpMessageParser2._requestLineRegex);
        if (Array.isArray(requestLineMatch) && requestLineMatch.length > 1) {
          result2.httpVersion = parseFloat(requestLineMatch[1]);
          result2.statusCode = parseInt(requestLineMatch[2]);
          result2.statusMessage = requestLineMatch[3];
        } else {
          const responseLineMath = possibleRequestLine.match(httpMessageParser2._responseLineRegex);
          if (Array.isArray(responseLineMath) && responseLineMath.length > 1) {
            result2.method = responseLineMath[1];
            result2.url = responseLineMath[2];
            result2.httpVersion = parseFloat(responseLineMath[3]);
          }
        }
      })();
      (function() {
        headerNewlineIndex = messageString.search(httpMessageParser2._headerNewlineRegex);
        if (headerNewlineIndex > -1) {
          headerNewlineIndex = headerNewlineIndex + 1;
        } else {
          if (result2.httpVersion) {
            headerNewlineIndex = messageString.length;
          }
        }
        const headersString = messageString.substr(0, headerNewlineIndex);
        const headers = httpMessageParser2._parseHeaders(headersString);
        if (Object.keys(headers).length > 0) {
          result2.headers = headers;
        }
      })();
      (function() {
        if (!result2.boundary) {
          const boundaryMatch = messageString.match(httpMessageParser2._boundaryRegex);
          if (Array.isArray(boundaryMatch) && boundaryMatch.length) {
            fullBoundary = boundaryMatch[0].replace(/[\r\n]+/gi, "");
            const boundary = fullBoundary.replace(/^--/, "");
            result2.boundary = boundary;
          }
        }
      })();
      (function() {
        var start = headerNewlineIndex;
        var end = message.length;
        const firstBoundaryIndex = messageString.indexOf(fullBoundary);
        if (firstBoundaryIndex > -1) {
          start = headerNewlineIndex;
          end = firstBoundaryIndex;
        }
        if (headerNewlineIndex > -1) {
          const body2 = messageString.slice(start, end);
          if (body2 && body2.length) {
            result2.body = body2;
          }
        }
      })();
      (function() {
        if (result2.boundary) {
          const multipartStart = messageString.indexOf(fullBoundary) + fullBoundary.length;
          const multipartEnd = messageString.lastIndexOf(fullBoundary);
          const multipartBody = messageString.substr(multipartStart, multipartEnd);
          const splitRegex = new RegExp("^" + fullBoundary + ".*[\n\r]?$", "gm");
          const parts = multipartBody.split(splitRegex);
          result2.multipart = parts.filter(httpMessageParser2._isTruthy).map(function(part, i2) {
            const result3 = {
              headers: null,
              body: null,
              meta: {
                body: {
                  byteOffset: {
                    start: null,
                    end: null
                  }
                }
              }
            };
            const newlineRegex = /\n\n|\r\n\r\n/gim;
            var newlineIndex = 0;
            var newlineMatch = newlineRegex.exec(part);
            var body2 = null;
            if (newlineMatch) {
              newlineIndex = newlineMatch.index;
              if (newlineMatch.index <= 0) {
                newlineMatch = newlineRegex.exec(part);
                if (newlineMatch) {
                  newlineIndex = newlineMatch.index;
                }
              }
            }
            const possibleHeadersString = part.substr(0, newlineIndex);
            var startOffset = null;
            var endOffset = null;
            if (newlineIndex > -1) {
              const headers = httpMessageParser2._parseHeaders(possibleHeadersString);
              if (Object.keys(headers).length > 0) {
                result3.headers = headers;
                var boundaryIndexes = [];
                for (var j = 0; j >= 0; ) {
                  j = message.indexOf(fullBoundary, j);
                  if (j >= 0) {
                    boundaryIndexes.push(j);
                    j += fullBoundary.length;
                  }
                }
                var boundaryNewlineIndexes = [];
                boundaryIndexes.slice(0, boundaryIndexes.length - 1).forEach(function(m2, k) {
                  const partBody = message.slice(boundaryIndexes[k], boundaryIndexes[k + 1]).toString();
                  var headerNewlineIndex2 = partBody.search(/\n\n|\r\n\r\n/gim) + 2;
                  headerNewlineIndex2 = boundaryIndexes[k] + headerNewlineIndex2;
                  boundaryNewlineIndexes.push(headerNewlineIndex2);
                });
                startOffset = boundaryNewlineIndexes[i2];
                endOffset = boundaryIndexes[i2 + 1];
                body2 = message.slice(startOffset, endOffset);
              } else {
                body2 = part;
              }
            } else {
              body2 = part;
            }
            result3.body = body2;
            result3.meta.body.byteOffset.start = startOffset;
            result3.meta.body.byteOffset.end = endOffset;
            return result3;
          });
        }
      })();
      return result2;
    }
    httpMessageParser2._isTruthy = function _isTruthy(v2) {
      return !!v2;
    };
    httpMessageParser2._isNumeric = function _isNumeric(v2) {
      if (typeof v2 === "number" && !isNaN(v2)) {
        return true;
      }
      v2 = (v2 || "").toString().trim();
      if (!v2) {
        return false;
      }
      return !isNaN(v2);
    };
    httpMessageParser2._isBuffer = function(item) {
      return httpMessageParser2._isNodeBufferSupported() && typeof global === "object" && global.Buffer.isBuffer(item) || item instanceof Object && item._isBuffer;
    };
    httpMessageParser2._isNodeBufferSupported = function() {
      return typeof global === "object" && typeof global.Buffer === "function" && typeof global.Buffer.isBuffer === "function";
    };
    httpMessageParser2._parseHeaders = function _parseHeaders(body2) {
      const headers = {};
      if (typeof body2 !== "string") {
        return headers;
      }
      body2.split(/[\r\n]/).forEach(function(string) {
        const match = string.match(/([\w-]+):\s*(.*)/i);
        if (Array.isArray(match) && match.length === 3) {
          const key = match[1];
          const value = match[2];
          headers[key] = httpMessageParser2._isNumeric(value) ? Number(value) : value;
        }
      });
      return headers;
    };
    httpMessageParser2._requestLineRegex = /HTTP\/(1\.0|1\.1|2\.0)\s+(\d+)\s+([\w\s-_]+)/i;
    httpMessageParser2._responseLineRegex = /(GET|POST|PUT|DELETE|PATCH|OPTIONS|HEAD|TRACE|CONNECT)\s+(.*)\s+HTTP\/(1\.0|1\.1|2\.0)/i;
    httpMessageParser2._headerNewlineRegex = /^[\r\n]+/gim;
    httpMessageParser2._boundaryRegex = /(\n|\r\n)+--[\w-]+(\n|\r\n)+/g;
    httpMessageParser2._createBuffer = function(data) {
      return new Buffer4(data);
    };
    httpMessageParser2._isInBrowser = function() {
      return !(typeof process === "object" && process + "" === "[object process]");
    };
    if (httpMessageParser2._isInBrowser) {
      if (typeof window === "object") {
        window.httpMessageParser = httpMessageParser2;
      }
    }
    if (typeof exports4 !== "undefined") {
      if (typeof module !== "undefined" && module.exports) {
        exports4 = module.exports = httpMessageParser2;
      }
      exports4.httpMessageParser = httpMessageParser2;
    } else if (typeof define === "function" && define.amd) {
      define([], function() {
        return httpMessageParser2;
      });
    }
  }
});

// node_modules/azle/src/stable/lib/state.ts
globalThis._azleDispatch = (action) => {
  if (globalThis.process !== void 0 && globalThis.process.env.AZLE_LOG_ACTIONS === "true") {
    log(action);
  }
  if (globalThis.process !== void 0 && globalThis.process.env.AZLE_RECORD_ACTIONS === "true") {
    globalThis._azleActions?.push(action);
  }
  if (action.type === "DELETE_AZLE_REJECT_CALLBACK") {
    delete globalThis._azleRejectCallbacks[action.payload];
    return;
  }
  if (action.type === "DELETE_AZLE_RESOLVE_CALLBACK") {
    delete globalThis._azleResolveCallbacks[action.payload];
    return;
  }
  if (action.type === "DELETE_AZLE_TIMER_CALLBACK") {
    delete globalThis._azleTimerCallbacks[action.payload.toString()];
    return;
  }
  if (action.type === "SET_AZLE_CANISTER_CLASS_META") {
    globalThis._azleCanisterClassMeta = action.payload;
    return;
  }
  if (action.type === "SET_AZLE_CANISTER_METHOD_NAMES") {
    globalThis._azleCanisterMethodNames = action.payload;
    return;
  }
  if (action.type === "SET_AZLE_ICP_REPLICA_WASM_ENVIRONMENT") {
    globalThis._azleIcpReplicaWasmEnvironment = action.payload;
    return;
  }
  if (action.type === "SET_AZLE_REJECT_CALLBACK") {
    globalThis._azleRejectCallbacks[action.payload.globalRejectId] = action.payload.rejectCallback;
    return;
  }
  if (action.type === "SET_AZLE_RESOLVE_CALLBACK") {
    globalThis._azleResolveCallbacks[action.payload.globalResolveId] = action.payload.resolveCallback;
    return;
  }
  if (action.type === "SET_AZLE_TIMER_CALLBACK") {
    globalThis._azleTimerCallbacks[action.payload.timerId.toString()] = action.payload.timerCallback;
    return;
  }
  if (action.type === "SET_CONSOLE") {
    globalThis.console = action.payload;
    return;
  }
  if (action.type === "SET_CRYPTO") {
    globalThis.crypto = action.payload;
    return;
  }
  if (action.type === "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY") {
    Object.defineProperty(globalThis, action.payload, {
      get() {
        throw new Error(experimentalWarningMessage(action.payload));
      },
      configurable: true
    });
    return;
  }
  if (action.type === "SET_TEXT_DECODER") {
    globalThis.TextDecoder = action.payload;
    return;
  }
  if (action.type === "SET_TEXT_ENCODER") {
    globalThis.TextEncoder = action.payload;
    return;
  }
};
function experimentalWarningMessage(name) {
  return `Azle: experimental mode must be enabled to use global ${name}. You can enable experimental mode in your dfx.json file like this:
{
    "canisters": {
        "canisterName": {
            "type": "azle",
            "main": "index.ts",
            "custom": {
                "experimental": true
            }
        }
    }
}
`;
}

// node_modules/azle/src/stable/lib/globals.ts
var import_text_encoding2 = __toESM(require_text_encoding(), 1);

// node_modules/azle/node_modules/@dfinity/principal/lib/esm/utils/base32.js
var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
var lookupTable = /* @__PURE__ */ Object.create(null);
for (let i2 = 0; i2 < alphabet.length; i2++) {
  lookupTable[alphabet[i2]] = i2;
}
lookupTable["0"] = lookupTable.o;
lookupTable["1"] = lookupTable.i;
function encode(input2) {
  let skip = 0;
  let bits = 0;
  let output3 = "";
  function encodeByte(byte) {
    if (skip < 0) {
      bits |= byte >> -skip;
    } else {
      bits = byte << skip & 248;
    }
    if (skip > 3) {
      skip -= 8;
      return 1;
    }
    if (skip < 4) {
      output3 += alphabet[bits >> 3];
      skip += 5;
    }
    return 0;
  }
  for (let i2 = 0; i2 < input2.length; ) {
    i2 += encodeByte(input2[i2]);
  }
  return output3 + (skip < 0 ? alphabet[bits >> 3] : "");
}
function decode(input2) {
  let skip = 0;
  let byte = 0;
  const output3 = new Uint8Array(input2.length * 4 / 3 | 0);
  let o3 = 0;
  function decodeChar(char) {
    let val = lookupTable[char.toLowerCase()];
    if (val === void 0) {
      throw new Error(`Invalid character: ${JSON.stringify(char)}`);
    }
    val <<= 3;
    byte |= val >>> skip;
    skip += 5;
    if (skip >= 8) {
      output3[o3++] = byte;
      skip -= 8;
      if (skip > 0) {
        byte = val << 5 - skip & 255;
      } else {
        byte = 0;
      }
    }
  }
  for (const c2 of input2) {
    decodeChar(c2);
  }
  return output3.slice(0, o3);
}

// node_modules/azle/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js
var lookUpTable = new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
function getCrc32(buf) {
  const b4 = new Uint8Array(buf);
  let crc = -1;
  for (let i2 = 0; i2 < b4.length; i2++) {
    const byte = b4[i2];
    const t2 = (byte ^ crc) & 255;
    crc = lookUpTable[t2] ^ crc >>> 8;
  }
  return (crc ^ -1) >>> 0;
}

// node_modules/azle/node_modules/@noble/hashes/esm/_assert.js
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes(b4, ...lengths) {
  if (!isBytes(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}

// node_modules/azle/node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// node_modules/azle/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l2 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l2, wl, isLE3);
}
var Chi = (a2, b4, c2) => a2 & b4 ^ ~a2 & c2;
var Maj = (a2, b4, c2) => a2 & b4 ^ a2 & c2 ^ b4 & c2;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/azle/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F: F2, G, H } = this;
    return [A, B, C, D, E, F2, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F2, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F: F2, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T15 = H + sigma1 + Chi(E, F2, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T23 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F2;
      F2 = E;
      E = D + T15 | 0;
      D = C;
      C = B;
      B = A;
      A = T15 + T23 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F2, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());

// node_modules/azle/node_modules/@dfinity/principal/lib/esm/utils/sha224.js
function sha2242(data) {
  return sha224.create().update(new Uint8Array(data)).digest();
}

// node_modules/azle/node_modules/@dfinity/principal/lib/esm/index.js
var JSON_KEY_PRINCIPAL = "__principal__";
var SELF_AUTHENTICATING_SUFFIX = 2;
var ANONYMOUS_SUFFIX = 4;
var MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR = "aaaaa-aa";
var fromHexString = (hexString) => {
  var _a;
  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map((byte) => parseInt(byte, 16)));
};
var toHexString = (bytes4) => bytes4.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
var Principal = class _Principal {
  constructor(_arr) {
    this._arr = _arr;
    this._isPrincipal = true;
  }
  static anonymous() {
    return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
  }
  /**
   * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`
   * @returns {Principal} principal of the management canister
   */
  static managementCanister() {
    return this.fromText(MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR);
  }
  static selfAuthenticating(publicKey) {
    const sha = sha2242(publicKey);
    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));
  }
  static from(other) {
    if (typeof other === "string") {
      return _Principal.fromText(other);
    } else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {
      return new _Principal(other);
    } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
      return new _Principal(other._arr);
    }
    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
  }
  static fromHex(hex) {
    return new this(fromHexString(hex));
  }
  static fromText(text3) {
    let maybePrincipal = text3;
    if (text3.includes(JSON_KEY_PRINCIPAL)) {
      const obj = JSON.parse(text3);
      if (JSON_KEY_PRINCIPAL in obj) {
        maybePrincipal = obj[JSON_KEY_PRINCIPAL];
      }
    }
    const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, "");
    let arr = decode(canisterIdNoDash);
    arr = arr.slice(4, arr.length);
    const principal = new this(arr);
    if (principal.toText() !== maybePrincipal) {
      throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${maybePrincipal}" may not be a valid Principal ID).`);
    }
    return principal;
  }
  static fromUint8Array(arr) {
    return new this(arr);
  }
  isAnonymous() {
    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
  }
  toUint8Array() {
    return this._arr;
  }
  toHex() {
    return toHexString(this._arr).toUpperCase();
  }
  toText() {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, getCrc32(this._arr));
    const checksum3 = new Uint8Array(checksumArrayBuf);
    const bytes4 = Uint8Array.from(this._arr);
    const array = new Uint8Array([...checksum3, ...bytes4]);
    const result2 = encode(array);
    const matches = result2.match(/.{1,5}/g);
    if (!matches) {
      throw new Error();
    }
    return matches.join("-");
  }
  toString() {
    return this.toText();
  }
  /**
   * Serializes to JSON
   * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string
   */
  toJSON() {
    return { [JSON_KEY_PRINCIPAL]: this.toText() };
  }
  /**
   * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification
   * @param {Principal} other - a {@link Principal} to compare
   * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than
   */
  compareTo(other) {
    for (let i2 = 0; i2 < Math.min(this._arr.length, other._arr.length); i2++) {
      if (this._arr[i2] < other._arr[i2])
        return "lt";
      else if (this._arr[i2] > other._arr[i2])
        return "gt";
    }
    if (this._arr.length < other._arr.length)
      return "lt";
    if (this._arr.length > other._arr.length)
      return "gt";
    return "eq";
  }
  /**
   * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method
   * @param other a {@link Principal} to compare
   * @returns {boolean} boolean
   */
  ltEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "lt" || cmp == "eq";
  }
  /**
   * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method
   * @param other a {@link Principal} to compare
   * @returns {boolean} boolean
   */
  gtEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "gt" || cmp == "eq";
  }
};

// node_modules/azle/src/stable/lib/stable_structures/stable_json.ts
var import_text_encoding = __toESM(require_text_encoding(), 1);

// node_modules/azle/src/stable/lib/json.ts
function jsonStringify(value, replacer, space) {
  return JSON.stringify(value, replacer ?? jsonReplacer, space);
}
function jsonParse(text3, reviver) {
  try {
    return JSON.parse(text3, reviver ?? jsonReviver);
  } catch (error2) {
    throw new Error(
      `jsonParse: Error parsing JSON: ${error2.message}. text: ${text3}`
    );
  }
}

// node_modules/azle/src/stable/lib/stable_structures/stable_json.ts
function StableJson(options) {
  const textEncoder = new import_text_encoding.TextEncoder();
  const textDecoder = new import_text_encoding.TextDecoder();
  return {
    toBytes(data) {
      return textEncoder.encode(jsonStringify(data, options?.replacer));
    },
    fromBytes(bytes4) {
      return jsonParse(textDecoder.decode(bytes4), options?.reviver);
    }
  };
}
var stableJson = StableJson();
function jsonReplacer(_key, value) {
  if (typeof value === "undefined") {
    return {
      __undefined__: "__undefined__"
    };
  }
  if (typeof value === "bigint") {
    return {
      __bigint__: value.toString()
    };
  }
  if (typeof value === "object" && value !== null && value._isPrincipal === true) {
    return {
      __principal__: value.toString()
    };
  }
  if (typeof value === "number" && isNaN(value)) {
    return {
      __nan__: "__nan__"
    };
  }
  if (typeof value === "number" && value === Infinity) {
    return {
      __infinity__: "__infinity__"
    };
  }
  if (typeof value === "number" && value === -Infinity) {
    return {
      __negative_infinity__: "__negative_infinity__"
    };
  }
  if (typeof value === "number" && Object.is(value, -0)) {
    return {
      __negative_zero__: "__negative_zero__"
    };
  }
  if (value instanceof Int8Array) {
    return {
      __int8array__: Array.from(value)
    };
  }
  if (value instanceof Int16Array) {
    return {
      __int16array__: Array.from(value)
    };
  }
  if (value instanceof Int32Array) {
    return {
      __int32array__: Array.from(value)
    };
  }
  if (value instanceof BigInt64Array) {
    return {
      __bigint64array__: Array.from(value)
    };
  }
  if (value instanceof Uint8Array) {
    return {
      __uint8array__: Array.from(value)
    };
  }
  if (value instanceof Uint16Array) {
    return {
      __uint16array__: Array.from(value)
    };
  }
  if (value instanceof Uint32Array) {
    return {
      __uint32array__: Array.from(value)
    };
  }
  if (value instanceof BigUint64Array) {
    return {
      __biguint64array__: Array.from(value)
    };
  }
  if (value instanceof Float32Array) {
    return {
      __float32array__: Array.from(value)
    };
  }
  if (value instanceof Float64Array) {
    return {
      __float64array__: Array.from(value)
    };
  }
  if (value instanceof Map) {
    return {
      __map__: Array.from(value.entries())
    };
  }
  if (value instanceof Set) {
    return {
      __set__: Array.from(value)
    };
  }
  return value;
}
function jsonReviver(_key, value) {
  if (typeof value === "object" && value !== null) {
    if (typeof value.__undefined__ === "string") {
      return void 0;
    }
    if (typeof value.__bigint__ === "string") {
      return BigInt(value.__bigint__);
    }
    if (typeof value.__principal__ === "string") {
      return Principal.fromText(value.__principal__);
    }
    if (value.__nan__ === "__nan__") {
      return NaN;
    }
    if (value.__infinity__ === "__infinity__") {
      return Infinity;
    }
    if (value.__negative_infinity__ === "__negative_infinity__") {
      return -Infinity;
    }
    if (value.__negative_zero__ === "__negative_zero__") {
      return -0;
    }
    if (Array.isArray(value.__int8array__)) {
      return Int8Array.from(value.__int8array__);
    }
    if (Array.isArray(value.__int16array__)) {
      return Int16Array.from(value.__int16array__);
    }
    if (Array.isArray(value.__int32array__)) {
      return Int32Array.from(value.__int32array__);
    }
    if (Array.isArray(value.__bigint64array__)) {
      return BigInt64Array.from(value.__bigint64array__);
    }
    if (Array.isArray(value.__uint8array__)) {
      return Uint8Array.from(value.__uint8array__);
    }
    if (Array.isArray(value.__uint16array__)) {
      return Uint16Array.from(value.__uint16array__);
    }
    if (Array.isArray(value.__uint32array__)) {
      return Uint32Array.from(value.__uint32array__);
    }
    if (Array.isArray(value.__biguint64array__)) {
      return BigUint64Array.from(value.__biguint64array__);
    }
    if (Array.isArray(value.__float32array__)) {
      return Float32Array.from(value.__float32array__);
    }
    if (Array.isArray(value.__float64array__)) {
      return Float64Array.from(value.__float64array__);
    }
    if (Array.isArray(value.__map__)) {
      return new Map(value.__map__);
    }
    if (Array.isArray(value.__set__)) {
      return new Set(value.__set__);
    }
  }
  return value;
}

// node_modules/azle/src/stable/lib/globals.ts
if (globalThis._azleIcpReplicaWasmEnvironment === true || globalThis._azleNodejsWasmEnvironment === true) {
  globalThis._azleDispatch({
    type: "SET_TEXT_DECODER",
    payload: import_text_encoding2.TextDecoder,
    location: {
      filepath: "azle/src/stable/lib/global.ts",
      functionName: ""
    }
  });
  globalThis._azleDispatch({
    type: "SET_TEXT_ENCODER",
    payload: import_text_encoding2.TextEncoder,
    location: {
      filepath: "azle/src/stable/lib/global.ts",
      functionName: ""
    }
  });
  globalThis._azleDispatch({
    type: "SET_CRYPTO",
    payload: {
      ...globalThis.crypto,
      getRandomValues: (array) => {
        if (array instanceof Int8Array === false && array instanceof Uint8Array === false && array instanceof Uint8ClampedArray === false && array instanceof Int16Array === false && array instanceof Uint16Array === false && array instanceof Int32Array === false && array instanceof Uint32Array === false && array instanceof BigInt64Array === false && array instanceof BigUint64Array === false) {
          throw new TypeError(
            "Expected an Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, BigInt64Array, or BigUint64Array"
          );
        }
        const byteLength = array.byteLength;
        if (byteLength === 0) {
          return array;
        }
        if (byteLength > 65536) {
          throw new Error(
            `QuotaExceeded: array cannot be larger than 65_536 bytes`
          );
        }
        const bytes4 = globalThis._azleIc !== void 0 ? globalThis._azleIc.randBytes(byteLength) : globalThis._azleIcExperimental !== void 0 ? new Uint8Array(
          globalThis._azleIcExperimental.randBytes(
            byteLength
          )
        ) : (() => {
          throw new Error(
            `Neither globalThis._azleIc nor globalThis._azleIcExperimental are defined`
          );
        })();
        let targetView = new Uint8Array(
          array.buffer,
          array.byteOffset,
          byteLength
        );
        targetView.set(bytes4);
        return array;
      }
    },
    location: {
      filepath: "azle/src/stable/lib/global.ts",
      functionName: ""
    }
  });
  globalThis._azleDispatch({
    type: "SET_CONSOLE",
    payload: {
      ...globalThis.console,
      log,
      error: log,
      warn: log,
      info: log
    },
    location: {
      filepath: "azle/src/stable/lib/global.ts",
      functionName: ""
    }
  });
  if (globalThis._azleExperimental === false) {
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "fetch",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "Buffer",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "window",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "global",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "self",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "URL",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "WebAssembly",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "setTimeout",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
    globalThis._azleDispatch({
      type: "SET_GLOBAL_EXPERIMENTAL_ERROR_PROPERTY",
      payload: "clearTimeout",
      location: {
        filepath: "azle/src/stable/lib/global.ts",
        functionName: ""
      }
    });
  }
}
function log(...args2) {
  const jsonStringifiedArgs = args2.map((arg) => {
    if (arg instanceof Error) {
      return `${arg.name}: ${arg.message} at ${arg.stack}`;
    } else {
      return JSON.stringify(arg, jsonReplacer, 4);
    }
  }).join(" ");
  if (globalThis._azleIc !== void 0) {
    return globalThis._azleIc.debugPrint(jsonStringifiedArgs);
  } else if (globalThis._azleIcExperimental !== void 0) {
    return globalThis._azleIcExperimental.debugPrint(jsonStringifiedArgs);
  }
  throw new Error(`No global debugPrint implementation found`);
}

// node_modules/azle/src/experimental/lib/assert_experimental.ts
if (globalThis._azleExperimental !== true) {
  throw new Error(experimentalMessage());
}
function experimentalMessage() {
  return `Azle: experimental mode must be enabled to import from azle/experimental. You can enable experimental mode in your dfx.json file like this:
{
    "canisters": {
        "canisterName": {
            "type": "azle",
            "main": "index.ts",
            "custom": {
                "experimental": true
            }
        }
    }
}
`;
}

// node_modules/azle/src/experimental/lib/globals.ts
var import_text_encoding3 = __toESM(require_text_encoding(), 1);
init_buffer();

// ../../../../../../node_modules/wasmedge_quickjs/modules/process.js
var process_exports = {};
__export(process_exports, {
  _debugEnd: () => _debugEnd,
  _debugProcess: () => _debugProcess,
  _events: () => _events,
  _eventsCount: () => _eventsCount,
  _exiting: () => _exiting,
  _fatalExceptions: () => _fatalExceptions,
  _getActiveHandles: () => _getActiveHandles,
  _getActiveRequests: () => _getActiveRequests,
  _kill: () => _kill,
  _linkedBinding: () => _linkedBinding,
  _maxListeners: () => _maxListeners,
  _preload_modules: () => _preload_modules,
  _rawDebug: () => _rawDebug,
  _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
  _tickCallback: () => _tickCallback,
  abort: () => abort,
  addListener: () => addListener,
  allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
  arch: () => arch,
  argv: () => argv,
  argv0: () => argv0,
  assert: () => assert2,
  binding: () => binding,
  chdir: () => chdir,
  config: () => config,
  cpuUsage: () => cpuUsage,
  cwd: () => cwd,
  debugPort: () => debugPort,
  default: () => process2,
  dlopen: () => dlopen,
  domain: () => domain,
  emit: () => emit,
  emitWarning: () => emitWarning,
  env: () => env2,
  execArgv: () => execArgv,
  execPath: () => execPath,
  exit: () => exit,
  features: () => features,
  hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
  hrtime: () => hrtime,
  kill: () => kill,
  listeners: () => listeners,
  memoryUsage: () => memoryUsage,
  moduleLoadList: () => moduleLoadList,
  nextTick: () => nextTick2,
  off: () => off,
  on: () => on,
  once: () => once,
  openStdin: () => openStdin,
  pid: () => pid,
  platform: () => platform,
  ppid: () => ppid,
  prependListener: () => prependListener,
  prependOnceListener: () => prependOnceListener,
  reallyExit: () => reallyExit,
  release: () => release,
  removeAllListeners: () => removeAllListeners,
  removeListener: () => removeListener,
  resourceUsage: () => resourceUsage,
  setSourceMapsEnabled: () => setSourceMapsEnabled,
  setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
  stderr: () => stderr,
  stdin: () => stdin,
  stdout: () => stdout,
  title: () => title,
  umask: () => umask,
  uptime: () => uptime,
  version: () => version,
  versions: () => versions
});
function unimplemented(name) {
  throw new Error("Node.js process " + name + " is not supported");
}
var title = "wasmedge_quickjs";
var arch = "wasm";
var platform = "wasi";
var env2 = globalThis.env;
var argv = globalThis.argv;
var execArgv = [];
var version = "v16.8.0";
var versions = {};
var emitWarning = function(message, type) {
  console.warn((type ? type + ": " : "") + message);
};
var binding = function(name) {
  unimplemented("binding");
};
var umask = function(mask3) {
  return 0;
};
var cwd = function() {
  return "./";
};
var chdir = function(dir) {
  unimplemented("chdir");
};
var release = {
  name: "wasmedge_quickjs",
  sourceUrl: "",
  headersUrl: "",
  libUrl: ""
};
function noop() {
}
var _rawDebug = noop;
var moduleLoadList = [];
function _linkedBinding(name) {
  unimplemented("_linkedBinding");
}
var domain = {};
var _exiting = false;
var config = {};
function dlopen(name) {
  unimplemented("dlopen");
}
function _getActiveRequests() {
  return [];
}
function _getActiveHandles() {
  return [];
}
var reallyExit = noop;
var _kill = noop;
var cpuUsage = function() {
  return {};
};
var resourceUsage = cpuUsage;
var memoryUsage = cpuUsage;
var kill = noop;
var exit = globalThis.exit;
var openStdin = noop;
var allowedNodeEnvironmentFlags = {};
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "assertion error");
  }
}
var features = {
  inspector: false,
  debug: false,
  uv: false,
  ipv6: false,
  tls_alpn: false,
  tls_sni: false,
  tls_ocsp: false,
  tls: false,
  cached_builtins: true
};
var _fatalExceptions = noop;
var setUncaughtExceptionCaptureCallback = noop;
function hasUncaughtExceptionCaptureCallback() {
  return false;
}
var _tickCallback = noop;
var _debugProcess = noop;
var _debugEnd = noop;
var _startProfilerIdleNotifier = noop;
var _stopProfilerIdleNotifier = noop;
var stdout = void 0;
var stderr = void 0;
var stdin = void 0;
var abort = noop;
var pid = 2;
var ppid = 1;
var execPath = "wasmedge-quickjs";
var debugPort = 9229;
var argv0 = "wasmedge-quickjs";
var _preload_modules = [];
var setSourceMapsEnabled = noop;
var _performance = {
  now: void 0,
  timing: void 0
};
if (_performance.now === void 0) {
  nowOffset = Date.now();
  if (_performance.timing && _performance.timing.navigationStart) {
    nowOffset = _performance.timing.navigationStart;
  }
  _performance.now = function() {
    return Date.now() - nowOffset;
  };
}
var nowOffset;
function uptime() {
  return _performance.now() / 1e3;
}
var nanoPerSec = 1e9;
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
hrtime.bigint = function(time2) {
  var diff = hrtime(time2);
  if (typeof BigInt === "undefined") {
    return diff[0] * nanoPerSec + diff[1];
  }
  return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
};
var _maxListeners = 10;
var _events = {};
var _eventsCount = 0;
function on() {
  return process2;
}
var addListener = on;
var once = on;
var off = on;
var removeListener = on;
var removeAllListeners = on;
var emit = noop;
var prependListener = on;
var prependOnceListener = on;
function listeners(name) {
  return [];
}
var process2 = {
  version,
  versions,
  arch,
  platform,
  release,
  _rawDebug,
  moduleLoadList,
  binding,
  _linkedBinding,
  _events,
  _eventsCount,
  _maxListeners,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  prependListener,
  prependOnceListener,
  listeners,
  domain,
  _exiting,
  config,
  dlopen,
  uptime,
  _getActiveRequests,
  _getActiveHandles,
  reallyExit,
  _kill,
  cpuUsage,
  resourceUsage,
  memoryUsage,
  kill,
  exit,
  openStdin,
  allowedNodeEnvironmentFlags,
  assert: assert2,
  features,
  _fatalExceptions,
  setUncaughtExceptionCaptureCallback,
  hasUncaughtExceptionCaptureCallback,
  emitWarning,
  nextTick: globalThis.nextTick,
  _tickCallback,
  _debugProcess,
  _debugEnd,
  _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier,
  stdout,
  stdin,
  stderr,
  abort,
  umask,
  chdir,
  cwd,
  env: env2,
  title,
  argv,
  execArgv,
  pid,
  ppid,
  execPath,
  debugPort,
  hrtime,
  argv0,
  _preload_modules,
  setSourceMapsEnabled
};
var nextTick2 = globalThis.nextTick;

// ../../../../../../node_modules/wasmedge_quickjs/modules/punycode.js
var punycode_exports = {};
__export(punycode_exports, {
  decode: () => decode2,
  default: () => punycode_default,
  encode: () => encode2,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, fn) {
  const result2 = [];
  let length = array.length;
  while (length--) {
    result2[length] = fn(array[length]);
  }
  return result2;
}
function mapDomain(string, fn) {
  const parts = string.split("@");
  let result2 = "";
  if (parts.length > 1) {
    result2 = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map(labels, fn).join(".");
  return result2 + encoded;
}
function ucs2decode(string) {
  const output3 = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output3.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output3.push(value);
        counter--;
      }
    } else {
      output3.push(value);
    }
  }
  return output3;
}
var ucs2encode = (array) => String.fromCodePoint(...array);
var basicToDigit = function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode2 = function(input2) {
  const output3 = [];
  const inputLength = input2.length;
  let i2 = 0;
  let n5 = initialN;
  let bias = initialBias;
  let basic = input2.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input2.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output3.push(input2.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    let oldi = i2;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input2.charCodeAt(index++));
      if (digit >= base || digit > floor((maxInt - i2) / w)) {
        error("overflow");
      }
      i2 += digit * w;
      const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output3.length + 1;
    bias = adapt(i2 - oldi, out, oldi == 0);
    if (floor(i2 / out) > maxInt - n5) {
      error("overflow");
    }
    n5 += floor(i2 / out);
    i2 %= out;
    output3.splice(i2++, 0, n5);
  }
  return String.fromCodePoint(...output3);
};
var encode2 = function(input2) {
  const output3 = [];
  input2 = ucs2decode(input2);
  let inputLength = input2.length;
  let n5 = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input2) {
    if (currentValue < 128) {
      output3.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output3.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output3.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input2) {
      if (currentValue >= n5 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n5 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m2 - n5) * handledCPCountPlusOne;
    n5 = m2;
    for (const currentValue of input2) {
      if (currentValue < n5 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n5) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t2) {
            break;
          }
          const qMinusT = q - t2;
          const baseMinusT = base - t2;
          output3.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output3.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n5;
  }
  return output3.join("");
};
var toUnicode = function(input2) {
  return mapDomain(input2, function(string) {
    return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII = function(input2) {
  return mapDomain(input2, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode2,
  "encode": encode2,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_default = punycode;

// ../../../../../../node_modules/wasmedge_quickjs/modules/querystring.js
var querystring_exports = {};
__export(querystring_exports, {
  decode: () => decode3,
  default: () => o,
  encode: () => encode3,
  parse: () => parse,
  stringify: () => stringify
});
function e(e3, n5) {
  return Object.prototype.hasOwnProperty.call(e3, n5);
}
var n = function(n5, r3, t2, o3) {
  r3 = r3 || "&", t2 = t2 || "=";
  var a2 = {};
  if ("string" != typeof n5 || 0 === n5.length) {
    return a2;
  }
  var u2 = /\+/g;
  n5 = n5.split(r3);
  var c2 = 1e3;
  o3 && "number" == typeof o3.maxKeys && (c2 = o3.maxKeys);
  var i2 = n5.length;
  c2 > 0 && i2 > c2 && (i2 = c2);
  for (var s = 0; s < i2; ++s) {
    var p3, f4, d, y2, m2 = n5[s].replace(u2, "%20"), l2 = m2.indexOf(t2);
    l2 >= 0 ? (p3 = m2.substr(0, l2), f4 = m2.substr(l2 + 1)) : (p3 = m2, f4 = ""), d = decodeURIComponent(p3), y2 = decodeURIComponent(f4), e(a2, d) ? Array.isArray(a2[d]) ? a2[d].push(y2) : a2[d] = [a2[d], y2] : a2[d] = y2;
  }
  return a2;
};
var r = function(e3) {
  switch (typeof e3) {
    case "string":
      return e3;
    case "boolean":
      return e3 ? "true" : "false";
    case "number":
      return isFinite(e3) ? e3 : "";
    default:
      return "";
  }
};
var t = function(e3, n5, t2, o3) {
  return n5 = n5 || "&", t2 = t2 || "=", null === e3 && (e3 = void 0), "object" == typeof e3 ? Object.keys(e3).map(function(o4) {
    var a2 = encodeURIComponent(r(o4)) + t2;
    return Array.isArray(e3[o4]) ? e3[o4].map(function(e4) {
      return a2 + encodeURIComponent(r(e4));
    }).join(n5) : a2 + encodeURIComponent(r(e3[o4]));
  }).join(n5) : o3 ? encodeURIComponent(r(o3)) + t2 + encodeURIComponent(r(e3)) : "";
};
var o = {};
o.decode = o.parse = n, o.encode = o.stringify = t;
o.decode;
o.encode;
o.parse;
o.stringify;
o.decode;
o.encode;
o.parse;
o.stringify;
var decode3 = o.decode;
var encode3 = o.encode;
var parse = o.parse;
var stringify = o.stringify;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/errors.js
var errors_exports = {};
__export(errors_exports, {
  AbortError: () => AbortError2,
  AggregateError: () => AggregateError,
  ERR_AMBIGUOUS_ARGUMENT: () => ERR_AMBIGUOUS_ARGUMENT,
  ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED: () => ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED,
  ERR_CRYPTO_ENGINE_UNKNOWN: () => ERR_CRYPTO_ENGINE_UNKNOWN,
  ERR_CRYPTO_FIPS_FORCED: () => ERR_CRYPTO_FIPS_FORCED,
  ERR_CRYPTO_HASH_FINALIZED: () => ERR_CRYPTO_HASH_FINALIZED,
  ERR_CRYPTO_HASH_UPDATE_FAILED: () => ERR_CRYPTO_HASH_UPDATE_FAILED,
  ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS: () => ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,
  ERR_CRYPTO_INVALID_DIGEST: () => ERR_CRYPTO_INVALID_DIGEST,
  ERR_CRYPTO_INVALID_JWK: () => ERR_CRYPTO_INVALID_JWK,
  ERR_CRYPTO_INVALID_KEYLEN: () => ERR_CRYPTO_INVALID_KEYLEN,
  ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE: () => ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
  ERR_CRYPTO_INVALID_STATE: () => ERR_CRYPTO_INVALID_STATE,
  ERR_CRYPTO_SCRYPT_INVALID_PARAMETER: () => ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,
  ERR_CRYPTO_SCRYPT_NOT_SUPPORTED: () => ERR_CRYPTO_SCRYPT_NOT_SUPPORTED,
  ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH: () => ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH,
  ERR_CRYPTO_UNKNOWN_CIPHER: () => ERR_CRYPTO_UNKNOWN_CIPHER,
  ERR_DIR_CLOSED: () => ERR_DIR_CLOSED,
  ERR_DIR_CONCURRENT_OPERATION: () => ERR_DIR_CONCURRENT_OPERATION,
  ERR_FS_CP_DIR_TO_NON_DIR: () => ERR_FS_CP_DIR_TO_NON_DIR,
  ERR_FS_CP_EEXIST: () => ERR_FS_CP_EEXIST,
  ERR_FS_CP_EINVAL: () => ERR_FS_CP_EINVAL,
  ERR_FS_CP_FIFO_PIPE: () => ERR_FS_CP_FIFO_PIPE,
  ERR_FS_CP_NON_DIR_TO_DIR: () => ERR_FS_CP_NON_DIR_TO_DIR,
  ERR_FS_CP_SOCKET: () => ERR_FS_CP_SOCKET,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY: () => ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
  ERR_FS_CP_UNKNOWN: () => ERR_FS_CP_UNKNOWN,
  ERR_FS_EISDIR: () => ERR_FS_EISDIR,
  ERR_FS_FILE_TOO_LARGE: () => ERR_FS_FILE_TOO_LARGE,
  ERR_FS_INVALID_SYMLINK_TYPE: () => ERR_FS_INVALID_SYMLINK_TYPE,
  ERR_HTTP_HEADERS_SENT: () => ERR_HTTP_HEADERS_SENT,
  ERR_HTTP_INVALID_HEADER_VALUE: () => ERR_HTTP_INVALID_HEADER_VALUE,
  ERR_HTTP_TRAILER_INVALID: () => ERR_HTTP_TRAILER_INVALID,
  ERR_ILLEGAL_CONSTRUCTOR: () => ERR_ILLEGAL_CONSTRUCTOR,
  ERR_INCOMPATIBLE_OPTION_PAIR: () => ERR_INCOMPATIBLE_OPTION_PAIR,
  ERR_INVALID_ARG_TYPE: () => ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_TYPE_RANGE: () => ERR_INVALID_ARG_TYPE_RANGE,
  ERR_INVALID_ARG_VALUE: () => ERR_INVALID_ARG_VALUE,
  ERR_INVALID_ARG_VALUE_RANGE: () => ERR_INVALID_ARG_VALUE_RANGE,
  ERR_INVALID_CALLBACK: () => ERR_INVALID_CALLBACK,
  ERR_INVALID_CHAR: () => ERR_INVALID_CHAR,
  ERR_INVALID_HTTP_TOKEN: () => ERR_INVALID_HTTP_TOKEN,
  ERR_INVALID_RETURN_VALUE: () => ERR_INVALID_RETURN_VALUE,
  ERR_METHOD_NOT_IMPLEMENTED: () => ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MISSING_ARGS: () => ERR_MISSING_ARGS,
  ERR_MISSING_OPTION: () => ERR_MISSING_OPTION,
  ERR_MULTIPLE_CALLBACK: () => ERR_MULTIPLE_CALLBACK,
  ERR_OPERATION_FAILED: () => ERR_OPERATION_FAILED,
  ERR_OUT_OF_RANGE: () => ERR_OUT_OF_RANGE,
  ERR_SOCKET_BAD_PORT: () => ERR_SOCKET_BAD_PORT,
  ERR_STREAM_ALREADY_FINISHED: () => ERR_STREAM_ALREADY_FINISHED,
  ERR_STREAM_CANNOT_PIPE: () => ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED: () => ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES: () => ERR_STREAM_NULL_VALUES,
  ERR_STREAM_PREMATURE_CLOSE: () => ERR_STREAM_PREMATURE_CLOSE,
  ERR_STREAM_PUSH_AFTER_EOF: () => ERR_STREAM_PUSH_AFTER_EOF,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT: () => ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
  ERR_STREAM_WRITE_AFTER_END: () => ERR_STREAM_WRITE_AFTER_END,
  ERR_UNAVAILABLE_DURING_EXIT: () => ERR_UNAVAILABLE_DURING_EXIT,
  ERR_UNKNOWN_ENCODING: () => ERR_UNKNOWN_ENCODING,
  NodeErrorAbstraction: () => NodeErrorAbstraction,
  aggregateTwoErrors: () => aggregateTwoErrors,
  captureStackTrace: () => captureStackTrace,
  hideStackFrames: () => hideStackFrames,
  isErrorStackTraceLimitWritable: () => isErrorStackTraceLimitWritable,
  uvException: () => uvException
});

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/util/types.js
var types_exports = {};
__export(types_exports, {
  isAnyArrayBuffer: () => isAnyArrayBuffer,
  isArgumentsObject: () => isArgumentsObject,
  isArrayBuffer: () => isArrayBuffer,
  isArrayBufferView: () => isArrayBufferView,
  isAsyncFunction: () => isAsyncFunction,
  isBigInt64Array: () => isBigInt64Array,
  isBigIntObject: () => isBigIntObject,
  isBigUint64Array: () => isBigUint64Array,
  isBooleanObject: () => isBooleanObject,
  isBoxedPrimitive: () => isBoxedPrimitive,
  isDataView: () => isDataView,
  isDate: () => isDate,
  isFloat32Array: () => isFloat32Array,
  isFloat64Array: () => isFloat64Array,
  isGeneratorFunction: () => isGeneratorFunction,
  isGeneratorObject: () => isGeneratorObject,
  isInt16Array: () => isInt16Array,
  isInt32Array: () => isInt32Array,
  isInt8Array: () => isInt8Array,
  isMap: () => isMap,
  isMapIterator: () => isMapIterator,
  isModuleNamespaceObject: () => isModuleNamespaceObject,
  isNativeError: () => isNativeError,
  isNumberObject: () => isNumberObject,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isSetIterator: () => isSetIterator,
  isSharedArrayBuffer: () => isSharedArrayBuffer,
  isStringObject: () => isStringObject,
  isSymbolObject: () => isSymbolObject,
  isTypedArray: () => isTypedArray,
  isUint16Array: () => isUint16Array,
  isUint32Array: () => isUint32Array,
  isUint8Array: () => isUint8Array,
  isUint8ClampedArray: () => isUint8ClampedArray,
  isWeakMap: () => isWeakMap,
  isWeakSet: () => isWeakSet
});
var _toString = Object.prototype.toString;
var _isObjectLike = (value) => value !== null && typeof value === "object";
var _isFunctionLike = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
  return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
  return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
function isArrayBufferView(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Int32Array]";
}
function isTypedArray(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike(value) && reTypedTag.test(_toString.call(value));
}
function isUint8Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Uint32Array]";
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/validators.js
function validatePort(port, name = "Port", allowZero = true) {
  if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && port.trim().length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
  }
  return port;
}
var validateFunction = hideStackFrames(
  (value, name) => {
    if (typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
  }
);
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean") {
    throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
}
var validateAbortSignal2 = hideStackFrames(
  (signal, name) => {
    if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  }
);
var validateObject = hideStackFrames((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateCallback = hideStackFrames((callback) => {
  if (typeof callback !== "function") {
    throw new ERR_INVALID_CALLBACK(callback);
  }
});
function isInt32(value) {
  return value === (value | 0);
}
function isUint32(value) {
  return value === value >>> 0;
}
var validateInt32 = hideStackFrames(
  (value, name, min2 = -2147483648, max = 2147483647) => {
    if (!isInt32(value)) {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!Number.isInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      throw new ERR_OUT_OF_RANGE(name, `>= ${min2} && <= ${max}`, value);
    }
    if (value < min2 || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min2} && <= ${max}`, value);
    }
  }
);
var validateUint32 = hideStackFrames(
  (value, name, positive) => {
    if (!isUint32(value)) {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!Number.isInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min2 = positive ? 1 : 0;
      throw new ERR_OUT_OF_RANGE(
        name,
        `>= ${min2} && < 4294967296`,
        value
      );
    }
    if (positive && value === 0) {
      throw new ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
  }
);
var validateInteger = hideStackFrames(
  (value, name, min2 = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min2 || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `an integer >= ${min2} && <= ${max}`, value);
    }
  }
);
var getValidMode = hideStackFrames((mode, type) => {
  let min2 = kMinimumAccessMode;
  let max = kMaximumAccessMode;
  let def = F_OK;
  if (type === "copyFile") {
    min2 = kMinimumCopyMode;
    max = kMaximumCopyMode;
    def = mode || kDefaultCopyMode;
  } else {
  }
  if (mode == null) {
    return def;
  }
  if (Number.isInteger(mode) && mode >= min2 && mode <= max) {
    return mode;
  }
  if (typeof mode !== "number") {
    throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode);
  }
  throw new ERR_OUT_OF_RANGE(
    "mode",
    `an integer >= ${min2} && <= ${max}`,
    mode
  );
});
var validateArray = hideStackFrames((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateOneOf = hideStackFrames((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(
      Array.prototype.map.call(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String(v2)),
      ", "
    );
    const reason = "must be one of: " + allowed;
    throw new ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal_binding/util.js
var ALL_PROPERTIES = 0;
var ONLY_WRITABLE = 1;
var ONLY_ENUMERABLE = 2;
var ONLY_CONFIGURABLE = 4;
var SKIP_STRINGS = 8;
var SKIP_SYMBOLS = 16;
var isNumericLookup = {};
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result2 = isNumericLookup[value];
      if (result2 !== void 0) {
        return result2;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      let i2 = 0;
      for (; i2 < length; ++i2) {
        ch = value.charCodeAt(i2);
        if (i2 === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties(obj, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj)
  ];
  if (Array.isArray(obj)) {
    allProperties = allProperties.filter((k) => !isArrayIndex(k));
  }
  if (filter === ALL_PROPERTIES) {
    return allProperties;
  }
  const result2 = [];
  for (const key of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj, key);
    if (desc === void 0) {
      continue;
    }
    if (filter & ONLY_WRITABLE && !desc.writable) {
      continue;
    }
    if (filter & ONLY_ENUMERABLE && !desc.enumerable) {
      continue;
    }
    if (filter & ONLY_CONFIGURABLE && !desc.configurable) {
      continue;
    }
    if (filter & SKIP_STRINGS && typeof key === "string") {
      continue;
    }
    if (filter & SKIP_SYMBOLS && typeof key === "symbol") {
      continue;
    }
    result2.push(key);
  }
  return result2;
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/util/inspect.js
var kObjectType = 0;
var kArrayType = 1;
var kArrayExtrasType = 2;
var kMinLineLength = 16;
var kWeak = 0;
var kIterator = 1;
var kMapEntries = 2;
var kPending = 0;
var kRejected = 2;
var meta = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  // x07
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  // x0F
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  // x17
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  // x1F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // x2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // x3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // x4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // x5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // x6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  // x7F
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  // x87
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  // x8F
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  // x97
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
  // x9F
];
var isUndetectableObject = (v2) => typeof v2 === "undefined" && v2 !== void 0;
var strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key of Object.keys(ret)) {
      if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
        delete ret[key];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string") return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    maxStringLength: inspectDefaultOptions.maxStringLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i2 = 0; i2 < optKeys.length; ++i2) {
        const key = optKeys[i2];
        if (
          // deno-lint-ignore no-prototype-builtins
          inspectDefaultOptions.hasOwnProperty(key) || key === "stylize"
        ) {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
  return formatValue(ctx, value, 0);
}
var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
  get() {
    return inspectDefaultOptions;
  },
  set(options) {
    validateObject(options, "options");
    return Object.assign(inspectDefaultOptions, options);
  }
});
var defaultFG = 39;
var defaultBG = 49;
inspect.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  // Alias: faint
  italic: [3, 23],
  underline: [4, 24],
  blink: [5, 25],
  // Swap foreground and background colors
  inverse: [7, 27],
  // Alias: swapcolors, swapColors
  hidden: [8, 28],
  // Alias: conceal
  strikethrough: [9, 29],
  // Alias: strikeThrough, crossedout, crossedOut
  doubleunderline: [21, 24],
  // Alias: doubleUnderline
  black: [30, defaultFG],
  red: [31, defaultFG],
  green: [32, defaultFG],
  yellow: [33, defaultFG],
  blue: [34, defaultFG],
  magenta: [35, defaultFG],
  cyan: [36, defaultFG],
  white: [37, defaultFG],
  bgBlack: [40, defaultBG],
  bgRed: [41, defaultBG],
  bgGreen: [42, defaultBG],
  bgYellow: [43, defaultBG],
  bgBlue: [44, defaultBG],
  bgMagenta: [45, defaultBG],
  bgCyan: [46, defaultBG],
  bgWhite: [47, defaultBG],
  framed: [51, 54],
  overlined: [53, 55],
  gray: [90, defaultFG],
  // Alias: grey, blackBright
  redBright: [91, defaultFG],
  greenBright: [92, defaultFG],
  yellowBright: [93, defaultFG],
  blueBright: [94, defaultFG],
  magentaBright: [95, defaultFG],
  cyanBright: [96, defaultFG],
  whiteBright: [97, defaultFG],
  bgGray: [100, defaultBG],
  // Alias: bgGrey, bgBlackBright
  bgRedBright: [101, defaultBG],
  bgGreenBright: [102, defaultBG],
  bgYellowBright: [103, defaultBG],
  bgBlueBright: [104, defaultBG],
  bgMagentaBright: [105, defaultBG],
  bgCyanBright: [106, defaultBG],
  bgWhiteBright: [107, defaultBG]
});
function defineColorAlias(target, alias) {
  Object.defineProperty(inspect.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  // "name": intentionally not styling
  // TODO(BridgeAR): Highlight regular expressions properly.
  regexp: "red",
  module: "underline"
});
function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn = (str) => meta[str.charCodeAt(0)];
function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }
  let result2 = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i2 = 0; i2 < lastIndex; i2++) {
    const point = str.charCodeAt(i2);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i2) {
        result2 += meta[point];
      } else {
        result2 += `${str.slice(last, i2)}${meta[point]}`;
      }
      last = i2 + 1;
    }
  }
  if (last !== lastIndex) {
    result2 += str.slice(last);
  }
  return addQuotes(result2, singleQuote);
}
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style !== void 0) {
    const color = inspect.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor(str) {
  return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
    return formatPrimitive(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];
    if (typeof maybeCustom === "function" && // Filter out the util module, its inspect function is special.
    maybeCustom !== inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(
        context,
        depth,
        getUserOptions(ctx, isCrossContext)
      );
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag = value[Symbol.toStringTag];
  if (typeof tag !== "string") {
    tag = "";
  }
  let base2 = "";
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i2 = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties(value, filter);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      const size = value.size;
      const prefix = getPrefix(constructor, tag, "Set", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isMap(value)) {
      const size = value.size;
      const prefix = getPrefix(constructor, tag, "Map", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const bound = value;
      const fallback = "";
      if (constructor === null) {
      }
      const size = value.length;
      const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray.bind(null, bound, size);
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Map", tag);
      formatter = formatIterator.bind(null, braces);
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Set", tag);
      formatter = formatIterator.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ["{", "}"];
    if (constructor === "Object") {
      if (isArgumentsObject(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag !== "") {
        braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base2 = getFunctionBase(value, constructor, tag);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "special");
      }
    } else if (isRegExp(value)) {
      base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix = getPrefix(constructor, tag, "RegExp");
      if (prefix !== "RegExp ") {
        base2 = `${prefix}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base2, "regexp");
      }
    } else if (isDate(value)) {
      base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix = getPrefix(constructor, tag, "Date");
      if (prefix !== "Date ") {
        base2 = `${prefix}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "date");
      }
    } else if (value instanceof Error) {
      base2 = formatError(value, constructor, tag, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else if (isAnyArrayBuffer(value)) {
      const arrayType = isArrayBuffer(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix = getPrefix(constructor, tag, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      Array.prototype.unshift.call(keys, "byteLength");
    } else if (isDataView(value)) {
      braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
      Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise(value)) {
      braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
    } else if (isModuleNamespaceObject(value)) {
      braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
      formatter = formatNamespaceObject.bind(null, keys);
    } else if (isBoxedPrimitive(value)) {
      base2 = getBoxedBase(value, ctx, keys, constructor, tag);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle(value, constructor, tag)}{}`;
      }
      braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output3;
  const indentationLvl = ctx.indentationLvl;
  try {
    output3 = formatter(ctx, value, recurseTimes);
    for (i2 = 0; i2 < keys.length; i2++) {
      output3.push(
        formatProperty(ctx, value, recurseTimes, keys[i2], extrasType)
      );
    }
    if (protoProps !== void 0) {
      output3.push(...protoProps);
    }
  } catch (err3) {
    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    return handleMaxCallStackSize(ctx, err3, constructorName, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base2 = base2 === "" ? reference : `${reference} ${base2}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === kObjectType) {
      output3 = output3.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output3.slice(output3.length - keys.length).sort(comparator);
      output3.splice(output3.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString(
    ctx,
    output3,
    base2,
    braces,
    extrasType,
    recurseTimes,
    value
  );
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects = new Set(
  Object.getOwnPropertyNames(globalThis).filter(
    (e3) => /^[A-Z][a-zA-Z0-9]+$/.test(e3)
  )
);
function addPrototypeProperties(ctx, main, obj, recurseTimes, output3) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj) {
      obj = Object.getPrototypeOf(obj);
      if (obj === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach.call(keys, (key) => keySet.add(key));
    }
    keys = Reflect.ownKeys(obj);
    Array.prototype.push.call(ctx.seen, main);
    for (const key of keys) {
      if (key === "constructor" || // deno-lint-ignore no-prototype-builtins
      main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj, key);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty(
        ctx,
        obj,
        recurseTimes,
        key,
        kObjectType,
        desc,
        main
      );
      if (ctx.colors) {
        Array.prototype.push.call(output3, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push.call(output3, value);
      }
    }
    Array.prototype.pop.call(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj;
  while (obj || isUndetectableObject(obj)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
        addPrototypeProperties(
          ctx,
          tmp,
          firstProto || tmp,
          recurseTimes,
          protoProps
        );
      }
      return descriptor.value.name;
    }
    obj = Object.getPrototypeOf(obj);
    if (firstProto === void 0) {
      firstProto = obj;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName(
    firstProto,
    ctx,
    recurseTimes + 1,
    protoProps
  );
  if (protoConstr === null) {
    return `${res} <${inspect(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth
    // function.
    value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
  return [];
}
function isInstanceof(object3, proto) {
  try {
    return object3 instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix(constructor, tag, fallback, size = "") {
  if (constructor === null) {
    if (tag !== "" && fallback !== tag) {
      return `[${fallback}${size}: null prototype] [${tag}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag !== "" && constructor !== tag) {
    return `${constructor}${size} [${tag}] `;
  }
  return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output3 = [];
  for (let i2 = 0; i2 < len; i2++) {
    if (!value.hasOwnProperty(i2)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output3, i2);
    }
    output3.push(formatProperty(ctx, value, recurseTimes, i2, kArrayType));
  }
  if (remaining > 0) {
    output3.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output3;
}
function getCtxStyle(_value, constructor, tag) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag) {
      fallback = "Object";
    }
  }
  return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
  const output3 = [];
  ctx.indentationLvl += 2;
  for (const v2 of value) {
    Array.prototype.push.call(output3, formatValue(ctx, v2, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output3;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
  const output3 = [];
  ctx.indentationLvl += 2;
  for (const { 0: k, 1: v2 } of value) {
    output3.push(
      `${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v2, recurseTimes)}`
    );
  }
  ctx.indentationLvl -= 2;
  return output3;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output3 = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
  for (let i2 = 0; i2 < maxLength; ++i2) {
    output3[i2] = elementFormatter(ctx.stylize, value[i2]);
  }
  if (remaining > 0) {
    output3[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue(ctx, value[key], recurseTimes, true);
      Array.prototype.push.call(output3, `[${key}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output3;
}
function getIteratorBraces(type, tag) {
  if (tag !== `${type} Iterator`) {
    if (tag !== "") {
      tag += "] [";
    }
    tag += `${type} Iterator`;
  }
  return [`[${tag}] {`, "}"];
}
function formatIterator(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }
  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}
function getFunctionBase(value, constructor, tag) {
  const stringified = Function.prototype.toString.call(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice = stringified.slice(5, -1);
    const bracketIndex = slice.indexOf("{");
    if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || // Slow path to guarantee that it's indeed a class.
    classRegExp.test(slice.replace(stripCommentsRegExp)))) {
      return getClassBase(value, constructor, tag);
    }
  }
  let type = "Function";
  if (isGeneratorFunction(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction(value)) {
    type = `Async${type}`;
  }
  let base2 = `[${type}`;
  if (constructor === null) {
    base2 += " (null prototype)";
  }
  if (value.name === "") {
    base2 += " (anonymous)";
  } else {
    base2 += `: ${value.name}`;
  }
  base2 += "]";
  if (constructor !== type && constructor !== null) {
    base2 += ` ${constructor}`;
  }
  if (tag !== "" && constructor !== tag) {
    base2 += ` [${tag}]`;
  }
  return base2;
}
function formatError(err3, constructor, tag, ctx, keys) {
  const name = err3.name != null ? String(err3.name) : "Error";
  let len = name.length;
  let stack = err3.stack ? String(err3.stack) : err3.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name2 of ["name", "message", "stack"]) {
      const index = keys.indexOf(name2);
      if (index !== -1 && stack.includes(err3[name2])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err3.message && stack.indexOf(err3.message) || -1;
  if (pos !== -1) {
    pos += err3.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos2 = 0;
      while (nodeModule = nodeModulesRegExp.exec(line)) {
        newStack += line.slice(pos2, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos2 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos2 === 0 ? line : line.slice(pos2);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice;
function formatArrayBuffer(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [ctx.stylize("(detached)", "special")];
  }
  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [`${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`];
}
function formatNumber(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
  let output3;
  const { 0: state, 1: result2 } = value;
  if (state === kPending) {
    output3 = [ctx.stylize("<pending>", "special")];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue(ctx, result2, recurseTimes);
    ctx.indentationLvl -= 2;
    output3 = [
      state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output3;
}
function formatWeakCollection(ctx) {
  return [ctx.stylize("<items unknown>", "special")];
}
function formatWeakSet(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);
}
function formatWeakMap(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key) || { value: value[key], enumerable: true };
  if (desc.value !== void 0) {
    const diff = ctx.compact !== true || type !== kObjectType ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);
    if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err3) {
        const message = `<Inspection threw (${err3.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === kArrayType) {
    return str;
  }
  if (typeof key === "symbol") {
    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, "symbol")}]`;
  } else if (key === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${tmp}]`;
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, "name");
  } else {
    name = ctx.stylize(strEscape(key), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
  return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output3, start, base2) {
  let totalLength = output3.length + start;
  if (totalLength + output3.length > ctx.breakLength) {
    return false;
  }
  for (let i2 = 0; i2 < output3.length; i2++) {
    if (ctx.colors) {
      totalLength += removeColors(output3[i2]).length;
    } else {
      totalLength += output3[i2].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base2 === "" || !base2.includes("\n");
}
function formatBigInt(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
  const output3 = new Array(keys.length);
  for (let i2 = 0; i2 < keys.length; i2++) {
    try {
      output3[i2] = formatProperty(
        ctx,
        value,
        recurseTimes,
        keys[i2],
        kObjectType
      );
    } catch (_err) {
      const tmp = { [keys[i2]]: "" };
      output3[i2] = formatProperty(ctx, tmp, recurseTimes, keys[i2], kObjectType);
      const pos = output3[i2].lastIndexOf(" ");
      output3[i2] = output3[i2].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output3;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output3, i2) {
  const keys = Object.keys(value);
  let index = i2;
  for (; i2 < keys.length && output3.length < maxLength; i2++) {
    const key = keys[i2];
    const tmp = +key;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output3.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output3.length === maxLength) {
        break;
      }
    }
    output3.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }
  const remaining = value.length - index;
  if (output3.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? "s" : "";
      const message = `<${remaining} empty item${ending}>`;
      output3.push(ctx.stylize(message, "undefined"));
    }
  } else if (remaining > 0) {
    output3.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output3;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
  let type;
  if (isNumberObject(value)) {
    type = "Number";
  } else if (isStringObject(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    type = "Boolean";
  } else if (isBigIntObject(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base2 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base2 += " (null prototype)";
    } else {
      base2 += ` (${constructor})`;
    }
  }
  base2 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
  if (tag !== "" && tag !== constructor) {
    base2 += ` [${tag}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base2;
  }
  return ctx.stylize(base2, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base2 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base2 += ` [${constructor}]`;
  }
  if (tag !== "" && constructor !== tag) {
    base2 += ` [${tag}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base2 += ` extends ${superName}`;
    }
  } else {
    base2 += " extends [null prototype]";
  }
  return `[${base2}]`;
}
function reduceToSingleString(ctx, output3, base2, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output3.length;
      if (extrasType === kArrayExtrasType && entries > 6) {
        output3 = groupArrayElements(ctx, output3, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output3.length) {
        const start = output3.length + ctx.indentationLvl + braces[0].length + base2.length + 10;
        if (isBelowBreakLength(ctx, output3, start, base2)) {
          return `${base2 ? `${base2} ` : ""}${braces[0]} ${join(output3, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation2 = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base2 ? `${base2} ` : ""}${braces[0]}${indentation2}  ${join(output3, `,${indentation2}  `)}${indentation2}${braces[1]}`;
  }
  if (isBelowBreakLength(ctx, output3, 0, base2)) {
    return `${braces[0]}${base2 ? ` ${base2}` : ""} ${join(output3, ", ")} ` + braces[1];
  }
  const indentation = " ".repeat(ctx.indentationLvl);
  const ln = base2 === "" && braces[0].length === 1 ? " " : `${base2 ? ` ${base2}` : ""}
${indentation}  `;
  return `${braces[0]}${ln}${join(output3, `,
${indentation}  `)} ${braces[1]}`;
}
function join(output3, separator) {
  let str = "";
  if (output3.length !== 0) {
    const lastIndex = output3.length - 1;
    for (let i2 = 0; i2 < lastIndex; i2++) {
      str += output3[i2];
      str += separator;
    }
    str += output3[lastIndex];
  }
  return str;
}
function groupArrayElements(ctx, output3, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i2 = 0;
  let outputLength = output3.length;
  if (ctx.maxArrayLength < output3.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i2 < outputLength; i2++) {
    const len = getStringWidth(output3[i2], ctx.colors);
    dataLen[i2] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + separatorSpace;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output3.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(
      // Ideally a square should be drawn. We expect a character to be about 2.5
      // times as high as wide. This is the area formula to calculate a square
      // which contains n rectangles of size `actualMax * approxCharHeights`.
      // Divide that by `actualMax` to receive the correct number of columns.
      // The added bias increases the columns for short entries.
      Math.round(
        Math.sqrt(
          approxCharHeights * biasedMax * outputLength
        ) / biasedMax
      ),
      // Do not exceed the breakLength.
      Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax),
      // Limit array grouping for small `compact` modes as the user requested
      // minimal grouping.
      ctx.compact * 4,
      // Limit the columns to a maximum of fifteen.
      15
    );
    if (columns <= 1) {
      return output3;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i3 = 0; i3 < columns; i3++) {
      let lineMaxLength = 0;
      for (let j = i3; j < output3.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i3] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i3 = 0; i3 < output3.length; i3++) {
        if (typeof value[i3] !== "number" && typeof value[i3] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i3 = 0; i3 < outputLength; i3 += columns) {
      const max = Math.min(i3 + columns, outputLength);
      let str = "";
      let j = i3;
      for (; j < max - 1; j++) {
        const padding3 = maxLineLength[j - i3] + output3[j].length - dataLen[j];
        str += `${output3[j]}, `.padStart(padding3, " ");
      }
      if (order === String.prototype.padStart) {
        const padding3 = maxLineLength[j - i3] + output3[j].length - dataLen[j] - separatorSpace;
        str += output3[j].padStart(padding3, " ");
      } else {
        str += output3[j];
      }
      Array.prototype.push.call(tmp, str);
    }
    if (ctx.maxArrayLength < output3.length) {
      Array.prototype.push.call(tmp, output3[outputLength]);
    }
    output3 = tmp;
  }
  return output3;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output3 = new Array(maxLength);
  let i2 = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak) {
    for (; i2 < maxLength; i2++) {
      const pos = i2 * 2;
      output3[i2] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output3 = output3.sort();
    }
  } else {
    for (; i2 < maxLength; i2++) {
      const pos = i2 * 2;
      const res = [
        formatValue(ctx, entries[pos], recurseTimes),
        formatValue(ctx, entries[pos + 1], recurseTimes)
      ];
      output3[i2] = reduceToSingleString(
        ctx,
        res,
        "",
        ["[", "]"],
        kArrayExtrasType,
        recurseTimes
      );
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output3.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output3;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output3 = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i2 = 0; i2 < maxLength; i2++) {
    output3[i2] = formatValue(ctx, entries[i2], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak && !ctx.sorted) {
    output3.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push.call(
      output3,
      `... ${remaining} more item${remaining > 1 ? "s" : ""}`
    );
  }
  return output3;
}
var ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters(str);
  }
  str = str.normalize("NFC");
  for (const char of str[Symbol.iterator]()) {
    const code = char.codePointAt(0);
    if (isFullWidthCodePoint(code)) {
      width += 2;
    } else if (!isZeroWidthCodePoint(code)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint = (code) => {
  return code >= 4352 && (code <= 4447 || // Hangul Jamo
  code === 9001 || // LEFT-POINTING ANGLE BRACKET
  code === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  code >= 11904 && code <= 12871 && code !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  code >= 12880 && code <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  code >= 19968 && code <= 42182 || // Hangul Jamo Extended-A
  code >= 43360 && code <= 43388 || // Hangul Syllables
  code >= 44032 && code <= 55203 || // CJK Compatibility Ideographs
  code >= 63744 && code <= 64255 || // Vertical Forms
  code >= 65040 && code <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  code >= 65072 && code <= 65131 || // Halfwidth and Fullwidth Forms
  code >= 65281 && code <= 65376 || code >= 65504 && code <= 65510 || // Kana Supplement
  code >= 110592 && code <= 110593 || // Enclosed Ideographic Supplement
  code >= 127488 && code <= 127569 || // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff
  // Emoticons 0x1f600 - 0x1f64f
  code >= 127744 && code <= 128591 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  code >= 131072 && code <= 262141);
};
var isZeroWidthCodePoint = (code) => {
  return code <= 31 || // C0 control codes
  code >= 127 && code <= 159 || // C1 control codes
  code >= 768 && code <= 879 || // Combining Diacritical Marks
  code >= 8203 && code <= 8207 || // Modifying Invisible Characters
  // Combining Diacritical Marks for Symbols
  code >= 8400 && code <= 8447 || code >= 65024 && code <= 65039 || // Variation Selectors
  code >= 65056 && code <= 65071 || // Combining Half Marks
  code >= 917760 && code <= 917999;
};
function stripVTControlCharacters(str) {
  validateString(str, "str");
  return str.replace(ansi, "");
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/errors.js
function hideStackFrames(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
var ERR_HTTP_HEADERS_SENT = class extends Error {
  constructor(x) {
    super(
      `Cannot ${x} headers after they are sent to the client`
    );
    this.code = "ERR_HTTP_HEADERS_SENT";
  }
};
var ERR_HTTP_INVALID_HEADER_VALUE = class extends TypeError {
  constructor(x, y2) {
    super(
      `Invalid value "${x}" for header "${y2}"`
    );
    this.code = "ERR_HTTP_INVALID_HEADER_VALUE";
  }
};
var ERR_HTTP_TRAILER_INVALID = class extends Error {
  constructor() {
    super(
      `Trailers are invalid with this transfer encoding`
    );
    this.code = "ERR_HTTP_TRAILER_INVALID";
  }
};
var ERR_INVALID_HTTP_TOKEN = class extends TypeError {
  constructor(x, y2) {
    super(`${x} must be a valid HTTP token ["${y2}"]`);
    this.code = "ERR_INVALID_HTTP_TOKEN";
  }
};
var classRegExp2 = /^([A-Z][a-z0-9]*)+$/;
var kTypes = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
function createInvalidArgType(name, expected) {
  expected = Array.isArray(expected) ? expected : [expected];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes.includes(value)) {
      types.push(value.toLocaleLowerCase());
    } else if (classRegExp2.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types.indexOf("object");
    if (pos !== -1) {
      types.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types.length > 0) {
    if (types.length > 2) {
      const last = types.pop();
      msg += `one of type ${types.join(", ")}, or ${last}`;
    } else if (types.length === 2) {
      msg += `one of type ${types[0]} or ${types[1]}`;
    } else {
      msg += `of type ${types[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last = other.pop();
      msg += `one of ${other.join(", ")}, or ${last}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
function invalidArgTypeHelper(input2) {
  if (input2 == null) {
    return ` Received ${input2}`;
  }
  if (typeof input2 === "function" && input2.name) {
    return ` Received function ${input2.name}`;
  }
  if (typeof input2 === "object") {
    if (input2.constructor && input2.constructor.name) {
      return ` Received an instance of ${input2.constructor.name}`;
    }
    return ` Received ${inspect(input2, { depth: -1 })}`;
  }
  let inspected = inspect(input2, { colors: false });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input2} (${inspected})`;
}
function addNumericalSeparator(val) {
  let res = "";
  let i2 = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i2 >= start + 4; i2 -= 3) {
    res = `_${val.slice(i2 - 3, i2)}${res}`;
  }
  return `${val.slice(0, i2)}${res}`;
}
var ERR_OUT_OF_RANGE = class extends RangeError {
  code = "ERR_OUT_OF_RANGE";
  /**
   * 
   * @param {string} str 
   * @param {string} range 
   * @param {unknown} input 
   * @param {boolean} replaceDefaultBoolean 
   */
  constructor(str, range, input2, replaceDefaultBoolean = false) {
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input2) && Math.abs(input2) > 2 ** 32) {
      received = addNumericalSeparator(String(input2));
    } else if (typeof input2 === "bigint") {
      received = String(input2);
      if (input2 > 2n ** 32n || input2 < -(2n ** 32n)) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input2);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_INVALID_ARG_TYPE_RANGE = class extends RangeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super(`${msg}.${invalidArgTypeHelper(actual)}`);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
var ERR_INVALID_ARG_TYPE = class extends TypeError {
  /**
   * 
   * @param {string} name 
   * @param {string | string[]} expected 
   * @param {unknown} actual 
   */
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super(`${msg}.${invalidArgTypeHelper(actual)}`);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
  static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
};
var ERR_INVALID_ARG_VALUE_RANGE = class extends RangeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = JSON.stringify(value);
    super(`The ${type} '${name}' ${reason}. Received ${inspected}`);
    this.code = "ERR_INVALID_ARG_VALUE";
  }
};
var ERR_INVALID_ARG_VALUE = class extends TypeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = JSON.stringify(value);
    super(`The ${type} '${name}' ${reason}. Received ${inspected}`);
    this.code = "ERR_INVALID_ARG_VALUE";
  }
};
var ERR_INVALID_CHAR = class extends TypeError {
  constructor(name, field) {
    super(
      field ? `Invalid character in ${name}` : `Invalid character in ${name} ["${field}"]`
    );
    this.code = "ERR_INVALID_CHAR";
  }
};
var ERR_METHOD_NOT_IMPLEMENTED = class extends Error {
  constructor(x) {
    super(`The ${x} method is not implemented`);
    this.code = "ERR_METHOD_NOT_IMPLEMENTED";
  }
};
var ERR_STREAM_CANNOT_PIPE = class extends Error {
  constructor() {
    super(`Cannot pipe, not readable`);
    this.code = "ERR_STREAM_CANNOT_PIPE";
  }
};
var ERR_STREAM_ALREADY_FINISHED = class extends Error {
  constructor(x) {
    super(
      `Cannot call ${x} after a stream was finished`
    );
    this.code = "ERR_STREAM_ALREADY_FINISHED";
  }
};
var ERR_STREAM_WRITE_AFTER_END = class extends Error {
  constructor() {
    super(`write after end`);
    this.code = "ERR_STREAM_WRITE_AFTER_END";
  }
};
var ERR_STREAM_NULL_VALUES = class extends TypeError {
  constructor() {
    super(`May not write null values to stream`);
    this.code = "ERR_STREAM_NULL_VALUES";
  }
};
var ERR_STREAM_DESTROYED = class extends Error {
  constructor(x) {
    super(
      `Cannot call ${x} after a stream was destroyed`
    );
    this.code = "ERR_STREAM_DESTROYED";
  }
};
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      outerError.errors.push(innerError);
      return outerError;
    }
    const err3 = new AggregateError(
      [
        outerError,
        innerError
      ],
      outerError.message
    );
    err3.code = outerError.code;
    return err3;
  }
  return innerError || outerError;
}
var ERR_SOCKET_BAD_PORT = class extends RangeError {
  constructor(name, port, allowZero = true) {
    assert(
      typeof allowZero === "boolean",
      "The 'allowZero' argument must be of type boolean."
    );
    const operator = allowZero ? ">=" : ">";
    super(
      `${name} should be ${operator} 0 and < 65536. Received ${port}.`
    );
    this.code = "ERR_SOCKET_BAD_PORT";
  }
};
var ERR_STREAM_PREMATURE_CLOSE = class extends Error {
  constructor() {
    super(`Premature close`);
    this.code = "ERR_STREAM_PREMATURE_CLOSE";
  }
};
var AbortError2 = class extends Error {
  constructor() {
    super("The operation was aborted");
    this.code = "ABORT_ERR";
    this.name = "AbortError";
  }
};
var ERR_INVALID_CALLBACK = class extends TypeError {
  constructor(object3) {
    super(
      `Callback must be a function. Received ${JSON.stringify(object3)}`
    );
    this.code = "ERR_INVALID_CALLBACK";
  }
};
var ERR_MISSING_ARGS = class extends TypeError {
  constructor(...args2) {
    let msg = "The ";
    const len = args2.length;
    const wrap2 = (a2) => `"${a2}"`;
    args2 = args2.map(
      (a2) => Array.isArray(a2) ? a2.map(wrap2).join(" or ") : wrap2(a2)
    );
    switch (len) {
      case 1:
        msg += `${args2[0]} argument`;
        break;
      case 2:
        msg += `${args2[0]} and ${args2[1]} arguments`;
        break;
      default:
        msg += args2.slice(0, len - 1).join(", ");
        msg += `, and ${args2[len - 1]} arguments`;
        break;
    }
    super(`${msg} must be specified`);
    this.code = "ERR_MISSING_ARGS";
  }
};
var ERR_MISSING_OPTION = class extends TypeError {
  constructor(x) {
    super(`${x} is required`);
    this.code = "ERR_MISSING_OPTION";
  }
};
var ERR_MULTIPLE_CALLBACK = class extends Error {
  constructor() {
    super(`Callback called multiple times`);
    this.code = "ERR_MULTIPLE_CALLBACK";
  }
};
var ERR_STREAM_PUSH_AFTER_EOF = class extends Error {
  constructor() {
    super(`stream.push() after EOF`);
    this.code = "ERR_STREAM_PUSH_AFTER_EOF";
  }
};
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = class extends Error {
  constructor() {
    super(
      `stream.unshift() after end event`
    );
    this.code = "ERR_STREAM_UNSHIFT_AFTER_END_EVENT";
  }
};
var ERR_UNKNOWN_ENCODING = class extends TypeError {
  constructor(x) {
    super(`Unknown encoding: ${x}`);
    this.code = "ERR_UNKNOWN_ENCODING";
  }
};
function buildReturnPropertyType(value) {
  if (value && value.constructor && value.constructor.name) {
    return `instance of ${value.constructor.name}`;
  } else {
    return `type ${typeof value}`;
  }
}
var ERR_INVALID_RETURN_VALUE = class extends TypeError {
  constructor(input2, name, value) {
    super(
      `Expected ${input2} to be returned from the "${name}" function but got ${buildReturnPropertyType(value)}.`
    );
    this.code = "ERR_INVALID_RETURN_VALUE";
  }
};
var ERR_INCOMPATIBLE_OPTION_PAIR = class extends TypeError {
  constructor(input2, name) {
    super(
      `Option "${input2}" cannot be used in combination with option "${name}"`
    );
    this.code = "ERR_INCOMPATIBLE_OPTION_PAIR";
  }
};
var captureStackTrace = hideStackFrames(
  function captureStackTrace2(err3) {
    const e3 = new Error();
    Object.defineProperties(err3, {
      stack: {
        configurable: true,
        writable: true,
        get: () => e3.stack
      }
    });
    return err3;
  }
);
var captureLargerStackTrace = hideStackFrames(
  function captureLargerStackTrace2(err3) {
    captureStackTrace(err3);
    return err3;
  }
);
var NodeErrorAbstraction = class extends Error {
  /**
   * @type {string}
   */
  code;
  /**
   * 
   * @param {string} name 
   * @param {string} code 
   * @param {string} message 
   */
  constructor(name, code, message) {
    super(message);
    this.code = code;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var kIsNodeError = Symbol("kIsNodeError");
var NodeSystemError = class extends NodeErrorAbstraction {
  /**
   * 
   * @param {string} key 
   * @param {NodeSystemErrorCtx} context 
   * @param {string} msgPrefix 
   */
  constructor(key, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key, message);
    Object.defineProperties(this, {
      [kIsNodeError]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode(key, msgPrfix) {
  return class NodeError extends NodeSystemError {
    /**
     * 
     * @param {NodeSystemErrorCtx} ctx 
     */
    constructor(ctx) {
      super(key, ctx, msgPrfix);
    }
  };
}
var ERR_FS_EISDIR = makeSystemErrorWithCode(
  "ERR_FS_EISDIR",
  "Path is a directory"
);
var ERR_FS_CP_DIR_TO_NON_DIR = makeSystemErrorWithCode(
  "ERR_FS_CP_DIR_TO_NON_DIR",
  "Cannot overwrite directory with non-directory"
);
var ERR_FS_CP_EEXIST = makeSystemErrorWithCode("ERR_FS_CP_EEXIST", "Target already exists");
var ERR_FS_CP_EINVAL = makeSystemErrorWithCode("ERR_FS_CP_EINVAL", "Invalid src or dest");
var ERR_FS_CP_FIFO_PIPE = makeSystemErrorWithCode("ERR_FS_CP_FIFO_PIPE", "Cannot copy a FIFO pipe");
var ERR_FS_CP_NON_DIR_TO_DIR = makeSystemErrorWithCode(
  "ERR_FS_CP_NON_DIR_TO_DIR",
  "Cannot overwrite non-directory with directory"
);
var ERR_FS_CP_SOCKET = makeSystemErrorWithCode("ERR_FS_CP_SOCKET", "Cannot copy a socket file");
var ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY = makeSystemErrorWithCode(
  "ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY",
  "Cannot overwrite symlink in subdirectory of self"
);
var ERR_FS_CP_UNKNOWN = makeSystemErrorWithCode("ERR_FS_CP_UNKNOWN", "Cannot copy an unknown file type");
function uvErrmapGet(name) {
  return errorMap.get(name);
}
var uvUnmappedError = ["UNKNOWN", "unknown error"];
var uvException = hideStackFrames(
  /**
   * 
   * @param {NodeSystemErrorCtx} ctx 
   * @returns 
   */
  function uvException2(ctx) {
    const { 0: code, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path2;
    let dest;
    if (ctx.path) {
      path2 = ctx.path.toString();
      message += ` '${path2}'`;
    }
    if (ctx.dest) {
      dest = ctx.dest.toString();
      message += ` -> '${dest}'`;
    }
    const err3 = new Error(message);
    for (const prop of Object.keys(ctx)) {
      if (prop === "message" || prop === "path" || prop === "dest") {
        continue;
      }
      err3[prop] = ctx[prop];
    }
    err3.code = code;
    if (path2) {
      err3.path = path2;
    }
    if (dest) {
      err3.dest = dest;
    }
    return captureLargerStackTrace(err3);
  }
);
function isErrorStackTraceLimitWritable() {
  if (false) {
    return false;
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return Object.prototype.hasOwnProperty(desc, "writable") ? desc.writable : desc.set !== void 0;
}
var ERR_UNAVAILABLE_DURING_EXIT = class extends Error {
  constructor() {
    super(
      "ERR_UNAVAILABLE_DURING_EXIT",
      `Cannot call function in process exit handler`
    );
  }
};
var ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED = class extends TypeError {
  constructor() {
    super(
      "ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED",
      `Snapshot is not supported in this context`
    );
  }
};
var ERR_AMBIGUOUS_ARGUMENT = class extends TypeError {
  constructor(arg, msg) {
    super(
      "ERR_AMBIGUOUS_ARGUMENT",
      `The ${arg} argument is ambiguous. ${msg}`
    );
  }
};
var ERR_DIR_CLOSED = class extends Error {
  constructor() {
    super("Directory handle was closed");
    this.code = "ERR_DIR_CLOSED";
  }
};
var ERR_DIR_CONCURRENT_OPERATION = class extends Error {
  constructor() {
    super(
      "Cannot do synchronous work on directory handle with concurrent asynchronous operations"
    );
    this.code = "ERR_DIR_CONCURRENT_OPERATION";
  }
};
var ERR_FS_FILE_TOO_LARGE = class extends RangeError {
  constructor(x) {
    super(
      `File size (${x}) is greater than 2 GB`
    );
    this.code = "ERR_FS_FILE_TOO_LARGE";
  }
};
var AggregateError = class extends Error {
  constructor(errs) {
    super();
    this.name = "AggregateError";
    this.code = errs[0].code;
    this.errors = errs;
  }
};
var ERR_FS_INVALID_SYMLINK_TYPE = class extends Error {
  constructor(x) {
    super(
      `Symlink type must be one of "dir", "file", or "junction". Received "${x}"`
    );
    this.code = "ERR_FS_INVALID_SYMLINK_TYPE";
  }
};
var ERR_CRYPTO_FIPS_FORCED = class extends Error {
  constructor() {
    super(
      "Cannot set FIPS mode, it was forced with --force-fips at startup."
    );
    this.code = "ERR_CRYPTO_FIPS_FORCED";
  }
};
var ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH = class extends RangeError {
  constructor() {
    super(
      "Input buffers must have the same byte length"
    );
    this.code = "ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH";
  }
};
var ERR_OPERATION_FAILED = class extends Error {
  constructor(x) {
    super(
      `Operation failed: ${x}`
    );
    this.code = "ERR_OPERATION_FAILED";
  }
};
var ERR_CRYPTO_ENGINE_UNKNOWN = class extends Error {
  constructor(x) {
    super(
      `Engine "${x}" was not found`
    );
    this.code = "ERR_CRYPTO_ENGINE_UNKNOWN";
  }
};
var ERR_CRYPTO_INVALID_DIGEST = class extends TypeError {
  constructor(x) {
    super(`Invalid digest: ${x}`);
    this.code = "ERR_CRYPTO_INVALID_DIGEST";
  }
};
var ERR_CRYPTO_SCRYPT_INVALID_PARAMETER = class extends Error {
  constructor() {
    super(`Invalid scrypt parameter`);
    this.code = "ERR_CRYPTO_SCRYPT_INVALID_PARAMETER";
  }
};
var ERR_CRYPTO_SCRYPT_NOT_SUPPORTED = class extends Error {
  constructor() {
    super(`Scrypt algorithm not supported`);
    this.code = "ERR_CRYPTO_SCRYPT_NOT_SUPPORTED";
  }
};
var ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS = class extends Error {
  constructor(a2, b4) {
    super(`The selected key encoding ${a2} ${b4}.`);
    this.code = "ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS";
  }
};
var ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE = class extends TypeError {
  constructor(t2, e3) {
    super(`Invalid key object type ${t2}, expected ${e3}.`);
    this.code = "ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE";
  }
};
var ERR_CRYPTO_INVALID_JWK = class extends TypeError {
  constructor() {
    super(`Invalid JWK data`);
    this.code = "ERR_CRYPTO_INVALID_JWK";
  }
};
var ERR_ILLEGAL_CONSTRUCTOR = class extends TypeError {
  constructor() {
    super(`Illegal constructor`);
    this.code = "ERR_ILLEGAL_CONSTRUCTOR";
  }
};
var ERR_CRYPTO_INVALID_KEYLEN = class extends RangeError {
  constructor() {
    super(`Invalid key length`);
    this.code = "ERR_CRYPTO_INVALID_KEYLEN";
  }
};
var ERR_CRYPTO_HASH_FINALIZED = class extends Error {
  constructor() {
    super(`Digest already called`);
    this.code = "ERR_CRYPTO_HASH_FINALIZED";
  }
};
var ERR_CRYPTO_HASH_UPDATE_FAILED = class extends Error {
  constructor() {
    super(`Hash update failed`);
    this.code = "ERR_CRYPTO_HASH_UPDATE_FAILED";
  }
};
var ERR_CRYPTO_INVALID_STATE = class extends Error {
  constructor() {
    super(`Invalid state`);
    this.code = "ERR_CRYPTO_INVALID_STATE";
  }
};
var ERR_CRYPTO_UNKNOWN_CIPHER = class extends Error {
  constructor() {
    super(`Unknown cipher`);
    this.code = "ERR_CRYPTO_UNKNOWN_CIPHER";
  }
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs/utils.js
init_buffer();

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/util.js
var customInspectSymbol2 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
kEnumerableProperty.enumerable = true;
function once2(callback) {
  let called = false;
  return function(...args2) {
    if (called) return;
    called = true;
    Reflect.apply(callback, this, args2);
  };
}
function createDeferredPromise() {
  let resolve3;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve3 = res;
    reject = rej;
  });
  return { promise, resolve: resolve3, reject };
}
var codesWarned = /* @__PURE__ */ new Set();
function deprecate(fn, msg, code) {
  if (code !== void 0) {
    validateString(code, "code");
  }
  let warned = false;
  function deprecated(...args2) {
    if (!warned) {
      warned = true;
      if (code !== void 0) {
        if (!codesWarned.has(code)) {
          process.emitWarning(msg, "DeprecationWarning", code, deprecated);
          codesWarned.add(code);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args2, new.target);
    }
    return Reflect.apply(fn, this, args2);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol = Symbol.for(
  "nodejs.util.promisify.customArgs"
);
var customPromisifyArgs = kCustomPromisifyArgsSymbol;
function promisify(original) {
  validateFunction(original, "original");
  if (original[kCustomPromisifiedSymbol]) {
    const fn2 = original[kCustomPromisifiedSymbol];
    validateFunction(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol];
  function fn(...args2) {
    return new Promise((resolve3, reject) => {
      args2.push((err3, ...values) => {
        if (err3) {
          return reject(err3);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj = {};
          for (let i2 = 0; i2 < argumentNames.length; i2++) {
            obj[argumentNames[i2]] = values[i2];
          }
          resolve3(obj);
        } else {
          resolve3(values[0]);
        }
      });
      try {
        Reflect.apply(original, this, args2);
      } catch (err3) {
        return reject(err3);
      }
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    Object.getOwnPropertyDescriptors(original)
  );
}
promisify.custom = kCustomPromisifiedSymbol;
var kEmptyObject2 = Object.freeze(/* @__PURE__ */ Object.create(null));

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/url.js
init_buffer();
var searchParams = Symbol("query");
function toPathIfFileURL(fileURLOrPath) {
  if (!(fileURLOrPath instanceof _URL)) {
    return fileURLOrPath;
  }
  return fileURLToPath(fileURLOrPath);
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/assert.js
function assert3(expr, msg = "") {
  if (!expr) {
    throw new Error(msg);
  }
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs.js
import * as binding2 from "_node:fs";

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal_binding/constants.js
var os = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    // TODO(uki00a): In Solaris, this should be `19`. Is there any way to address this difference?
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
var fs = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs.js
init_buffer();

// ../../../../../../node_modules/wasmedge_quickjs/modules/fs/promises.js
var access2 = promisify(access);
var appendFile2 = (file, data, opts) => {
  if (file instanceof FileHandle) {
    return file.appendFile(data, opts);
  } else {
    return promisify(appendFile)(file, data, opts);
  }
};
var chmod2 = promisify(chmod);
var chown2 = promisify(chown);
var copyFile2 = promisify(copyFile);
var cp2 = promisify(cp);
var lchmod2 = promisify(lchmod);
var lchown2 = promisify(lchown);
var lutimes2 = promisify(lutimes);
var link2 = promisify(link);
var lstat2 = promisify(lstat);
var mkdir2 = promisify(mkdir);
var mkdtemp2 = promisify(mkdtemp);
var open2 = (path2, flag, mode) => {
  return new Promise((res, rej) => {
    open(path2, flag, mode, (err3, fd) => {
      if (err3 !== null) {
        return rej(err3);
      }
      res(new FileHandle(fd, path2));
    });
  });
};
var opendir2 = promisify(opendir);
var readdir2 = promisify(readdir);
var readFile = async (path2, ...args2) => {
  let file = await open2(path2, "r");
  let res = await file.readFile(...args2);
  await file.close();
  return res;
};
var readlink2 = promisify(readlink);
var realpath2 = promisify(realpath);
var rename2 = promisify(rename);
var rmdir2 = promisify(rmdir);
var rm2 = promisify(rm);
var stat2 = promisify(stat);
var symlink2 = promisify(symlink);
var truncate = async (path2, len) => {
  let file = await open2(path2, "r+");
  await file.truncate(len);
  await file.close();
};
var unlink2 = promisify(unlink);
var utimes2 = promisify(utimes);
var watch2 = promisify(watch);
var writeFile = async (path2, ...args2) => {
  let file = await open2(path2, "w");
  await file.writeFile(...args2);
  await file.close();
};
var constants = fs;
var promises = {
  access: access2,
  appendFile: appendFile2,
  chmod: chmod2,
  chown: chown2,
  copyFile: copyFile2,
  cp: cp2,
  lchmod: lchmod2,
  lchown: lchown2,
  lutimes: lutimes2,
  link: link2,
  lstat: lstat2,
  mkdir: mkdir2,
  mkdtemp: mkdtemp2,
  open: open2,
  opendir: opendir2,
  readdir: readdir2,
  readFile,
  readlink: readlink2,
  realpath: realpath2,
  rename: rename2,
  rmdir: rmdir2,
  rm: rm2,
  stat: stat2,
  symlink: symlink2,
  truncate,
  unlink: unlink2,
  utimes: utimes2,
  watch: watch2,
  writeFile,
  constants
};
var promises_default = promises;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs/cp/cp.js
var {
  ERR_FS_CP_DIR_TO_NON_DIR: ERR_FS_CP_DIR_TO_NON_DIR2,
  ERR_FS_CP_EEXIST: ERR_FS_CP_EEXIST2,
  ERR_FS_CP_EINVAL: ERR_FS_CP_EINVAL2,
  ERR_FS_CP_FIFO_PIPE: ERR_FS_CP_FIFO_PIPE2,
  ERR_FS_CP_NON_DIR_TO_DIR: ERR_FS_CP_NON_DIR_TO_DIR2,
  ERR_FS_CP_SOCKET: ERR_FS_CP_SOCKET2,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY: ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY2,
  ERR_FS_CP_UNKNOWN: ERR_FS_CP_UNKNOWN2,
  ERR_FS_EISDIR: ERR_FS_EISDIR2
} = errors_exports;
var {
  errno: {
    EEXIST,
    EISDIR,
    EINVAL,
    ENOTDIR
  }
} = os;
async function cpFn(src, dest, opts) {
  if (opts.preserveTimestamps && process2.arch === "ia32") {
    const warning = "Using the preserveTimestamps option in 32-bit node is not recommended";
    process2.emitWarning(warning, "TimestampPrecisionWarning");
  }
  const stats = await checkPaths(src, dest, opts);
  const { srcStat, destStat } = stats;
  await checkParentPaths(src, srcStat, dest);
  if (opts.filter) {
    return handleFilter(checkParentDir, destStat, src, dest, opts);
  }
  return checkParentDir(destStat, src, dest, opts);
}
async function checkPaths(src, dest, opts) {
  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts);
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL2({
        message: "src and dest cannot be the same",
        path: dest,
        syscall: "cp",
        errno: EINVAL,
        code: "EINVAL"
      });
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR2({
        message: `cannot overwrite directory ${src} with non-directory ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EISDIR,
        code: "EISDIR"
      });
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR2({
        message: `cannot overwrite non-directory ${src} with directory ${dest}`,
        path: dest,
        syscall: "cp",
        errno: ENOTDIR,
        code: "ENOTDIR"
      });
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL2({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL,
      code: "EINVAL"
    });
  }
  return { srcStat, destStat };
}
function areIdentical(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function getStats(src, dest, opts) {
  const statFunc = opts.dereference ? (file) => stat2(file, { bigint: true }) : (file) => lstat2(file, { bigint: true });
  return Promise.all([
    statFunc(src),
    Promise.prototype.then.call(statFunc(dest), void 0, (err3) => {
      if (err3.code === "ENOENT") return null;
      throw err3;
    })
  ]);
}
async function checkParentDir(destStat, src, dest, opts) {
  const destParent = dirname(dest);
  const dirExists = await pathExists(destParent);
  if (dirExists) return getStatsForCopy(destStat, src, dest, opts);
  await mkdir2(destParent, { recursive: true });
  return getStatsForCopy(destStat, src, dest, opts);
}
function pathExists(dest) {
  return Promise.prototype.then.call(
    stat2(dest),
    () => true,
    (err3) => err3.code === "ENOENT" ? false : PromiseReject(err3)
  );
}
async function checkParentPaths(src, srcStat, dest) {
  const srcParent = resolve(dirname(src));
  const destParent = resolve(dirname(dest));
  if (destParent === srcParent || destParent === parse2(destParent).root || destParent === ".") {
    return;
  }
  let destStat;
  try {
    destStat = await stat2(destParent, { bigint: true });
  } catch (err3) {
    if (err3.code === "ENOENT") return;
    throw err3;
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL2({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL,
      code: "EINVAL"
    });
  }
  return checkParentPaths(src, srcStat, destParent);
}
var normalizePathToArray = (path2) => Array.prototype.filter.call(String.prototype.split.call(resolve(path2), sep), Boolean);
function isSrcSubdir(src, dest) {
  const srcArr = normalizePathToArray(src);
  const destArr = normalizePathToArray(dest);
  return Array.prototype.every.call(srcArr, (cur, i2) => destArr[i2] === cur);
}
async function handleFilter(onInclude, destStat, src, dest, opts, cb) {
  const include = await opts.filter(src, dest);
  if (include) return onInclude(destStat, src, dest, opts, cb);
}
function startCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    return handleFilter(getStatsForCopy, destStat, src, dest, opts);
  }
  return getStatsForCopy(destStat, src, dest, opts);
}
async function getStatsForCopy(destStat, src, dest, opts) {
  const statFn = opts.dereference ? stat2 : lstat2;
  const srcStat = await statFn(src);
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR2({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: "cp",
      errno: EISDIR,
      code: "EISDIR"
    });
  } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {
    return onFile(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isSymbolicLink()) {
    return onLink(destStat, src, dest, opts);
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET2({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL,
      code: "EINVAL"
    });
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE2({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL,
      code: "EINVAL"
    });
  }
  throw new ERR_FS_CP_UNKNOWN2({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: "cp",
    errno: EINVAL,
    code: "EINVAL"
  });
}
function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat) return _copyFile(srcStat, src, dest, opts);
  return mayCopyFile(srcStat, src, dest, opts);
}
async function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.force) {
    await unlink2(dest);
    return _copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST2({
      message: `${dest} already exists`,
      path: dest,
      syscall: "cp",
      errno: EEXIST,
      code: "EEXIST"
    });
  }
}
async function _copyFile(srcStat, src, dest, opts) {
  await copyFile2(src, dest);
  if (opts.preserveTimestamps) {
    return handleTimestampsAndMode(srcStat.mode, src, dest);
  }
  return setDestMode(dest, srcStat.mode);
}
async function handleTimestampsAndMode(srcMode, src, dest) {
  if (fileIsNotWritable(srcMode)) {
    await makeFileWritable(dest, srcMode);
    return setDestTimestampsAndMode(srcMode, src, dest);
  }
  return setDestTimestampsAndMode(srcMode, src, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
async function setDestTimestampsAndMode(srcMode, src, dest) {
  await setDestTimestamps(src, dest);
  return setDestMode(dest, srcMode);
}
function setDestMode(dest, srcMode) {
  return chmod2(dest, srcMode);
}
async function setDestTimestamps(src, dest) {
  const updatedSrcStat = await stat2(src);
  return utimes2(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
  return copyDir(src, dest, opts);
}
async function mkDirAndCopy(srcMode, src, dest, opts) {
  await mkdir2(dest);
  await copyDir(src, dest, opts);
  return setDestMode(dest, srcMode);
}
async function copyDir(src, dest, opts) {
  const dir = await opendir2(src);
  for await (const { name } of dir) {
    const srcItem = join2(src, name);
    const destItem = join2(dest, name);
    const { destStat } = await checkPaths(srcItem, destItem, opts);
    await startCopy(destStat, srcItem, destItem, opts);
  }
}
async function onLink(destStat, src, dest, opts) {
  let resolvedSrc = await readlink2(src);
  if (!opts.verbatimSymlinks && !isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc);
  }
  if (!destStat) {
    return symlink2(resolvedSrc, dest);
  }
  let resolvedDest;
  try {
    resolvedDest = await readlink2(dest);
  } catch (err3) {
    if (err3.code === "EINVAL" || err3.code === "UNKNOWN") {
      return symlink2(resolvedSrc, dest);
    }
    throw err3;
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest);
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL2({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ${resolvedDest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL,
      code: "EINVAL"
    });
  }
  const srcStat = await stat2(src);
  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY2({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL,
      code: "EINVAL"
    });
  }
  return copyLink(resolvedSrc, dest);
}
async function copyLink(resolvedSrc, dest) {
  await unlink2(dest);
  return symlink2(resolvedSrc, dest);
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/util/types.js
var types_default = { ...types_exports };

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs/cp/cp-sync.js
var {
  errno: {
    EEXIST: EEXIST2,
    EISDIR: EISDIR2,
    EINVAL: EINVAL2,
    ENOTDIR: ENOTDIR2
  }
} = os;
var {
  ERR_FS_CP_DIR_TO_NON_DIR: ERR_FS_CP_DIR_TO_NON_DIR3,
  ERR_FS_CP_EEXIST: ERR_FS_CP_EEXIST3,
  ERR_FS_CP_EINVAL: ERR_FS_CP_EINVAL3,
  ERR_FS_CP_FIFO_PIPE: ERR_FS_CP_FIFO_PIPE3,
  ERR_FS_CP_NON_DIR_TO_DIR: ERR_FS_CP_NON_DIR_TO_DIR3,
  ERR_FS_CP_SOCKET: ERR_FS_CP_SOCKET3,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY: ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY3,
  ERR_FS_CP_UNKNOWN: ERR_FS_CP_UNKNOWN3,
  ERR_FS_EISDIR: ERR_FS_EISDIR3,
  ERR_INVALID_RETURN_VALUE: ERR_INVALID_RETURN_VALUE2
} = errors_exports;
function cpSyncFn(src, dest, opts) {
  if (opts.preserveTimestamps && process2.arch === "ia32") {
    const warning = "Using the preserveTimestamps option in 32-bit node is not recommended";
    process2.emitWarning(warning, "TimestampPrecisionWarning");
  }
  const { srcStat, destStat } = checkPathsSync(src, dest, opts);
  checkParentPathsSync(src, srcStat, dest);
  return handleFilterAndCopy(destStat, src, dest, opts);
}
function checkPathsSync(src, dest, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL3({
        message: "src and dest cannot be the same",
        path: dest,
        syscall: "cp",
        errno: EINVAL2,
        code: "EINVAL"
      });
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR3({
        message: `cannot overwrite directory ${src} with non-directory ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EISDIR2,
        code: "EISDIR"
      });
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR3({
        message: `cannot overwrite non-directory ${src} with directory ${dest}`,
        path: dest,
        syscall: "cp",
        errno: ENOTDIR2,
        code: "ENOTDIR"
      });
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL3({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL2,
      code: "EINVAL"
    });
  }
  return { srcStat, destStat };
}
function getStatsSync(src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file) => statSync(file, { bigint: true }) : (file) => lstatSync(file, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err3) {
    if (err3.code === "ENOENT") return { srcStat, destStat: null };
    throw err3;
  }
  return { srcStat, destStat };
}
function checkParentPathsSync(src, srcStat, dest) {
  const srcParent = resolve(dirname(src));
  const destParent = resolve(dirname(dest));
  if (destParent === srcParent || destParent === parse2(destParent).root || destParent === ".") return;
  let destStat;
  try {
    destStat = statSync(destParent, { bigint: true });
  } catch (err3) {
    if (err3.code === "ENOENT") return;
    throw err3;
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL3({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL2,
      code: "EINVAL"
    });
  }
  return checkParentPathsSync(src, srcStat, destParent);
}
function handleFilterAndCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    const shouldCopy = opts.filter(src, dest);
    if (isPromise(shouldCopy)) {
      throw new ERR_INVALID_RETURN_VALUE2("boolean", "filter", shouldCopy);
    }
    if (!shouldCopy) return;
  }
  const destParent = dirname(dest);
  if (!existsSync(destParent)) mkdirSync(destParent, { recursive: true });
  return getStats2(destStat, src, dest, opts);
}
function startCopy2(destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return;
  return getStats2(destStat, src, dest, opts);
}
function getStats2(destStat, src, dest, opts) {
  const statSyncFn = opts.dereference ? statSync : lstatSync;
  const srcStat = statSyncFn(src);
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir2(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR3({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: "cp",
      errno: EINVAL2,
      code: "EISDIR"
    });
  } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {
    return onFile2(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isSymbolicLink()) {
    return onLink2(destStat, src, dest, opts);
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET3({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL2,
      code: "EINVAL"
    });
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE3({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL2,
      code: "EINVAL"
    });
  }
  throw new ERR_FS_CP_UNKNOWN3({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: "cp",
    errno: EINVAL2,
    code: "EINVAL"
  });
}
function onFile2(srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile3(srcStat, src, dest, opts);
  return mayCopyFile2(srcStat, src, dest, opts);
}
function mayCopyFile2(srcStat, src, dest, opts) {
  if (opts.force) {
    unlinkSync(dest);
    return copyFile3(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST3({
      message: `${dest} already exists`,
      path: dest,
      syscall: "cp",
      errno: EEXIST2,
      code: "EEXIST"
    });
  }
}
function copyFile3(srcStat, src, dest, opts) {
  copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode2(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable2(srcMode)) makeFileWritable2(dest, srcMode);
  return setDestTimestamps2(src, dest);
}
function fileIsNotWritable2(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable2(dest, srcMode) {
  return setDestMode2(dest, srcMode | 128);
}
function setDestMode2(dest, srcMode) {
  return chmodSync(dest, srcMode);
}
function setDestTimestamps2(src, dest) {
  const updatedSrcStat = statSync(src);
  return utimesSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir2(srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy2(srcStat.mode, src, dest, opts);
  return copyDir2(src, dest, opts);
}
function mkDirAndCopy2(srcMode, src, dest, opts) {
  mkdirSync(dest);
  copyDir2(src, dest, opts);
  return setDestMode2(dest, srcMode);
}
function copyDir2(src, dest, opts) {
  const dir = opendirSync(src);
  try {
    let dirent;
    while ((dirent = dir.readSync()) !== null) {
      const { name } = dirent;
      const srcItem = join2(src, name);
      const destItem = join2(dest, name);
      const { destStat } = checkPathsSync(srcItem, destItem, opts);
      startCopy2(destStat, srcItem, destItem, opts);
    }
  } finally {
    dir.closeSync();
  }
}
function onLink2(destStat, src, dest, opts) {
  let resolvedSrc = readlinkSync(src);
  if (!opts.verbatimSymlinks && !isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc);
  }
  if (!destStat) {
    return symlinkSync(resolvedSrc, dest);
  }
  let resolvedDest;
  try {
    resolvedDest = readlinkSync(dest);
  } catch (err3) {
    if (err3.code === "EINVAL" || err3.code === "UNKNOWN") {
      return symlinkSync(resolvedSrc, dest);
    }
    throw err3;
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest);
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL3({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ${resolvedDest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL2,
      code: "EINVAL"
    });
  }
  if (statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY3({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL2,
      code: "EINVAL"
    });
  }
  return copyLink2(resolvedSrc, dest);
}
function copyLink2(resolvedSrc, dest) {
  unlinkSync(dest);
  return symlinkSync(resolvedSrc, dest);
}
var cp_sync_default = cpSyncFn;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/end-of-stream.js
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
  return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
  return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
  return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
  if (stream.writableFinished) return true;
  const wState = stream._writableState;
  if (!wState || wState.errored) return false;
  return wState.finished || wState.ended && wState.length === 0;
}
var nop = () => {
};
function isReadableEnded(stream) {
  if (stream.readableEnded) return true;
  const rState = stream._readableState;
  if (!rState || rState.errored) return false;
  return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  } else if (options == null) {
    options = {};
  } else {
    validateObject(options, "options");
  }
  validateFunction(callback, "callback");
  validateAbortSignal2(options.signal, "options.signal");
  callback = once2(callback);
  const readable = options.readable || options.readable !== false && isReadable(stream);
  const writable = options.writable || options.writable !== false && isWritable(stream);
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  const onlegacyfinish = () => {
    if (!stream.writable) onfinish();
  };
  let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
  let writableFinished = stream.writableFinished || wState && wState.finished;
  const onfinish = () => {
    writableFinished = true;
    if (stream.destroyed) willEmitClose = false;
    if (willEmitClose && (!stream.readable || readable)) return;
    if (!readable || readableEnded) callback.call(stream);
  };
  let readableEnded = stream.readableEnded || rState && rState.endEmitted;
  const onend = () => {
    readableEnded = true;
    if (stream.destroyed) willEmitClose = false;
    if (willEmitClose && (!stream.writable || writable)) return;
    if (!writable || writableFinished) callback.call(stream);
  };
  const onerror = (err3) => {
    callback.call(stream, err3);
  };
  const onclose = () => {
    if (readable && !readableEnded) {
      if (!isReadableEnded(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    callback.call(stream);
  };
  const onrequest = () => {
    stream.req.on("finish", onfinish);
  };
  if (isRequest(stream)) {
    stream.on("complete", onfinish);
    if (!willEmitClose) {
      stream.on("abort", onclose);
    }
    if (stream.req) onrequest();
    else stream.on("request", onrequest);
  } else if (writable && !wState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  if (!willEmitClose && typeof stream.aborted === "boolean") {
    stream.on("aborted", onclose);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (options.error !== false) stream.on("error", onerror);
  stream.on("close", onclose);
  const closed = !wState && !rState && stream._closed === true || (wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted));
  if (closed) {
    nextTick(() => {
      callback();
    });
  }
  const cleanup = () => {
    callback = nop;
    stream.removeListener("aborted", onclose);
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req) stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
  if (options.signal && !closed) {
    const abort2 = () => {
      const endCallback = callback;
      cleanup();
      endCallback.call(stream, new AbortError2());
    };
    if (options.signal.aborted) {
      nextTick(abort2);
    } else {
      const originalCallback = callback;
      callback = once2((...args2) => {
        options.signal.removeEventListener("abort", abort2);
        originalCallback.apply(stream, args2);
      });
      options.signal.addEventListener("abort", abort2);
    }
  }
  return cleanup;
}
var end_of_stream_default = eos;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/add-abort-signal.js
var validateAbortSignal3 = (signal, name) => {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
};
function isStream(obj) {
  return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
  validateAbortSignal3(signal, "signal");
  if (!isStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
  }
  return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    return stream;
  }
  const onAbort = () => {
    stream.destroy(new AbortError2());
  };
  if (signal.aborted) {
    onAbort();
  } else {
    signal.addEventListener("abort", onAbort);
    end_of_stream_default(stream, () => signal.removeEventListener("abort", onAbort));
  }
  return stream;
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/destroy.js
var kDestroy = Symbol("kDestroy");
var kConstruct = Symbol("kConstruct");
function checkError(err3, w, r3) {
  if (err3) {
    err3.stack;
    if (w && !w.errored) {
      w.errored = err3;
    }
    if (r3 && !r3.errored) {
      r3.errored = err3;
    }
  }
}
function destroy(err3, cb) {
  const r3 = this._readableState;
  const w = this._writableState;
  const s = w || r3;
  if (w && w.destroyed || r3 && r3.destroyed) {
    if (typeof cb === "function") {
      cb();
    }
    return this;
  }
  checkError(err3, w, r3);
  if (w) {
    w.destroyed = true;
  }
  if (r3) {
    r3.destroyed = true;
  }
  if (!s.constructed) {
    this.once(kDestroy, function(er) {
      _destroy(this, aggregateTwoErrors(er, err3), cb);
    });
  } else {
    _destroy(this, err3, cb);
  }
  return this;
}
function _destroy(self2, err3, cb) {
  let called = false;
  function onDestroy(err4) {
    if (called) {
      return;
    }
    called = true;
    const r3 = self2._readableState;
    const w = self2._writableState;
    checkError(err4, w, r3);
    if (w) {
      w.closed = true;
    }
    if (r3) {
      r3.closed = true;
    }
    if (typeof cb === "function") {
      cb(err4);
    }
    if (err4) {
      nextTick(emitErrorCloseNT, self2, err4);
    } else {
      nextTick(emitCloseNT, self2);
    }
  }
  try {
    const result2 = self2._destroy(err3 || null, onDestroy);
    if (result2 != null) {
      const then = result2.then;
      if (typeof then === "function") {
        then.call(
          result2,
          function() {
            nextTick(onDestroy, null);
          },
          function(err4) {
            nextTick(onDestroy, err4);
          }
        );
      }
    }
  } catch (err4) {
    onDestroy(err4);
  }
}
function emitErrorCloseNT(self2, err3) {
  emitErrorNT(self2, err3);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  const r3 = self2._readableState;
  const w = self2._writableState;
  if (w) {
    w.closeEmitted = true;
  }
  if (r3) {
    r3.closeEmitted = true;
  }
  if (w && w.emitClose || r3 && r3.emitClose) {
    self2.emit("close");
  }
}
function emitErrorNT(self2, err3) {
  const r3 = self2._readableState;
  const w = self2._writableState;
  if (w && w.errorEmitted || r3 && r3.errorEmitted) {
    return;
  }
  if (w) {
    w.errorEmitted = true;
  }
  if (r3) {
    r3.errorEmitted = true;
  }
  self2.emit("error", err3);
}
function undestroy() {
  const r3 = this._readableState;
  const w = this._writableState;
  if (r3) {
    r3.constructed = true;
    r3.closed = false;
    r3.closeEmitted = false;
    r3.destroyed = false;
    r3.errored = null;
    r3.errorEmitted = false;
    r3.reading = false;
    r3.ended = false;
    r3.endEmitted = false;
  }
  if (w) {
    w.constructed = true;
    w.destroyed = false;
    w.closed = false;
    w.closeEmitted = false;
    w.errored = null;
    w.errorEmitted = false;
    w.ended = false;
    w.ending = false;
    w.finalCalled = false;
    w.prefinished = false;
    w.finished = false;
  }
}
function errorOrDestroy(stream, err3, sync) {
  const r3 = stream._readableState;
  const w = stream._writableState;
  if (w && w.destroyed || r3 && r3.destroyed) {
    return this;
  }
  if (r3 && r3.autoDestroy || w && w.autoDestroy) {
    stream.destroy(err3);
  } else if (err3) {
    err3.stack;
    if (w && !w.errored) {
      w.errored = err3;
    }
    if (r3 && !r3.errored) {
      r3.errored = err3;
    }
    if (sync) {
      nextTick(emitErrorNT, stream, err3);
    } else {
      emitErrorNT(stream, err3);
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== "function") {
    return;
  }
  const r3 = stream._readableState;
  const w = stream._writableState;
  if (r3) {
    r3.constructed = false;
  }
  if (w) {
    w.constructed = false;
  }
  stream.once(kConstruct, cb);
  if (stream.listenerCount(kConstruct) > 1) {
    return;
  }
  nextTick(constructNT, stream);
}
function constructNT(stream) {
  let called = false;
  function onConstruct(err3) {
    if (called) {
      errorOrDestroy(stream, err3 ?? new ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    const r3 = stream._readableState;
    const w = stream._writableState;
    const s = w || r3;
    if (r3) {
      r3.constructed = true;
    }
    if (w) {
      w.constructed = true;
    }
    if (s.destroyed) {
      stream.emit(kDestroy, err3);
    } else if (err3) {
      errorOrDestroy(stream, err3, true);
    } else {
      nextTick(emitConstructNT, stream);
    }
  }
  try {
    const result2 = stream._construct(onConstruct);
    if (result2 != null) {
      const then = result2.then;
      if (typeof then === "function") {
        then.call(
          result2,
          function() {
            nextTick(onConstruct, null);
          },
          function(err3) {
            nextTick(onConstruct, err3);
          }
        );
      }
    }
  } catch (err3) {
    onConstruct(err3);
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct);
}
function isRequest2(stream) {
  return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err3) {
  if (!stream) return;
  if (isRequest2(stream)) return stream.abort();
  if (isRequest2(stream.req)) return stream.req.abort();
  if (typeof stream.destroy === "function") return stream.destroy(err3);
  if (typeof stream.close === "function") return stream.close();
}
var destroy_default = {
  construct,
  destroyer,
  destroy,
  undestroy,
  errorOrDestroy
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/utils.js
var kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
  return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && // Duplex
  (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
  return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
  return !!(obj && (typeof obj.pipe === "function" && obj._readableState) && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
  return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync2) {
  if (obj == null) return false;
  if (isAsync2 === true) return typeof obj[Symbol.asyncIterator] === "function";
  if (isAsync2 === false) return typeof obj[Symbol.iterator] === "function";
  return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
  if (!isNodeStream(stream)) return null;
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream)) return null;
  if (stream.writableEnded === true) return true;
  const wState = stream._writableState;
  if (wState?.errored) return false;
  if (typeof wState?.ended !== "boolean") return null;
  return wState.ended;
}
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream)) return null;
  const rState = stream._readableState;
  if (rState?.errored) return false;
  if (typeof rState?.endEmitted !== "boolean") return null;
  return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
  return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable2(stream) {
  const r3 = isReadableNodeStream(stream);
  if (r3 === null || typeof stream?.readable !== "boolean") return null;
  if (isDestroyed(stream)) return false;
  return r3 && stream.readable && !isReadableFinished(stream);
}
function isWritable2(stream) {
  const r3 = isWritableNodeStream(stream);
  if (r3 === null || typeof stream?.writable !== "boolean") return null;
  if (isDestroyed(stream)) return false;
  return r3 && stream.writable && !isWritableEnded(stream);
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/from.js
init_buffer();
function _from(Readable2, iterable, opts) {
  let iterator;
  if (typeof iterable === "string" || iterable instanceof Buffer2) {
    return new Readable2({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable);
        this.push(null);
      }
    });
  }
  let isAsync2;
  if (iterable && iterable[Symbol.asyncIterator]) {
    isAsync2 = true;
    iterator = iterable[Symbol.asyncIterator]();
  } else if (iterable && iterable[Symbol.iterator]) {
    isAsync2 = false;
    iterator = iterable[Symbol.iterator]();
  } else {
    throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
  }
  const readable = new Readable2({
    objectMode: true,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...opts
  });
  let reading = false;
  readable._read = function() {
    if (!reading) {
      reading = true;
      next();
    }
  };
  readable._destroy = function(error2, cb) {
    close2(error2).then(
      () => nextTick(cb, error2),
      // nextTick is here in case cb throws
      (e3) => nextTick(cb, e3 || error2)
    );
  };
  async function close2(error2) {
    const hadError = error2 !== void 0 && error2 !== null;
    const hasThrow = typeof iterator.throw === "function";
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error2);
      await value;
      if (done) {
        return;
      }
    }
    if (typeof iterator.return === "function") {
      const { value } = await iterator.return();
      await value;
    }
  }
  async function next() {
    for (; ; ) {
      try {
        const { value, done } = isAsync2 ? await iterator.next() : iterator.next();
        if (done) {
          readable.push(null);
        } else {
          const res = value && typeof value.then === "function" ? await value : value;
          if (res === null) {
            reading = false;
            throw new ERR_STREAM_NULL_VALUES();
          } else if (readable.push(res)) {
            continue;
          } else {
            reading = false;
          }
        }
      } catch (err3) {
        readable.destroy(err3);
      }
      break;
    }
  }
  return readable;
}
var from_default = _from;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/readable.js
init_buffer();

// ../../../../../../node_modules/wasmedge_quickjs/modules/fmt/printf.js
var State = {
  PASSTHROUGH: 1,
  PERCENT: 2,
  POSITIONAL: 3,
  PRECISION: 4,
  WIDTH: 5
};
var WorP = {
  WIDTH: "WIDTH",
  PRECISION: "PREC"
};
var Flags = class {
  plus;
  dash;
  sharp;
  space;
  zero;
  lessthan;
  width = -1;
  precision = -1;
};
var min = Math.min;
var UNICODE_REPLACEMENT_CHARACTER = "\uFFFD";
var DEFAULT_PRECISION = 6;
var FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F = {
  sign: 1,
  mantissa: 2,
  fractional: 3,
  esign: 4,
  exponent: 5
};
var Printf = class {
  format;
  args = [];
  i;
  state = State.PASSTHROUGH;
  verb = "";
  buf = "";
  argNum = 0;
  flags = new Flags();
  haveSeen;
  // barf, store precision and width errors for later processing ...
  tmpError;
  constructor(format3, ...args2) {
    this.format = format3;
    this.args = args2;
    this.haveSeen = Array.from({ length: args2.length });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c2 = this.format[this.i];
      switch (this.state) {
        case State.PASSTHROUGH:
          if (c2 === "%") {
            this.state = State.PERCENT;
          } else {
            this.buf += c2;
          }
          break;
        case State.PERCENT:
          if (c2 === "%") {
            this.buf += c2;
            this.state = State.PASSTHROUGH;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err3 = "%!(EXTRA)";
    if (extras) {
      this.buf += err3;
    }
    return this.buf;
  }
  // %[<positional>]<flag>...<verb>
  handleFormat() {
    this.flags = new Flags();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c2 = this.format[this.i];
      switch (this.state) {
        case State.PERCENT:
          switch (c2) {
            case "[":
              this.handlePositional();
              this.state = State.POSITIONAL;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c2 && c2 <= "9" || c2 === "." || c2 === "*") {
                if (c2 === ".") {
                  this.flags.precision = 0;
                  this.state = State.PRECISION;
                  this.i++;
                } else {
                  this.state = State.WIDTH;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case State.POSITIONAL:
          if (c2 === "*") {
            const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
            this.handleWidthOrPrecisionRef(worp);
            this.state = State.PERCENT;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  /**
   * Handle width or precision
   * @param wOrP
   */
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case WorP.WIDTH:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  /**
   * Handle width and precision
   * @param flags
   */
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c2 = fmt[this.i];
      switch (this.state) {
        case State.WIDTH:
          switch (c2) {
            case ".":
              this.flags.precision = 0;
              this.state = State.PRECISION;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(WorP.WIDTH);
              break;
            default: {
              const val = parseInt(c2);
              if (isNaN(val)) {
                this.i--;
                this.state = State.PERCENT;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case State.PRECISION: {
          if (c2 === "*") {
            this.handleWidthOrPrecisionRef(WorP.PRECISION);
            break;
          }
          const val = parseInt(c2);
          if (isNaN(val)) {
            this.i--;
            this.state = State.PERCENT;
            return;
          }
          flags.precision *= 10;
          flags.precision += val;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  /** Handle positional */
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format3 = this.format;
    this.i++;
    let err3 = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format3[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format3[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err3 = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err3 = true;
    }
    this.argNum = err3 ? this.argNum : positional - 1;
    return;
  }
  /** Handle less than */
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i2 = 0; i2 !== arg.length; ++i2) {
      if (i2 !== 0) str += ", ";
      str += this._handleVerb(arg[i2]);
    }
    return str + " ]";
  }
  /** Handle verb */
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = State.PASSTHROUGH;
  }
  // deno-lint-ignore no-explicit-any
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  /**
   * Pad a string
   * @param s text to pad
   */
  pad(s) {
    const padding3 = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s.padEnd(this.flags.width, padding3);
    }
    return s.padStart(this.flags.width, padding3);
  }
  /**
   * Pad a number
   * @param nStr
   * @param neg
   */
  padNum(nStr, neg) {
    let sign;
    if (neg) {
      sign = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign = this.flags.plus ? "+" : " ";
    } else {
      sign = "";
    }
    const zero2 = this.flags.zero;
    if (!zero2) {
      nStr = sign + nStr;
    }
    const pad2 = zero2 ? "0" : " ";
    const len = zero2 ? this.flags.width - sign.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad2);
    } else {
      nStr = nStr.padStart(len, pad2);
    }
    if (zero2) {
      nStr = sign + nStr;
    }
    return nStr;
  }
  /**
   * Format a number
   * @param n
   * @param radix
   * @param upcase
   */
  fmtNumber(n5, radix, upcase = false) {
    let num = Math.abs(n5).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n5 === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n5 < 0);
  }
  /**
   * Format number with code points
   * @param n
   */
  fmtNumberCodePoint(n5) {
    let s = "";
    try {
      s = String.fromCodePoint(n5);
    } catch {
      s = UNICODE_REPLACEMENT_CHARACTER;
    }
    return this.pad(s);
  }
  /**
   * Format special float
   * @param n
   */
  fmtFloatSpecial(n5) {
    if (isNaN(n5)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n5 === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n5 === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  /**
   * Round fraction to precision
   * @param fractional
   * @param precision
   * @returns tuple of fractional and round
   */
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [fractional, round];
  }
  /**
   * Format float E
   * @param n
   * @param upcase
   */
  fmtFloatE(n5, upcase = false) {
    const special = this.fmtFloatSpecial(n5);
    if (special !== "") {
      return special;
    }
    const m2 = n5.toExponential().match(FLOAT_REGEXP);
    if (!m2) {
      throw Error("can't happen, bug");
    }
    let fractional = m2[F.fractional];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(
      fractional,
      precision
    );
    let e3 = m2[F.exponent];
    let esign = m2[F.esign];
    let mantissa = parseInt(m2[F.mantissa]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r3 = parseInt(esign + e3) + 1;
        e3 = r3.toString();
        esign = r3 < 0 ? "-" : "+";
      }
    }
    e3 = e3.length == 1 ? "0" + e3 : e3;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e3}`;
    return this.padNum(val, n5 < 0);
  }
  /**
   * Format float F
   * @param n
   */
  fmtFloatF(n5) {
    const special = this.fmtFloatSpecial(n5);
    if (special !== "") {
      return special;
    }
    function expandNumber(n6) {
      if (Number.isSafeInteger(n6)) {
        return n6.toString() + ".";
      }
      const t2 = n6.toExponential().split("e");
      let m2 = t2[0].replace(".", "");
      const e3 = parseInt(t2[1]);
      if (e3 < 0) {
        let nStr = "0.";
        for (let i2 = 0; i2 !== Math.abs(e3) - 1; ++i2) {
          nStr += "0";
        }
        return nStr += m2;
      } else {
        const splIdx = e3 + 1;
        while (m2.length < splIdx) {
          m2 += "0";
        }
        return m2.substr(0, splIdx) + "." + m2.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n5));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n5 < 0);
  }
  /**
   * Format float G
   * @param n
   * @param upcase
   */
  fmtFloatG(n5, upcase = false) {
    const special = this.fmtFloatSpecial(n5);
    if (special !== "") {
      return special;
    }
    let P2 = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    P2 = P2 === 0 ? 1 : P2;
    const m2 = n5.toExponential().match(FLOAT_REGEXP);
    if (!m2) {
      throw Error("can't happen");
    }
    const X = parseInt(m2[F.exponent]) * (m2[F.esign] === "-" ? -1 : 1);
    let nStr = "";
    if (P2 > X && X >= -4) {
      this.flags.precision = P2 - (X + 1);
      nStr = this.fmtFloatF(n5);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P2 - 1;
      nStr = this.fmtFloatE(n5);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  /**
   * Format string
   * @param s
   */
  fmtString(s) {
    if (this.flags.precision !== -1) {
      s = s.substr(0, this.flags.precision);
    }
    return this.pad(s);
  }
  /**
   * Format hex
   * @param val
   * @param upper
   */
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min(prec, val.length) : val.length;
        for (let i2 = 0; i2 !== end; ++i2) {
          if (i2 !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c2 = (val.charCodeAt(i2) & 255).toString(16);
          hex += c2.length === 1 ? `0${c2}` : c2;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error(
          "currently only number and string are implemented for hex"
        );
    }
  }
  /**
   * Format value
   * @param val
   */
  fmtV(val) {
    if (this.flags.sharp) {
      return this.pad(JSON.stringify(val));
    } else {
      const p3 = this.flags.precision;
      return p3 === -1 ? val.toString() : val.toString().substr(0, p3);
    }
  }
  /**
   * Format JSON
   * @param val
   */
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf(format3, ...args2) {
  const printf = new Printf(format3, ...args2);
  return printf.doPrintf();
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/util/debuglog.js
var debugImpls;
var testEnabled;
function initializeDebugEnv(debugEnv2) {
  debugImpls = /* @__PURE__ */ Object.create(null);
  if (debugEnv2) {
    debugEnv2 = debugEnv2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv2}$`, "i");
    testEnabled = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled = () => false;
  }
}
function emitWarningIfNeeded(set) {
  if ("HTTP" === set || "HTTP2" === set) {
    console.warn(
      "Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log."
    );
  }
}
var noop2 = () => {
};
function debuglogImpl(enabled, set) {
  if (debugImpls[set] === void 0) {
    if (enabled) {
      emitWarningIfNeeded(set);
      debugImpls[set] = function debug2(...args2) {
        const msg = args2.map((arg) => JSON.stringify(arg)).join(" ");
        console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls[set] = noop2;
    }
  }
  return debugImpls[set];
}
function debuglog(set, cb) {
  function init6() {
    set = set.toUpperCase();
    enabled = testEnabled(set);
  }
  let debug2 = (...args2) => {
    init6();
    debug2 = debuglogImpl(enabled, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args2);
  };
  let enabled;
  let test = () => {
    init6();
    test = () => enabled;
    return enabled;
  };
  const logger = (...args2) => debug2(...args2);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv = env["NODE_DEBUG"] ?? "";
initializeDebugEnv(debugEnv);

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/state.js
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!Number.isInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
      throw new ERR_INVALID_ARG_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return getDefaultHighWaterMark(state.objectMode);
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/events.js
var domain2;
var kRejection = Symbol.for("nodejs.rejection");
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}
var captureRejectionSymbol = EventEmitter.captureRejectionSymbol;
EventEmitter.captureRejectionSymbol = kRejection;
var events_default = EventEmitter;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = void 0;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._maxListeners = void 0;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    if (domain2.active && !(this instanceof domain2.Domain)) {
      this.domain = domain2.active;
    }
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n5) {
  if (typeof n5 !== "number" || n5 < 0 || isNaN(n5))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n5;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args2) {
  if (isFn)
    handler.apply(self2, args2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].apply(self2, args2);
  }
}
EventEmitter.prototype.emit = function emit2(type) {
  var er, handler, len, args2, i2, events, domain3;
  var needDomainExit = false;
  var doError = type === "error";
  events = this._events;
  if (events)
    doError = doError && events.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err3 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err3.context = er;
      throw err3;
    }
    return false;
  }
  handler = events[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args2 = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args2[i2 - 1] = arguments[i2];
      emitMany(handler, isFn, this, args2);
  }
  if (needDomainExit)
    domain3.exit();
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning2(w);
      }
    }
  }
  return target;
}
function emitWarning2(e3) {
  typeof console.warn === "function" ? console.warn(e3) : console.log(e3);
}
EventEmitter.prototype.addListener = function addListener2(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener2(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g2() {
    target.removeListener(type, g2);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g2.listener = listener;
  return g2;
}
EventEmitter.prototype.once = function once3(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
  var list, events, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = this._events;
  if (!events)
    return this;
  list = events[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
  var listeners3, events;
  events = this._events;
  if (!events)
    return this;
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i2 = 0, key; i2 < keys.length; ++i2) {
      key = keys[i2];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners2(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index) {
  for (var i2 = index, k = i2 + 1, n5 = list.length; k < n5; i2 += 1, k += 1)
    list[i2] = list[k];
  list.pop();
}
function arrayClone(arr, i2) {
  var copy7 = new Array(i2);
  while (i2--)
    copy7[i2] = arr[i2];
  return copy7;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/legacy.js
function Stream(opts) {
  events_default.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, events_default.prototype);
Object.setPrototypeOf(Stream, events_default);
Stream.prototype.pipe = function(dest, options) {
  const source = this;
  function ondata(chunk2) {
    if (dest.writable && dest.write(chunk2) === false && source.pause) {
      source.pause();
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  let didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (events_default.listenerCount(this, "error") === 0) {
      this.emit("error", er);
    }
  }
  prependListener3(source, "error", onerror);
  prependListener3(dest, "error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
function prependListener3(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  }
  if (!emitter._events || !emitter._events[event]) {
    emitter.on(event, fn);
  } else if (Array.isArray(emitter._events[event])) {
    emitter._events[event].unshift(fn);
  } else {
    emitter._events[event] = [fn, emitter._events[event]];
  }
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/string_decoder.js
init_buffer();
var isBufferEncoding = Buffer2.isEncoding || function(encoding2) {
  switch (encoding2 && encoding2.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding2) {
  if (encoding2 && !isBufferEncoding(encoding2)) {
    throw new Error("Unknown encoding: " + encoding2);
  }
}
function StringDecoder(encoding2) {
  this.encoding = (encoding2 || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding2);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end);
  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  var i2 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i2 > 0; i2--) {
    var c2 = buffer[buffer.length - i2];
    if (i2 == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/buffer_list.js
init_buffer();
var BufferList = class {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(v2) {
    const entry = { data: v2, next: null };
    if (this.length > 0) {
      this.tail.next = entry;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    ++this.length;
  }
  unshift(v2) {
    const entry = { data: v2, next: this.head };
    if (this.length === 0) {
      this.tail = entry;
    }
    this.head = entry;
    ++this.length;
  }
  shift() {
    if (this.length === 0) {
      return;
    }
    const ret = this.head.data;
    if (this.length === 1) {
      this.head = this.tail = null;
    } else {
      this.head = this.head.next;
    }
    --this.length;
    return ret;
  }
  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }
  join(s) {
    if (this.length === 0) {
      return "";
    }
    let p3 = this.head;
    let ret = "" + p3.data;
    while (p3 = p3.next) {
      ret += s + p3.data;
    }
    return ret;
  }
  concat(n5) {
    if (this.length === 0) {
      return Buffer2.alloc(0);
    }
    const ret = Buffer2.allocUnsafe(n5 >>> 0);
    let p3 = this.head;
    let i2 = 0;
    while (p3) {
      ret.set(p3.data, i2);
      i2 += p3.data.length;
      p3 = p3.next;
    }
    return ret;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(n5, hasStrings) {
    const data = this.head.data;
    if (n5 < data.length) {
      const slice = data.slice(0, n5);
      this.head.data = data.slice(n5);
      return slice;
    }
    if (n5 === data.length) {
      return this.shift();
    }
    return hasStrings ? this._getString(n5) : this._getBuffer(n5);
  }
  first() {
    return this.head.data;
  }
  *[Symbol.iterator]() {
    for (let p3 = this.head; p3; p3 = p3.next) {
      yield p3.data;
    }
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(n5) {
    let ret = "";
    let p3 = this.head;
    let c2 = 0;
    do {
      const str = p3.data;
      if (n5 > str.length) {
        ret += str;
        n5 -= str.length;
      } else {
        if (n5 === str.length) {
          ret += str;
          ++c2;
          if (p3.next) {
            this.head = p3.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret += str.slice(0, n5);
          this.head = p3;
          p3.data = str.slice(n5);
        }
        break;
      }
      ++c2;
    } while (p3 = p3.next);
    this.length -= c2;
    return ret;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(n5) {
    const ret = Buffer2.allocUnsafe(n5);
    const retLen = n5;
    let p3 = this.head;
    let c2 = 0;
    do {
      const buf = p3.data;
      if (n5 > buf.length) {
        ret.set(buf, retLen - n5);
        n5 -= buf.length;
      } else {
        if (n5 === buf.length) {
          ret.set(buf, retLen - n5);
          ++c2;
          if (p3.next) {
            this.head = p3.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret.set(
            new Uint8Array(buf.buffer, buf.byteOffset, n5),
            retLen - n5
          );
          this.head = p3;
          p3.data = buf.slice(n5);
        }
        break;
      }
      ++c2;
    } while (p3 = p3.next);
    this.length -= c2;
    return ret;
  }
};
var buffer_list_default = BufferList;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/readable.js
var debug = debuglog("stream", (fn) => {
  debug = fn;
});
var kPaused = Symbol("kPaused");
var nop2 = () => {
};
var { errorOrDestroy: errorOrDestroy2 } = destroy_default;
function ReadableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = stream instanceof Stream.Duplex;
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = [];
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.constructed = true;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this[kPaused] = null;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.destroyed = false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.awaitDrainWriters = null;
  this.multiAwaitDrain = false;
  this.readingMore = false;
  this.dataEmitted = false;
  this.decoder = null;
  this.encoding = null;
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  }
  const isDuplex = this instanceof Stream.Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);
  if (options) {
    if (typeof options.read === "function") {
      this._read = options.read;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal && !isDuplex) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  destroy_default.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState);
    }
  });
}
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
Readable.prototype.destroy = destroy_default.destroy;
Readable.prototype._undestroy = destroy_default.undestroy;
Readable.prototype._destroy = function(err3, cb) {
  cb(err3);
};
Readable.prototype[events_default.captureRejectionSymbol] = function(err3) {
  this.destroy(err3);
};
Readable.prototype.push = function(chunk2, encoding2) {
  return readableAddChunk(this, chunk2, encoding2, false);
};
Readable.prototype.unshift = function(chunk2, encoding2) {
  return readableAddChunk(this, chunk2, encoding2, true);
};
function readableAddChunk(stream, chunk2, encoding2, addToFront) {
  debug("readableAddChunk", chunk2);
  const state = stream._readableState;
  let err3;
  if (!state.objectMode) {
    if (typeof chunk2 === "string") {
      encoding2 = encoding2 || state.defaultEncoding;
      if (state.encoding !== encoding2) {
        if (addToFront && state.encoding) {
          chunk2 = Buffer2.from(chunk2, encoding2).toString(state.encoding);
        } else {
          chunk2 = Buffer2.from(chunk2, encoding2);
          encoding2 = "";
        }
      }
    } else if (chunk2 instanceof Buffer2) {
      encoding2 = "";
    } else if (Stream._isUint8Array(chunk2)) {
      chunk2 = Stream._uint8ArrayToBuffer(chunk2);
      encoding2 = "";
    } else if (chunk2 != null) {
      err3 = new ERR_INVALID_ARG_TYPE(
        "chunk",
        ["string", "Buffer", "Uint8Array"],
        chunk2
      );
    }
  }
  if (err3) {
    errorOrDestroy2(stream, err3);
  } else if (chunk2 === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk2 && chunk2.length > 0) {
    if (addToFront) {
      if (state.endEmitted) {
        errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
      } else {
        addChunk(stream, state, chunk2, true);
      }
    } else if (state.ended) {
      errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
    } else if (state.destroyed || state.errored) {
      return false;
    } else {
      state.reading = false;
      if (state.decoder && !encoding2) {
        chunk2 = state.decoder.write(chunk2);
        if (state.objectMode || chunk2.length !== 0) {
          addChunk(stream, state, chunk2, false);
        } else {
          maybeReadMore(stream, state);
        }
      } else {
        addChunk(stream, state, chunk2, false);
      }
    }
  } else if (!addToFront) {
    state.reading = false;
    maybeReadMore(stream, state);
  }
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk2, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
    state.dataEmitted = true;
    stream.emit("data", chunk2);
  } else {
    state.length += state.objectMode ? 1 : chunk2.length;
    if (addToFront) {
      state.buffer.unshift(chunk2);
    } else {
      state.buffer.push(chunk2);
    }
    if (state.needReadable) {
      emitReadable(stream);
    }
  }
  maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
  const state = this._readableState;
  return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
  const decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  this._readableState.encoding = this._readableState.decoder.encoding;
  const buffer = this._readableState.buffer;
  let content = "";
  for (const data of buffer) {
    content += decoder.write(data);
  }
  buffer.clear();
  if (content !== "") {
    buffer.push(content);
  }
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n5) {
  if (n5 >= MAX_HWM) {
    n5 = MAX_HWM;
  } else {
    n5--;
    n5 |= n5 >>> 1;
    n5 |= n5 >>> 2;
    n5 |= n5 >>> 4;
    n5 |= n5 >>> 8;
    n5 |= n5 >>> 16;
    n5++;
  }
  return n5;
}
function howMuchToRead(n5, state) {
  if (n5 <= 0 || state.length === 0 && state.ended) {
    return 0;
  }
  if (state.objectMode) {
    return 1;
  }
  if (Number.isNaN(n5)) {
    if (state.flowing && state.length) {
      return state.buffer.first().length;
    }
    return state.length;
  }
  if (n5 <= state.length) {
    return n5;
  }
  return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n5) {
  debug("read", n5);
  if (n5 === void 0) {
    n5 = NaN;
  } else if (!Number.isInteger(n5)) {
    n5 = Number.parseInt(n5, 10);
  }
  const state = this._readableState;
  const nOrig = n5;
  if (n5 > state.highWaterMark) {
    state.highWaterMark = computeNewHighWaterMark(n5);
  }
  if (n5 !== 0) {
    state.emittedReadable = false;
  }
  if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended) {
      endReadable(this);
    } else {
      emitReadable(this);
    }
    return null;
  }
  n5 = howMuchToRead(n5, state);
  if (n5 === 0 && state.ended) {
    if (state.length === 0) {
      endReadable(this);
    }
    return null;
  }
  let doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n5 < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false;
    debug("reading, ended or constructing", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0) {
      state.needReadable = true;
    }
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading) {
      n5 = howMuchToRead(nOrig, state);
    }
  }
  let ret;
  if (n5 > 0) {
    ret = fromList(n5, state);
  } else {
    ret = null;
  }
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n5 = 0;
  } else {
    state.length -= n5;
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
  }
  if (state.length === 0) {
    if (!state.ended) {
      state.needReadable = true;
    }
    if (nOrig !== n5 && state.ended) {
      endReadable(this);
    }
  }
  if (ret !== null) {
    state.dataEmitted = true;
    this.emit("data", ret);
  }
  return ret;
};
function onEofChunk(stream, state) {
  debug("onEofChunk");
  if (state.ended) return;
  if (state.decoder) {
    const chunk2 = state.decoder.end();
    if (chunk2 && chunk2.length) {
      state.buffer.push(chunk2);
      state.length += state.objectMode ? 1 : chunk2.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    emitReadable(stream);
  } else {
    state.needReadable = false;
    state.emittedReadable = true;
    emitReadable_(stream);
  }
}
function emitReadable(stream) {
  const state = stream._readableState;
  debug("emitReadable", state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  const state = stream._readableState;
  debug("emitReadable_", state.destroyed, state.length, state.ended);
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit("readable");
    state.emittedReadable = false;
  }
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    const len = state.length;
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length) {
      break;
    }
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n5) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  const src = this;
  const state = this._readableState;
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true;
      state.awaitDrainWriters = new Set(
        state.awaitDrainWriters ? [state.awaitDrainWriters] : []
      );
    }
  }
  state.pipes.push(dest);
  debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
  const doEnd = !pipeOpts || pipeOpts.end !== false;
  const endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) {
    nextTick(endFn);
  } else {
    src.once("end", endFn);
  }
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug("onend");
    dest.end();
  }
  let ondrain;
  let cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    if (ondrain) {
      dest.removeListener("drain", ondrain);
    }
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
      ondrain();
    }
  }
  function pause() {
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug("false write response, pause", 0);
        state.awaitDrainWriters = dest;
        state.multiAwaitDrain = false;
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug("false write response, pause", state.awaitDrainWriters.size);
        state.awaitDrainWriters.add(dest);
      }
      src.pause();
    }
    if (!ondrain) {
      ondrain = pipeOnDrain(src, dest);
      dest.on("drain", ondrain);
    }
  }
  src.on("data", ondata);
  function ondata(chunk2) {
    debug("ondata");
    const ret = dest.write(chunk2);
    debug("dest.write", ret);
    if (ret === false) {
      pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (events_default.listenerCount(dest, "error") === 0) {
      const s = dest._writableState || dest._readableState;
      if (s && !s.errorEmitted) {
        errorOrDestroy2(dest, er);
      } else {
        dest.emit("error", er);
      }
    }
  }
  prependListener3(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause();
    }
  } else if (!state.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState;
    if (state.awaitDrainWriters === dest) {
      debug("pipeOnDrain", 1);
      state.awaitDrainWriters = null;
    } else if (state.multiAwaitDrain) {
      debug("pipeOnDrain", state.awaitDrainWriters.size);
      state.awaitDrainWriters.delete(dest);
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && events_default.listenerCount(src, "data")) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  const state = this._readableState;
  const unpipeInfo = { hasUnpiped: false };
  if (state.pipes.length === 0) {
    return this;
  }
  if (!dest) {
    const dests = state.pipes;
    state.pipes = [];
    this.pause();
    for (let i2 = 0; i2 < dests.length; i2++) {
      dests[i2].emit("unpipe", this, { hasUnpiped: false });
    }
    return this;
  }
  const index = state.pipes.indexOf(dest);
  if (index === -1) {
    return this;
  }
  state.pipes.splice(index, 1);
  if (state.pipes.length === 0) {
    this.pause();
  }
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);
  const state = this._readableState;
  if (ev === "data") {
    state.readableListening = this.listenerCount("readable") > 0;
    if (state.flowing !== false) {
      this.resume();
    }
  } else if (ev === "readable") {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug("on readable", state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  const state = self2._readableState;
  state.readableListening = self2.listenerCount("readable") > 0;
  if (state.resumeScheduled && state[kPaused] === false) {
    state.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  } else if (!state.readableListening) {
    state.flowing = null;
  }
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  const state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state[kPaused] = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug("resume", state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading) {
    stream.read(0);
  }
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState[kPaused] = true;
  return this;
};
function flow(stream) {
  const state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) ;
}
Readable.prototype.wrap = function(stream) {
  let paused = false;
  stream.on("data", (chunk2) => {
    if (!this.push(chunk2) && stream.pause) {
      paused = true;
      stream.pause();
    }
  });
  stream.on("end", () => {
    this.push(null);
  });
  stream.on("error", (err3) => {
    errorOrDestroy2(this, err3);
  });
  stream.on("close", () => {
    this.destroy();
  });
  stream.on("destroy", () => {
    this.destroy();
  });
  this._read = () => {
    if (paused && stream.resume) {
      paused = false;
      stream.resume();
    }
  };
  const streamKeys = Object.keys(stream);
  for (let j = 1; j < streamKeys.length; j++) {
    const i2 = streamKeys[j];
    if (this[i2] === void 0 && typeof stream[i2] === "function") {
      this[i2] = stream[i2].bind(stream);
    }
  }
  return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
  return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
  if (options !== void 0) {
    validateObject(options, "options");
  }
  return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== "function") {
    stream = Readable.wrap(stream, { objectMode: true });
  }
  const iter = createAsyncIterator(stream, options);
  iter.stream = stream;
  return iter;
}
async function* createAsyncIterator(stream, options) {
  let callback = nop2;
  const opts = {
    destroyOnReturn: true,
    destroyOnError: true,
    ...options
  };
  function next(resolve3) {
    if (this === stream) {
      callback();
      callback = nop2;
    } else {
      callback = resolve3;
    }
  }
  const state = stream._readableState;
  let error2 = state.errored;
  let errorEmitted = state.errorEmitted;
  let endEmitted = state.endEmitted;
  let closeEmitted = state.closeEmitted;
  stream.on("readable", next).on("error", function(err3) {
    error2 = err3;
    errorEmitted = true;
    next.call(this);
  }).on("end", function() {
    endEmitted = true;
    next.call(this);
  }).on("close", function() {
    closeEmitted = true;
    next.call(this);
  });
  let errorThrown = false;
  try {
    while (true) {
      const chunk2 = stream.destroyed ? null : stream.read();
      if (chunk2 !== null) {
        yield chunk2;
      } else if (errorEmitted) {
        throw error2;
      } else if (endEmitted) {
        break;
      } else if (closeEmitted) {
        break;
      } else {
        await new Promise(next);
      }
    }
  } catch (err3) {
    if (opts.destroyOnError) {
      destroy_default.destroyer(stream, err3);
    }
    errorThrown = true;
    throw err3;
  } finally {
    if (!errorThrown && opts.destroyOnReturn) {
      if (state.autoDestroy || !endEmitted) {
        destroy_default.destroyer(stream, null);
      }
    }
  }
}
Object.defineProperties(Readable.prototype, {
  readable: {
    get() {
      const r3 = this._readableState;
      return !!r3 && r3.readable !== false && !r3.destroyed && !r3.errorEmitted && !r3.endEmitted;
    },
    set(val) {
      if (this._readableState) {
        this._readableState.readable = !!val;
      }
    }
  },
  readableDidRead: {
    enumerable: false,
    get: function() {
      return this._readableState.dataEmitted;
    }
  },
  readableAborted: {
    enumerable: false,
    get: function() {
      return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
    }
  },
  readableHighWaterMark: {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  },
  readableBuffer: {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  },
  readableFlowing: {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  },
  readableLength: {
    enumerable: false,
    get() {
      return this._readableState.length;
    }
  },
  readableObjectMode: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false;
    }
  },
  readableEncoding: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null;
    }
  },
  destroyed: {
    enumerable: false,
    get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  },
  readableEnded: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false;
    }
  }
});
Object.defineProperties(ReadableState.prototype, {
  // Legacy getter for `pipesCount`.
  pipesCount: {
    get() {
      return this.pipes.length;
    }
  },
  // Legacy property for `paused`.
  paused: {
    get() {
      return this[kPaused] !== false;
    },
    set(value) {
      this[kPaused] = !!value;
    }
  }
});
function fromList(n5, state) {
  if (state.length === 0) {
    return null;
  }
  let ret;
  if (state.objectMode) {
    ret = state.buffer.shift();
  } else if (!n5 || n5 >= state.length) {
    if (state.decoder) {
      ret = state.buffer.join("");
    } else if (state.buffer.length === 1) {
      ret = state.buffer.first();
    } else {
      ret = state.buffer.concat(state.length);
    }
    state.buffer.clear();
  } else {
    ret = state.buffer.consume(n5, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  const state = stream._readableState;
  debug("endReadable", state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug("endReadableNT", state.endEmitted, state.length);
  if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.emit("end");
    if (stream.writable && stream.allowHalfOpen === false) {
      nextTick(endWritableNT, stream);
    } else if (state.autoDestroy) {
      const wState = stream._writableState;
      const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
      // if writable is explicitly set to false.
      (wState.finished || wState.writable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
  if (writable) {
    stream.end();
  }
}
function readableFrom(iterable, opts) {
  return from_default(Readable, iterable, opts);
}
function wrap(src, options) {
  return new Readable({
    objectMode: src.readableObjectMode ?? src.objectMode ?? true,
    ...options,
    destroy(err3, callback) {
      destroy_default.destroyer(src, err3);
      callback(err3);
    }
  }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
var readable_default = Readable;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/writable.js
init_buffer();
function _uint8ArrayToBuffer(chunk2) {
  return Buffer2.from(
    chunk2.buffer,
    chunk2.byteOffset,
    chunk2.byteLength
  );
}
var { errorOrDestroy: errorOrDestroy3 } = destroy_default;
function isDuplexStream(maybe_duplex) {
  const isReadable3 = readable_default.prototype.isPrototypeOf(maybe_duplex);
  let prototype = maybe_duplex;
  let isDuplex = false;
  while (prototype?.constructor && prototype.constructor.name !== "Object") {
    if (prototype.constructor.name === "Duplex") {
      isDuplex = true;
      break;
    }
    prototype = Object.getPrototypeOf(prototype);
  }
  return isReadable3 && isDuplex;
}
function nop3() {
}
var kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = isDuplexStream(stream);
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  const noDecode = !!(options && options.decodeStrings === false);
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = onwrite.bind(void 0, stream);
  this.writecb = null;
  this.writelen = 0;
  this.afterWriteTickInfo = null;
  resetBuffer(this);
  this.pendingcb = 0;
  this.constructed = true;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this[kOnFinished] = [];
}
function resetBuffer(state) {
  state.buffered = [];
  state.bufferedIndex = 0;
  state.allBuffers = true;
  state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
  return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
  get() {
    return this.buffered.length - this.bufferedIndex;
  }
});
function Writable(options) {
  const isDuplex = isDuplexStream(this);
  if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
    return new Writable(options);
  }
  this._writableState = new WritableState(options, this, isDuplex);
  if (options) {
    if (typeof options.write === "function") {
      this._write = options.write;
    }
    if (typeof options.writev === "function") {
      this._writev = options.writev;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.final === "function") {
      this._final = options.final;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  destroy_default.construct(this, () => {
    const state = this._writableState;
    if (!state.writing) {
      clearBuffer(this, state);
    }
    finishMaybe(this, state);
  });
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
Object.defineProperty(Writable, Symbol.hasInstance, {
  value: function(object3) {
    if (Function.prototype[Symbol.hasInstance].call(this, object3)) return true;
    if (this !== Writable) return false;
    return object3 && object3._writableState instanceof WritableState;
  }
});
Writable.prototype.pipe = function() {
  errorOrDestroy3(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk2, encoding2, cb) {
  const state = stream._writableState;
  if (typeof encoding2 === "function") {
    cb = encoding2;
    encoding2 = state.defaultEncoding;
  } else {
    if (!encoding2) {
      encoding2 = state.defaultEncoding;
    } else if (encoding2 !== "buffer" && !Buffer2.isEncoding(encoding2)) {
      throw new ERR_UNKNOWN_ENCODING(encoding2);
    }
    if (typeof cb !== "function") {
      cb = nop3;
    }
  }
  if (chunk2 === null) {
    throw new ERR_STREAM_NULL_VALUES();
  } else if (!state.objectMode) {
    if (typeof chunk2 === "string") {
      if (state.decodeStrings !== false) {
        chunk2 = Buffer2.from(chunk2, encoding2);
        encoding2 = "buffer";
      }
    } else if (chunk2 instanceof Buffer2) {
      encoding2 = "buffer";
    } else if (isUint8Array(chunk2)) {
      chunk2 = _uint8ArrayToBuffer(chunk2);
      encoding2 = "buffer";
    } else {
      throw new ERR_INVALID_ARG_TYPE(
        "chunk",
        ["string", "Buffer", "Uint8Array"],
        chunk2
      );
    }
  }
  let err3;
  if (state.ending) {
    err3 = new ERR_STREAM_WRITE_AFTER_END();
  } else if (state.destroyed) {
    err3 = new ERR_STREAM_DESTROYED("write");
  }
  if (err3) {
    nextTick(cb, err3);
    errorOrDestroy3(stream, err3, true);
    return err3;
  }
  state.pendingcb++;
  return writeOrBuffer(stream, state, chunk2, encoding2, cb);
}
Writable.prototype.write = function(chunk2, encoding2, cb) {
  return _write(this, chunk2, encoding2, cb) === true;
};
Writable.prototype.cork = function() {
  this._writableState.corked++;
};
Writable.prototype.uncork = function() {
  const state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing) {
      clearBuffer(this, state);
    }
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
  if (typeof encoding2 === "string") {
    encoding2 = encoding2.toLowerCase();
  }
  if (!Buffer2.isEncoding(encoding2)) {
    throw new ERR_UNKNOWN_ENCODING(encoding2);
  }
  this._writableState.defaultEncoding = encoding2;
  return this;
};
function writeOrBuffer(stream, state, chunk2, encoding2, callback) {
  const len = state.objectMode ? 1 : chunk2.length;
  state.length += len;
  const ret = state.length < state.highWaterMark;
  if (!ret) {
    state.needDrain = true;
  }
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({ chunk: chunk2, encoding: encoding2, callback });
    if (state.allBuffers && encoding2 !== "buffer") {
      state.allBuffers = false;
    }
    if (state.allNoop && callback !== nop3) {
      state.allNoop = false;
    }
  } else {
    state.writelen = len;
    state.writecb = callback;
    state.writing = true;
    state.sync = true;
    stream._write(chunk2, encoding2, state.onwrite);
    state.sync = false;
  }
  return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev2, len, chunk2, encoding2, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) {
    state.onwrite(new ERR_STREAM_DESTROYED("write"));
  } else if (writev2) {
    stream._writev(chunk2, state.onwrite);
  } else {
    stream._write(chunk2, encoding2, state.onwrite);
  }
  state.sync = false;
}
function onwriteError(stream, state, er, cb) {
  --state.pendingcb;
  cb(er);
  errorBuffer(state);
  errorOrDestroy3(stream, er);
}
function onwrite(stream, er) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;
  if (typeof cb !== "function") {
    errorOrDestroy3(stream, new ERR_MULTIPLE_CALLBACK());
    return;
  }
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
  if (er) {
    er.stack;
    if (!state.errored) {
      state.errored = er;
    }
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er;
    }
    if (sync) {
      nextTick(onwriteError, stream, state, er, cb);
    } else {
      onwriteError(stream, state, er, cb);
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state);
    }
    if (sync) {
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++;
      } else {
        state.afterWriteTickInfo = { count: 1, cb, stream, state };
        nextTick(afterWriteTick, state.afterWriteTickInfo);
      }
    } else {
      afterWrite(stream, state, 1, cb);
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null;
  return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
  if (needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
  while (count-- > 0) {
    state.pendingcb--;
    cb();
  }
  if (state.destroyed) {
    errorBuffer(state);
  }
  finishMaybe(stream, state);
}
function errorBuffer(state) {
  if (state.writing) {
    return;
  }
  for (let n5 = state.bufferedIndex; n5 < state.buffered.length; ++n5) {
    const { chunk: chunk2, callback } = state.buffered[n5];
    const len = state.objectMode ? 1 : chunk2.length;
    state.length -= len;
    callback(new ERR_STREAM_DESTROYED("write"));
  }
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
    onfinishCallbacks[i2](new ERR_STREAM_DESTROYED("end"));
  }
  resetBuffer(state);
}
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return;
  }
  const { buffered, bufferedIndex, objectMode } = state;
  const bufferedLength = buffered.length - bufferedIndex;
  if (!bufferedLength) {
    return;
  }
  let i2 = bufferedIndex;
  state.bufferProcessing = true;
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1;
    const callback = state.allNoop ? nop3 : (err3) => {
      for (let n5 = i2; n5 < buffered.length; ++n5) {
        buffered[n5].callback(err3);
      }
    };
    const chunks = state.allNoop && i2 === 0 ? buffered : buffered.slice(i2);
    chunks.allBuffers = state.allBuffers;
    doWrite(stream, state, true, state.length, chunks, "", callback);
    resetBuffer(state);
  } else {
    do {
      const { chunk: chunk2, encoding: encoding2, callback } = buffered[i2];
      buffered[i2++] = null;
      const len = objectMode ? 1 : chunk2.length;
      doWrite(stream, state, false, len, chunk2, encoding2, callback);
    } while (i2 < buffered.length && !state.writing);
    if (i2 === buffered.length) {
      resetBuffer(state);
    } else if (i2 > 256) {
      buffered.splice(0, i2);
      state.bufferedIndex = 0;
    } else {
      state.bufferedIndex = i2;
    }
  }
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk2, encoding2, cb) {
  if (this._writev) {
    this._writev([{ chunk: chunk2, encoding: encoding2 }], cb);
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
  }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk2, encoding2, cb) {
  const state = this._writableState;
  if (typeof chunk2 === "function") {
    cb = chunk2;
    chunk2 = null;
    encoding2 = null;
  } else if (typeof encoding2 === "function") {
    cb = encoding2;
    encoding2 = null;
  }
  let err3;
  if (chunk2 !== null && chunk2 !== void 0) {
    const ret = _write(this, chunk2, encoding2);
    if (ret instanceof Error) {
      err3 = ret;
    }
  }
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (err3) {
  } else if (!state.errored && !state.ending) {
    state.ending = true;
    finishMaybe(this, state, true);
    state.ended = true;
  } else if (state.finished) {
    err3 = new ERR_STREAM_ALREADY_FINISHED("end");
  } else if (state.destroyed) {
    err3 = new ERR_STREAM_DESTROYED("end");
  }
  if (typeof cb === "function") {
    if (err3 || state.finished) {
      nextTick(cb, err3);
    } else {
      state[kOnFinished].push(cb);
    }
  }
  return this;
};
function needFinish(state) {
  return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
  let called = false;
  function onFinish(err3) {
    if (called) {
      errorOrDestroy3(stream, err3 ?? ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    state.pendingcb--;
    if (err3) {
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
        onfinishCallbacks[i2](err3);
      }
      errorOrDestroy3(stream, err3, state.sync);
    } else if (needFinish(state)) {
      state.prefinished = true;
      stream.emit("prefinish");
      state.pendingcb++;
      nextTick(finish, stream, state);
    }
  }
  state.sync = true;
  state.pendingcb++;
  try {
    const result2 = stream._final(onFinish);
    if (result2 != null) {
      const then = result2.then;
      if (typeof then === "function") {
        then.call(
          result2,
          function() {
            nextTick(onFinish, null);
          },
          function(err3) {
            nextTick(onFinish, err3);
          }
        );
      }
    }
  } catch (err3) {
    onFinish(stream, state, err3);
  }
  state.sync = false;
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === "function" && !state.destroyed) {
      state.finalCalled = true;
      callFinal(stream, state);
    } else {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state);
    if (state.pendingcb === 0 && needFinish(state)) {
      state.pendingcb++;
      if (sync) {
        nextTick(finish, stream, state);
      } else {
        finish(stream, state);
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--;
  state.finished = true;
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
    onfinishCallbacks[i2]();
  }
  stream.emit("finish");
  if (state.autoDestroy) {
    const rState = stream._readableState;
    const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
    // if readable is explicitly set to false.
    (rState.endEmitted || rState.readable === false);
    if (autoDestroy) {
      stream.destroy();
    }
  }
}
Object.defineProperties(Writable.prototype, {
  destroyed: {
    get() {
      return this._writableState ? this._writableState.destroyed : false;
    },
    set(value) {
      if (this._writableState) {
        this._writableState.destroyed = value;
      }
    }
  },
  writable: {
    get() {
      const w = this._writableState;
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
    },
    set(val) {
      if (this._writableState) {
        this._writableState.writable = !!val;
      }
    }
  },
  writableFinished: {
    get() {
      return this._writableState ? this._writableState.finished : false;
    }
  },
  writableObjectMode: {
    get() {
      return this._writableState ? this._writableState.objectMode : false;
    }
  },
  writableBuffer: {
    get() {
      return this._writableState && this._writableState.getBuffer();
    }
  },
  writableEnded: {
    get() {
      return this._writableState ? this._writableState.ending : false;
    }
  },
  writableNeedDrain: {
    get() {
      const wState = this._writableState;
      if (!wState) return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    }
  },
  writableHighWaterMark: {
    get() {
      return this._writableState && this._writableState.highWaterMark;
    }
  },
  writableCorked: {
    get() {
      return this._writableState ? this._writableState.corked : 0;
    }
  },
  writableLength: {
    get() {
      return this._writableState && this._writableState.length;
    }
  }
});
var destroy2 = destroy_default.destroy;
Writable.prototype.destroy = function(err3, cb) {
  const state = this._writableState;
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    nextTick(errorBuffer, state);
  }
  destroy2.call(this, err3, cb);
  return this;
};
Writable.prototype._undestroy = destroy_default.undestroy;
Writable.prototype._destroy = function(err3, cb) {
  cb(err3);
};
Writable.prototype[events_default.captureRejectionSymbol] = function(err3) {
  this.destroy(err3);
};
Writable.WritableState = WritableState;
var writable_default = Writable;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }
  readable_default.call(this, options);
  writable_default.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
    }
  }
}
Object.setPrototypeOf(Duplex.prototype, readable_default.prototype);
Object.setPrototypeOf(Duplex, readable_default);
Object.defineProperties(Duplex.prototype, {
  writable: Object.getOwnPropertyDescriptor(writable_default.prototype, "writable"),
  writableHighWaterMark: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableHighWaterMark"
  ),
  writableObjectMode: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableObjectMode"
  ),
  writableBuffer: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableBuffer"
  ),
  writableLength: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableLength"
  ),
  writableFinished: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableFinished"
  ),
  writableCorked: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableCorked"
  ),
  writableEnded: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableEnded"
  ),
  writableNeedDrain: Object.getOwnPropertyDescriptor(
    writable_default.prototype,
    "writableNeedDrain"
  ),
  destroyed: {
    get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set(value) {
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    }
  }
});
{
  for (const method of Object.keys(writable_default.prototype)) {
    if (!Duplex.prototype[method]) {
      Duplex.prototype[method] = writable_default.prototype[method];
    }
  }
}
Duplex.fromWeb = function(pair, options) {
};
var Duplexify = class extends Duplex {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function duplexify(body2, name) {
  if (isDuplexNodeStream(body2)) {
    return body2;
  }
  if (isReadableNodeStream(body2)) {
    return _duplexify({ readable: body2 });
  }
  if (isWritableNodeStream(body2)) {
    return _duplexify({ writable: body2 });
  }
  if (isNodeStream(body2)) {
    return _duplexify({ writable: false, readable: false });
  }
  if (typeof body2 === "function") {
    const { value, write: write2, final: final2, destroy: destroy3 } = fromAsyncGen(body2);
    if (isIterable(value)) {
      return from_default(Duplexify, value, {
        // TODO (ronag): highWaterMark?
        objectMode: true,
        write: write2,
        final: final2,
        destroy: destroy3
      });
    }
    const then2 = value?.then;
    if (typeof then2 === "function") {
      let d;
      const promise = then2.call(
        value,
        (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }
        },
        (err3) => {
          destroyer(d, err3);
        }
      );
      return d = new Duplexify({
        // TODO (ronag): highWaterMark?
        objectMode: true,
        readable: false,
        write: write2,
        final(cb) {
          final2(async () => {
            try {
              await promise;
              nextTick(cb, null);
            } catch (err3) {
              nextTick(cb, err3);
            }
          });
        },
        destroy: destroy3
      });
    }
    throw new ERR_INVALID_RETURN_VALUE(
      "Iterable, AsyncIterable or AsyncFunction",
      name,
      value
    );
  }
  if (isIterable(body2)) {
    return from_default(Duplexify, body2, {
      // TODO (ronag): highWaterMark?
      objectMode: true,
      writable: false
    });
  }
  if (typeof body2?.writable === "object" || typeof body2?.readable === "object") {
    const readable = body2?.readable ? isReadableNodeStream(body2?.readable) ? body2?.readable : duplexify(body2.readable) : void 0;
    const writable = body2?.writable ? isWritableNodeStream(body2?.writable) ? body2?.writable : duplexify(body2.writable) : void 0;
    return _duplexify({ readable, writable });
  }
  const then = body2?.then;
  if (typeof then === "function") {
    let d;
    then.call(
      body2,
      (val) => {
        if (val != null) {
          d.push(val);
        }
        d.push(null);
      },
      (err3) => {
        destroyer(d, err3);
      }
    );
    return d = new Duplexify({
      objectMode: true,
      writable: false,
      read() {
      }
    });
  }
  throw new ERR_INVALID_ARG_TYPE(
    name,
    [
      // "Blob",
      // "ReadableStream",
      // "WritableStream",
      "Stream",
      "Iterable",
      "AsyncIterable",
      "Function",
      "{ readable, writable } pair",
      "Promise"
    ],
    body2
  );
}
function fromAsyncGen(fn) {
  let { promise, resolve: resolve3 } = createDeferredPromise();
  const ac = new AbortController();
  const signal = ac.signal;
  const value = fn(
    async function* () {
      while (true) {
        const _promise = promise;
        promise = null;
        const { chunk: chunk2, done, cb } = await _promise;
        nextTick(cb);
        if (done) return;
        if (signal.aborted) throw new AbortError2();
        ({ promise, resolve: resolve3 } = createDeferredPromise());
        yield chunk2;
      }
    }(),
    { signal }
  );
  return {
    value,
    write(chunk2, encoding2, cb) {
      const _resolve = resolve3;
      resolve3 = null;
      _resolve({ chunk: chunk2, done: false, cb });
    },
    final(cb) {
      const _resolve = resolve3;
      resolve3 = null;
      _resolve({ done: true, cb });
    },
    destroy(err3, cb) {
      ac.abort();
      cb(err3);
    }
  };
}
function _duplexify(pair) {
  const r3 = pair.readable && typeof pair.readable.read !== "function" ? readable_default.wrap(pair.readable) : pair.readable;
  const w = pair.writable;
  let readable = !!isReadable2(r3);
  let writable = !!isWritable2(w);
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d;
  function onfinished(err3) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err3);
    } else if (err3) {
      d.destroy(err3);
    } else if (!readable && !writable) {
      d.destroy();
    }
  }
  d = new Duplexify({
    // TODO (ronag): highWaterMark?
    readableObjectMode: !!r3?.readableObjectMode,
    writableObjectMode: !!w?.writableObjectMode,
    readable,
    writable
  });
  if (writable) {
    end_of_stream_default(w, (err3) => {
      writable = false;
      if (err3) {
        destroyer(r3, err3);
      }
      onfinished(err3);
    });
    d._write = function(chunk2, encoding2, callback) {
      if (w.write(chunk2, encoding2)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d._final = function(callback) {
      w.end();
      onfinish = callback;
    };
    w.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    w.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    end_of_stream_default(r3, (err3) => {
      readable = false;
      if (err3) {
        destroyer(r3, err3);
      }
      onfinished(err3);
    });
    r3.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    r3.on("end", function() {
      d.push(null);
    });
    d._read = function() {
      while (true) {
        const buf = r3.read();
        if (buf === null) {
          onreadable = d._read;
          return;
        }
        if (!d.push(buf)) {
          return;
        }
      }
    };
  }
  d._destroy = function(err3, callback) {
    if (!err3 && onclose !== null) {
      err3 = new AbortError2();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err3);
    } else {
      onclose = callback;
      destroyer(w, err3);
      destroyer(r3, err3);
    }
  };
  return d;
}
function duplexFrom(body2) {
  return duplexify(body2, "body");
}
Duplex.from = duplexFrom;
var duplex_default = Duplex;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/transform.js
var kCallback = Symbol("kCallback");
function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }
  duplex_default.call(this, options);
  this._readableState.sync = false;
  this[kCallback] = null;
  if (options) {
    if (typeof options.transform === "function") {
      this._transform = options.transform;
    }
    if (typeof options.flush === "function") {
      this._flush = options.flush;
    }
  }
  this.on("prefinish", prefinish2);
}
Object.setPrototypeOf(Transform.prototype, duplex_default.prototype);
Object.setPrototypeOf(Transform, duplex_default);
function final(cb) {
  let called = false;
  if (typeof this._flush === "function" && !this.destroyed) {
    const result2 = this._flush((er, data) => {
      called = true;
      if (er) {
        if (cb) {
          cb(er);
        } else {
          this.destroy(er);
        }
        return;
      }
      if (data != null) {
        this.push(data);
      }
      this.push(null);
      if (cb) {
        cb();
      }
    });
    if (result2 !== void 0 && result2 !== null) {
      try {
        const then = result2.then;
        if (typeof then === "function") {
          then.call(
            result2,
            (data) => {
              if (called) {
                return;
              }
              if (data != null) {
                this.push(data);
              }
              this.push(null);
              if (cb) {
                nextTick(cb);
              }
            },
            (err3) => {
              if (cb) {
                nextTick(cb, err3);
              } else {
                nextTick(() => this.destroy(err3));
              }
            }
          );
        }
      } catch (err3) {
        nextTick(() => this.destroy(err3));
      }
    }
  } else {
    this.push(null);
    if (cb) {
      cb();
    }
  }
}
function prefinish2() {
  if (this._final !== final) {
    final.call(this);
  }
}
Transform.prototype._final = final;
Transform.prototype._transform = function(chunk2, encoding2, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk2, encoding2, callback) {
  const rState = this._readableState;
  const wState = this._writableState;
  const length = rState.length;
  let called = false;
  const result2 = this._transform(chunk2, encoding2, (err3, val) => {
    called = true;
    if (err3) {
      callback(err3);
      return;
    }
    if (val != null) {
      this.push(val);
    }
    if (wState.ended || // Backwards compat.
    length === rState.length || // Backwards compat.
    rState.length < rState.highWaterMark || rState.length === 0) {
      callback();
    } else {
      this[kCallback] = callback;
    }
  });
  if (result2 !== void 0 && result2 != null) {
    try {
      const then = result2.then;
      if (typeof then === "function") {
        then.call(
          result2,
          (val) => {
            if (called) {
              return;
            }
            if (val != null) {
              this.push(val);
            }
            if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
              nextTick(callback);
            } else {
              this[kCallback] = callback;
            }
          },
          (err3) => {
            nextTick(callback, err3);
          }
        );
      }
    } catch (err3) {
      nextTick(callback, err3);
    }
  }
};
Transform.prototype._read = function() {
  if (this[kCallback]) {
    const callback = this[kCallback];
    this[kCallback] = null;
    callback();
  }
};
var transform_default = Transform;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough)) {
    return new PassThrough(options);
  }
  transform_default.call(this, options);
}
Object.setPrototypeOf(PassThrough.prototype, transform_default.prototype);
Object.setPrototypeOf(PassThrough, transform_default);
PassThrough.prototype._transform = function(chunk2, encoding2, cb) {
  cb(null, chunk2);
};
var passthrough_default = PassThrough;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/pipeline.js
function destroyer2(stream, reading, writing, callback) {
  callback = once2(callback);
  let finished2 = false;
  stream.on("close", () => {
    finished2 = true;
  });
  end_of_stream_default(stream, { readable: reading, writable: writing }, (err3) => {
    finished2 = !err3;
    const rState = stream._readableState;
    if (err3 && err3.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && (rState && rState.ended && !rState.errored && !rState.errorEmitted)) {
      stream.once("end", callback).once("error", callback);
    } else {
      callback(err3);
    }
  });
  return (err3) => {
    if (finished2) return;
    finished2 = true;
    destroy_default.destroyer(stream, err3);
    callback(err3 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function popCallback(streams) {
  validateCallback(streams[streams.length - 1]);
  return streams.pop();
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val;
  } else if (isReadableNodeStream(val)) {
    return fromReadable(val);
  }
  throw new ERR_INVALID_ARG_TYPE(
    "val",
    ["Readable", "Iterable", "AsyncIterable"],
    val
  );
}
async function* fromReadable(val) {
  yield* readable_default.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish2) {
  let error2;
  let onresolve = null;
  const resume2 = (err3) => {
    if (err3) {
      error2 = err3;
    }
    if (onresolve) {
      const callback = onresolve;
      onresolve = null;
      callback();
    }
  };
  const wait3 = () => new Promise((resolve3, reject) => {
    if (error2) {
      reject(error2);
    } else {
      onresolve = () => {
        if (error2) {
          reject(error2);
        } else {
          resolve3();
        }
      };
    }
  });
  writable.on("drain", resume2);
  const cleanup = end_of_stream_default(writable, { readable: false }, resume2);
  try {
    if (writable.writableNeedDrain) {
      await wait3();
    }
    for await (const chunk2 of iterable) {
      if (!writable.write(chunk2)) {
        await wait3();
      }
    }
    writable.end();
    await wait3();
    finish2();
  } catch (err3) {
    finish2(error2 !== err3 ? aggregateTwoErrors(error2, err3) : err3);
  } finally {
    cleanup();
    writable.off("drain", resume2);
  }
}
function pipeline(...streams) {
  const callback = once2(popCallback(streams));
  if (Array.isArray(streams[0]) && streams.length === 1) {
    streams = streams[0];
  }
  return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  const ac = new AbortController();
  const signal = ac.signal;
  const outerSignal = opts?.signal;
  validateAbortSignal2(outerSignal, "options.signal");
  function abort2() {
    finishImpl(new AbortError2());
  }
  outerSignal?.addEventListener("abort", abort2);
  let error2;
  let value;
  const destroys = [];
  let finishCount = 0;
  function finish2(err3) {
    finishImpl(err3, --finishCount === 0);
  }
  function finishImpl(err3, final2) {
    if (err3 && (!error2 || error2.code === "ERR_STREAM_PREMATURE_CLOSE")) {
      error2 = err3;
    }
    if (!error2 && !final2) {
      return;
    }
    while (destroys.length) {
      destroys.shift()(error2);
    }
    outerSignal?.removeEventListener("abort", abort2);
    ac.abort();
    if (final2) {
      callback(error2, value);
    }
  }
  let ret;
  for (let i2 = 0; i2 < streams.length; i2++) {
    const stream = streams[i2];
    const reading = i2 < streams.length - 1;
    const writing = i2 > 0;
    if (isNodeStream(stream)) {
      finishCount++;
      destroys.push(destroyer2(stream, reading, writing, finish2));
    }
    if (i2 === 0) {
      if (typeof stream === "function") {
        ret = stream({ signal });
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE(
            "Iterable, AsyncIterable or Stream",
            "source",
            ret
          );
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream)) {
        ret = stream;
      } else {
        ret = duplex_default.from(stream);
      }
    } else if (typeof stream === "function") {
      ret = makeAsyncIterable(ret);
      ret = stream(ret, { signal });
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE(
            "AsyncIterable",
            `transform[${i2 - 1}]`,
            ret
          );
        }
      } else {
        const pt = new passthrough_default({
          objectMode: true
        });
        const then = ret?.then;
        if (typeof then === "function") {
          then.call(ret, (val) => {
            value = val;
            pt.end(val);
          }, (err3) => {
            pt.destroy(err3);
          });
        } else if (isIterable(ret, true)) {
          finishCount++;
          pump(ret, pt, finish2);
        } else {
          throw new ERR_INVALID_RETURN_VALUE(
            "AsyncIterable or Promise",
            "destination",
            ret
          );
        }
        ret = pt;
        finishCount++;
        destroys.push(destroyer2(ret, false, true, finish2));
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        ret.pipe(stream);
      } else {
        ret = makeAsyncIterable(ret);
        finishCount++;
        pump(ret, stream, finish2);
      }
      ret = stream;
    } else {
      ret = duplex_default.from(stream);
    }
  }
  if (signal?.aborted || outerSignal?.aborted) {
    nextTick(abort2);
  }
  return ret;
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/streams/compose.js
var ComposeDuplex = class extends duplex_default {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS("streams");
  }
  if (streams.length === 1) {
    return duplex_default.from(streams[0]);
  }
  const orgStreams = [...streams];
  if (typeof streams[0] === "function") {
    streams[0] = duplex_default.from(streams[0]);
  }
  if (typeof streams[streams.length - 1] === "function") {
    const idx = streams.length - 1;
    streams[idx] = duplex_default.from(streams[idx]);
  }
  for (let n5 = 0; n5 < streams.length; ++n5) {
    if (!isNodeStream(streams[n5])) {
      continue;
    }
    if (n5 < streams.length - 1 && !isReadable2(streams[n5])) {
      throw new ERR_INVALID_ARG_VALUE(
        `streams[${n5}]`,
        orgStreams[n5],
        "must be readable"
      );
    }
    if (n5 > 0 && !isWritable2(streams[n5])) {
      throw new ERR_INVALID_ARG_VALUE(
        `streams[${n5}]`,
        orgStreams[n5],
        "must be writable"
      );
    }
  }
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d;
  function onfinished(err3) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err3);
    } else if (err3) {
      d.destroy(err3);
    } else if (!readable && !writable) {
      d.destroy();
    }
  }
  const head = streams[0];
  const tail = pipeline(streams, onfinished);
  const writable = !!isWritable2(head);
  const readable = !!isReadable2(tail);
  d = new ComposeDuplex({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!head?.writableObjectMode,
    readableObjectMode: !!tail?.writableObjectMode,
    writable,
    readable
  });
  if (writable) {
    d._write = function(chunk2, encoding2, callback) {
      if (head.write(chunk2, encoding2)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d._final = function(callback) {
      head.end();
      onfinish = callback;
    };
    head.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    tail.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    tail.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    tail.on("end", function() {
      d.push(null);
    });
    d._read = function() {
      while (true) {
        const buf = tail.read();
        if (buf === null) {
          onreadable = d._read;
          return;
        }
        if (!d.push(buf)) {
          return;
        }
      }
    };
  }
  d._destroy = function(err3, callback) {
    if (!err3 && onclose !== null) {
      err3 = new AbortError2();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err3);
    } else {
      onclose = callback;
      destroyer(tail, err3);
    }
  };
  return d;
}
var compose_default = compose;

// ../../../../../../node_modules/wasmedge_quickjs/modules/stream/promises.js
function pipeline2(...streams) {
  return new Promise((resolve3, reject) => {
    let signal;
    let end;
    const lastArg = streams[streams.length - 1];
    if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
      const options = streams.pop();
      signal = options.signal;
      end = options.end;
    }
    pipelineImpl(streams, (err3, value) => {
      if (err3) {
        reject(err3);
      } else {
        resolve3(value);
      }
    }, { signal, end });
  });
}
function finished(stream, opts) {
  return new Promise((resolve3, reject) => {
    end_of_stream_default(stream, opts, (err3) => {
      if (err3) {
        reject(err3);
      } else {
        resolve3();
      }
    });
  });
}
var promises_default2 = {
  finished,
  pipeline: pipeline2
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/stream.js
init_buffer();
var { custom: customPromisify } = promisify;
function _uint8ArrayToBuffer2(chunk2) {
  return Buffer2.from(
    chunk2.buffer,
    chunk2.byteOffset,
    chunk2.byteLength
  );
}
Stream.isDisturbed = isDisturbed;
Stream.Readable = readable_default;
Stream.Writable = writable_default;
Stream.Duplex = duplex_default;
Stream.Transform = transform_default;
Stream.PassThrough = passthrough_default;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = end_of_stream_default;
Stream.destroy = destroyer;
Stream.compose = compose_default;
Object.defineProperty(Stream, "promises", {
  configurable: true,
  enumerable: true,
  get() {
    return promises_default2;
  }
});
Object.defineProperty(pipeline, customPromisify, {
  enumerable: true,
  get() {
    return promises_default2.pipeline;
  }
});
Object.defineProperty(end_of_stream_default, customPromisify, {
  enumerable: true,
  get() {
    return promises_default2.finished;
  }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer2;

// ../../../../../../node_modules/wasmedge_quickjs/modules/fs.js
var fs_default = {
  F_OK: fs.F_OK,
  R_OK: fs.R_OK,
  W_OK: fs.W_OK,
  X_OK: fs.X_OK,
  promises: promises_default,
  stat,
  statSync,
  lstat,
  lstatSync,
  fstat,
  fstatSync,
  access,
  accessSync,
  exists,
  existsSync,
  mkdir,
  mkdirSync,
  fchown,
  fchownSync,
  chown,
  chownSync,
  lchown,
  lchownSync,
  rmdir,
  rmdirSync,
  rm,
  rmSync,
  fchmod,
  fchmodSync,
  lchmod,
  lchmodSync,
  chmod,
  chmodSync,
  futimes,
  futimesSync,
  lutimes,
  lutimesSync,
  utimes,
  utimesSync,
  rename,
  renameSync,
  unlink,
  unlinkSync,
  truncate: truncate2,
  truncateSync,
  ftruncate,
  ftruncateSync,
  realpath,
  realpathSync,
  mkdtemp,
  mkdtempSync,
  copyFile,
  copyFileSync,
  link,
  linkSync,
  symlink,
  symlinkSync,
  close,
  closeSync,
  fdatasync,
  fdatasyncSync,
  fsync,
  fsyncSync,
  read,
  readSync,
  open,
  openSync,
  readFile: readFile2,
  readFileSync,
  readlink,
  readlinkSync,
  readv,
  readvSync,
  write,
  writeSync,
  writeFile: writeFile2,
  writeFileSync,
  appendFile,
  appendFileSync,
  writev,
  writevSync,
  opendir,
  opendirSync,
  Dir,
  Dirent,
  readdir,
  readdirSync,
  watch,
  watchFile,
  unwatch,
  cp,
  cpSync,
  createWriteStream,
  WriteStream,
  createReadStream,
  ReadStream,
  FileHandle,
  constants: fs
};
var F_OK2 = fs.F_OK;
var R_OK = fs.R_OK;
var W_OK = fs.W_OK;
var X_OK = fs.X_OK;

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs/stream.js
var kIsPerformingIO = Symbol("kIsPerformingIO");
var kFs = Symbol("kFs");
var WriteStreamClass = class extends writable_default {
  fd = null;
  bytesWritten = 0;
  pos = 0;
  [kFs] = {
    open: fs_default.open,
    write: fs_default.write
  };
  [kIsPerformingIO] = false;
  constructor(path2, opts) {
    super(opts);
    if (typeof opts === "string") {
      validateEncoding(opts, "encoding");
      opts = {};
    }
    if (opts === null || opts === void 0) {
      opts = {};
    }
    validateObject(opts, "options");
    if (opts.encoding) {
      validateEncoding(opts.encoding, "encoding");
      this.setDefaultEncoding(opts.encoding);
    }
    if (opts.start) {
      validateInteger(opts.start, "start");
    }
    this.pending = true;
    this.path = toPathIfFileURL(path2);
    this.flags = opts.flags || "w";
    this.mode = opts.mode || 438;
    this[kFs] = opts.fs ?? {
      open: fs_default.open,
      write: fs_default.write,
      close: fs_default.close
    };
  }
  _construct(callback) {
    this[kFs].open(
      this.path.toString(),
      this.flags,
      this.mode,
      (err3, fd) => {
        if (err3) {
          callback(err3);
          return;
        }
        this.pending = false;
        this.fd = fd;
        callback();
        this.emit("open", this.fd);
        this.emit("ready");
      }
    );
  }
  _write(data, _encoding, cb) {
    this[kIsPerformingIO] = true;
    this[kFs].write(
      this.fd,
      data,
      0,
      data.length,
      this.pos,
      (er) => {
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
          cb(er);
          return this.emit(kIoDone, er);
        }
        if (er) {
          return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
      }
    );
    if (this.pos !== void 0) {
      this.pos += data.length;
    }
  }
  _destroy(err3, cb) {
    if (this[kIsPerformingIO]) {
      this.once(kIoDone, (er) => closeStream(this, err3 || er, cb));
    } else {
      closeStream(this, err3, cb);
    }
  }
};
function closeStream(stream, err3, cb) {
  if (!stream.fd) {
    cb(err3);
  } else {
    stream[kFs].close(stream.fd, (er) => {
      cb(er || err3);
    });
    stream.fd = null;
  }
}
function WriteStream(path2, opts) {
  return new WriteStreamClass(path2, opts);
}
WriteStream.prototype = WriteStreamClass.prototype;
function createWriteStream(path2, opts) {
  return new WriteStreamClass(path2, opts);
}
var ReadStream = class extends readable_default {
  constructor(path2, opts) {
    path2 = path2 instanceof _URL ? fromFileUrl(path2) : path2;
    if (opts && opts.start) {
      validateInteger(opts.start, "start");
    }
    if (opts && opts.end) {
      validateInteger(opts.end, "end");
    }
    const hasBadOptions = opts && (opts.start || opts.end || opts.fs);
    if (opts === null || typeof opts === "undefined") {
      opts = "utf8";
    }
    if (typeof opts === "string") {
      validateEncoding(opts, "encoding");
    } else {
      validateEncoding(opts.encoding || "utf8", "encoding");
    }
    if (hasBadOptions && false) {
      notImplemented(
        `fs.ReadStream.prototype.constructor with unsupported options (${JSON.stringify(opts)})`
      );
    }
    const buffer = Buffer.alloc(16 * 1024);
    let curPos = 0;
    let notClose = true;
    if (opts.fd) {
      setTimeout(() => {
        if (this.file === void 0) {
          this.file = opts.fd;
          this.pending = false;
          this.emit("ready");
        }
      }, 0);
    } else {
      fs_default.promises.open(path2, fs_default.constants.O_RDONLY).then((f4) => {
        if (this.file === void 0) {
          notClose = false;
          this.file = f4;
          this.pending = false;
          this.emit("ready");
        }
      });
    }
    super({
      autoDestroy: true,
      emitClose: true,
      objectMode: false,
      read: async function(_size) {
        opts = typeof opts !== "object" ? {} : opts;
        try {
          if (this.file === void 0) {
            if (opts.fd) {
              if (opts.fd instanceof fs_default.FileHandle) {
                this.file = opts.fd;
              } else {
                this.file = new FileHandle(opts.fd, path2);
              }
            } else {
              this.file = new FileHandle(fs_default.openSync(path2, fs_default.constants.O_RDONLY), path2);
              notClose = false;
            }
            this.pending = false;
            this.emit("ready");
          }
          opts.end = opts.end ?? fs_default.fstatSync(this.file.fd).size;
          opts.start = opts.start ?? 0;
          const preLength = opts.end - opts.start - curPos + 1;
          const { bytesRead: n5 } = await this.file.read(buffer, 0, preLength > buffer.byteLength ? buffer.byteLength : preLength, curPos === 0 ? opts.start : opts.start + curPos);
          curPos += n5;
          if (n5 === 0) {
            this.push(null);
            this.emit("end");
          } else {
            this.push(Buffer.from(buffer.slice(0, n5)));
          }
        } catch (err3) {
          this.destroy(err3);
        }
      },
      destroy: (err3, cb) => {
        try {
          if (!notClose) {
            this.file.close();
          }
        } catch {
        }
        cb(err3);
      }
    });
    this.pending = true;
    this.path = path2;
  }
};
function createReadStream(path2, options) {
  return new ReadStream(path2, options);
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal_binding/uv.js
var UV_EOF = -4095;
var UV_UNKNOWN = -4094;
var UV_EAI_ADDRFAMILY = -3e3;
var UV_EAI_AGAIN = -3001;
var UV_EAI_BADFLAGS = -3002;
var UV_EAI_CANCELED = -3003;
var UV_EAI_FAIL = -3004;
var UV_EAI_FAMILY = -3005;
var UV_EAI_MEMORY = -3006;
var UV_EAI_NODATA = -3007;
var UV_EAI_NONAME = -3008;
var UV_EAI_OVERFLOW = -3009;
var UV_EAI_SERVICE = -3010;
var UV_EAI_SOCKTYPE = -3011;
var UV_EAI_BADHINTS = -3013;
var UV_EAI_PROTOCOL = -3014;
var UV_E2BIG = -4093;
var UV_EACCES = -4092;
var UV_EADDRINUSE = -4091;
var UV_EADDRNOTAVAIL = -4090;
var UV_EAFNOSUPPORT = -4089;
var UV_EAGAIN = -4088;
var UV_EALREADY = -4084;
var UV_EBADF = -4083;
var UV_EBUSY = -4082;
var UV_ECANCELED = -4081;
var UV_ECHARSET = -4080;
var UV_ECONNABORTED = -4079;
var UV_ECONNREFUSED = -4078;
var UV_ECONNRESET = -4077;
var UV_EDESTADDRREQ = -4076;
var UV_EEXIST = -4075;
var UV_EFAULT = -4074;
var UV_EHOSTUNREACH = -4073;
var UV_EINTR = -4072;
var UV_EINVAL = -4071;
var UV_EIO = -4070;
var UV_EISCONN = -4069;
var UV_EISDIR = -4068;
var UV_ELOOP = -4067;
var UV_EMFILE = -4066;
var UV_EMSGSIZE = -4065;
var UV_ENAMETOOLONG = -4064;
var UV_ENETDOWN = -4063;
var UV_ENETUNREACH = -4062;
var UV_ENFILE = -4061;
var UV_ENOBUFS = -4060;
var UV_ENODEV = -4059;
var UV_ENOENT = -4058;
var UV_ENOMEM = -4057;
var UV_ENONET = -4056;
var UV_ENOSPC = -4055;
var UV_ENOSYS = -4054;
var UV_ENOTCONN = -4053;
var UV_ENOTDIR = -4052;
var UV_ENOTEMPTY = -4051;
var UV_ENOTSOCK = -4050;
var UV_ENOTSUP = -4049;
var UV_EPERM = -4048;
var UV_EPIPE = -4047;
var UV_EPROTO = -4046;
var UV_EPROTONOSUPPORT = -4045;
var UV_EPROTOTYPE = -4044;
var UV_EROFS = -4043;
var UV_ESHUTDOWN = -4042;
var UV_ESPIPE = -4041;
var UV_ESRCH = -4040;
var UV_ETIMEDOUT = -4039;
var UV_ETXTBSY = -4038;
var UV_EXDEV = -4037;
var UV_EFBIG = -4036;
var UV_ENOPROTOOPT = -4035;
var UV_ERANGE = -4034;
var UV_ENXIO = -4033;
var UV_EMLINK = -4032;
var UV_EHOSTDOWN = -4031;
var UV_EREMOTEIO = -4030;
var UV_ENOTTY = -4029;
var UV_EFTYPE = -4028;
var UV_EILSEQ = -4027;
var UV_EOVERFLOW = -4026;
var UV_ESOCKTNOSUPPORT = -4025;
var uv_default = {
  UV_EOF,
  UV_UNKNOWN,
  UV_EAI_ADDRFAMILY,
  UV_EAI_AGAIN,
  UV_EAI_BADFLAGS,
  UV_EAI_CANCELED,
  UV_EAI_FAIL,
  UV_EAI_FAMILY,
  UV_EAI_MEMORY,
  UV_EAI_NODATA,
  UV_EAI_NONAME,
  UV_EAI_OVERFLOW,
  UV_EAI_SERVICE,
  UV_EAI_SOCKTYPE,
  UV_EAI_BADHINTS,
  UV_EAI_PROTOCOL,
  UV_E2BIG,
  UV_EACCES,
  UV_EADDRINUSE,
  UV_EADDRNOTAVAIL,
  UV_EAFNOSUPPORT,
  UV_EAGAIN,
  UV_EALREADY,
  UV_EBADF,
  UV_EBUSY,
  UV_ECANCELED,
  UV_ECHARSET,
  UV_ECONNABORTED,
  UV_ECONNREFUSED,
  UV_ECONNRESET,
  UV_EDESTADDRREQ,
  UV_EEXIST,
  UV_EFAULT,
  UV_EHOSTUNREACH,
  UV_EINTR,
  UV_EINVAL,
  UV_EIO,
  UV_EISCONN,
  UV_EISDIR,
  UV_ELOOP,
  UV_EMFILE,
  UV_EMSGSIZE,
  UV_ENAMETOOLONG,
  UV_ENETDOWN,
  UV_ENETUNREACH,
  UV_ENFILE,
  UV_ENOBUFS,
  UV_ENODEV,
  UV_ENOENT,
  UV_ENOMEM,
  UV_ENONET,
  UV_ENOSPC,
  UV_ENOSYS,
  UV_ENOTCONN,
  UV_ENOTDIR,
  UV_ENOTEMPTY,
  UV_ENOTSOCK,
  UV_ENOTSUP,
  UV_EPERM,
  UV_EPIPE,
  UV_EPROTO,
  UV_EPROTONOSUPPORT,
  UV_EPROTOTYPE,
  UV_EROFS,
  UV_ESHUTDOWN,
  UV_ESPIPE,
  UV_ESRCH,
  UV_ETIMEDOUT,
  UV_ETXTBSY,
  UV_EXDEV,
  UV_EFBIG,
  UV_ENOPROTOOPT,
  UV_ERANGE,
  UV_ENXIO,
  UV_EMLINK,
  UV_EHOSTDOWN,
  UV_EREMOTEIO,
  UV_ENOTTY,
  UV_EFTYPE,
  UV_EILSEQ,
  UV_EOVERFLOW,
  UV_ESOCKTNOSUPPORT
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs.js
function makeCallback(cb) {
  validateFunction(cb, "cb");
  return (...args2) => Reflect.apply(cb, this, args2);
}
function applyDefaultValue(dest, def) {
  let res = {};
  for (const [key, val] of Object.entries(def)) {
    res[key] = dest[key] === void 0 ? val : dest[key];
  }
  return res;
}
function applyDefaultValueAlsoNull(dest, def) {
  let res = {};
  for (const [key, val] of Object.entries(def)) {
    res[key] = dest[key] ?? val;
  }
  return res;
}
var Stats2 = class {
  #origin = {};
  constructor(origin) {
    this.dev = origin.dev;
    this.ino = origin.ino;
    this.mode = origin.mode;
    this.nlink = origin.nlink;
    this.uid = origin.uid;
    this.gid = origin.gid;
    this.rdev = origin.rdev;
    this.size = origin.size || 0;
    this.blksize = origin.blksize;
    this.blocks = origin.blocks;
    this.mtime = new Date(origin.mtime);
    this.atime = new Date(origin.atime);
    this.birthtime = new Date(origin.birthtime);
    this.mtimeMs = origin.mtime;
    this.atimeMs = origin.atime;
    this.birthtimeMs = origin.birthtime;
    this.ctime = new Date(origin.mtime);
    this.ctimeMs = origin.mtime;
    this.#origin = origin;
  }
  isFile() {
    return this.#origin.is_file;
  }
  isDirectory() {
    return this.#origin.is_directory;
  }
  isSymbolicLink() {
    return this.#origin.is_symlink;
  }
  isBlockDevice() {
    return this.#origin.is_block_device;
  }
  isFIFO() {
    return false;
  }
  isCharacterDevice() {
    return this.#origin.is_char_device;
  }
  isSocket() {
    return this.#origin.is_socket;
  }
};
function toBigInt(number3) {
  if (number3 === null || number3 === void 0) return null;
  return BigInt(number3);
}
var BigIntStats = class {
  #origin = {};
  constructor(origin) {
    this.dev = toBigInt(origin.dev);
    this.ino = toBigInt(origin.ino);
    this.mode = toBigInt(origin.mode);
    this.nlink = toBigInt(origin.nlink);
    this.uid = toBigInt(origin.uid);
    this.gid = toBigInt(origin.gid);
    this.rdev = toBigInt(origin.rdev);
    this.size = toBigInt(origin.size) || 0n;
    this.blksize = toBigInt(origin.blksize);
    this.blocks = toBigInt(origin.blocks);
    this.mtime = new Date(origin.mtime);
    this.atime = new Date(origin.atime);
    this.birthtime = new Date(origin.birthtime);
    this.mtimeMs = toBigInt(origin.mtime);
    this.atimeMs = toBigInt(origin.atime);
    this.birthtimeMs = toBigInt(origin.birthtime);
    this.mtimeNs = toBigInt(origin.mtime) * 1000000n;
    this.atimeNs = toBigInt(origin.atime) * 1000000n;
    this.birthtimeNs = toBigInt(origin.birthtime) * 1000000n;
    this.ctime = new Date(origin.mtime);
    this.ctimeMs = toBigInt(origin.mtime);
    this.ctimeNs = toBigInt(origin.mtime) * 1000000n;
    this.#origin = origin;
  }
  isFile() {
    return this.#origin.is_file;
  }
  isDirectory() {
    return this.#origin.is_directory;
  }
  isSymbolicLink() {
    return this.#origin.is_symlink;
  }
  isBlockDevice() {
    return this.#origin.is_block_device;
  }
  isFIFO() {
    return false;
  }
  isCharacterDevice() {
    return this.#origin.is_char_device;
  }
  isSocket() {
    return this.#origin.is_socket;
  }
};
var codeToErrorMsg = {
  "E2BIG": "argument list too long",
  "EACCES": "permission denied",
  "EADDRINUSE": "address already in use",
  "EADDRNOTAVAIL": "address not available",
  "EAFNOSUPPORT": "address family not supported",
  "EAGAIN": "resource temporarily unavailable",
  "EAI_ADDRFAMILY": "address family not supported",
  "EAI_AGAIN": "temporary failure",
  "EAI_BADFLAGS": "bad ai_flags value",
  "EAI_BADHINTS": "invalid value for hints",
  "EAI_CANCELED": "request canceled",
  "EAI_FAIL": "permanent failure",
  "EAI_FAMILY": "ai_family not supported",
  "EAI_MEMORY": "out of memory",
  "EAI_NODATA": "no address",
  "EAI_NONAME": "unknown node or service",
  "EAI_OVERFLOW": "argument buffer overflow",
  "EAI_PROTOCOL": "resolved protocol is unknown",
  "EAI_SERVICE": "service not available for socket type",
  "EAI_SOCKTYPE": "socket type not supported",
  "EALREADY": "connection already in progress",
  "EBADF": "bad file descriptor",
  "EBUSY": "resource busy or locked",
  "ECANCELED": "operation canceled",
  "ECHARSET": "invalid Unicode character",
  "ECONNABORTED": "software caused connection abort",
  "ECONNREFUSED": "connection refused",
  "ECONNRESET": "connection reset by peer",
  "EDESTADDRREQ": "destination address required",
  "EEXIST": "file already exists",
  "EFAULT": "bad address in system call argument",
  "EFBIG": "file too large",
  "EHOSTUNREACH": "host is unreachable",
  "EINTR": "interrupted system call",
  "EINVAL": "invalid argument",
  "EIO": "i/o error",
  "EISCONN": "socket is already connected",
  "EISDIR": "illegal operation on a directory",
  "ELOOP": "too many symbolic links encountered",
  "EMFILE": "too many open files",
  "EMSGSIZE": "message too long",
  "ENAMETOOLONG": "name too long",
  "ENETDOWN": "network is down",
  "ENETUNREACH": "network is unreachable",
  "ENFILE": "file table overflow",
  "ENOBUFS": "no buffer space available",
  "ENODEV": "no such device",
  "ENOENT": "no such file or directory",
  "ENOMEM": "not enough memory",
  "ENONET": "machine is not on the network",
  "ENOPROTOOPT": "protocol not available",
  "ENOSPC": "no space left on device",
  "ENOSYS": "function not implemented",
  "ENOTCONN": "socket is not connected",
  "ENOTDIR": "not a directory",
  "ENOTEMPTY": "directory not empty",
  "ENOTSOCK": "socket operation on non-socket",
  "ENOTSUP": "operation not supported on socket",
  "EPERM": "operation not permitted",
  "EPIPE": "broken pipe",
  "EPROTO": "protocol error",
  "EPROTONOSUPPORT": "protocol not supported",
  "EPROTOTYPE": "protocol wrong type for socket",
  "ERANGE": "result too large",
  "EROFS": "read-only file system",
  "ESHUTDOWN": "cannot send after transport endpoint shutdown",
  "ESPIPE": "invalid seek",
  "ESRCH": "no such process",
  "ETIMEDOUT": "connection timed out",
  "ETXTBSY": "text file is busy",
  "EXDEV": "cross-device link not permitted",
  "UNKNOWN": "unknown error",
  "EOF": "end of file",
  "ENXIO": "no such device or address",
  "EMLINK": "too many links",
  "EHOSTDOWN": "host is down",
  "EREMOTEIO": "remote I/O error",
  "ENOTTY": "inappropriate ioctl for device",
  "EFTYPE": "inappropriate file type or format",
  "EILSEQ": "illegal byte sequence"
};
var codeToUvErrno = {
  "E2BIG": uv_default.UV_E2BIG,
  "EACCES": uv_default.UV_EACCES,
  "EADDRINUSE": uv_default.UV_EADDRINUSE,
  "EADDRNOTAVAIL": uv_default.UV_EADDRNOTAVAIL,
  "EAFNOSUPPORT": uv_default.UV_EAFNOSUPPORT,
  "EAGAIN": uv_default.UV_EAGAIN,
  "EAI_ADDRFAMILY": uv_default.UV_EAI_ADDRFAMILY,
  "EAI_AGAIN": uv_default.UV_EAI_AGAIN,
  "EAI_BADFLAGS": uv_default.UV_EAI_BADFLAGS,
  "EAI_BADHINTS": uv_default.UV_EAI_BADHINTS,
  "EAI_CANCELED": uv_default.UV_EAI_CANCELED,
  "EAI_FAIL": uv_default.UV_EAI_FAIL,
  "EAI_FAMILY": uv_default.UV_EAI_FAMILY,
  "EAI_MEMORY": uv_default.UV_EAI_MEMORY,
  "EAI_NODATA": uv_default.UV_EAI_NODATA,
  "EAI_NONAME": uv_default.UV_EAI_NONAME,
  "EAI_OVERFLOW": uv_default.UV_EAI_OVERFLOW,
  "EAI_PROTOCOL": uv_default.UV_EAI_PROTOCOL,
  "EAI_SERVICE": uv_default.UV_EAI_SERVICE,
  "EAI_SOCKTYPE": uv_default.UV_EAI_SOCKTYPE,
  "EALREADY": uv_default.UV_EALREADY,
  "EBADF": uv_default.UV_EBADF,
  "EBUSY": uv_default.UV_EBUSY,
  "ECANCELED": uv_default.UV_ECANCELED,
  "ECHARSET": uv_default.UV_ECHARSET,
  "ECONNABORTED": uv_default.UV_ECONNABORTED,
  "ECONNREFUSED": uv_default.UV_ECONNREFUSED,
  "ECONNRESET": uv_default.UV_ECONNRESET,
  "EDESTADDRREQ": uv_default.UV_EDESTADDRREQ,
  "EEXIST": uv_default.UV_EEXIST,
  "EFAULT": uv_default.UV_EFAULT,
  "EFBIG": uv_default.UV_EFBIG,
  "EHOSTUNREACH": uv_default.UV_EHOSTUNREACH,
  "EINTR": uv_default.UV_EINTR,
  "EINVAL": uv_default.UV_EINVAL,
  "EIO": uv_default.UV_EIO,
  "EISCONN": uv_default.UV_EISCONN,
  "EISDIR": uv_default.UV_EISDIR,
  "ELOOP": uv_default.UV_ELOOP,
  "EMFILE": uv_default.UV_EMFILE,
  "EMSGSIZE": uv_default.UV_EMSGSIZE,
  "ENAMETOOLONG": uv_default.UV_ENAMETOOLONG,
  "ENETDOWN": uv_default.UV_ENETDOWN,
  "ENETUNREACH": uv_default.UV_ENETUNREACH,
  "ENFILE": uv_default.UV_ENFILE,
  "ENOBUFS": uv_default.UV_ENOBUFS,
  "ENODEV": uv_default.UV_ENODEV,
  "ENOENT": uv_default.UV_ENOENT,
  "ENOMEM": uv_default.UV_ENOMEM,
  "ENONET": uv_default.UV_ENONET,
  "ENOPROTOOPT": uv_default.UV_ENOPROTOOPT,
  "ENOSPC": uv_default.UV_ENOSPC,
  "ENOSYS": uv_default.UV_ENOSYS,
  "ENOTCONN": uv_default.UV_ENOTCONN,
  "ENOTDIR": uv_default.UV_ENOTDIR,
  "ENOTEMPTY": uv_default.UV_ENOTEMPTY,
  "ENOTSOCK": uv_default.UV_ENOTSOCK,
  "ENOTSUP": uv_default.UV_ENOTSUP,
  "EPERM": uv_default.UV_EPERM,
  "EPIPE": uv_default.UV_EPIPE,
  "EPROTO": uv_default.UV_EPROTO,
  "EPROTONOSUPPORT": uv_default.UV_EPROTONOSUPPORT,
  "EPROTOTYPE": uv_default.UV_EPROTOTYPE,
  "ERANGE": uv_default.UV_ERANGE,
  "EROFS": uv_default.UV_EROFS,
  "ESHUTDOWN": uv_default.UV_ESHUTDOWN,
  "ESPIPE": uv_default.UV_ESPIPE,
  "ESRCH": uv_default.UV_ESRCH,
  "ETIMEDOUT": uv_default.UV_ETIMEDOUT,
  "ETXTBSY": uv_default.UV_ETXTBSY,
  "EXDEV": uv_default.UV_EXDEV,
  "UNKNOWN": uv_default.UV_UNKNOWN,
  "EOF": uv_default.UV_EOF,
  "ENXIO": uv_default.UV_ENXIO,
  "EMLINK": uv_default.UV_EMLINK,
  "EHOSTDOWN": uv_default.UV_EHOSTDOWN,
  "EREMOTEIO": uv_default.UV_EREMOTEIO,
  "ENOTTY": uv_default.UV_ENOTTY,
  "EFTYPE": uv_default.UV_EFTYPE,
  "EILSEQ": uv_default.UV_EILSEQ
};
function wasiFsSyscallErrorMap(err3, syscall, path2, dest) {
  if (typeof err3 === "string") {
    err3 = {
      code: err3
    };
  }
  let code = codeToErrorMsg[err3.code] === void 0 ? "E" + err3.code : err3.code;
  if (codeToErrorMsg[code] === void 0) {
    return err3;
  }
  let msg = `${code}: ${codeToErrorMsg[code]}, ${syscall}`;
  if (path2 !== void 0) {
    msg += ` '${path2}'`;
  }
  if (dest !== void 0) {
    msg += ` -> '${dest}'`;
  }
  let e3 = new Error(msg);
  e3.code = code;
  e3.errno = codeToUvErrno[code];
  e3.syscall = syscall;
  e3.path = path2;
  e3.dest = dest;
  if (err3.stack) {
    e3.stack = err3.stack;
  }
  return e3;
}
function stat(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  validateFunction(callback, "callback");
  path2 = getValidatedPath(path2);
  setTimeout(() => {
    try {
      let res = statSync(path2, options);
      callback(null, res);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function statSync(path2, options = { bigint: false, throwIfNoEntry: true }) {
  path2 = getValidatedPath(path2);
  options = applyDefaultValue(options, { bigint: false, throwIfNoEntry: true });
  try {
    let stat3 = binding2.statSync(path2);
    if (options.bigint === true) {
      return new BigIntStats(stat3);
    } else {
      return new Stats2(stat3);
    }
  } catch (err3) {
    if (err3.code === "NOENT" && options.throwIfNoEntry === false) {
      return void 0;
    }
    throw wasiFsSyscallErrorMap(err3, "stat", path2);
  }
}
function lstat(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
  }
  validateFunction(callback, "callback");
  path2 = getValidatedPath(path2);
  setTimeout(() => {
    try {
      let res = lstatSync(path2, options);
      callback(null, res);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function lstatSync(path2, options = { bigint: false, throwIfNoEntry: true }) {
  path2 = getValidatedPath(path2);
  options = applyDefaultValue(options, { bigint: false, throwIfNoEntry: true });
  try {
    let stat3 = binding2.lstatSync(path2);
    if (options.bigint === true) {
      return new BigIntStats(stat3);
    } else {
      return new Stats2(stat3);
    }
  } catch (err3) {
    if (err3.code === "NOENT" && options.throwIfNoEntry === false) {
      return void 0;
    }
    throw wasiFsSyscallErrorMap(err3, "lstat", path2);
  }
}
function fstat(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
  }
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      let res = fstatSync(fd, options);
      callback(null, res);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function fstatSync(fd, options = { bigint: false, throwIfNoEntry: true }) {
  validateInteger(fd, "fd");
  options = applyDefaultValue(options, { bigint: false, throwIfNoEntry: true });
  try {
    let stat3 = binding2.fstatSync(fd);
    if (options.bigint === true) {
      return new BigIntStats(stat3);
    } else {
      return new Stats2(stat3);
    }
  } catch (err3) {
    if (err3.code === "NOENT" && options.throwIfNoEntry === false) {
      return void 0;
    }
    throw wasiFsSyscallErrorMap(err3, "fstat");
  }
}
function access(path2, mode = fs.F_OK, callback) {
  if (typeof mode === "function") {
    callback = mode;
    mode = fs.F_OK;
  }
  mode = getValidMode2(mode, "access");
  path2 = getValidatedPath(path2);
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      accessSync(path2, mode);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function accessSync(path2, mode = fs.F_OK) {
  path2 = getValidatedPath(path2);
  mode = getValidMode2(mode, "access");
  try {
    const stat3 = statSync(path2, { throwIfNoEntry: true });
    if ((stat3.mode & mode) === mode) {
      return void 0;
    } else {
      throw new Error(`EACCES: permission denied, access '${path2}'`);
    }
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "access", path2);
  }
}
function exists(path2, callback) {
  validateFunction(callback, "callback");
  try {
    path2 = getValidatedPath(path2);
  } catch (err3) {
    callback(false);
    return;
  }
  setTimeout(() => {
    callback(existsSync(path2));
  }, 0);
}
exists[kCustomPromisifiedSymbol] = (path2) => {
  return new Promise((res, rej) => {
    exists(path2, res);
  });
};
function existsSync(path2) {
  try {
    path2 = getValidatedPath(path2);
    accessSync(path2);
    return true;
  } catch (err3) {
    return false;
  }
}
function mkdir(path2, options, callback) {
  path2 = getValidatedPath(path2);
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  validateFunction(callback, "callback");
  if (typeof options === "number") {
    options = {
      mode: options
    };
  } else if (typeof options === "string") {
    options = {
      mode: parseInt(options)
    };
  }
  options = applyDefaultValue(options, { recursive: false, mode: 511 });
  validateBoolean(options.recursive, "options.recursive");
  setTimeout(() => {
    try {
      let newPath = mkdirSync(path2, options);
      callback(null, newPath);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function mkdirSync(path2, options = { recursive: false, mode: 511 }) {
  path2 = getValidatedPath(path2);
  if (typeof options === "number") {
    options = {
      mode: options
    };
  } else if (typeof options === "string") {
    options = {
      mode: parseInt(options)
    };
  }
  options = applyDefaultValue(options, { recursive: false, mode: 511 });
  validateBoolean(options.recursive, "options.recursive");
  try {
    let dirs = path2.split("/");
    let dir = "";
    let allExist = true;
    for (const d of dirs) {
      dir = join2(dir, d);
      if (!existsSync(dir)) {
        allExist = false;
        break;
      }
    }
    binding2.mkdirSync(path2, options.recursive, options.mode);
    return allExist ? void 0 : dir;
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "mkdir", path2);
  }
}
function fchown(fd, uid, gid, callback) {
  validateFunction(callback);
  callback(void 0);
}
function fchownSync(fd, uid, gid) {
  return void 0;
}
function lchown(path2, uid, gid, callback) {
  validateFunction(callback);
  callback(void 0);
}
function lchownSync(path2, uid, gid) {
  return void 0;
}
function chown(path2, uid, gid, callback) {
  validateFunction(callback);
  callback(void 0);
}
function chownSync(path2, uid, gid) {
  return void 0;
}
function chmod(path2, mode, callback) {
  validateFunction(callback);
  callback(void 0);
}
function chmodSync(path2, mode) {
  return void 0;
}
function lchmod(path2, mode, callback) {
  validateFunction(callback);
  callback(void 0);
}
function lchmodSync(path2, mode) {
  return void 0;
}
function fchmod(fd, mode, callback) {
  validateFunction(callback, "callback");
  callback(void 0);
}
function fchmodSync(fd, mode) {
  return void 0;
}
function getValidTime(time2, name) {
  if (typeof time2 === "string") {
    time2 = Number(time2);
  }
  if (typeof time2 === "number" && (Number.isNaN(time2) || !Number.isFinite(time2))) {
    throw new ERR_INVALID_ARG_TYPE(name, "number | string | Date", time2);
  }
  return time2;
}
function utimes(path2, atime, mtime, callback) {
  path2 = getValidatedPath(path2);
  atime = getValidTime(atime);
  mtime = getValidTime(mtime);
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      utimesSync(path2, atime, mtime);
    } catch (err3) {
      callback(err3);
      return;
    }
    callback(null);
  }, 0);
}
function utimesSync(path2, atime, mtime) {
  path2 = getValidatedPath(path2);
  atime = getValidTime(atime);
  mtime = getValidTime(mtime);
  if (atime instanceof Date) {
    atime = atime.getTime();
  }
  mtime = getValidTime(mtime);
  if (mtime instanceof Date) {
    mtime = mtime.getTime();
  }
  try {
    binding2.utimeSync(path2, atime, mtime);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "utime", path2);
  }
}
function lutimes(path2, atime, mtime, callback) {
  callback(wasiFsSyscallErrorMap("ENOSYS", "lutime", path2));
  return;
  path2 = getValidatedPath(path2);
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      lutimesSync(path2, atime, mtime);
      callback(null);
    } catch (err3) {
      print(err3, err3.stack);
      callback(err3);
    }
  }, 0);
}
function lutimesSync(path2, atime, mtime) {
  throw wasiFsSyscallErrorMap("ENOSYS", "lutime", path2);
  path2 = getValidatedPath(path2);
  atime = getValidTime(atime);
  if (atime instanceof Date) {
    atime = atime.getTime();
  }
  mtime = getValidTime(mtime);
  if (mtime instanceof Date) {
    mtime = mtime.getTime();
  }
  try {
    binding2.lutimeSync(path2, atime, mtime);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "utime", path2);
  }
}
function futimes(fd, atime, mtime, callback) {
  validateFunction(callback, "callback");
  validateInteger(fd, "fd", 0, 2147483647);
  atime = getValidTime(atime, "atime");
  mtime = getValidTime(mtime, "mtime");
  setTimeout(() => {
    try {
      futimesSync(fd, atime, mtime);
    } catch (err3) {
      callback(err3);
      return;
    }
    callback(null);
  }, 0);
}
function futimesSync(fd, atime, mtime) {
  validateInteger(fd, "fd", 0, 2147483647);
  atime = getValidTime(atime, "atime");
  mtime = getValidTime(mtime, "mtime");
  try {
    fstatSync(fd);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "futime");
  }
  try {
    binding2.futimeSync(fd, atime, mtime);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "futime");
  }
}
function rmdir(path2, options, callback) {
  path2 = getValidatedPath(path2);
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      rmdirSync(path2, options, callback);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function rmdirSync(path2, options = { maxRetries: 0, recursive: false, retryDelay: 100 }) {
  path2 = getValidatedPath(path2);
  options = applyDefaultValue(options, { maxRetries: 0, recursive: false, retryDelay: 100 });
  try {
    binding2.rmdirSync(path2, options.recursive);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "rmdir", path2);
  }
}
function rm(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  validateFunction(callback, "callback");
  validateObject2(options, options);
  options = applyDefaultValue(options, { force: false, maxRetries: 1, recursive: false, retryDelay: 100 });
  validateBoolean(options.force, "options.force");
  validateBoolean(options.recursive, "options.recursive");
  validateInteger(options.maxRetries, "options.maxRetries", 0);
  validateInteger(options.retryDelay, "options.retryDelay", 0);
  setTimeout(() => {
    try {
      rmSync(path2, options);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function rmSync(path2, options = { force: false, maxRetries: 1, recursive: false, retryDelay: 100 }) {
  path2 = getValidatedPath(path2);
  validateObject2(options, options);
  options = applyDefaultValue(options, { force: false, maxRetries: 1, recursive: false, retryDelay: 100 });
  validateBoolean(options.force, "options.force");
  validateBoolean(options.recursive, "options.recursive");
  validateInteger(options.maxRetries, "options.maxRetries", 0);
  validateInteger(options.retryDelay, "options.retryDelay", 0);
  for (let i2 = 0; i2 < options.maxRetries; i2++) {
    try {
      binding2.rmSync(path2, options.recursive, options.force);
    } catch (err3) {
      if (i2 === options.maxRetries - 1) {
        throw wasiFsSyscallErrorMap(err3, "rm", path2);
      }
      continue;
    }
    break;
  }
}
function rename(oldPath, newPath, callback) {
  oldPath = getValidatedPath(oldPath, "oldPath");
  newPath = getValidatedPath(newPath, "newPath");
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      renameSync(oldPath, newPath);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function renameSync(oldPath, newPath) {
  oldPath = getValidatedPath(oldPath, "oldPath");
  newPath = getValidatedPath(newPath, "newPath");
  if (statSync(oldPath, { throwIfNoEntry: false }) === void 0) {
    throw wasiFsSyscallErrorMap("NOENT", "rename", oldPath, newPath);
  }
  if (statSync(newPath, { throwIfNoEntry: false }) !== void 0) {
    throw wasiFsSyscallErrorMap("EXIST", "rename", oldPath, newPath);
  }
  try {
    binding2.renameSync(oldPath, newPath);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "rename", oldPath, newPath);
  }
}
function unlink(path2, callback) {
  path2 = getValidatedPath(path2);
  rm(path2, (err3) => {
    if (err3 != null) {
      callback(wasiFsSyscallErrorMap(err3, "unlink", path2));
    } else {
      callback(null);
    }
  });
}
function unlinkSync(path2) {
  path2 = getValidatedPath(path2);
  try {
    rmSync(path2);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "unlink", path2);
  }
}
function truncate2(path2, len, callback) {
  if (typeof path2 !== "number") {
    path2 = getValidatedPath(path2);
  } else {
    validateInteger(path2);
  }
  if (typeof len === "function") {
    callback = len;
    len = 0;
  }
  len = len === void 0 ? 0 : len;
  validateInteger(len, "len");
  validateFunction(callback, "callback");
  if (len < 0) {
    len = 0;
  }
  setTimeout(() => {
    try {
      if (typeof path2 === "number") {
        ftruncateSync(path2, len);
      } else {
        truncateSync(path2, len);
      }
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function truncateSync(path2, len = 0) {
  validateInteger(len, "len");
  if (typeof path2 !== "number") {
    path2 = getValidatedPath(path2);
  } else {
    validateInteger(path2);
  }
  if (len < 0) {
    len = 0;
  }
  try {
    if (typeof path2 === "number") {
      binding2.ftruncateSync(path2, len);
    } else {
      binding2.truncateSync(path2, len);
    }
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "truncate", path2);
  }
}
function ftruncate(fd, len, callback) {
  validateInteger(fd, "fd");
  if (typeof len === "function") {
    callback = len;
    len = 0;
  }
  len = len === void 0 ? 0 : len;
  validateInteger(len, "len");
  validateFunction(callback, "callback");
  if (len < 0) {
    len = 0;
  }
  setTimeout(() => {
    try {
      ftruncateSync(fd, len);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function ftruncateSync(fd, len = 0) {
  validateInteger(len, "len");
  validateInteger(fd, "fd");
  if (len < 0) {
    len = 0;
  }
  try {
    binding2.ftruncateSync(fd, len);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "ftruncate");
  }
}
function realpath(path2, options = { encoding: "utf8" }, callback) {
  path2 = getValidatedPath(path2);
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  validateFunction(callback, "callback");
  if (typeof options === "string") {
    options = {
      encoding: options
    };
  }
  options = applyDefaultValue(options, {
    encoding: "utf8"
  });
  validateEncoding(options.encoding, "encoding");
  setTimeout(() => {
    try {
      callback(null, realpathSync(path2, options));
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function realpathSync(path2, options = { encoding: "utf8" }) {
  path2 = getValidatedPath(path2);
  if (typeof options === "string") {
    options = {
      encoding: options
    };
  }
  options = applyDefaultValue(options, { encoding: "utf8" });
  validateEncoding(options.encoding, "encoding");
  let useBuffer = options.encoding === "buffer" || options.encoding === "Buffer";
  let stat3 = lstatSync(path2);
  if (stat3 != null) {
    if (!stat3.isSymbolicLink()) {
      let res = normalize(path2);
      if (!useBuffer) {
        return res;
      } else {
        return Buffer2.from(res, "utf8");
      }
    }
  }
  try {
    let res = binding2.realpathSync(path2);
    res = normalize(res);
    if (!useBuffer) {
      return res;
    } else {
      return Buffer2.from(res, "utf8");
    }
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "realpath", path2);
  }
}
function genId(len) {
  let result2 = "";
  let characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let charactersLength = characters.length;
  for (let i2 = 0; i2 < len; i2++) {
    result2 += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result2;
}
function mkdtemp(prefix, options = { encoding: "utf8" }, callback) {
  prefix = getValidatedPath(prefix);
  if (typeof options === "string") {
    options = { encoding: options };
  } else if (typeof options === "function") {
    callback = options;
    options = { encoding: "utf8" };
  } else {
    options = applyDefaultValue(options, { encoding: "utf8" });
  }
  validateFunction(callback, "callback");
  validateEncoding(options.encoding, "encoding");
  let useBuffer = options.encoding === "buffer" || options.encoding === "Buffer";
  let path2 = prefix + genId(6);
  mkdir(path2, (err3) => {
    if (err3) {
      callback(wasiFsSyscallErrorMap(err3, "mkdtemp", prefix));
    } else if (useBuffer) {
      callback(null, Buffer2.from(path2, "utf8"));
    } else {
      callback(null, path2);
    }
  });
}
function mkdtempSync(prefix, options = { encoding: "utf8" }) {
  prefix = getValidatedPath(prefix);
  if (typeof options === "string") {
    options = { encoding: options };
  } else {
    options = applyDefaultValue(options, { encoding: "utf8" });
  }
  validateEncoding(options.encoding, "encoding");
  let useBuffer = options.encoding === "buffer" || options.encoding === "Buffer";
  let path2 = prefix + genId(6);
  try {
    mkdirSync(path2);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "mkdtemp", prefix);
  }
  if (useBuffer) {
    return Buffer2.from(path2, "utf8");
  } else {
    return path2;
  }
}
function copyFile(src, dest, mode, callback) {
  if (typeof mode === "function") {
    callback = mode;
    mode = 0;
  }
  src = getValidatedPath(src, "src");
  dest = getValidatedPath(dest, "dest");
  validateInteger(mode, "mode", 0, 7);
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      copyFileSync(src, dest, mode);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function copyFileSync(src, dest, mode = 0) {
  src = getValidatedPath(src, "src");
  dest = getValidatedPath(dest, "dest");
  validateInteger(mode, "mode", 0, 7);
  if (statSync(src, { throwIfNoEntry: false }) === void 0) {
    throw wasiFsSyscallErrorMap("NOENT", "copyfile", src, dest);
  }
  if (mode & fs.COPYFILE_EXCL === fs.COPYFILE_EXCL) {
    if (existsSync(dest)) {
      let e3 = new Error(`EEXIST: file already exists, copyfile '${src}' -> '${dest}'`);
      e3.code = "EEXIST";
      e3.syscall = "copyfile";
      e3.errno = uv_default.UV_EEXIST;
      throw e3;
    }
  }
  try {
    binding2.copyFileSync(src, dest);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "copyfile", src, dest);
  }
}
function link(existingPath, newPath, callback) {
  existingPath = getValidatedPath(existingPath);
  newPath = getValidatedPath(newPath);
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      linkSync(existingPath, newPath);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function linkSync(existingPath, newPath) {
  existingPath = getValidatedPath(existingPath);
  newPath = getValidatedPath(newPath);
  try {
    binding2.linkSync(existingPath, newPath);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "link", existingPath, newPath);
  }
}
function symlink(target, path2, type, callback) {
  if (typeof type === "function") {
    callback = type;
    type = "file";
  }
  target = getValidatedPath(target);
  path2 = getValidatedPath(path2);
  validateFunction(callback, "callback");
  if (!["dir", "file", "junction"].includes(type)) {
    throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
  }
  setTimeout(() => {
    try {
      symlinkSync(target, path2);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function symlinkSync(target, path2, type) {
  type = type ?? "file";
  if (!["dir", "file", "junction"].includes(type)) {
    throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
  }
  target = getValidatedPath(target);
  path2 = getValidatedPath(path2);
  let reTarget;
  if (dirname(target) === "." || dirname(target) === "") {
    reTarget = target;
  } else {
    reTarget = relative(dirname(path2), target);
  }
  try {
    binding2.symlinkSync(reTarget, path2);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "symlink", target, path2);
  }
}
function close(fd, callback) {
  validateInteger(fd, "fd");
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      closeSync(fd);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function closeSync(fd) {
  validateInteger(fd, "fd");
  try {
    binding2.fcloseSync(fd);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "close");
  }
}
function fsync(fd, callback) {
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      fsyncSync(fd);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function fsyncSync(fd) {
  validateInteger(fd, "fd");
  try {
    binding2.fsyncSync(fd);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "fsync");
  }
}
function fdatasync(fd, callback) {
  validateFunction(callback, "callback");
  setTimeout(() => {
    try {
      fdatasyncSync(fd);
      callback(null);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function fdatasyncSync(fd) {
  validateInteger(fd, "fd");
  try {
    binding2.fdatasyncSync(fd);
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "fdatasync");
  }
}
function fread2(fd, position, length) {
  let stat3 = null;
  try {
    stat3 = fstatSync(fd);
  } catch (err3) {
    return new Promise((res, rej) => {
      rej(err3);
    });
  }
  if (stat3.isFile()) {
    return new Promise((res, rej) => {
      try {
        res(binding2.freadSync(fd, position, length));
      } catch (e3) {
        rej(e3);
      }
    });
  } else {
    return binding2.fread(fd, position, length);
  }
}
function read(fd, buffer, offset, length, position, callback) {
  if (typeof buffer === "function") {
    callback = buffer;
    buffer = Buffer2.alloc(16384);
    offset = 0;
    length = buffer.byteLength - offset;
    position = -1;
  } else if (!(buffer instanceof Buffer2) && !Object.prototype.toString.call(buffer).endsWith("Array]") && arguments.length === 3) {
    callback = offset;
    let option = buffer ?? {};
    buffer = option.buffer !== void 0 ? option.buffer : Buffer2.alloc(16384);
    offset = option.offset ?? 0;
    length = option.length ?? buffer.byteLength - offset;
    if (option.position === null) {
      position = -1;
    }
    position = position ?? option.position ?? -1;
  } else if (arguments.length === 4) {
    callback = length;
    let option = offset;
    offset = (option && option.offset) ?? 0;
    length = (option && option.length) ?? buffer.byteLength - offset;
    if ((option && option.position) === null) {
      position = -1;
    }
    position = position ?? (option && option.position) ?? -1;
  } else if (typeof offset === "function") {
    callback = offset;
    offset = 0;
    length = buffer.byteLength - offset;
    position = -1;
  }
  offset = offset ?? 0;
  position = position ?? -1;
  if (!isArrayBufferView2(buffer)) {
    throw new ERR_INVALID_ARG_TYPE("buffer", ["Buffer", "TypedArray", "DataView"], buffer);
  }
  validateInteger(fd, "fd");
  validateFunction(callback, "callback");
  validateInteger(offset, "offset", 0);
  const nodePositionMin = -9223372036854775808n;
  const nodePositionMax = 9223372036854775807n;
  if (typeof position === "bigint") {
    if (position < nodePositionMin || position > nodePositionMax) {
      throw new ERR_OUT_OF_RANGE("position", `>= ${nodePositionMin} && <= ${nodePositionMax}`, position);
    } else {
      position = Number(position);
    }
  } else {
    validateInteger(position, "position");
  }
  if (length === 0) {
    callback(null, 0, buffer);
    return;
  }
  try {
    let stat3 = fstatSync(fd);
    if (position > stat3.size) {
      callback(null, 0, buffer);
      return;
    }
  } catch (err3) {
    callback(wasiFsSyscallErrorMap(err3, "read"));
    return;
  }
  if (buffer.byteLength === 0) {
    throw new ERR_INVALID_ARG_VALUE(
      "buffer",
      buffer,
      "is empty and cannot be written"
    );
  }
  validateInteger(length, "length", 0, buffer.byteLength);
  fread2(fd, position, length).then((data) => {
    let len = data.byteLength;
    if (buffer instanceof Buffer2) {
      Buffer2.from(data).copy(buffer, offset, 0, len);
    } else {
      buffer.set(new Uint8Array(data.slice(0, len)), offset);
    }
    callback(null, len, buffer);
  }).catch((e3) => {
    if (err.code === "INVAL") {
      let e4 = new Error(err.message);
      e4.code = "EOVERFLOW";
      callback(e4);
    }
    callback(wasiFsSyscallErrorMap(e3, "read"));
  });
}
read[customPromisifyArgs] = ["bytesRead", "buffer"];
function readSync(fd, buffer, offset, length, position) {
  if (typeof offset === "object" && offset !== null) {
    let option = offset;
    offset = option.offset ?? 0;
    length = option.length ?? buffer.byteLength - offset;
    if (option.position === null || typeof option.position === "undefined") {
      position = -1;
    } else {
      position = option.position;
    }
  } else if (!(buffer instanceof Buffer2) && !Object.prototype.toString.call(buffer).endsWith("Array]")) {
    let option = buffer;
    buffer = option.buffer !== void 0 ? option.buffer : Buffer2.alloc(16384);
    offset = option.offset ?? 0;
    length = option.length ?? buffer.byteLength - offset;
    if (option.position === null) {
      position = -1;
    }
    position = position ?? option.position ?? -1;
  }
  if (typeof offset !== "number" || offset === Infinity) {
    offset = 0;
    length = buffer.byteLength;
    position = -1;
  } else {
    offset = offset ?? 0;
    length = length ?? buffer.byteLength - offset;
    if (position === null || typeof position === "undefined") {
      position = -1;
    }
  }
  validateInteger(fd, "fd");
  validateInteger(offset, "offset", 0);
  if (length === 0) {
    return 0;
  }
  if (buffer.byteLength === 0) {
    throw new ERR_INVALID_ARG_VALUE(
      "buffer",
      buffer,
      "is empty and cannot be written"
    );
  }
  validateInteger(length, "length", 0, buffer.byteLength);
  const nodePositionMin = -9223372036854775808n;
  const nodePositionMax = 9223372036854775807n;
  if (typeof position === "bigint") {
    if (position < nodePositionMin || position > nodePositionMax) {
      throw new ERR_OUT_OF_RANGE("position", `>= ${nodePositionMin} && <= ${nodePositionMax}`, position);
    } else {
      position = Number(position);
    }
  } else {
    validateInteger(position, "position");
  }
  try {
    let stat3 = fstatSync(fd);
    if (position > stat3.size) {
      return 0;
    }
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "read");
  }
  position = Number(position);
  try {
    let data = binding2.freadSync(fd, position, length);
    if (buffer instanceof Buffer2) {
      Buffer2.from(data).copy(buffer, offset, 0, data.byteLength);
    } else {
      buffer.set(new Uint8Array(data), offset);
    }
    return data.byteLength;
  } catch (err3) {
    if (err3.code === "INVAL") {
      let e3 = new Error(err3.message);
      e3.code = "EOVERFLOW";
      throw e3;
    }
    throw wasiFsSyscallErrorMap(err3, "read");
  }
}
function openSync(path2, flag = "r", mode = 438) {
  path2 = getValidatedPath(path2);
  flag = stringToFlags(flag);
  if (mode === null || mode === void 0) {
    mode = 438;
  }
  try {
    validateInteger(mode, "mode", 0, 511);
  } catch (err3) {
    if (typeof mode === "string") {
      err3.code = "ERR_INVALID_ARG_VALUE";
    }
    throw err3;
  }
  try {
    let fd = binding2.openSync(path2, flag, mode);
    return fd;
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "open", path2);
  }
}
function open(path2, flag = "r", mode = 438, callback) {
  if (typeof flag === "function") {
    callback = flag;
    flag = "r";
    mode = 438;
  } else if (typeof mode === "function") {
    callback = mode;
    mode = 438;
  }
  path2 = getValidatedPath(path2);
  validateFunction(callback, "callback");
  if (mode === null || mode === void 0) {
    mode = 438;
  }
  try {
    validateInteger(mode, "mode", 0, 511);
  } catch (err3) {
    if (typeof mode === "string") {
      err3.code = "ERR_INVALID_ARG_VALUE";
    }
    throw err3;
  }
  setTimeout(() => {
    try {
      let fd = openSync(path2, flag, mode);
      callback(null, fd);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function readFile2(path2, option, callback) {
  if (typeof option === "function") {
    callback = option;
    option = {};
  }
  let encoding2 = void 0;
  if (typeof option === "string") {
    encoding2 = option;
    option = {};
  } else {
    option = option ?? {};
  }
  option = applyDefaultValue(option, {
    encoding: encoding2 ?? "",
    flag: "r",
    signal: void 0
  });
  validateEncoding(option.encoding, "encoding");
  validateFunction(callback, "callback");
  let fd;
  if (typeof path2 === "number") {
    fd = path2;
  } else {
    fd = getValidatedPath(path2);
    try {
      fd = openSync(path2, option.flag);
    } catch (err3) {
      callback(err3);
      return;
    }
  }
  let stat3 = fstatSync(fd);
  let len = stat3.size;
  if (len > 2 ** 31 - 1) {
    callback(new ERR_FS_FILE_TOO_LARGE(len));
    return;
  }
  let buf = Buffer2.alloc(Math.max(len, 1));
  read(fd, buf, (err3, rlen, obuf) => {
    if (typeof path2 !== "number") {
      closeSync(fd);
    }
    if (err3) {
      callback(err3);
    } else if (option.encoding !== "") {
      callback(err3, obuf.slice(0, rlen).toString(option.encoding));
    } else {
      callback(err3, obuf.slice(0, rlen));
    }
  });
}
function readFileSync(path2, option) {
  let encoding2 = void 0;
  if (typeof option === "string") {
    encoding2 = option;
    option = {};
  } else {
    option = option ?? {};
  }
  option = applyDefaultValue(option, {
    encoding: encoding2 ?? "",
    flag: "r",
    signal: void 0
  });
  validateEncoding(option.encoding, "encoding");
  let fd;
  if (typeof path2 === "number") {
    fd = path2;
  } else {
    fd = getValidatedPath(path2);
    fd = openSync(path2, option.flag);
  }
  let stat3 = fstatSync(fd);
  let len = stat3.size;
  if (len > 2 ** 31 - 1) {
    throw new ERR_FS_FILE_TOO_LARGE(len);
  }
  let buf = Buffer2.alloc(Math.max(len, 1));
  let rlen = readSync(fd, buf);
  if (typeof path2 !== "number") {
    closeSync(fd);
  }
  if (option.encoding !== "") {
    return buf.slice(0, rlen).toString(option.encoding);
  } else {
    return buf.slice(0, rlen);
  }
}
function readlinkSync(path2, option) {
  path2 = getValidatedPath(path2);
  if (typeof option === "string") {
    option = {
      encoding: option
    };
  } else {
    option = option ?? {};
  }
  option = applyDefaultValue(option, {
    encoding: "utf8"
  });
  validateEncoding(option.encoding, "encoding");
  try {
    let res = binding2.readlinkSync(path2);
    if (option.encoding === "buffer" || option.encoding === "Buffer") {
      return Buffer2.from(res);
    }
    return res;
  } catch (e3) {
    throw wasiFsSyscallErrorMap(e3, "readlink", path2);
  }
}
function readlink(path2, option, callback) {
  if (typeof option === "function") {
    callback = option;
    option = {};
  }
  if (typeof option === "string") {
    option = {
      encoding: option
    };
  }
  path2 = getValidatedPath(path2);
  option = applyDefaultValue(option, {
    encoding: "utf8"
  });
  validateEncoding(option.encoding, "encoding");
  setTimeout(() => {
    try {
      let res = readlinkSync(path2, option);
      callback(null, res);
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function readv(fd, buffer, position, callback) {
  if (typeof position === "function") {
    callback = position;
    position = -1;
  }
  position = position ?? -1;
  validateFunction(callback, "callback");
  validateInteger(position, "position");
  validateInteger(fd, "fd");
  if (!buffer || !Array.isArray(buffer) || buffer.length > 0 && !isArrayBufferView2(buffer[0])) {
    throw new ERR_INVALID_ARG_TYPE("buffers", "ArrayBufferView[]", buffer);
  }
  let length = 0;
  for (const buf of buffer) {
    length += buf.byteLength;
  }
  if (length === 0) {
    callback(null, 0, buffer);
    return;
  }
  fread2(fd, position, length).then((data) => {
    let off2 = 0;
    let databuf = Buffer2.from(data);
    for (const buf of buffer) {
      if (buf.byteLength !== 0) {
        databuf.copy(buf, 0, off2, off2 + buf.byteLength);
        off2 += buf.byteLength;
      }
    }
    callback(null, databuf.byteLength, buffer);
  }).catch((e3) => {
    let err3 = new Error(e3.message);
    err3.code = e3.code;
    callback(err3);
  });
}
readv[customPromisifyArgs] = ["bytesRead", "buffers"];
function readvSync(fd, buffer, position = -1) {
  validateInteger(fd, "fd");
  position = position ?? -1;
  validateInteger(position, "position");
  if (!buffer || !Array.isArray(buffer) || buffer.length > 0 && !isArrayBufferView2(buffer[0])) {
    throw new ERR_INVALID_ARG_TYPE("buffers", "ArrayBufferView[]", buffer);
  }
  let length = 0;
  for (const buf of buffer) {
    length += buf.byteLength;
  }
  if (length === 0) {
    return 0;
  }
  let data = binding2.freadSync(fd, position, length);
  let off2 = 0;
  for (const buf of buffer) {
    if (buf.byteLength !== 0) {
      buf.fill(data.slice(off2, off2 + buf.byteLength));
      off2 += buf.byteLength;
    }
  }
  return data.byteLength;
}
function fwrite2(fd, position, buffer) {
  let stat3 = null;
  try {
    stat3 = fstatSync(fd);
  } catch (err3) {
    return new Promise((res, rej) => {
      rej(err3);
    });
  }
  if (stat3.isFile()) {
    return new Promise((res, rej) => {
      try {
        res(binding2.fwriteSync(fd, position, buffer));
      } catch (e3) {
        rej(e3);
      }
    });
  } else {
    return binding2.fwrite(fd, position, buffer);
  }
}
function write(fd, buffer, offset, length, position, callback) {
  let oriStr = null;
  if (buffer === null || buffer === void 0) {
    throw new ERR_INVALID_ARG_TYPE("buffer", ["string", "Buffer", "DataView"], buffer);
  }
  if (typeof buffer === "string") {
    oriStr = buffer;
    if (typeof offset === "function") {
      callback = offset;
      position = -1;
      buffer = Buffer2.from(buffer);
    } else if (typeof length === "function") {
      callback = length;
      position = offset;
      buffer = Buffer2.from(buffer);
    } else {
      callback = position;
      position = offset;
      if (length === "hex" && buffer.length % 2 == 1) {
        throw new ERR_INVALID_ARG_VALUE_RANGE("encoding", length, `is invalid for data of length ${buffer.length}`);
      }
      buffer = Buffer2.from(buffer, length);
      position = -1;
    }
    offset = 0;
    length = buffer.byteLength - offset;
  } else if (typeof offset === "object") {
    callback = length;
    let option = offset;
    offset = (option && option.offset) ?? 0;
    validateInteger(offset, "offset", 0, buffer.byteLength);
    length = (option && option.length) ?? buffer.byteLength - offset;
    position = (option && option.position) ?? -1;
  } else if (typeof offset === "function") {
    callback = offset;
    offset = 0;
    length = buffer.byteLength - offset;
    position = -1;
  } else if (typeof position === "function") {
    callback = position;
    offset = offset ?? 0;
    length = length ?? buffer.byteLength - offset;
    position = -1;
  } else if (typeof length === "function") {
    callback = length;
    offset = offset ?? 0;
    validateInteger(offset, "offset", 0, buffer.byteLength);
    length = buffer.byteLength - offset;
    position = -1;
  }
  position = position ?? -1;
  if (isArrayBufferView2(buffer) && !(buffer instanceof Buffer2)) {
    buffer = Buffer2.from(buffer.buffer);
  }
  if (typeof buffer !== "string" && !(buffer instanceof Buffer2)) {
    throw new ERR_INVALID_ARG_TYPE("buffer", ["string", "Buffer", "DataView"], buffer);
  }
  validateFunction(callback, "callback");
  validateInteger(offset, "offset", 0, buffer.byteLength);
  validateInteger(position, "position");
  validateInteger(length, "length", 0, buffer.byteLength);
  validateInteger(fd, "fd");
  validateInteger(offset + length, "length + offset", 0, buffer.byteLength);
  fwrite2(fd, position, buffer.buffer.slice(offset, offset + length)).then((len) => {
    callback(null, len, buffer);
  }).catch((e3) => {
    callback(wasiFsSyscallErrorMap(e3, "write"));
  });
}
write[customPromisifyArgs] = ["bytesWritten", "buffer"];
function writeSync(fd, buffer, offset, length, position) {
  if (typeof buffer !== "string") {
    if (typeof buffer !== "object" || !(buffer instanceof Buffer2)) {
      throw new ERR_INVALID_ARG_TYPE("buffer", "buffer | string");
    }
  }
  let oriStr = null;
  if (typeof buffer === "string") {
    oriStr = buffer;
    let encoding2 = length ?? "utf8";
    if (encoding2 === "hex" && buffer.length % 2 == 1) {
      throw new ERR_INVALID_ARG_VALUE_RANGE("encoding", encoding2, `is invalid for data of length ${buffer.length}`);
    }
    buffer = Buffer2.from(buffer, encoding2);
    position = offset ?? -1;
    offset = 0;
    length = buffer.byteLength - offset;
  } else if (typeof offset === "object") {
    let option = offset;
    offset = (option && option.offset) ?? 0;
    length = (option && option.length) ?? buffer.byteLength - offset;
    position = (option && option.position) ?? -1;
  } else {
    offset = offset ?? 0;
    length = length ?? buffer.byteLength - offset;
    position = position ?? -1;
  }
  validateInteger(offset, "offset", 0, buffer.byteLength);
  validateInteger(position, "position");
  validateInteger(length, "length", 0, buffer.byteLength);
  validateInteger(fd, "fd");
  validateInteger(length + offset, "length + offset", 0, buffer.byteLength);
  try {
    let len = binding2.fwriteSync(fd, position, buffer.buffer.slice(offset, offset + length));
    return len;
  } catch (e3) {
    throw wasiFsSyscallErrorMap(e3, "write");
  }
}
function writeFile2(file, data, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options ?? {};
  if (typeof options === "string") {
    validateEncoding(options, "option.encoding");
    options = {
      encoding: options
    };
  } else {
    validateObject2(options, "option");
  }
  options = applyDefaultValue(options, {
    encoding: "utf8",
    mode: 438,
    flag: "w",
    signal: null
  });
  validateFunction(callback, "callback");
  if (typeof file === "string") {
    file = getValidatedPath(file);
  }
  let buffer = typeof data === "string" ? Buffer2.from(data, options.encoding) : data;
  if (!(buffer instanceof Buffer2) && (Object.prototype.toString.call(data).endsWith("Array]") || Object.prototype.toString.call(data) === "[object DataView]")) {
    let enc = new TextDecoder(options.encoding);
    buffer = Buffer2.from(enc.decode(data));
  }
  try {
    let fd;
    if (typeof file === "number") {
      fd = file;
    } else {
      fd = openSync(file, options.flag, options.mode);
    }
    write(fd, buffer, (err3) => {
      if (err3) {
        callback(err3);
      } else {
        callback(null);
      }
      if (typeof file !== "number") {
        closeSync(fd);
      }
    });
  } catch (err3) {
    callback(err3);
  }
}
function isAsyncIterable(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj[Symbol.asyncIterator] === "function";
}
function isIterable2(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj[Symbol.iterator] === "function";
}
function writeDataCheck(data) {
  let ok = data && (typeof data === "string" || isArrayBufferView2(data));
  if (!ok) {
    throw new ERR_INVALID_ARG_TYPE("data", ["string", "Buffer", "TypedArray", "DataView"], data);
  }
}
writeFile2[kCustomPromisifiedSymbol] = (file, data, options) => {
  let encoding2;
  if (typeof options === "string") {
    encoding2 = options;
  } else {
    encoding2 = options && options.encoding;
  }
  return new Promise(async (res, rej) => {
    try {
      if (!(typeof data === "string" || isArrayBufferView2(data))) {
        if (data instanceof readable_default || isAsyncIterable(data)) {
          const arr = [];
          for await (const i2 of data) {
            writeDataCheck(i2);
            if (typeof i2 === "string") {
              arr.push(Buffer2.from(i2, encoding2 ?? "utf8"));
            } else {
              arr.push(Buffer2.from(i2));
            }
          }
          data = Buffer2.concat(arr);
        } else if (isIterable2(data)) {
          const arr = [];
          for (const i2 of data) {
            writeDataCheck(i2);
            if (typeof i2 === "string") {
              arr.push(Buffer2.from(i2, encoding2 ?? "utf8"));
            } else {
              arr.push(Buffer2.from(i2));
            }
          }
          data = Buffer2.concat(arr);
        }
      }
      writeFile2(file, data, options, (err3) => {
        if (err3 !== null) {
          rej(err3);
        } else {
          res();
        }
      });
    } catch (err3) {
      rej(err3);
    }
  });
};
function writeFileSync(file, data, options = {}) {
  options = options ?? {};
  if (typeof options === "string") {
    validateEncoding(options, "option");
    options = {
      encoding: options
    };
  } else {
    validateObject2(options, "option");
  }
  options = applyDefaultValue(options, {
    encoding: "utf8",
    mode: 438,
    flag: "w",
    signal: null
  });
  let buffer = typeof data === "string" ? Buffer2.from(data, options.encoding) : data;
  if (!(buffer instanceof Buffer2) && (Object.prototype.toString.call(data).endsWith("Array]") || Object.prototype.toString.call(data) === "[object DataView]")) {
    let enc = new TextDecoder(options.encoding);
    buffer = Buffer2.from(enc.decode(data));
  } else if (!(buffer instanceof Buffer2) && data.toString !== void 0) {
    buffer = Buffer2.from(data.toString(), options.encoding);
  }
  let fd;
  if (typeof file === "number") {
    fd = file;
  } else {
    file = getValidatedPath(file);
    fd = openSync(file, options.flag, options.mode);
  }
  writeSync(fd, buffer);
  if (typeof file !== "number") {
    closeSync(fd);
  }
}
function appendFile(file, data, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  validateFunction(callback, "callback");
  if (typeof file !== "number") {
    file = getValidatedPath(file);
  }
  if (typeof options === "string") {
    options = {
      encoding: options
    };
  }
  options = applyDefaultValueAlsoNull(options ?? {}, {
    encoding: "utf8",
    mode: 438,
    flag: "a",
    signal: null
  });
  validateEncoding(options.encoding, "encoding");
  if (typeof data !== "string" && !(data instanceof Buffer2)) {
    throw new ERR_INVALID_ARG_TYPE("data", ["string", "buffer"]);
  }
  let buffer = typeof data === "string" ? Buffer2.from(data, options.encoding) : data;
  try {
    let fd = -1;
    if (typeof file === "number") {
      fd = file;
    } else {
      fd = openSync(file, options.flag, options.mode);
    }
    write(fd, buffer, (err3) => {
      if (err3) {
        callback(err3);
      } else {
        callback(null);
      }
      if (typeof file !== "number") {
        closeSync(fd);
      }
    });
  } catch (err3) {
    callback(err3);
  }
}
function appendFileSync(file, data, options = {}) {
  if (typeof options === "string") {
    options = {
      encoding: options
    };
  }
  options = applyDefaultValue(options ?? {}, {
    encoding: "utf8",
    mode: 438,
    flag: "a",
    signal: null
  });
  validateEncoding(options.encoding, "encoding");
  if (typeof data !== "string" && !(data instanceof Buffer2)) {
    throw new ERR_INVALID_ARG_TYPE("data", ["string", "buffer"]);
  }
  let fd = -1;
  if (typeof file === "number") {
    fd = file;
  } else {
    file = getValidatedPath(file);
    fd = openSync(file, options.flag, options.mode);
  }
  let buffer = typeof data === "string" ? Buffer2.from(data, options.encoding) : data;
  writeSync(fd, buffer);
  if (typeof file !== "number") {
    closeSync(fd);
  }
}
function isArrayBufferView2(value) {
  return value && value.buffer instanceof ArrayBuffer && value.byteLength !== void 0;
}
function writev(fd, buffer, position, callback) {
  if (typeof position === "function") {
    callback = position;
    position = -1;
  }
  position = position ?? -1;
  validateFunction(callback, "callback");
  validateInteger(position, "position");
  if (!buffer || !Array.isArray(buffer) || buffer.length > 0 && !isArrayBufferView2(buffer[0])) {
    throw new ERR_INVALID_ARG_TYPE("buffers", "ArrayBufferView[]", buffer);
  }
  validateInteger(fd, "fd");
  let length = 0;
  for (const buf of buffer) {
    length += buf.byteLength;
  }
  fwrite2(fd, position, Buffer2.concat(buffer).buffer).then((len) => {
    callback(null, len, buffer);
  }).catch((e3) => {
    callback(e3);
  });
}
writev[customPromisifyArgs] = ["bytesWritten", "buffers"];
function writevSync(fd, buffer, position = -1) {
  position = position ?? -1;
  validateInteger(position, "position");
  if (!buffer || !Array.isArray(buffer) || buffer.length > 0 && !isArrayBufferView2(buffer[0])) {
    throw new ERR_INVALID_ARG_TYPE("buffers", "ArrayBufferView[]", buffer);
  }
  validateInteger(fd, "fd");
  let length = 0;
  for (const buf of buffer) {
    length += buf.byteLength;
  }
  try {
    let len = binding2.fwriteSync(fd, position, Buffer2.concat(buffer).buffer);
    return len;
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "write");
  }
}
var FILETYPE_BLOCK_DEVICE = 1;
var FILETYPE_CHARACTER_DEVICE = 2;
var FILETYPE_DIRECTORY = 3;
var FILETYPE_REGULAR_FILE = 4;
var FILETYPE_SOCKET_DGRAM = 5;
var FILETYPE_SOCKET_STREAM = 6;
var FILETYPE_SYMBOLIC_LINK = 7;
var Dirent = class {
  constructor(innerData) {
    this.filetype = innerData.filetype;
    this.name = innerData.name;
  }
  isFile = () => this.filetype === FILETYPE_REGULAR_FILE;
  isDirectory = () => this.filetype === FILETYPE_DIRECTORY;
  isSymbolicLink = () => this.filetype === FILETYPE_SYMBOLIC_LINK;
  isBlockDevice = () => this.filetype === FILETYPE_BLOCK_DEVICE;
  isFIFO = () => false;
  isCharacterDevice = () => this.filetype === FILETYPE_CHARACTER_DEVICE;
  isSocket = () => this.filetype === FILETYPE_SOCKET_DGRAM || this.filetype === FILETYPE_SOCKET_STREAM;
};
var Dir = class {
  #fd = 0;
  constructor(fd, path2) {
    this.#fd = fd;
    this.path = path2;
  }
  #dataBuf = [];
  #idx = 0;
  #fin = false;
  #cookie = 0;
  #closed = false;
  #fetch() {
    if (this.#closed) {
      throw new ERR_DIR_CLOSED();
    }
    if (this.#idx === this.#dataBuf.length && !this.#fin) {
      try {
        let data = binding2.freaddirSync(this.#fd, this.#cookie);
        this.#dataBuf.push(...data.res.filter((d) => d.name !== "." && d.name !== ".."));
        this.#fin = data.fin;
        this.#cookie = data.cookie;
      } catch (err3) {
        let e3 = new Error(err3.message);
        e3.code = err3.code;
        throw e3;
      }
    }
    return !(this.#idx === this.#dataBuf.length && this.#fin);
  }
  close(callback) {
    if (callback) {
      validateFunction(callback, "callback");
      if (this.#closed) {
        callback(new ERR_DIR_CLOSED());
        return;
      }
      close(this.#fd, (...args2) => {
        this.#closed = true;
        callback(...args2);
      });
    } else {
      if (this.#closed) {
        return new Promise((_res, rej) => rej(new ERR_DIR_CLOSED()));
      }
      return promisify(close)(this.#fd).then(() => this.#closed = true);
    }
  }
  closeSync() {
    if (this.#closed) {
      throw new ERR_DIR_CLOSED();
    }
    if (this.#inReading) {
      throw new ERR_DIR_CONCURRENT_OPERATION();
    }
    closeSync(this.#fd);
    this.#closed = true;
  }
  #inReading = false;
  read(callback) {
    if (callback) {
      validateFunction(callback, "callback");
      this.#inReading = true;
      setTimeout(() => {
        try {
          if (!this.#fetch()) {
            callback(null, null);
          }
          this.#inReading = false;
          callback(null, new Dirent(this.#dataBuf[this.#idx++]));
        } catch (err3) {
          this.#inReading = false;
          callback(err3);
        }
      }, 0);
    } else {
      this.#inReading = true;
      return new Promise((resolve3, reject) => {
        setTimeout(() => {
          try {
            if (!this.#fetch()) {
              this.#inReading = false;
              resolve3(null);
              return;
            }
            this.#inReading = false;
            resolve3(new Dirent(this.#dataBuf[this.#idx++]));
          } catch (err3) {
            this.#inReading = false;
            reject(err3);
          }
        }, 0);
      });
    }
  }
  readSync() {
    if (this.#inReading) {
      throw new ERR_DIR_CONCURRENT_OPERATION();
    }
    if (!this.#fetch()) {
      return null;
    }
    return new Dirent(this.#dataBuf[this.#idx++]);
  }
  async *[Symbol.asyncIterator]() {
    try {
      let p3 = this.readSync();
      while (p3) {
        yield p3;
        p3 = this.readSync();
      }
    } finally {
      this.closeSync();
    }
  }
};
function opendir(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  path2 = getValidatedPath(path2);
  validateFunction(callback, "callback");
  if (options && options.bufferSize !== void 0) {
    validateInteger(options.bufferSize, "bufferSize", 1);
  }
  try {
    if (!statSync(path2).isDirectory()) {
      throw wasiFsSyscallErrorMap("NOTDIR", "opendir", path2);
    }
  } catch (err3) {
    callback(wasiFsSyscallErrorMap(err3, "opendir", path2));
    return;
  }
  setTimeout(() => {
    try {
      let fd = openSync(path2);
      callback(null, new Dir(fd, path2));
    } catch (err3) {
      callback(err3);
    }
  }, 0);
}
function opendirSync(path2, options) {
  path2 = getValidatedPath(path2);
  if (options && options.bufferSize !== void 0) {
    validateInteger(options.bufferSize, "bufferSize", 1);
  }
  try {
    if (!statSync(path2).isDirectory()) {
      throw wasiFsSyscallErrorMap("NOTDIR", "opendir", path2);
    }
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "opendir", path2);
  }
  let fd = openSync(path2);
  return new Dir(fd, path2);
}
function readdir(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  if (typeof options === "string") {
    options = {
      encoding: options
    };
  }
  options = applyDefaultValue(options, {
    encoding: "utf8",
    withFileTypes: false
  });
  validateEncoding(options.encoding, "encoding");
  path2 = getValidatedPath(path2);
  validateFunction(callback, "callback");
  setTimeout(async () => {
    try {
      let data = [];
      let dir = opendirSync(path2, { encoding: options.encoding });
      for await (const p3 of dir) {
        if (options.encoding === "buffer") {
          p3.name === Buffer2.from(p3.name);
        } else if (options.encoding !== "utf8") {
          p3.name = Buffer2.from(p3.name).toString(options.encoding);
        }
        data.push(options.withFileTypes ? p3 : p3.name);
      }
      callback(null, data);
    } catch (err3) {
      callback(wasiFsSyscallErrorMap(err3, "scandir", path2));
    }
  }, 0);
}
function readdirSync(path2, options) {
  path2 = getValidatedPath(path2);
  if (typeof options === "string") {
    options = {
      encoding: options
    };
  }
  options = applyDefaultValue(options ?? {}, {
    encoding: "utf8",
    withFileTypes: false
  });
  validateEncoding(options.encoding, "encoding");
  let data = [];
  try {
    let dir = opendirSync(path2);
    let p3 = dir.readSync();
    while (p3) {
      data.push(options.withFileTypes ? p3 : p3.name);
      p3 = dir.readSync();
    }
    return data;
  } catch (err3) {
    throw wasiFsSyscallErrorMap(err3, "scandir", path2);
  }
}
function watch() {
  throw new Error(`'watch' is unsupported`);
}
function unwatch() {
  throw new Error(`'unwatch' is unsupported`);
}
function watchFile() {
  throw new Error(`'watchFile' is unsupported`);
}
function getOwnPropertyValueOrDefault(options, key, defaultValue) {
  return options == null || !Object.prototype.hasOwnProperty(options, key) ? defaultValue : options[key];
}
var validateObject2 = hideStackFrames(
  (value, name, options = null) => {
    const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
    const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
    const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
      throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
  }
);
var defaultCpOptions = {
  dereference: false,
  errorOnExist: false,
  filter: void 0,
  force: true,
  preserveTimestamps: false,
  recursive: false,
  verbatimSymlinks: false
};
var validateCpOptions = hideStackFrames((options) => {
  if (options === void 0)
    return { ...defaultCpOptions };
  validateObject2(options, "options");
  options = { ...defaultCpOptions, ...options };
  validateBoolean(options.dereference, "options.dereference");
  validateBoolean(options.errorOnExist, "options.errorOnExist");
  validateBoolean(options.force, "options.force");
  validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
  validateBoolean(options.recursive, "options.recursive");
  validateBoolean(options.verbatimSymlinks, "options.verbatimSymlinks");
  if (options.dereference === true && options.verbatimSymlinks === true) {
    throw new ERR_INCOMPATIBLE_OPTION_PAIR("dereference", "verbatimSymlinks");
  }
  if (options.filter !== void 0) {
    validateFunction(options.filter, "options.filter");
  }
  return options;
});
function cpSync(src, dest, options) {
  options = validateCpOptions(options);
  src = getValidatedPath(src, "src");
  dest = getValidatedPath(dest, "dest");
  cp_sync_default(src, dest, options);
}
function cp(src, dest, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = void 0;
  }
  callback = makeCallback(callback);
  options = validateCpOptions(options);
  src = getValidatedPath(src, "src");
  dest = getValidatedPath(dest, "dest");
  cpFn(src, dest, options).then((_val, err3) => {
    callback(err3 === void 0 ? null : err3);
  }).catch((err3) => {
    callback(err3);
  });
}
var FileHandle = class extends events_default {
  #fd = -1;
  #path = "";
  constructor(fd, path2) {
    super();
    this.#fd = fd;
    this.#path = path2;
  }
  // for test-fs-promises-file-handle-close-error can re-define property
  get fd() {
    return this.#fd;
  }
  async appendFile(data, options) {
    return await promisify(appendFile)(this.fd, data, options);
  }
  async chown() {
    return void 0;
  }
  async close() {
    if (this.#fd === -1) {
      return;
    }
    this.emit("close");
    return await promisify(close)(this.#fd).then(() => {
      this.#fd = -1;
    });
  }
  async createReadStream(options) {
    return createReadStream(this.#path, options);
  }
  async createWriteStream(options) {
    return createWriteStream(this.#path, options);
  }
  async datasync() {
    return await promisify(fdatasync)(this.fd);
  }
  async read(...args2) {
    if (args2.length === 3) {
      args2.push(-1);
    }
    return await promisify(read)(this.fd, ...args2);
  }
  async readFile(options) {
    let errs = [];
    try {
      return await promisify(readFile2)(this.fd, options);
    } catch (err3) {
      errs.push(err3);
      try {
        await this.close();
      } catch (err22) {
        errs.push(err22);
      }
    }
    if (errs.length == 1) {
      throw errs[0];
    } else if (errs.length > 1) {
      throw new AggregateError(errs);
    }
  }
  async readv(buffers, position) {
    return await promisify(readv)(this.fd, buffers, position);
  }
  async stat(options) {
    return await promisify(fstat)(this.fd, options);
  }
  async sync() {
    return await promisify(fsync)(this.fd);
  }
  async truncate(len) {
    let errs = [];
    try {
      return await promisify(ftruncate)(this.fd, len);
    } catch (err3) {
      errs.push(err3);
      try {
        await this.close();
      } catch (err22) {
        errs.push(err22);
      }
    }
    if (errs.length == 1) {
      throw errs[0];
    } else if (errs.length > 1) {
      throw new AggregateError(errs);
    }
  }
  utimes(atime, mtime) {
    return promisify(futimes)(this.fd, atime, mtime);
  }
  write(...args2) {
    return promisify(write)(this.fd, ...args2);
  }
  async writeFile(data, options) {
    let errs = [];
    try {
      return await promisify(writeFile2)(this.fd, data, options);
    } catch (err3) {
      errs.push(err3);
      try {
        await this.close();
      } catch (err22) {
        errs.push(err22);
      }
    }
    if (errs.length == 1) {
      throw errs[0];
    } else if (errs.length > 1) {
      throw new AggregateError(errs);
    }
  }
  writev(buffers, position) {
    return promisify(writev)(this.fd, buffers, position);
  }
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/internal/fs/utils.js
var kType = Symbol("type");
var kStats = Symbol("stats");
var isWindows = false;
var {
  F_OK: F_OK3 = 0,
  W_OK: W_OK2 = 0,
  R_OK: R_OK2 = 0,
  X_OK: X_OK2 = 0,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
  O_APPEND,
  O_CREAT,
  O_EXCL,
  O_RDONLY,
  O_RDWR,
  O_SYNC,
  O_TRUNC,
  O_WRONLY,
  S_IFBLK,
  S_IFCHR,
  S_IFDIR,
  S_IFIFO,
  S_IFLNK,
  S_IFMT,
  S_IFREG,
  S_IFSOCK,
  UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION,
  UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE,
  UV_DIRENT_DIR,
  UV_DIRENT_LINK,
  UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK
} = fs;
var {
  errno: {
    EISDIR: EISDIR3
  }
} = os;
var kMinimumAccessMode2 = Math.min(F_OK3, W_OK2, R_OK2, X_OK2);
var kMaximumAccessMode2 = F_OK3 | W_OK2 | R_OK2 | X_OK2;
var kDefaultCopyMode2 = 0;
var kMinimumCopyMode2 = Math.min(
  kDefaultCopyMode2,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE
);
var kMaximumCopyMode2 = COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE;
var kIoMaxLength = 2 ** 31 - 1;
var kReadFileUnknownBufferLength = 64 * 1024;
var kReadFileBufferLength = 512 * 1024;
var kWriteFileMaxChunkSize = 512 * 1024;
var kMaxUserId = 2 ** 32 - 1;
var Dirent2 = class {
  constructor(name, type) {
    this.name = name;
    this[kType] = type;
  }
  isDirectory() {
    return this[kType] === UV_DIRENT_DIR;
  }
  isFile() {
    return this[kType] === UV_DIRENT_FILE;
  }
  isBlockDevice() {
    return this[kType] === UV_DIRENT_BLOCK;
  }
  isCharacterDevice() {
    return this[kType] === UV_DIRENT_CHAR;
  }
  isSymbolicLink() {
    return this[kType] === UV_DIRENT_LINK;
  }
  isFIFO() {
    return this[kType] === UV_DIRENT_FIFO;
  }
  isSocket() {
    return this[kType] === UV_DIRENT_SOCKET;
  }
};
var DirentFromStats = class extends Dirent2 {
  constructor(name, stats) {
    super(name, null);
    this[kStats] = stats;
  }
};
for (const name of Reflect.ownKeys(Dirent2.prototype)) {
  if (name === "constructor") {
    continue;
  }
  DirentFromStats.prototype[name] = function() {
    return this[kStats][name]();
  };
}
var bufferSep = Buffer2.from(sep ?? "/");
var nullCheck = hideStackFrames(
  (path2, propName, throwError3 = true) => {
    const pathIsString = typeof path2 === "string";
    const pathIsUint8Array = isUint8Array(path2);
    if (!pathIsString && !pathIsUint8Array || pathIsString && !path2.includes("\0") || pathIsUint8Array && !path2.includes(0)) {
      return;
    }
    const err3 = new ERR_INVALID_ARG_VALUE(
      propName,
      path2,
      "must be a string or Uint8Array without null bytes"
    );
    if (throwError3) {
      throw err3;
    }
    return err3;
  }
);
function StatsBase(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
}
StatsBase.prototype.isDirectory = function() {
  return this._checkModeProperty(S_IFDIR);
};
StatsBase.prototype.isFile = function() {
  return this._checkModeProperty(S_IFREG);
};
StatsBase.prototype.isBlockDevice = function() {
  return this._checkModeProperty(S_IFBLK);
};
StatsBase.prototype.isCharacterDevice = function() {
  return this._checkModeProperty(S_IFCHR);
};
StatsBase.prototype.isSymbolicLink = function() {
  return this._checkModeProperty(S_IFLNK);
};
StatsBase.prototype.isFIFO = function() {
  return this._checkModeProperty(S_IFIFO);
};
StatsBase.prototype.isSocket = function() {
  return this._checkModeProperty(S_IFSOCK);
};
var kNsPerMsBigInt = 10n ** 6n;
var kNsPerSecBigInt = 10n ** 9n;
var kMsPerSec = 10 ** 3;
var kNsPerMs = 10 ** 6;
function dateFromMs(ms) {
  return new Date(Number(ms) + 0.5);
}
function BigIntStats2(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {
  Reflect.apply(StatsBase, this, [
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks
  ]);
  this.atimeMs = atimeNs / kNsPerMsBigInt;
  this.mtimeMs = mtimeNs / kNsPerMsBigInt;
  this.ctimeMs = ctimeNs / kNsPerMsBigInt;
  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
  this.atimeNs = atimeNs;
  this.mtimeNs = mtimeNs;
  this.ctimeNs = ctimeNs;
  this.birthtimeNs = birthtimeNs;
  this.atime = dateFromMs(this.atimeMs);
  this.mtime = dateFromMs(this.mtimeMs);
  this.ctime = dateFromMs(this.ctimeMs);
  this.birthtime = dateFromMs(this.birthtimeMs);
}
Object.setPrototypeOf(BigIntStats2.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats2, StatsBase);
BigIntStats2.prototype._checkModeProperty = function(property) {
  if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
    return false;
  }
  return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};
function Stats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
  StatsBase.call(
    this,
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks
  );
  this.atimeMs = atimeMs;
  this.mtimeMs = mtimeMs;
  this.ctimeMs = ctimeMs;
  this.birthtimeMs = birthtimeMs;
  this.atime = dateFromMs(atimeMs);
  this.mtime = dateFromMs(mtimeMs);
  this.ctime = dateFromMs(ctimeMs);
  this.birthtime = dateFromMs(birthtimeMs);
}
Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);
Stats.prototype.isFile = StatsBase.prototype.isFile;
Stats.prototype._checkModeProperty = function(property) {
  if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
    return false;
  }
  return (this.mode & S_IFMT) === property;
};
function stringToFlags(flags, name = "flags") {
  if (typeof flags === "number") {
    validateInt32(flags, name);
    return flags;
  }
  if (flags == null) {
    return O_RDONLY;
  }
  switch (flags) {
    case "r":
      return O_RDONLY;
    case "rs":
    // Fall through.
    case "sr":
      return O_RDONLY | O_SYNC;
    case "r+":
      return O_RDWR;
    case "rs+":
    // Fall through.
    case "sr+":
      return O_RDWR | O_SYNC;
    case "w":
      return O_TRUNC | O_CREAT | O_WRONLY;
    case "wx":
    // Fall through.
    case "xw":
      return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
    case "w+":
      return O_TRUNC | O_CREAT | O_RDWR;
    case "wx+":
    // Fall through.
    case "xw+":
      return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
    case "a":
      return O_APPEND | O_CREAT | O_WRONLY;
    case "ax":
    // Fall through.
    case "xa":
      return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
    case "as":
    // Fall through.
    case "sa":
      return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;
    case "a+":
      return O_APPEND | O_CREAT | O_RDWR;
    case "ax+":
    // Fall through.
    case "xa+":
      return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
    case "as+":
    // Fall through.
    case "sa+":
      return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
  }
  throw new ERR_INVALID_ARG_VALUE("flags", flags);
}
var stringToSymlinkType = hideStackFrames((type) => {
  let flags = 0;
  if (typeof type === "string") {
    switch (type) {
      case "dir":
        flags |= UV_FS_SYMLINK_DIR;
        break;
      case "junction":
        flags |= UV_FS_SYMLINK_JUNCTION;
        break;
      case "file":
        break;
      default:
        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
    }
  }
  return flags;
});
var validateOffsetLengthRead = hideStackFrames(
  (offset, length, bufferLength) => {
    if (offset < 0) {
      throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
    }
    if (length < 0) {
      throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    if (offset + length > bufferLength) {
      throw new ERR_OUT_OF_RANGE(
        "length",
        `<= ${bufferLength - offset}`,
        length
      );
    }
  }
);
var validateOffsetLengthWrite = hideStackFrames(
  (offset, length, byteLength) => {
    if (offset > byteLength) {
      throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength}`, offset);
    }
    if (length > byteLength - offset) {
      throw new ERR_OUT_OF_RANGE("length", `<= ${byteLength - offset}`, length);
    }
    if (length < 0) {
      throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    validateInt32(length, "length", 0);
  }
);
var validatePath = hideStackFrames((path2, propName = "path") => {
  if (typeof path2 !== "string" && !isUint8Array(path2)) {
    throw new ERR_INVALID_ARG_TYPE(propName, ["string", "Buffer", "URL"], path2);
  }
  const err3 = nullCheck(path2, propName, false);
  if (err3 !== void 0) {
    throw err3;
  }
});
var getValidatedPath = hideStackFrames(
  (fileURLOrPath, propName = "path") => {
    const path2 = toPathIfFileURL(fileURLOrPath);
    validatePath(path2, propName);
    return typeof path2 === "string" ? path2 : path2.toString();
  }
);
var getValidatedFd = hideStackFrames((fd, propName = "fd") => {
  if (Object.is(fd, -0)) {
    return 0;
  }
  validateInt32(fd, propName, 0);
  return fd;
});
var validateBufferArray = hideStackFrames(
  (buffers, propName = "buffers") => {
    if (!Array.isArray(buffers)) {
      throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
    }
    for (let i2 = 0; i2 < buffers.length; i2++) {
      if (!isArrayBufferView(buffers[i2])) {
        throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
      }
    }
    return buffers;
  }
);
var defaultCpOptions2 = {
  dereference: false,
  errorOnExist: false,
  filter: void 0,
  force: true,
  preserveTimestamps: false,
  recursive: false
};
var defaultRmOptions = {
  recursive: false,
  force: false,
  retryDelay: 100,
  maxRetries: 0
};
var defaultRmdirOptions = {
  retryDelay: 100,
  maxRetries: 0,
  recursive: false
};
var validateCpOptions2 = hideStackFrames((options) => {
  if (options === void 0) {
    return { ...defaultCpOptions2 };
  }
  validateObject(options, "options");
  options = { ...defaultCpOptions2, ...options };
  validateBoolean(options.dereference, "options.dereference");
  validateBoolean(options.errorOnExist, "options.errorOnExist");
  validateBoolean(options.force, "options.force");
  validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
  validateBoolean(options.recursive, "options.recursive");
  if (options.filter !== void 0) {
    validateFunction(options.filter, "options.filter");
  }
  return options;
});
var validateRmOptions = hideStackFrames(
  (path2, options, expectDir, cb) => {
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    stat(path2, (err3, stats) => {
      if (err3) {
        if (options.force && err3.code === "ENOENT") {
          return cb(null, options);
        }
        return cb(err3, options);
      }
      if (expectDir && !stats.isDirectory()) {
        return cb(false);
      }
      if (stats.isDirectory() && !options.recursive) {
        return cb(
          new ERR_FS_EISDIR({
            code: "EISDIR",
            message: "is a directory",
            path: path2,
            syscall: "rm",
            errno: EISDIR3
          })
        );
      }
      return cb(null, options);
    });
  }
);
var validateRmOptionsSync = hideStackFrames(
  (path2, options, expectDir) => {
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    if (!options.force || expectDir || !options.recursive) {
      const isDirectory = statSync(path2, { throwIfNoEntry: !options.force })?.isDirectory();
      if (expectDir && !isDirectory) {
        return false;
      }
      if (isDirectory && !options.recursive) {
        throw new ERR_FS_EISDIR({
          code: "EISDIR",
          message: "is a directory",
          path: path2,
          syscall: "rm",
          errno: EISDIR3
        });
      }
    }
    return options;
  }
);
var validateRmdirOptions = hideStackFrames(
  (options, defaults = defaultRmdirOptions) => {
    if (options === void 0) {
      return defaults;
    }
    validateObject(options, "options");
    options = { ...defaults, ...options };
    validateBoolean(options.recursive, "options.recursive");
    validateInt32(options.retryDelay, "options.retryDelay", 0);
    validateUint32(options.maxRetries, "options.maxRetries");
    return options;
  }
);
var getValidMode2 = hideStackFrames((mode, type) => {
  let min2 = kMinimumAccessMode2;
  let max = kMaximumAccessMode2;
  let def = F_OK3;
  if (type === "copyFile") {
    min2 = kMinimumCopyMode2;
    max = kMaximumCopyMode2;
    def = mode || kDefaultCopyMode2;
  } else {
    assert3(type === "access");
  }
  if (mode == null) {
    return def;
  }
  if (Number.isInteger(mode) && mode >= min2 && mode <= max) {
    return mode;
  }
  if (typeof mode !== "number") {
    throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode);
  }
  throw new ERR_OUT_OF_RANGE(
    "mode",
    `an integer >= ${min2} && <= ${max}`,
    mode
  );
});
var validateStringAfterArrayBufferView = hideStackFrames(
  (buffer, name) => {
    if (typeof buffer === "string") {
      return;
    }
    if (typeof buffer === "object" && buffer !== null && typeof buffer.toString === "function" && Object.prototype.hasOwnProperty.call(buffer, "toString")) {
      return;
    }
    throw new ERR_INVALID_ARG_TYPE(
      name,
      ["string", "Buffer", "TypedArray", "DataView"],
      buffer
    );
  }
);
var validatePosition = hideStackFrames((position) => {
  if (typeof position === "number") {
    validateInteger(position, "position");
  } else if (typeof position === "bigint") {
    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
      throw new ERR_OUT_OF_RANGE(
        "position",
        `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`,
        position
      );
    }
  } else {
    throw new ERR_INVALID_ARG_TYPE("position", ["integer", "bigint"], position);
  }
});
var realpathCacheKey = Symbol("realpathCacheKey");
var showStringCoercionDeprecation = deprecate(
  () => {
  },
  "Implicit coercion of objects with own toString property is deprecated.",
  "DEP0162"
);
var validateEncoding = hideStackFrames((value, name) => {
  let exist = [
    "utf8",
    "utf-8",
    "",
    "hex",
    "base64",
    "latin1",
    "usc2",
    "utf16le",
    "ascii",
    "base64url"
  ].indexOf(value);
  if (exist < 0) {
    throw new ERR_INVALID_ARG_VALUE(name, value);
  }
});

// ../../../../../../node_modules/wasmedge_quickjs/modules/path.js
var exports$12 = {};
var _dewExec2 = false;
function dew2() {
  if (_dewExec2) {
    return exports$12;
  }
  _dewExec2 = true;
  var process$1 = process2;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new ERR_INVALID_ARG_TYPE("path", "string", path2);
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length) {
        code = path2.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) ;
        else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += "/" + path2.slice(lastSlash + 1, i2);
          } else {
            res = path2.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base2;
    }
    if (dir === pathObject.root) {
      return dir + base2;
    }
    return dir + sep2 + base2;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var arguments$1 = arguments;
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        var path2;
        if (i2 >= 0) {
          path2 = arguments$1[i2];
        } else {
          if (cwd2 === void 0) {
            cwd2 = process$1.cwd();
          }
          path2 = cwd2;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) {
          return "/" + resolvedPath;
        } else {
          return "/";
        }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0) {
        return ".";
      }
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) {
        path2 = ".";
      }
      if (path2.length > 0 && trailingSeparator) {
        path2 += "/";
      }
      if (isAbsolute2) {
        return "/" + path2;
      }
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join3() {
      var arguments$1 = arguments;
      if (arguments.length === 0) {
        return ".";
      }
      var joined;
      for (var i2 = 0; i2 < arguments.length; ++i2) {
        var arg = arguments$1[i2];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += "/" + arg;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) {
        return "";
      }
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to) {
        return "";
      }
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) {
          break;
        }
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) {
          break;
        }
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i2 = 0;
      for (; i2 <= length; ++i2) {
        if (i2 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i2) === 47) {
              return to.slice(toStart + i2 + 1);
            } else if (i2 === 0) {
              return to.slice(toStart + i2);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i2) === 47) {
              lastCommonSep = i2;
            } else if (i2 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i2);
        var toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === 47) {
          lastCommonSep = i2;
        }
      }
      var out = "";
      for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
        if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "/..";
          }
        }
      }
      if (out.length > 0) {
        return out + to.slice(toStart + lastCommonSep);
      } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) {
          ++toStart;
        }
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0) {
        return ".";
      }
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i2 = path2.length - 1; i2 >= 1; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            end = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", "string", ext);
      }
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i2;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) {
          return "";
        }
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          var code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i2;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path2.length;
        }
        return path2.slice(start, end);
      } else {
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
        }
        if (end === -1) {
          return "";
        }
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i2 = path2.length - 1; i2 >= 0; --i2) {
        var code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format3(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", "object", pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse4(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0) {
        return ret;
      }
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i2 = path2.length - 1;
      var preDotState = 0;
      for (; i2 >= start; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) {
            ret.base = ret.name = path2.slice(1, end);
          } else {
            ret.base = ret.name = path2.slice(startPart, end);
          }
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) {
        ret.dir = path2.slice(0, startPart - 1);
      } else if (isAbsolute2) {
        ret.dir = "/";
      }
      return ret;
    },
    toNamespacedPath: (val) => val,
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports$12 = posix2;
  return exports$12;
}
var exports2 = dew2();
var _makeLong = exports2._makeLong;
var basename = exports2.basename;
var delimiter2 = exports2.delimiter;
var dirname = exports2.dirname;
var extname = exports2.extname;
var format = exports2.format;
var isAbsolute = exports2.isAbsolute;
var join2 = exports2.join;
var normalize = exports2.normalize;
var parse2 = exports2.parse;
var posix = exports2.posix;
var relative = exports2.relative;
var resolve = exports2.resolve;
var sep = exports2.sep;
var win32 = exports2.win32;
var toNamespacedPath = exports2.toNamespacedPath;

// ../../../../../../node_modules/wasmedge_quickjs/modules/util.js
init_buffer();

// ../../../../../../node_modules/wasmedge_quickjs/modules/encoding.js
import { text_encode, text_decode, text_encode_into } from "_encoding";
function isError(e3) {
  return isObject(e3) && (objectToString(e3) === "[object Error]" || e3 instanceof Error);
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isUndefined(arg) {
  return arg === void 0;
}
var TextEncoder4 = class {
  get encoding() {
    return "utf-8";
  }
  encode(input2) {
    let arr = text_encode(input2, "utf-8");
    if (isUndefined(arr)) {
      return new Uint8Array();
    } else {
      return new Uint8Array(arr);
    }
  }
  encodeInto(src, dest) {
    if (dest instanceof Uint8Array) {
      return text_encode_into(src, "utf8", dest.buffer, dest.byteOffset);
    } else {
      throw new TypeError('The "dest" argument must be an instance of Uint8Array.');
    }
  }
};
var TextDecoder4 = class {
  #encoding = "utf-8";
  #fatal = void 0;
  #ignoreBOM = void 0;
  constructor(encoding2, options) {
    let { fatal, ignoreBOM } = options || {};
    this.#fatal = fatal ? true : false;
    this.#ignoreBOM = ignoreBOM;
    encoding2 = encoding2 || "utf-8";
    let exist = [
      "utf8",
      "utf-8",
      "gbk",
      "gb18030",
      "hz-gb-2312",
      "big5",
      "euc-jp",
      "iso-2022-jp",
      "utf-16be",
      "utf-16le",
      "x-user-defined",
      "ibm866",
      "iso-8859-2",
      "iso-8859-3",
      "iso-8859-4",
      "iso-8859-5",
      "iso-8859-6",
      "iso-8859-7",
      "iso-8859-8",
      "iso-8859-8i",
      "iso-8859-10",
      "iso-8859-13",
      "iso-8859-14",
      "iso-8859-15",
      "iso-8859-16",
      "windows-874",
      "windows-1250",
      "windows-1251",
      "windows-1252",
      "windows-1253",
      "windows-1254",
      "windows-1255",
      "windows-1256",
      "windows-1257",
      "windows-1258",
      ""
    ].indexOf(encoding2);
    if (exist < 0) {
      throw new RangeError(`The "${encoding2}" encoding is not supported`);
    } else {
      this.#encoding = encoding2;
    }
  }
  get encoding() {
    return this.#encoding;
  }
  get fatal() {
    return this.#fatal;
  }
  decode(input2) {
    if (typeof input2 != "undefined") {
      let ret;
      if (input2.buffer instanceof ArrayBuffer) {
        ret = text_decode(input2.buffer, this.encoding, this.fatal);
      } else if (input2 instanceof ArrayBuffer) {
        ret = text_decode(input2, this.encoding, this.fatal);
      }
      if (isError(ret)) {
        throw new TypeError(`The encoded data was not valid for encoding ${this.encoding}`);
      }
      return ret;
    }
    throw new TypeError('The "input" argument must be an instance of ArrayBuffer or ArrayBufferView.');
  }
};
globalThis.TextDecoder = TextDecoder4;
globalThis.TextEncoder = TextEncoder4;

// ../../../../../../node_modules/wasmedge_quickjs/modules/util.js
var debuglog2 = debuglog;
var promisify2 = promisify;
var deprecate2 = deprecate;
var NodeFalsyValueRejectionError = class extends Error {
  reason;
  code = "ERR_FALSY_VALUE_REJECTION";
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError = class extends TypeError {
  code = "ERR_INVALID_ARG_TYPE";
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
  }
};
function callbackify(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError('"original"');
  }
  const callbackified = function(_this, ...args2) {
    const maybeCb = args2.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError("last");
    }
    const cb = (...args3) => {
      maybeCb.apply(_this, args3);
    };
    original.apply(_this, args2).then(
      (ret) => {
        nextTick(cb.bind(_this, null, ret));
      },
      (rej) => {
        rej = rej || new NodeFalsyValueRejectionError(rej);
        nextTick(cb.bind(_this, rej));
      }
    );
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function isUndefined2(value) {
  return value === void 0;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}
function isError2(e3) {
  return e3 instanceof Error;
}
function isFunction(value) {
  return typeof value === "function";
}
function isRegExp2(value) {
  return types_default.isRegExp(value);
}
function isDate2(value) {
  return types_default.isDate(value);
}
function isPrimitive(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer(value) {
  return Buffer2.isBuffer(value);
}
function _extend(target, source) {
  if (source === null || typeof source !== "object") return target;
  const keys = Object.keys(source);
  let i2 = keys.length;
  while (i2--) {
    target[keys[i2]] = source[keys[i2]];
  }
  return target;
}
function inherits(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new ERR_INVALID_ARG_TYPE(
      "superCtor.prototype",
      "Object",
      superCtor.prototype
    );
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
var TextDecoder5 = TextDecoder4;
var TextEncoder5 = TextEncoder4;
function pad(n5) {
  return n5.toString().padStart(2, "0");
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  const d = /* @__PURE__ */ new Date();
  const t2 = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return `${d.getDate()} ${months[d.getMonth()]} ${t2}`;
}
function log2(...args2) {
  console.log(timestamp(), "-", ...args2);
}
var util_default = {
  isArray,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isSymbol,
  isUndefined: isUndefined2,
  isObject: isObject2,
  isError: isError2,
  isFunction,
  isRegExp: isRegExp2,
  isDate: isDate2,
  isPrimitive,
  isBuffer,
  _extend,
  deprecate: deprecate2,
  callbackify,
  promisify: promisify2,
  inherits,
  types: types_default,
  TextDecoder: TextDecoder5,
  TextEncoder: TextEncoder5,
  log: log2,
  debuglog: debuglog2
};

// ../../../../../../node_modules/wasmedge_quickjs/modules/whatwg_url.js
var urlStateMachine = { exports: {} };
function isASCIIDigit(c2) {
  return c2 >= 48 && c2 <= 57;
}
function isASCIIAlpha(c2) {
  return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
}
function isASCIIAlphanumeric(c2) {
  return isASCIIAlpha(c2) || isASCIIDigit(c2);
}
function isASCIIHex$1(c2) {
  return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
}
var infra = {
  isASCIIDigit,
  isASCIIAlpha,
  isASCIIAlphanumeric,
  isASCIIHex: isASCIIHex$1
};
var ref$3 = util_default;
var TextEncoder6 = ref$3.TextEncoder;
var TextDecoder6 = ref$3.TextDecoder;
var utf8Encoder = new TextEncoder6();
var utf8Decoder = new TextDecoder6("utf-8", { ignoreBOM: true });
function utf8Encode$2(string) {
  return utf8Encoder.encode(string);
}
function utf8DecodeWithoutBOM$1(bytes4) {
  return utf8Decoder.decode(bytes4);
}
var encoding = {
  utf8Encode: utf8Encode$2,
  utf8DecodeWithoutBOM: utf8DecodeWithoutBOM$1
};
var ref$2 = infra;
var isASCIIHex = ref$2.isASCIIHex;
var ref$1$1 = encoding;
var utf8Encode$1 = ref$1$1.utf8Encode;
function p$1(char) {
  return char.codePointAt(0);
}
function percentEncode(c2) {
  var hex = c2.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = "0" + hex;
  }
  return "%" + hex;
}
function percentDecodeBytes$1(input2) {
  var output3 = new Uint8Array(input2.byteLength);
  var outputIndex = 0;
  for (var i2 = 0; i2 < input2.byteLength; ++i2) {
    var byte = input2[i2];
    if (byte !== 37) {
      output3[outputIndex++] = byte;
    } else if (byte === 37 && (!isASCIIHex(input2[i2 + 1]) || !isASCIIHex(input2[i2 + 2]))) {
      output3[outputIndex++] = byte;
    } else {
      var bytePoint = parseInt(String.fromCodePoint(input2[i2 + 1], input2[i2 + 2]), 16);
      output3[outputIndex++] = bytePoint;
      i2 += 2;
    }
  }
  return output3.slice(0, outputIndex);
}
function percentDecodeString(input2) {
  var bytes4 = utf8Encode$1(input2);
  return percentDecodeBytes$1(bytes4);
}
function isC0ControlPercentEncode(c2) {
  return c2 <= 31 || c2 > 126;
}
var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p$1(" "), p$1('"'), p$1("<"), p$1(">"), p$1("`")]);
function isFragmentPercentEncode(c2) {
  return isC0ControlPercentEncode(c2) || extraFragmentPercentEncodeSet.has(c2);
}
var extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p$1(" "), p$1('"'), p$1("#"), p$1("<"), p$1(">")]);
function isQueryPercentEncode(c2) {
  return isC0ControlPercentEncode(c2) || extraQueryPercentEncodeSet.has(c2);
}
function isSpecialQueryPercentEncode(c2) {
  return isQueryPercentEncode(c2) || c2 === p$1("'");
}
var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p$1("?"), p$1("`"), p$1("{"), p$1("}")]);
function isPathPercentEncode(c2) {
  return isQueryPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
}
var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p$1("/"), p$1(":"), p$1(";"), p$1("="), p$1("@"), p$1("["), p$1("\\"), p$1("]"), p$1("^"), p$1("|")]);
function isUserinfoPercentEncode(c2) {
  return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
}
var extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p$1("$"), p$1("%"), p$1("&"), p$1("+"), p$1(",")]);
function isComponentPercentEncode(c2) {
  return isUserinfoPercentEncode(c2) || extraComponentPercentEncodeSet.has(c2);
}
var extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p$1("!"), p$1("'"), p$1("("), p$1(")"), p$1("~")]);
function isURLEncodedPercentEncode$1(c2) {
  return isComponentPercentEncode(c2) || extraURLEncodedPercentEncodeSet.has(c2);
}
function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
  var bytes4 = utf8Encode$1(codePoint);
  var output3 = "";
  for (var byte of bytes4) {
    if (!percentEncodePredicate(byte)) {
      output3 += String.fromCharCode(byte);
    } else {
      output3 += percentEncode(byte);
    }
  }
  return output3;
}
function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
  return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
}
function utf8PercentEncodeString$1(input2, percentEncodePredicate, spaceAsPlus) {
  if (spaceAsPlus === void 0) spaceAsPlus = false;
  var output3 = "";
  for (var codePoint of input2) {
    if (spaceAsPlus && codePoint === " ") {
      output3 += "+";
    } else {
      output3 += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
    }
  }
  return output3;
}
var percentEncoding = {
  isC0ControlPercentEncode,
  isFragmentPercentEncode,
  isQueryPercentEncode,
  isSpecialQueryPercentEncode,
  isPathPercentEncode,
  isUserinfoPercentEncode,
  isURLEncodedPercentEncode: isURLEncodedPercentEncode$1,
  percentDecodeString,
  percentDecodeBytes: percentDecodeBytes$1,
  utf8PercentEncodeString: utf8PercentEncodeString$1,
  utf8PercentEncodeCodePoint
};
(function(module) {
  var ref2 = punycode_default;
  var toASCII2 = ref2.toASCII;
  var infra$1 = infra;
  var ref$12 = encoding;
  var utf8DecodeWithoutBOM2 = ref$12.utf8DecodeWithoutBOM;
  var ref$22 = percentEncoding;
  var percentDecodeString2 = ref$22.percentDecodeString;
  var utf8PercentEncodeCodePoint2 = ref$22.utf8PercentEncodeCodePoint;
  var utf8PercentEncodeString2 = ref$22.utf8PercentEncodeString;
  var isC0ControlPercentEncode2 = ref$22.isC0ControlPercentEncode;
  var isFragmentPercentEncode2 = ref$22.isFragmentPercentEncode;
  var isQueryPercentEncode2 = ref$22.isQueryPercentEncode;
  var isSpecialQueryPercentEncode2 = ref$22.isSpecialQueryPercentEncode;
  var isPathPercentEncode2 = ref$22.isPathPercentEncode;
  var isUserinfoPercentEncode2 = ref$22.isUserinfoPercentEncode;
  function p3(char) {
    return char.codePointAt(0);
  }
  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  function countSymbols(str) {
    return str.length;
  }
  function at(input2, idx) {
    var c2 = input2[idx];
    return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
  }
  function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp22) {
    return infra$1.isASCIIAlpha(cp1) && (cp22 === p3(":") || cp22 === p3("|"));
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && infra$1.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && infra$1.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\0|\t|\n|\r| |#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/) !== -1;
  }
  function containsForbiddenDomainCodePoint(string) {
    return containsForbiddenHostCodePoint(string) || string.search(/[\0-\x1F]|%|\x7F/) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== void 0;
  }
  function isSpecial(url2) {
    return isSpecialScheme(url2.scheme);
  }
  function isNotSpecial(url2) {
    return !isSpecialScheme(url2.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function parseIPv4Number(input2) {
    if (input2 === "") {
      return failure;
    }
    var R = 10;
    if (input2.length >= 2 && input2.charAt(0) === "0" && input2.charAt(1).toLowerCase() === "x") {
      input2 = input2.substring(2);
      R = 16;
    } else if (input2.length >= 2 && input2.charAt(0) === "0") {
      input2 = input2.substring(1);
      R = 8;
    }
    if (input2 === "") {
      return 0;
    }
    var regex = /(?:[\0-\/8-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    if (R === 10) {
      regex = /(?:[\0-\/:-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    }
    if (R === 16) {
      regex = /(?:[\0-\/:-@G-`g-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    }
    if (regex.test(input2)) {
      return failure;
    }
    return parseInt(input2, R);
  }
  function parseIPv4(input2) {
    var parts = input2.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return failure;
    }
    var numbers = [];
    for (var part of parts) {
      var n5 = parseIPv4Number(part);
      if (n5 === failure) {
        return failure;
      }
      numbers.push(n5);
    }
    for (var i2 = 0; i2 < numbers.length - 1; ++i2) {
      if (numbers[i2] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    var ipv4 = numbers.pop();
    var counter = 0;
    for (var n$1 of numbers) {
      ipv4 += n$1 * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    var output3 = "";
    var n5 = address;
    for (var i2 = 1; i2 <= 4; ++i2) {
      output3 = String(n5 % 256) + output3;
      if (i2 !== 4) {
        output3 = "." + output3;
      }
      n5 = Math.floor(n5 / 256);
    }
    return output3;
  }
  function parseIPv6(input2) {
    var address = [0, 0, 0, 0, 0, 0, 0, 0];
    var pieceIndex = 0;
    var compress = null;
    var pointer = 0;
    input2 = Array.from(input2, function(c2) {
      return c2.codePointAt(0);
    });
    if (input2[pointer] === p3(":")) {
      if (input2[pointer + 1] !== p3(":")) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input2.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input2[pointer] === p3(":")) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      var value = 0;
      var length = 0;
      while (length < 4 && infra$1.isASCIIHex(input2[pointer])) {
        value = value * 16 + parseInt(at(input2, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input2[pointer] === p3(".")) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        var numbersSeen = 0;
        while (input2[pointer] !== void 0) {
          var ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input2[pointer] === p3(".") && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!infra$1.isASCIIDigit(input2[pointer])) {
            return failure;
          }
          while (infra$1.isASCIIDigit(input2[pointer])) {
            var number3 = parseInt(at(input2, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number3;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number3;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input2[pointer] === p3(":")) {
        ++pointer;
        if (input2[pointer] === void 0) {
          return failure;
        }
      } else if (input2[pointer] !== void 0) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      var swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        var temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    var output3 = "";
    var compress = findLongestZeroSequence(address);
    var ignore0 = false;
    for (var pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        var separator = pieceIndex === 0 ? "::" : ":";
        output3 += separator;
        ignore0 = true;
        continue;
      }
      output3 += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output3 += ":";
      }
    }
    return output3;
  }
  function parseHost(input2, isNotSpecialArg) {
    if (isNotSpecialArg === void 0) isNotSpecialArg = false;
    if (input2[0] === "[") {
      if (input2[input2.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input2.substring(1, input2.length - 1));
    }
    if (isNotSpecialArg) {
      return parseOpaqueHost(input2);
    }
    var domain3 = utf8DecodeWithoutBOM2(percentDecodeString2(input2));
    var asciiDomain = domainToASCII(domain3);
    if (asciiDomain === failure) {
      return failure;
    }
    if (containsForbiddenDomainCodePoint(asciiDomain)) {
      return failure;
    }
    if (endsInANumber(asciiDomain)) {
      return parseIPv4(asciiDomain);
    }
    return asciiDomain;
  }
  function endsInANumber(input2) {
    var parts = input2.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length === 1) {
        return false;
      }
      parts.pop();
    }
    var last = parts[parts.length - 1];
    if (parseIPv4Number(last) !== failure) {
      return true;
    }
    if (/^[0-9]+$/.test(last)) {
      return true;
    }
    return false;
  }
  function parseOpaqueHost(input2) {
    if (containsForbiddenHostCodePoint(input2)) {
      return failure;
    }
    return utf8PercentEncodeString2(input2, isC0ControlPercentEncode2);
  }
  function findLongestZeroSequence(arr) {
    var maxIdx = null;
    var maxLen = 1;
    var currStart = null;
    var currLen = 0;
    for (var i2 = 0; i2 < arr.length; ++i2) {
      if (arr[i2] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i2;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      return currStart;
    }
    return maxIdx;
  }
  function serializeHost(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  }
  function domainToASCII(domain3, _beStrict) {
    var result2 = toASCII2(domain3);
    if (result2 === null || result2 === "") {
      return failure;
    }
    return result2;
  }
  function trimControlChars(url2) {
    return url2.replace(/^[\0- ]+|[\0- ]+$/g, "");
  }
  function trimTabAndNewline(url2) {
    return url2.replace(/\t|\n|\r/g, "");
  }
  function shortenPath(url2) {
    var path2 = url2.path;
    if (path2.length === 0) {
      return;
    }
    if (url2.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
      return;
    }
    path2.pop();
  }
  function includesCredentials(url2) {
    return url2.username !== "" || url2.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url2) {
    return url2.host === null || url2.host === "" || url2.scheme === "file";
  }
  function hasAnOpaquePath(url2) {
    return typeof url2.path === "string";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
  }
  function URLStateMachine(input2, base2, encodingOverride, url2, stateOverride) {
    this.pointer = 0;
    this.input = input2;
    this.base = base2 || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url2;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      var res$1 = trimControlChars(this.input);
      if (res$1 !== this.input) {
        this.parseError = true;
      }
      this.input = res$1;
    }
    var res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(this.input, function(c3) {
      return c3.codePointAt(0);
    });
    for (; this.pointer <= this.input.length; ++this.pointer) {
      var c2 = this.input[this.pointer];
      var cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
      var ret = this["parse " + this.state](c2, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
    if (infra$1.isASCIIAlpha(c2)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
    if (infra$1.isASCIIAlphanumeric(c2) || c2 === p3("+") || c2 === p3("-") || c2 === p3(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c2 === p3(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p3("/") || this.input[this.pointer + 2] !== p3("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p3("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = "";
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
    if (this.base === null || hasAnOpaquePath(this.base) && c2 !== p3("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c2 === p3("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
    if (c2 === p3("/") && this.input[this.pointer + 1] === p3("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
    if (c2 === p3("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
    this.url.scheme = this.base.scheme;
    if (c2 === p3("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c2 === p3("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c2 === p3("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === p3("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c2)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
    if (isSpecial(this.url) && (c2 === p3("/") || c2 === p3("\\"))) {
      if (c2 === p3("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c2 === p3("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
    if (c2 === p3("/") && this.input[this.pointer + 1] === p3("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
    if (c2 !== p3("/") && c2 !== p3("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
    if (c2 === p3("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      var len = countSymbols(this.buffer);
      for (var pointer = 0; pointer < len; ++pointer) {
        var codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === p3(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        var encodedCodePoints = utf8PercentEncodeCodePoint2(codePoint, isUserinfoPercentEncode2);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c2) || c2 === p3("/") || c2 === p3("?") || c2 === p3("#") || isSpecial(this.url) && c2 === p3("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c2 === p3(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      var host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c2) || c2 === p3("/") || c2 === p3("?") || c2 === p3("#") || isSpecial(this.url) && c2 === p3("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      var host$1 = parseHost(this.buffer, isNotSpecial(this.url));
      if (host$1 === failure) {
        return failure;
      }
      this.url.host = host$1;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c2 === p3("[")) {
        this.arrFlag = true;
      } else if (c2 === p3("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
    if (infra$1.isASCIIDigit(c2)) {
      this.buffer += cStr;
    } else if (isNaN(c2) || c2 === p3("/") || c2 === p3("?") || c2 === p3("#") || isSpecial(this.url) && c2 === p3("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        var port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p3("/"), p3("\\"), p3("?"), p3("#")]);
  function startsWithWindowsDriveLetter(input2, pointer) {
    var length = input2.length - pointer;
    return length >= 2 && isWindowsDriveLetterCodePoints(input2[pointer], input2[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input2[pointer + 2]));
  }
  URLStateMachine.prototype["parse file"] = function parseFile(c2) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c2 === p3("/") || c2 === p3("\\")) {
      if (c2 === p3("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c2 === p3("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === p3("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c2)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
    if (c2 === p3("/") || c2 === p3("\\")) {
      if (c2 === p3("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
    if (isNaN(c2) || c2 === p3("/") || c2 === p3("\\") || c2 === p3("?") || c2 === p3("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        var host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
    if (isSpecial(this.url)) {
      if (c2 === p3("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c2 !== p3("/") && c2 !== p3("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c2 === p3("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c2 === p3("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c2 !== void 0) {
      this.state = "path";
      if (c2 !== p3("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c2) {
    if (isNaN(c2) || c2 === p3("/") || isSpecial(this.url) && c2 === p3("\\") || !this.stateOverride && (c2 === p3("?") || c2 === p3("#"))) {
      if (isSpecial(this.url) && c2 === p3("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c2 !== p3("/") && !(isSpecial(this.url) && c2 === p3("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c2 !== p3("/") && !(isSpecial(this.url) && c2 === p3("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c2 === p3("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c2 === p3("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c2 === p3("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint2(c2, isPathPercentEncode2);
    }
    return true;
  };
  URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c2) {
    if (c2 === p3("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c2 === p3("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c2) && c2 !== p3("%")) {
        this.parseError = true;
      }
      if (c2 === p3("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c2)) {
        this.url.path += utf8PercentEncodeCodePoint2(c2, isC0ControlPercentEncode2);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c2 === p3("#") || isNaN(c2)) {
      var queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode2 : isQueryPercentEncode2;
      this.url.query += utf8PercentEncodeString2(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c2 === p3("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c2)) {
      if (c2 === p3("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
    if (!isNaN(c2)) {
      if (c2 === p3("%") && (!infra$1.isASCIIHex(this.input[this.pointer + 1]) || !infra$1.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint2(c2, isFragmentPercentEncode2);
    }
    return true;
  };
  function serializeURL(url2, excludeFragment) {
    var output3 = url2.scheme + ":";
    if (url2.host !== null) {
      output3 += "//";
      if (url2.username !== "" || url2.password !== "") {
        output3 += url2.username;
        if (url2.password !== "") {
          output3 += ":" + url2.password;
        }
        output3 += "@";
      }
      output3 += serializeHost(url2.host);
      if (url2.port !== null) {
        output3 += ":" + url2.port;
      }
    }
    if (url2.host === null && !hasAnOpaquePath(url2) && url2.path.length > 1 && url2.path[0] === "") {
      output3 += "/.";
    }
    output3 += serializePath(url2);
    if (url2.query !== null) {
      output3 += "?" + url2.query;
    }
    if (!excludeFragment && url2.fragment !== null) {
      output3 += "#" + url2.fragment;
    }
    return output3;
  }
  function serializeOrigin(tuple) {
    var result2 = tuple.scheme + "://";
    result2 += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result2 += ":" + tuple.port;
    }
    return result2;
  }
  function serializePath(url2) {
    if (hasAnOpaquePath(url2)) {
      return url2.path;
    }
    var output3 = "";
    for (var segment of url2.path) {
      output3 += "/" + segment;
    }
    return output3;
  }
  module.exports.serializeURL = serializeURL;
  module.exports.serializePath = serializePath;
  module.exports.serializeURLOrigin = function(url2) {
    switch (url2.scheme) {
      case "blob":
        try {
          return module.exports.serializeURLOrigin(module.exports.parseURL(serializePath(url2)));
        } catch (e3) {
          return "null";
        }
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url2.scheme,
          host: url2.host,
          port: url2.port
        });
      case "file":
        return "null";
      default:
        return "null";
    }
  };
  module.exports.basicURLParse = function(input2, options) {
    if (options === void 0) {
      options = {};
    }
    var usm2 = new URLStateMachine(input2, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm2.failure) {
      return null;
    }
    return usm2.url;
  };
  module.exports.setTheUsername = function(url2, username) {
    url2.username = utf8PercentEncodeString2(username, isUserinfoPercentEncode2);
  };
  module.exports.setThePassword = function(url2, password) {
    url2.password = utf8PercentEncodeString2(password, isUserinfoPercentEncode2);
  };
  module.exports.serializeHost = serializeHost;
  module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  module.exports.hasAnOpaquePath = hasAnOpaquePath;
  module.exports.serializeInteger = function(integer) {
    return String(integer);
  };
  module.exports.parseURL = function(input2, options) {
    if (options === void 0) {
      options = {};
    }
    return module.exports.basicURLParse(input2, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
})(urlStateMachine);
var ref = encoding;
var utf8Encode = ref.utf8Encode;
var utf8DecodeWithoutBOM = ref.utf8DecodeWithoutBOM;
var ref$1 = percentEncoding;
var percentDecodeBytes = ref$1.percentDecodeBytes;
var utf8PercentEncodeString = ref$1.utf8PercentEncodeString;
var isURLEncodedPercentEncode = ref$1.isURLEncodedPercentEncode;
function p(char) {
  return char.codePointAt(0);
}
function parseUrlencoded(input2) {
  var sequences = strictlySplitByteSequence(input2, p("&"));
  var output3 = [];
  for (var bytes4 of sequences) {
    if (bytes4.length === 0) {
      continue;
    }
    var name = void 0, value = void 0;
    var indexOfEqual = bytes4.indexOf(p("="));
    if (indexOfEqual >= 0) {
      name = bytes4.slice(0, indexOfEqual);
      value = bytes4.slice(indexOfEqual + 1);
    } else {
      name = bytes4;
      value = new Uint8Array(0);
    }
    name = replaceByteInByteSequence(name, 43, 32);
    value = replaceByteInByteSequence(value, 43, 32);
    var nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
    var valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
    output3.push([nameString, valueString]);
  }
  return output3;
}
function parseUrlencodedString(input2) {
  return parseUrlencoded(utf8Encode(input2));
}
function serializeUrlencoded(tuples, encodingOverride) {
  if (encodingOverride === void 0) encodingOverride = void 0;
  var encoding2 = "utf-8";
  if (encodingOverride !== void 0) {
    encoding2 = encodingOverride;
  }
  var output3 = "";
  for (var [i2, tuple] of tuples.entries()) {
    var name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
    var value = tuple[1];
    if (tuple.length > 2 && tuple[2] !== void 0) {
      if (tuple[2] === "hidden" && name === "_charset_") {
        value = encoding2;
      } else if (tuple[2] === "file") {
        value = value.name;
      }
    }
    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);
    if (i2 !== 0) {
      output3 += "&";
    }
    output3 += name + "=" + value;
  }
  return output3;
}
function strictlySplitByteSequence(buf, cp3) {
  var list = [];
  var last = 0;
  var i2 = buf.indexOf(cp3);
  while (i2 >= 0) {
    list.push(buf.slice(last, i2));
    last = i2 + 1;
    i2 = buf.indexOf(cp3, last);
  }
  if (last !== buf.length) {
    list.push(buf.slice(last));
  }
  return list;
}
function replaceByteInByteSequence(buf, from, to) {
  var i2 = buf.indexOf(from);
  while (i2 >= 0) {
    buf[i2] = to;
    i2 = buf.indexOf(from, i2 + 1);
  }
  return buf;
}
var urlencoded$2 = {
  parseUrlencodedString,
  serializeUrlencoded
};
var urlencoded$1 = urlencoded$2;
var URLSearchParams$1 = /* @__PURE__ */ function() {
  function URLSearchParams3(constructorArgs, ref2) {
    var doNotStripQMark = ref2.doNotStripQMark;
    if (doNotStripQMark === void 0) doNotStripQMark = false;
    var init6 = constructorArgs[0];
    this._list = [];
    this._url = null;
    if (!doNotStripQMark && typeof init6 === "string" && init6[0] === "?") {
      init6 = init6.slice(1);
    }
    if (Array.isArray(init6)) {
      for (var pair of init6) {
        if (pair.length !== 2) {
          throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
        }
        this._list.push([pair[0], pair[1]]);
      }
    } else if (typeof init6 === "object" && Object.getPrototypeOf(init6) === null) {
      for (var name of Object.keys(init6)) {
        var value = init6[name];
        this._list.push([name, value]);
      }
    } else {
      this._list = urlencoded$1.parseUrlencodedString(init6);
    }
  }
  URLSearchParams3.prototype._updateSteps = function _updateSteps() {
    if (this._url !== null) {
      var query3 = urlencoded$1.serializeUrlencoded(this._list);
      if (query3 === "") {
        query3 = null;
      }
      this._url._url.query = query3;
    }
  };
  URLSearchParams3.prototype.append = function append(name, value) {
    this._list.push([name, value]);
    this._updateSteps();
  };
  URLSearchParams3.prototype.delete = function delete$1(name) {
    var i2 = 0;
    while (i2 < this._list.length) {
      if (this._list[i2][0] === name) {
        this._list.splice(i2, 1);
      } else {
        i2++;
      }
    }
    this._updateSteps();
  };
  URLSearchParams3.prototype.get = function get(name) {
    for (var tuple of this._list) {
      if (tuple[0] === name) {
        return tuple[1];
      }
    }
    return null;
  };
  URLSearchParams3.prototype.getAll = function getAll(name) {
    var output3 = [];
    for (var tuple of this._list) {
      if (tuple[0] === name) {
        output3.push(tuple[1]);
      }
    }
    return output3;
  };
  URLSearchParams3.prototype.has = function has(name) {
    for (var tuple of this._list) {
      if (tuple[0] === name) {
        return true;
      }
    }
    return false;
  };
  URLSearchParams3.prototype.set = function set(name, value) {
    var found = false;
    var i2 = 0;
    while (i2 < this._list.length) {
      if (this._list[i2][0] === name) {
        if (found) {
          this._list.splice(i2, 1);
        } else {
          found = true;
          this._list[i2][1] = value;
          i2++;
        }
      } else {
        i2++;
      }
    }
    if (!found) {
      this._list.push([name, value]);
    }
    this._updateSteps();
  };
  URLSearchParams3.prototype.sort = function sort() {
    this._list.sort(function(a2, b4) {
      if (a2[0] < b4[0]) {
        return -1;
      }
      if (a2[0] > b4[0]) {
        return 1;
      }
      return 0;
    });
    this._updateSteps();
  };
  URLSearchParams3.prototype[Symbol.iterator] = function() {
    return this._list[Symbol.iterator]();
  };
  URLSearchParams3.prototype.toString = function toString4() {
    return urlencoded$1.serializeUrlencoded(this._list);
  };
  return URLSearchParams3;
}();
var usm = urlStateMachine.exports;
var urlencoded = urlencoded$2;
var URLSearchParams2 = URLSearchParams$1;
var URL2 = /* @__PURE__ */ function() {
  function URL4(url2, base2) {
    var parsedBase = null;
    if (base2 !== void 0) {
      parsedBase = usm.basicURLParse(base2);
      if (parsedBase === null) {
        throw new TypeError("Invalid base URL: " + base2);
      }
    }
    var parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
    if (parsedURL === null) {
      throw new TypeError("Invalid URL: " + url2);
    }
    var query3 = parsedURL.query !== null ? parsedURL.query : "";
    this._url = parsedURL;
    this._query = new URLSearchParams2([query3], { doNotStripQMark: true });
    this._query._url = this;
  }
  var prototypeAccessors = { href: { configurable: true }, origin: { configurable: true }, protocol: { configurable: true }, username: { configurable: true }, password: { configurable: true }, host: { configurable: true }, hostname: { configurable: true }, port: { configurable: true }, pathname: { configurable: true }, search: { configurable: true }, searchParams: { configurable: true }, hash: { configurable: true } };
  prototypeAccessors.href.get = function() {
    return usm.serializeURL(this._url);
  };
  prototypeAccessors.href.set = function(v2) {
    var parsedURL = usm.basicURLParse(v2);
    if (parsedURL === null) {
      throw new TypeError("Invalid URL: " + v2);
    }
    this._url = parsedURL;
    this._query._list.splice(0);
    var query3 = parsedURL.query;
    if (query3 !== null) {
      this._query._list = urlencoded.parseUrlencodedString(query3);
    }
  };
  prototypeAccessors.origin.get = function() {
    return usm.serializeURLOrigin(this._url);
  };
  prototypeAccessors.protocol.get = function() {
    return this._url.scheme + ":";
  };
  prototypeAccessors.protocol.set = function(v2) {
    usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
  };
  prototypeAccessors.username.get = function() {
    return this._url.username;
  };
  prototypeAccessors.username.set = function(v2) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }
    usm.setTheUsername(this._url, v2);
  };
  prototypeAccessors.password.get = function() {
    return this._url.password;
  };
  prototypeAccessors.password.set = function(v2) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }
    usm.setThePassword(this._url, v2);
  };
  prototypeAccessors.host.get = function() {
    var url2 = this._url;
    if (url2.host === null) {
      return "";
    }
    if (url2.port === null) {
      return usm.serializeHost(url2.host);
    }
    return usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port);
  };
  prototypeAccessors.host.set = function(v2) {
    if (usm.hasAnOpaquePath(this._url)) {
      return;
    }
    usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
  };
  prototypeAccessors.hostname.get = function() {
    if (this._url.host === null) {
      return "";
    }
    return usm.serializeHost(this._url.host);
  };
  prototypeAccessors.hostname.set = function(v2) {
    if (usm.hasAnOpaquePath(this._url)) {
      return;
    }
    usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
  };
  prototypeAccessors.port.get = function() {
    if (this._url.port === null) {
      return "";
    }
    return usm.serializeInteger(this._url.port);
  };
  prototypeAccessors.port.set = function(v2) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }
    if (v2 === "") {
      this._url.port = null;
    } else {
      usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
    }
  };
  prototypeAccessors.pathname.get = function() {
    return usm.serializePath(this._url);
  };
  prototypeAccessors.pathname.set = function(v2) {
    if (usm.hasAnOpaquePath(this._url)) {
      return;
    }
    this._url.path = [];
    usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
  };
  prototypeAccessors.search.get = function() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }
    return "?" + this._url.query;
  };
  prototypeAccessors.search.set = function(v2) {
    var url2 = this._url;
    if (v2 === "") {
      url2.query = null;
      this._query._list = [];
      return;
    }
    var input2 = v2[0] === "?" ? v2.substring(1) : v2;
    url2.query = "";
    usm.basicURLParse(input2, { url: url2, stateOverride: "query" });
    this._query._list = urlencoded.parseUrlencodedString(input2);
  };
  prototypeAccessors.searchParams.get = function() {
    return this._query;
  };
  prototypeAccessors.hash.get = function() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }
    return "#" + this._url.fragment;
  };
  prototypeAccessors.hash.set = function(v2) {
    if (v2 === "") {
      this._url.fragment = null;
      return;
    }
    var input2 = v2[0] === "#" ? v2.substring(1) : v2;
    this._url.fragment = "";
    usm.basicURLParse(input2, { url: this._url, stateOverride: "fragment" });
  };
  URL4.prototype.toJSON = function toJSON() {
    return this.href;
  };
  Object.defineProperties(URL4.prototype, prototypeAccessors);
  return URL4;
}();

// ../../../../../../node_modules/wasmedge_quickjs/modules/url.js
var h = {};
var e2 = punycode_exports;
var a = {
  isString: function(t2) {
    return "string" == typeof t2;
  },
  isObject: function(t2) {
    return "object" == typeof t2 && null !== t2;
  },
  isNull: function(t2) {
    return null === t2;
  },
  isNullOrUndefined: function(t2) {
    return null == t2;
  }
};
function r2() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
h.parse = O;
h.resolve = function(t2, s) {
  return O(t2, false, true).resolve(s);
};
h.resolveObject = function(t2, s) {
  return t2 ? O(t2, false, true).resolveObject(s) : s;
};
h.format = function(t2) {
  a.isString(t2) && (t2 = O(t2));
  return t2 instanceof r2 ? t2.format() : r2.prototype.format.call(t2);
};
h.Url = r2;
var o2 = /^([a-z0-9.+-]+:)/i;
var n2 = /:[0-9]*$/;
var i = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
var p2 = ["'"].concat(l);
var c = ["%", "/", "?", ";", "#"].concat(p2);
var u = ["/", "?", "#"];
var f = /^[+a-z0-9A-Z_-]{0,63}$/;
var m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var v = { javascript: true, "javascript:": true };
var g = { javascript: true, "javascript:": true };
var y = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
var b = querystring_exports;
function O(t2, s, h2) {
  if (t2 && a.isObject(t2) && t2 instanceof r2) {
    return t2;
  }
  var e3 = new r2();
  return e3.parse(t2, s, h2), e3;
}
r2.prototype.parse = function(t2, s, h2) {
  if (!a.isString(t2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof t2);
  }
  var r3 = t2.indexOf("?");
  var n5 = -1 !== r3 && r3 < t2.indexOf("#") ? "?" : "#";
  var l2 = t2.split(n5);
  l2[0] = l2[0].replace(/\\/g, "/");
  var O2 = t2 = l2.join(n5);
  if (O2 = O2.trim(), !h2 && 1 === t2.split("#").length) {
    var d = i.exec(O2);
    if (d) {
      return this.path = O2, this.href = O2, this.pathname = d[1], d[2] ? (this.search = d[2], this.query = s ? b.parse(this.search.substr(1)) : this.search.substr(1)) : s && (this.search = "", this.query = {}), this;
    }
  }
  var j = o2.exec(O2);
  if (j) {
    var q = (j = j[0]).toLowerCase();
    this.protocol = q;
    O2 = O2.substr(j.length);
  }
  if (h2 || j || O2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var x = "//" === O2.substr(0, 2);
    !x || j && g[j] || (O2 = O2.substr(2), this.slashes = true);
  }
  if (!g[j] && (x || j && !y[j])) {
    for (var A, C, I = -1, w = 0; w < u.length; w++) {
      -1 !== (N5 = O2.indexOf(u[w])) && (-1 === I || N5 < I) && (I = N5);
    }
    -1 !== (C = -1 === I ? O2.lastIndexOf("@") : O2.lastIndexOf("@", I)) && (A = O2.slice(0, C), O2 = O2.slice(C + 1), this.auth = decodeURIComponent(A));
    I = -1;
    for (w = 0; w < c.length; w++) {
      var N5;
      -1 !== (N5 = O2.indexOf(c[w])) && (-1 === I || N5 < I) && (I = N5);
    }
    -1 === I && (I = O2.length), this.host = O2.slice(0, I), O2 = O2.slice(I);
    this.parseHost();
    this.hostname = this.hostname || "";
    var U = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
    if (!U) {
      for (var k = this.hostname.split(/\./), S3 = (w = 0, k.length); w < S3; w++) {
        var R = k[w];
        if (R && !R.match(f)) {
          for (var $ = "", z = 0, H = R.length; z < H; z++) {
            R.charCodeAt(z) > 127 ? $ += "x" : $ += R[z];
          }
          if (!$.match(f)) {
            var L = k.slice(0, w), Z = k.slice(w + 1), _ = R.match(m);
            _ && (L.push(_[1]), Z.unshift(_[2])), Z.length && (O2 = "/" + Z.join(".") + O2);
            this.hostname = L.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase();
    U || (this.hostname = e2.toASCII(this.hostname));
    var E = this.port ? ":" + this.port : "";
    P = this.hostname || "";
    this.host = P + E, this.href += this.host;
    U && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O2[0] && (O2 = "/" + O2));
  }
  if (!v[q]) {
    for (w = 0, S3 = p2.length; w < S3; w++) {
      var T = p2[w];
      if (-1 !== O2.indexOf(T)) {
        var B = encodeURIComponent(T);
        B === T && (B = escape(T)), O2 = O2.split(T).join(B);
      }
    }
  }
  var D = O2.indexOf("#");
  -1 !== D && (this.hash = O2.substr(D), O2 = O2.slice(0, D));
  var F2 = O2.indexOf("?");
  if (-1 !== F2 ? (this.search = O2.substr(F2), this.query = O2.substr(F2 + 1), s && (this.query = b.parse(this.query)), O2 = O2.slice(0, F2)) : s && (this.search = "", this.query = {}), O2 && (this.pathname = O2), y[q] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    E = this.pathname || "";
    var G = this.search || "";
    this.path = E + G;
  }
  return this.href = this.format(), this;
};
r2.prototype.format = function() {
  var t2 = this.auth || "";
  t2 && (t2 = (t2 = encodeURIComponent(t2)).replace(/%3A/i, ":"), t2 += "@");
  var s = this.protocol || "", h2 = this.pathname || "", e3 = this.hash || "", r3 = false, o3 = "";
  this.host ? r3 = t2 + this.host : this.hostname && (r3 = t2 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r3 += ":" + this.port)), this.query && a.isObject(this.query) && Object.keys(this.query).length && (o3 = b.stringify(this.query));
  var n5 = this.search || o3 && "?" + o3 || "";
  return s && ":" !== s.substr(-1) && (s += ":"), this.slashes || (!s || y[s]) && false !== r3 ? (r3 = "//" + (r3 || ""), h2 && "/" !== h2.charAt(0) && (h2 = "/" + h2)) : r3 || (r3 = ""), e3 && "#" !== e3.charAt(0) && (e3 = "#" + e3), n5 && "?" !== n5.charAt(0) && (n5 = "?" + n5), s + r3 + (h2 = h2.replace(/[?#]/g, function(t3) {
    return encodeURIComponent(t3);
  })) + (n5 = n5.replace("#", "%23")) + e3;
};
r2.prototype.resolve = function(t2) {
  return this.resolveObject(O(t2, false, true)).format();
};
r2.prototype.resolveObject = function(t2) {
  if (a.isString(t2)) {
    var s = new r2();
    s.parse(t2, false, true), t2 = s;
  }
  for (var h2 = new r2(), e3 = Object.keys(this), o3 = 0; o3 < e3.length; o3++) {
    var n5 = e3[o3];
    h2[n5] = this[n5];
  }
  if (h2.hash = t2.hash, "" === t2.href) {
    return h2.href = h2.format(), h2;
  }
  if (t2.slashes && !t2.protocol) {
    for (var i2 = Object.keys(t2), l2 = 0; l2 < i2.length; l2++) {
      var p3 = i2[l2];
      "protocol" !== p3 && (h2[p3] = t2[p3]);
    }
    return y[h2.protocol] && h2.hostname && !h2.pathname && (h2.path = h2.pathname = "/"), h2.href = h2.format(), h2;
  }
  if (t2.protocol && t2.protocol !== h2.protocol) {
    if (!y[t2.protocol]) {
      for (var c2 = Object.keys(t2), u2 = 0; u2 < c2.length; u2++) {
        var f4 = c2[u2];
        h2[f4] = t2[f4];
      }
      return h2.href = h2.format(), h2;
    }
    if (h2.protocol = t2.protocol, t2.host || g[t2.protocol]) {
      h2.pathname = t2.pathname;
    } else {
      for (var m2 = (t2.pathname || "").split("/"); m2.length && !(t2.host = m2.shift()); ) {
      }
      t2.host || (t2.host = "");
      t2.hostname || (t2.hostname = "");
      "" !== m2[0] && m2.unshift("");
      m2.length < 2 && m2.unshift("");
      h2.pathname = m2.join("/");
    }
    if (h2.search = t2.search, h2.query = t2.query, h2.host = t2.host || "", h2.auth = t2.auth, h2.hostname = t2.hostname || t2.host, h2.port = t2.port, h2.pathname || h2.search) {
      var v2 = h2.pathname || "", b4 = h2.search || "";
      h2.path = v2 + b4;
    }
    return h2.slashes = h2.slashes || t2.slashes, h2.href = h2.format(), h2;
  }
  var O2 = h2.pathname && "/" === h2.pathname.charAt(0), d = t2.host || t2.pathname && "/" === t2.pathname.charAt(0), j = d || O2 || h2.host && t2.pathname, q = j, x = h2.pathname && h2.pathname.split("/") || [], A = (m2 = t2.pathname && t2.pathname.split("/") || [], h2.protocol && !y[h2.protocol]);
  if (A && (h2.hostname = "", h2.port = null, h2.host && ("" === x[0] ? x[0] = h2.host : x.unshift(h2.host)), h2.host = "", t2.protocol && (t2.hostname = null, t2.port = null, t2.host && ("" === m2[0] ? m2[0] = t2.host : m2.unshift(t2.host)), t2.host = null), j = j && ("" === m2[0] || "" === x[0])), d) {
    h2.host = t2.host || "" === t2.host ? t2.host : h2.host, h2.hostname = t2.hostname || "" === t2.hostname ? t2.hostname : h2.hostname, h2.search = t2.search, h2.query = t2.query, x = m2;
  } else if (m2.length) {
    x || (x = []), x.pop(), x = x.concat(m2), h2.search = t2.search, h2.query = t2.query;
  } else if (!a.isNullOrUndefined(t2.search)) {
    if (A) {
      h2.hostname = h2.host = x.shift(), (U = !!(h2.host && h2.host.indexOf("@") > 0) && h2.host.split("@")) && (h2.auth = U.shift(), h2.host = h2.hostname = U.shift());
    }
    return h2.search = t2.search, h2.query = t2.query, a.isNull(h2.pathname) && a.isNull(h2.search) || (h2.path = (h2.pathname ? h2.pathname : "") + (h2.search ? h2.search : "")), h2.href = h2.format(), h2;
  }
  if (!x.length) {
    return h2.pathname = null, h2.search ? h2.path = "/" + h2.search : h2.path = null, h2.href = h2.format(), h2;
  }
  for (var C = x.slice(-1)[0], I = (h2.host || t2.host || x.length > 1) && ("." === C || ".." === C) || "" === C, w = 0, N5 = x.length; N5 >= 0; N5--) {
    "." === (C = x[N5]) ? x.splice(N5, 1) : ".." === C ? (x.splice(N5, 1), w++) : w && (x.splice(N5, 1), w--);
  }
  if (!j && !q) {
    for (; w--; w) {
      x.unshift("..");
    }
  }
  !j || "" === x[0] || x[0] && "/" === x[0].charAt(0) || x.unshift(""), I && "/" !== x.join("/").substr(-1) && x.push("");
  var U, k = "" === x[0] || x[0] && "/" === x[0].charAt(0);
  A && (h2.hostname = h2.host = k ? "" : x.length ? x.shift() : "", (U = !!(h2.host && h2.host.indexOf("@") > 0) && h2.host.split("@")) && (h2.auth = U.shift(), h2.host = h2.hostname = U.shift()));
  return (j = j || h2.host && x.length) && !k && x.unshift(""), x.length ? h2.pathname = x.join("/") : (h2.pathname = null, h2.path = null), a.isNull(h2.pathname) && a.isNull(h2.search) || (h2.path = (h2.pathname ? h2.pathname : "") + (h2.search ? h2.search : "")), h2.auth = t2.auth || h2.auth, h2.slashes = h2.slashes || t2.slashes, h2.href = h2.format(), h2;
};
r2.prototype.parseHost = function() {
  var t2 = this.host, s = n2.exec(t2);
  s && (":" !== (s = s[0]) && (this.port = s.substr(1)), t2 = t2.substr(0, t2.length - s.length)), t2 && (this.hostname = t2);
};
h.Url;
h.format;
h.resolve;
h.resolveObject;
var exports3 = {};
var _dewExec3 = false;
function dew3() {
  if (_dewExec3) {
    return exports3;
  }
  _dewExec3 = true;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length) {
        code = path2.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) ;
        else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += "/" + path2.slice(lastSlash + 1, i2);
          } else {
            res = path2.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base2;
    }
    if (dir === pathObject.root) {
      return dir + base2;
    }
    return dir + sep2 + base2;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var arguments$1 = arguments;
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd2;
      for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        var path2;
        if (i2 >= 0) {
          path2 = arguments$1[i2];
        } else {
          if (cwd2 === void 0) {
            cwd2 = process2.cwd();
          }
          path2 = cwd2;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) {
          return "/" + resolvedPath;
        } else {
          return "/";
        }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0) {
        return ".";
      }
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) {
        path2 = ".";
      }
      if (path2.length > 0 && trailingSeparator) {
        path2 += "/";
      }
      if (isAbsolute2) {
        return "/" + path2;
      }
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join3() {
      var arguments$1 = arguments;
      if (arguments.length === 0) {
        return ".";
      }
      var joined;
      for (var i2 = 0; i2 < arguments.length; ++i2) {
        var arg = arguments$1[i2];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += "/" + arg;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) {
        return "";
      }
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to) {
        return "";
      }
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) {
          break;
        }
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) {
          break;
        }
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i2 = 0;
      for (; i2 <= length; ++i2) {
        if (i2 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i2) === 47) {
              return to.slice(toStart + i2 + 1);
            } else if (i2 === 0) {
              return to.slice(toStart + i2);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i2) === 47) {
              lastCommonSep = i2;
            } else if (i2 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i2);
        var toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === 47) {
          lastCommonSep = i2;
        }
      }
      var out = "";
      for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
        if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "/..";
          }
        }
      }
      if (out.length > 0) {
        return out + to.slice(toStart + lastCommonSep);
      } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) {
          ++toStart;
        }
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0) {
        return ".";
      }
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i2 = path2.length - 1; i2 >= 1; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            end = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i2;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) {
          return "";
        }
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          var code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i2;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path2.length;
        }
        return path2.slice(start, end);
      } else {
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
        }
        if (end === -1) {
          return "";
        }
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i2 = path2.length - 1; i2 >= 0; --i2) {
        var code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format3(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse4(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0) {
        return ret;
      }
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i2 = path2.length - 1;
      var preDotState = 0;
      for (; i2 >= start; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1) {
            startDot = i2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) {
            ret.base = ret.name = path2.slice(1, end);
          } else {
            ret.base = ret.name = path2.slice(startPart, end);
          }
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) {
        ret.dir = path2.slice(0, startPart - 1);
      } else if (isAbsolute2) {
        ret.dir = "/";
      }
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports3 = posix2;
  return exports3;
}
var path = dew3();
var processPlatform$1 = "wasi";
h.URL = typeof URL2 !== "undefined" ? URL2 : null;
h.pathToFileURL = pathToFileURL$1;
h.fileURLToPath = fileURLToPath$1;
h.Url;
h.format;
h.resolve;
h.resolveObject;
h.URL;
var CHAR_FORWARD_SLASH$1 = 47;
var CHAR_LOWERCASE_A$1 = 97;
var CHAR_LOWERCASE_Z$1 = 122;
var isWindows$1 = processPlatform$1 === "win32";
var forwardSlashRegEx$1 = /\//g;
var percentRegEx$1 = /%/g;
var backslashRegEx$1 = /\\/g;
var newlineRegEx$1 = /\n/g;
var carriageReturnRegEx$1 = /\r/g;
var tabRegEx$1 = /\t/g;
function fileURLToPath$1(path2) {
  if (typeof path2 === "string") {
    path2 = new URL2(path2);
  } else if (!(path2 instanceof URL2)) {
    throw new TypeError(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new TypeError("invalid url scheme");
  }
  return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
}
function getPathFromURLWin$1(url2) {
  var hostname = url2.hostname;
  var pathname = url2.pathname;
  for (var n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      var third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n5 + 1] === "5" && third === 99) {
        throw new TypeError(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return "\\\\" + hostname + pathname;
  } else {
    var letter = pathname.codePointAt(1) | 32;
    var sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
    sep2 !== ":") {
      throw new TypeError("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url2) {
  if (url2.hostname !== "") {
    throw new TypeError("invalid file url hostname");
  }
  var pathname = url2.pathname;
  for (var n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      var third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102) {
        throw new TypeError(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  var resolved = path.resolve(filepath);
  var filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += "/";
  }
  var outURL = new URL2("file://");
  if (resolved.includes("%")) {
    resolved = resolved.replace(percentRegEx$1, "%25");
  }
  if (resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$1, "%5C");
  }
  if (resolved.includes("\n")) {
    resolved = resolved.replace(newlineRegEx$1, "%0A");
  }
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
  }
  if (resolved.includes("	")) {
    resolved = resolved.replace(tabRegEx$1, "%09");
  }
  outURL.pathname = resolved;
  return outURL;
}
var processPlatform = "wasi";
h.URL = typeof URL2 !== "undefined" ? URL2 : null;
h.pathToFileURL = pathToFileURL;
h.fileURLToPath = fileURLToPath;
var Url = h.Url;
var format2 = h.format;
var resolve2 = h.resolve;
var resolveObject = h.resolveObject;
var parse3 = h.parse;
var _URL = h.URL;
var CHAR_FORWARD_SLASH = 47;
var CHAR_LOWERCASE_A = 97;
var CHAR_LOWERCASE_Z = 122;
var isWindows2 = processPlatform === "win32";
var forwardSlashRegEx = /\//g;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function fileURLToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL2(path2);
  } else if (!(path2 instanceof URL2)) {
    throw new TypeError(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new TypeError("invalid url scheme");
  }
  return isWindows2 ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
}
function getPathFromURLWin(url2) {
  var hostname = url2.hostname;
  var pathname = url2.pathname;
  for (var n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      var third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n5 + 1] === "5" && third === 99) {
        throw new TypeError(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return "\\\\" + hostname + pathname;
  } else {
    var letter = pathname.codePointAt(1) | 32;
    var sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep2 !== ":") {
      throw new TypeError("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url2) {
  if (url2.hostname !== "") {
    throw new TypeError("invalid file url hostname");
  }
  var pathname = url2.pathname;
  for (var n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      var third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102) {
        throw new TypeError(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  var resolved = resolve(filepath);
  var filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows2) && resolved[resolved.length - 1] !== sep) {
    resolved += "/";
  }
  var outURL = new URL2("file://");
  if (resolved.includes("%")) {
    resolved = resolved.replace(percentRegEx, "%25");
  }
  if (resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n")) {
    resolved = resolved.replace(newlineRegEx, "%0A");
  }
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	")) {
    resolved = resolved.replace(tabRegEx, "%09");
  }
  outURL.pathname = resolved;
  return outURL;
}

// node_modules/azle/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/azle/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/azle/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/azle/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/azle/src/experimental/lib/fetch/headers.ts
var AzleFetchHeaders = class _AzleFetchHeaders {
  headers = {};
  [Symbol.iterator]() {
    return this.entries();
  }
  constructor(headers) {
    if (Array.isArray(headers)) {
      this.headers = headers.reduce((acc, [key, value]) => {
        return {
          ...acc,
          [key]: value
        };
      }, {});
    }
    if (headers instanceof _AzleFetchHeaders) {
      this.headers = headers.headers;
    }
    if (typeof headers === "object") {
      this.headers = headers;
    }
  }
  // TODO append seems a bit complicated to implement because we have to know which
  // TODO headers can accept multiple values
  append() {
    throw new Error(`AzleFetchHeaders: append is not yet implemented`);
  }
  // TODO we do not throw here like the documentation says we should
  delete(name) {
    delete this.headers[name];
  }
  entries() {
    return Object.entries(this.headers)[Symbol.iterator]();
  }
  forEach(callback, thisArg = this) {
    Object.entries(this.headers).forEach(([key, value]) => {
      callback.bind(thisArg)(value, key, this);
    });
  }
  get(name) {
    return this.headers[name] ?? null;
  }
  getSetCookie() {
    throw new Error(
      `AzleFetchHeaders: getSetCookie is not yet implemented`
    );
  }
  has(name) {
    return this.headers[name] !== void 0;
  }
  keys() {
    return Object.keys(this.headers)[Symbol.iterator]();
  }
  set(name, value) {
    this.headers[name] = value;
  }
  values() {
    return Object.values(this.headers)[Symbol.iterator]();
  }
};

// node_modules/azle/src/experimental/lib/fetch/response.ts
var AzleFetchResponse = class _AzleFetchResponse {
  url;
  ok;
  type;
  redirected;
  status;
  statusText;
  headers;
  body = null;
  bodyUsed;
  constructor(body2, init6) {
    this.body = convertBodyInitToBody(body2);
    this.status = init6?.status ?? 200;
    this.statusText = getStatusText(this.status);
    this.ok = this.status >= 200 && this.status <= 299;
    this.type = "";
    this.redirected = false;
    this.bodyUsed = false;
    this.headers = new AzleFetchHeaders(init6?.headers);
    this.url = "";
  }
  async arrayBuffer() {
    this.bodyUsed = true;
    if (this.body === null) {
      return new ArrayBuffer(0);
    }
    const result2 = this.body;
    return result2.buffer instanceof ArrayBuffer ? result2.buffer : new Uint8Array(result2).buffer;
  }
  async bytes() {
    this.bodyUsed = true;
    if (this.body === null) {
      return new Uint8Array();
    }
    return new Uint8Array(this.body);
  }
  async json() {
    this.bodyUsed = true;
    if (this.body === null) {
      return JSON.parse("");
    }
    return JSON.parse(
      this.body.toString()
    );
  }
  async text() {
    this.bodyUsed = true;
    if (this.body === null) {
      return "";
    }
    return this.body.toString();
  }
  async blob() {
    throw new Error(`AzleFetchResponse: blob is not yet implemented`);
  }
  async formData() {
    throw new Error(`AzleFetchResponse: formData is not yet implemented`);
  }
  clone() {
    return new _AzleFetchResponse();
  }
};
function convertBodyInitToBody(body2) {
  if (body2 === void 0) {
    return null;
  }
  if (body2 instanceof Uint8Array || body2 instanceof Buffer) {
    return Buffer.from(body2);
  }
  throw new Error(`AzleFetchResponse: body must be a Uint8Array or Buffer`);
}
function getStatusText(status) {
  const statusTexts = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    103: "Early Hints",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    306: "unused",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Content",
    423: "Locked",
    424: "Failed Dependency",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    510: "Not Extended",
    511: "Network Authentication Required"
  };
  return statusTexts[status] ?? "";
}

// node_modules/azle/src/experimental/lib/fetch/url.ts
function getUrl(input2) {
  if (input2 instanceof URL) {
    return input2;
  }
  if (typeof input2 === "string") {
    return new URL(input2);
  }
  throw new Error(`azleFetch: input must be of type URL or string`);
}

// node_modules/azle/src/experimental/lib/fetch/file.ts
async function fetchFile(input2) {
  const url2 = getUrl(input2);
  const path2 = `${url2.hostname}${url2.pathname}`;
  const contents = await readFile(path2);
  return new AzleFetchResponse(contents);
}

// node_modules/azle/node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c2, tree) => {
  send_bits(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base2 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h2;
  let n5, m2;
  let bits;
  let xbits;
  let f4;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h2 = s.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n5 = s.heap[h2];
    bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n5 * 2 + 1] = bits;
    if (n5 > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n5 >= base2) {
      xbits = extra[n5 - base2];
    }
    f4 = tree[n5 * 2];
    s.opt_len += f4 * (bits + xbits);
    if (has_stree) {
      s.static_len += f4 * (stree[n5 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n5 = s.bl_count[bits];
    while (n5 !== 0) {
      m2 = s.heap[--h2];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n5--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n5;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n5 = 0; n5 <= max_code; n5++) {
    let len = tree[n5 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n5 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n5;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n5 = 0; n5 < 1 << extra_lbits[code]; n5++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n5 = 0; n5 < 1 << extra_dbits[code]; n5++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n5 = 0; n5 < 1 << extra_dbits[code] - 7; n5++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n5 = 0;
  while (n5 <= 143) {
    static_ltree[n5 * 2 + 1] = 8;
    n5++;
    bl_count[8]++;
  }
  while (n5 <= 255) {
    static_ltree[n5 * 2 + 1] = 9;
    n5++;
    bl_count[9]++;
  }
  while (n5 <= 279) {
    static_ltree[n5 * 2 + 1] = 7;
    n5++;
    bl_count[7]++;
  }
  while (n5 <= 287) {
    static_ltree[n5 * 2 + 1] = 8;
    n5++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n5 = 0; n5 < D_CODES$1; n5++) {
    static_dtree[n5 * 2 + 1] = 5;
    static_dtree[n5 * 2] = bi_reverse(n5, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n5;
  for (n5 = 0; n5 < L_CODES$1; n5++) {
    s.dyn_ltree[n5 * 2] = 0;
  }
  for (n5 = 0; n5 < D_CODES$1; n5++) {
    s.dyn_dtree[n5 * 2] = 0;
  }
  for (n5 = 0; n5 < BL_CODES$1; n5++) {
    s.bl_tree[n5 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n5, m2, depth) => {
  const _n2 = n5 * 2;
  const _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m2];
};
var pqdownheap = (s, tree, k) => {
  const v2 = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v2, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v2;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n5, m2;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n5 = 0; n5 < elems; n5++) {
    if (tree[n5 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n5;
      s.depth[n5] = 0;
    } else {
      tree[n5 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n5 = s.heap_len >> 1; n5 >= 1; n5--) {
    pqdownheap(s, tree, n5);
  }
  node = elems;
  do {
    n5 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n5;
    s.heap[--s.heap_max] = m2;
    tree[node * 2] = tree[n5 * 2] + tree[m2 * 2];
    s.depth[node] = (s.depth[n5] >= s.depth[m2] ? s.depth[n5] : s.depth[m2]) + 1;
    tree[n5 * 2 + 1] = tree[m2 * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n5;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n5 = 0; n5 <= max_code; n5++) {
    curlen = nextlen;
    nextlen = tree[(n5 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n5;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n5 = 0; n5 <= max_code; n5++) {
    curlen = nextlen;
    nextlen = tree[(n5 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n5;
  for (n5 = 0; n5 <= 31; n5++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n5 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n5 = 32; n5 < LITERALS$1; n5++) {
    if (s.dyn_ltree[n5 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n5 = 0;
  while (len !== 0) {
    n5 = len > 2e3 ? 2e3 : len;
    len -= n5;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n5);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c2, table = [];
  for (var n5 = 0; n5 < 256; n5++) {
    c2 = n5;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n5] = c2;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err2 = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f4) => {
  return f4 * 2 - (f4 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n5, m2;
  let p3;
  let wsize = s.w_size;
  n5 = s.hash_size;
  p3 = n5;
  do {
    m2 = s.head[--p3];
    s.head[p3] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n5);
  n5 = wsize;
  p3 = n5;
  do {
    m2 = s.prev[--p3];
    s.prev[p3] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n5);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b4) => {
  s.pending_buf[s.pending++] = b4;
};
var putShortMSB = (s, b4) => {
  s.pending_buf[s.pending++] = b4 >>> 8 & 255;
  s.pending_buf[s.pending++] = b4 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n5, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n5 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n5;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err2(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err2(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err2(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err2(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err2(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy7 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy7), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy7;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy7;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err2(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input2 = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n5 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n5);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input2;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p3 in source) {
      if (_has(source, p3)) {
        obj[p3] = source[p3];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
    len += chunks[i2].length;
  }
  const result2 = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
    let chunk2 = chunks[i2];
    result2.set(chunk2, pos);
    pos += chunk2.length;
  }
  return result2;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i2++] = c2;
    } else if (c2 < 2048) {
      buf[i2++] = 192 | c2 >>> 6;
      buf[i2++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i2++] = 224 | c2 >>> 12;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    } else {
      buf[i2++] = 240 | c2 >>> 18;
      buf[i2++] = 128 | c2 >>> 12 & 63;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result2 = "";
  for (let i2 = 0; i2 < len; i2++) {
    result2 += String.fromCharCode(buf[i2]);
  }
  return result2;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c2 = buf[i2++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    let c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c2 = c2 << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk2) {
  this.chunks.push(chunk2);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input2, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input2, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input2, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input2, options);
}
function gzip$1(input2, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input2, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input2, output3;
  const state = strm.state;
  _in = strm.next_in;
  input2 = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output3 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input2[_in++] << bits;
        bits += 8;
        hold += input2[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output3[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input2[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input2[_in++] << bits;
              bits += 8;
              hold += input2[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input2[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input2[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output3[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output3;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output3[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output3[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output3;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output3[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output3;
                      }
                    }
                    while (len > 2) {
                      output3[_out++] = from_source[from++];
                      output3[_out++] = from_source[from++];
                      output3[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output3[_out++] = from_source[from++];
                      if (len > 1) {
                        output3[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output3[_out++] = output3[from++];
                      output3[_out++] = output3[from++];
                      output3[_out++] = output3[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output3[_out++] = output3[from++];
                      if (len > 1) {
                        output3[_out++] = output3[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min2 = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask3;
  let next;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask3 = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask3) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask3;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy7) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy7 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy7) {
      dist = copy7;
    }
    state.window.set(src.subarray(end - copy7, end - copy7 + dist), state.wnext);
    copy7 -= dist;
    if (copy7) {
      state.window.set(src.subarray(end - copy7, end), 0);
      state.wnext = copy7;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input2, output3;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy7;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n5;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output3 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input2 = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy7 = state.length;
            if (copy7 > have) {
              copy7 = have;
            }
            if (copy7) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input2.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy7
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input2, copy7, next);
              }
              have -= copy7;
              next += copy7;
              state.length -= copy7;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy7 = 0;
            do {
              len = input2[next + copy7++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy7 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input2, copy7, next);
            }
            have -= copy7;
            next += copy7;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy7 = 0;
            do {
              len = input2[next + copy7++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy7 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input2, copy7, next);
            }
            have -= copy7;
            next += copy7;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy7 = state.length;
          if (copy7) {
            if (copy7 > have) {
              copy7 = have;
            }
            if (copy7 > left) {
              copy7 = left;
            }
            if (copy7 === 0) {
              break inf_leave;
            }
            output3.set(input2.subarray(next, next + copy7), put);
            have -= copy7;
            next += copy7;
            left -= copy7;
            put += copy7;
            state.length -= copy7;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n5 = here_bits + 2;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input2[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy7 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n5 = here_bits + 3;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input2[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy7 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n5 = here_bits + 7;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input2[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy7 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy7 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy7--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output3 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input2 = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n5 = state.extra;
            while (bits < n5) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input2[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n5 = state.extra;
            while (bits < n5) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy7 = _out - left;
          if (state.offset > copy7) {
            copy7 = state.offset - copy7;
            if (copy7 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy7 > state.wnext) {
              copy7 -= state.wnext;
              from = state.wsize - copy7;
            } else {
              from = state.wnext - copy7;
            }
            if (copy7 > state.length) {
              copy7 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output3;
            from = put - state.offset;
            copy7 = state.length;
          }
          if (copy7 > left) {
            copy7 = left;
          }
          left -= copy7;
          state.length -= copy7;
          do {
            output3[put++] = from_source[from++];
          } while (--copy7);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output3[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input2[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output3, _out, put - _out) : adler32_1(state.check, output3, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input2[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output3, _out, strm.next_out - _out) : adler32_1(state.check, output3, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk2) {
  this.chunks.push(chunk2);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input2, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input2);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input2, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input2, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants2 = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants2
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// node_modules/azle/src/stable/lib/ic_apis/canister_self.ts
function canisterSelf() {
  if (globalThis._azleIcExperimental !== void 0) {
    return Principal.fromText(
      globalThis._azleIcExperimental.canisterSelf()
    );
  }
  if (globalThis._azleIc !== void 0) {
    return Principal.fromUint8Array(globalThis._azleIc.canisterSelf());
  }
  return Principal.fromHex("04");
}

// node_modules/azle/src/experimental/lib/fetch/http.ts
async function fetchHttp(input2, init6) {
  const urlObject = getUrl(input2);
  const url2 = `${urlObject.origin}${urlObject.pathname}${urlObject.search}`;
  const maxResponseBytes = getHttpMaxResponseBytes();
  const method = getHttpMethod(init6);
  const headers = getHeaders(init6);
  const body2 = await prepareRequestBody(init6);
  const transform = getHttpTransform();
  const cycles2 = getCycles(body2[0], headers, maxResponseBytes[0]);
  const response = await azleFetch(`icp://aaaaa-aa/http_request`, {
    body: serialize({
      args: [
        {
          url: url2,
          max_response_bytes: maxResponseBytes,
          method,
          headers,
          body: body2,
          transform
        }
      ],
      cycles: cycles2
    })
  });
  const responseJson = await response.json();
  const bodyIsGZipped = responseJson.headers.find(({ name, value }) => {
    return name.toLowerCase() === "content-encoding" && value.toLowerCase() === "gzip";
  }) !== void 0;
  const unGZippedBody = bodyIsGZipped ? inflate_1(responseJson.body) : responseJson.body;
  const finalBody = unGZippedBody;
  const responseHeaders = responseJson.headers.reduce(
    (acc, { name, value }) => {
      return {
        ...acc,
        [name]: value
      };
    },
    {}
  );
  return new AzleFetchResponse(finalBody, {
    status: Number(responseJson.status),
    headers: responseHeaders
  });
}
function getHttpMaxResponseBytes() {
  return globalThis._azleOutgoingHttpOptionsMaxResponseBytes === void 0 ? [] : [globalThis._azleOutgoingHttpOptionsMaxResponseBytes];
}
function getHttpMethod(init6) {
  if (init6 === void 0) {
    return {
      get: null
    };
  }
  if (init6.method === void 0) {
    return {
      get: null
    };
  }
  if (init6.method.toLowerCase() !== "get" && init6.method.toLowerCase() !== "head" && init6.method.toLowerCase() !== "post") {
    throw new Error(
      `azleFetch: ${init6.method} is not a supported HTTP method`
    );
  }
  return {
    [init6.method.toLowerCase()]: null
  };
}
function getHttpTransform() {
  if (globalThis._azleOutgoingHttpOptionsTransformMethodName === void 0) {
    return [];
  }
  return [
    {
      function: [
        canisterSelf(),
        globalThis._azleOutgoingHttpOptionsTransformMethodName
      ],
      context: globalThis._azleOutgoingHttpOptionsTransformContext ?? Uint8Array.from([])
    }
  ];
}
function getCycles(body2, headers, maxResponseBytes) {
  const subnetSize = BigInt(
    globalThis._azleOutgoingHttpOptionsSubnetSize ?? 13
  );
  const baseFeeEstimate = (3000000n + 60000n * subnetSize) * subnetSize;
  const concatenatedHeaders = headers.reduce(
    (acc, { name, value }) => `${acc}${name}${value}`,
    ""
  );
  const headersSize = BigInt(Buffer.byteLength(concatenatedHeaders, "utf-8"));
  const bodySize = BigInt(body2?.length ?? 0);
  const requestSize = headersSize + bodySize;
  const requestFeeEstimate = 400n * subnetSize * requestSize;
  const responseFeeEstimate = 800n * subnetSize * (maxResponseBytes ?? 2000000n);
  const totalFeeEstimate = baseFeeEstimate + requestFeeEstimate + responseFeeEstimate;
  return globalThis._azleOutgoingHttpOptionsCycles ?? totalFeeEstimate;
}
async function prepareRequestBody(init6) {
  if (init6 === void 0) {
    return [];
  }
  if (init6.body === null) {
    return [];
  }
  if (init6.body === void 0) {
    return [];
  }
  if (typeof init6.body === "string") {
    const textEncoder = new TextEncoder();
    return [textEncoder.encode(init6.body)];
  }
  if (init6.body instanceof BigUint64Array || init6.body instanceof BigInt64Array) {
    return [new Uint8Array(init6.body.buffer)];
  }
  if (init6.body instanceof Uint8Array) {
    return [init6.body];
  }
  if (init6.body instanceof ArrayBuffer || init6.body instanceof Uint8ClampedArray || init6.body instanceof Uint16Array || init6.body instanceof Uint32Array || init6.body instanceof Int8Array || init6.body instanceof Int16Array || init6.body instanceof Int32Array || init6.body instanceof Float32Array || init6.body instanceof Float64Array) {
    return [new Uint8Array(init6.body)];
  }
  if (init6.body instanceof DataView) {
    return [new Uint8Array(init6.body.buffer)];
  }
  if (init6.body instanceof Blob) {
    return [new Uint8Array(await init6.body.arrayBuffer())];
  }
  if (init6.body instanceof File) {
    const blob2 = new Blob([init6.body], { type: init6.body.type });
    const buffer = await blob2.arrayBuffer();
    return [new Uint8Array(buffer)];
  }
  if (init6.body instanceof URLSearchParams) {
    const encoder = new TextEncoder();
    return [encoder.encode(init6.body.toString())];
  }
  if (init6.body instanceof FormData) {
    throw new Error(`azleFetch: FormData is not a supported body type`);
  }
  throw new Error(`azleFetch: Not a supported body type`);
}
function getHeaders(init6) {
  if (init6 === void 0) {
    return [];
  }
  if (init6.headers === void 0) {
    return [];
  }
  if (Array.isArray(init6.headers)) {
    return init6.headers.map(([key, value]) => {
      return {
        name: key,
        value
      };
    });
  }
  if (typeof init6.headers === "object") {
    return Object.entries(init6.headers).map(([key, value]) => {
      return {
        name: key,
        value
      };
    });
  }
  throw new Error(`azleFetch: not a supported headers type`);
}

// node_modules/azle/node_modules/@dfinity/candid/lib/esm/idl.js
var idl_exports = {};
__export(idl_exports, {
  Bool: () => Bool,
  BoolClass: () => BoolClass,
  ConstructType: () => ConstructType,
  Empty: () => Empty,
  EmptyClass: () => EmptyClass,
  FixedIntClass: () => FixedIntClass,
  FixedNatClass: () => FixedNatClass,
  Float32: () => Float32,
  Float64: () => Float64,
  FloatClass: () => FloatClass,
  Func: () => Func,
  FuncClass: () => FuncClass,
  Int: () => Int,
  Int16: () => Int16,
  Int32: () => Int32,
  Int64: () => Int64,
  Int8: () => Int8,
  IntClass: () => IntClass,
  Nat: () => Nat,
  Nat16: () => Nat16,
  Nat32: () => Nat32,
  Nat64: () => Nat64,
  Nat8: () => Nat8,
  NatClass: () => NatClass,
  Null: () => Null,
  NullClass: () => NullClass,
  Opt: () => Opt,
  OptClass: () => OptClass,
  PrimitiveType: () => PrimitiveType,
  Principal: () => Principal2,
  PrincipalClass: () => PrincipalClass,
  Rec: () => Rec,
  RecClass: () => RecClass,
  Record: () => Record,
  RecordClass: () => RecordClass,
  Reserved: () => Reserved,
  ReservedClass: () => ReservedClass,
  Service: () => Service,
  ServiceClass: () => ServiceClass,
  Text: () => Text,
  TextClass: () => TextClass,
  Tuple: () => Tuple,
  TupleClass: () => TupleClass,
  Type: () => Type,
  Unknown: () => Unknown,
  UnknownClass: () => UnknownClass,
  Variant: () => Variant,
  VariantClass: () => VariantClass,
  Vec: () => Vec,
  VecClass: () => VecClass,
  Visitor: () => Visitor,
  decode: () => decode4,
  encode: () => encode4
});

// node_modules/azle/node_modules/@dfinity/candid/lib/esm/utils/buffer.js
function concat(...buffers) {
  const result2 = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
  let index = 0;
  for (const b4 of buffers) {
    result2.set(new Uint8Array(b4), index);
    index += b4.byteLength;
  }
  return result2;
}
var PipeArrayBuffer = class {
  /**
   * Creates a new instance of a pipe
   * @param buffer an optional buffer to start with
   * @param length an optional amount of bytes to use for the length.
   */
  constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {
    this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));
    this._view = new Uint8Array(this._buffer, 0, length);
  }
  /**
   * Save a checkpoint of the reading view (for backtracking)
   */
  save() {
    return this._view;
  }
  /**
   * Restore a checkpoint of the reading view (for backtracking)
   * @param checkPoint a previously saved checkpoint
   */
  restore(checkPoint) {
    this._view = checkPoint;
  }
  get buffer() {
    return bufFromBufLike(this._view.slice());
  }
  get byteLength() {
    return this._view.byteLength;
  }
  /**
   * Read `num` number of bytes from the front of the pipe.
   * @param num The number of bytes to read.
   */
  read(num) {
    const result2 = this._view.subarray(0, num);
    this._view = this._view.subarray(num);
    return result2.slice().buffer;
  }
  readUint8() {
    const result2 = this._view[0];
    this._view = this._view.subarray(1);
    return result2;
  }
  /**
   * Write a buffer to the end of the pipe.
   * @param buf The bytes to write.
   */
  write(buf) {
    const b4 = new Uint8Array(buf);
    const offset = this._view.byteLength;
    if (this._view.byteOffset + this._view.byteLength + b4.byteLength >= this._buffer.byteLength) {
      this.alloc(b4.byteLength);
    } else {
      this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b4.byteLength);
    }
    this._view.set(b4, offset);
  }
  /**
   * Whether or not there is more data to read from the buffer
   */
  get end() {
    return this._view.byteLength === 0;
  }
  /**
   * Allocate a fixed amount of memory in the buffer. This does not affect the view.
   * @param amount A number of bytes to add to the buffer.
   */
  alloc(amount) {
    const b4 = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);
    const v2 = new Uint8Array(b4, 0, this._view.byteLength + amount);
    v2.set(this._view);
    this._buffer = b4;
    this._view = v2;
  }
};
function uint8ToBuf(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;
}
function bufFromBufLike(bufLike) {
  if (bufLike instanceof Uint8Array) {
    return uint8ToBuf(bufLike);
  }
  if (bufLike instanceof ArrayBuffer) {
    return bufLike;
  }
  if (Array.isArray(bufLike)) {
    return uint8ToBuf(new Uint8Array(bufLike));
  }
  if ("buffer" in bufLike) {
    return bufFromBufLike(bufLike.buffer);
  }
  return uint8ToBuf(new Uint8Array(bufLike));
}

// node_modules/azle/node_modules/@dfinity/candid/lib/esm/utils/hash.js
function idlHash(s) {
  const utf8encoder = new TextEncoder();
  const array = utf8encoder.encode(s);
  let h2 = 0;
  for (const c2 of array) {
    h2 = (h2 * 223 + c2) % 2 ** 32;
  }
  return h2;
}
function idlLabelToId(label) {
  if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
    const num = +label.slice(1, -1);
    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
      return num;
    }
  }
  return idlHash(label);
}

// node_modules/azle/node_modules/@dfinity/candid/lib/esm/utils/leb128.js
function eob() {
  throw new Error("unexpected end of buffer");
}
function safeRead(pipe, num) {
  if (pipe.byteLength < num) {
    eob();
  }
  return pipe.read(num);
}
function safeReadUint8(pipe) {
  const byte = pipe.readUint8();
  if (byte === void 0) {
    eob();
  }
  return byte;
}
function lebEncode(value) {
  if (typeof value === "number") {
    value = BigInt(value);
  }
  if (value < BigInt(0)) {
    throw new Error("Cannot leb encode negative values.");
  }
  const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
  const pipe = new PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
  while (true) {
    const i2 = Number(value & BigInt(127));
    value /= BigInt(128);
    if (value === BigInt(0)) {
      pipe.write(new Uint8Array([i2]));
      break;
    } else {
      pipe.write(new Uint8Array([i2 | 128]));
    }
  }
  return pipe.buffer;
}
function lebDecode(pipe) {
  let weight = BigInt(1);
  let value = BigInt(0);
  let byte;
  do {
    byte = safeReadUint8(pipe);
    value += BigInt(byte & 127).valueOf() * weight;
    weight *= BigInt(128);
  } while (byte >= 128);
  return value;
}
function slebEncode(value) {
  if (typeof value === "number") {
    value = BigInt(value);
  }
  const isNeg = value < BigInt(0);
  if (isNeg) {
    value = -value - BigInt(1);
  }
  const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
  const pipe = new PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
  while (true) {
    const i2 = getLowerBytes(value);
    value /= BigInt(128);
    if (isNeg && value === BigInt(0) && (i2 & 64) !== 0 || !isNeg && value === BigInt(0) && (i2 & 64) === 0) {
      pipe.write(new Uint8Array([i2]));
      break;
    } else {
      pipe.write(new Uint8Array([i2 | 128]));
    }
  }
  function getLowerBytes(num) {
    const bytes4 = num % BigInt(128);
    if (isNeg) {
      return Number(BigInt(128) - bytes4 - BigInt(1));
    } else {
      return Number(bytes4);
    }
  }
  return pipe.buffer;
}
function slebDecode(pipe) {
  const pipeView = new Uint8Array(pipe.buffer);
  let len = 0;
  for (; len < pipeView.byteLength; len++) {
    if (pipeView[len] < 128) {
      if ((pipeView[len] & 64) === 0) {
        return lebDecode(pipe);
      }
      break;
    }
  }
  const bytes4 = new Uint8Array(safeRead(pipe, len + 1));
  let value = BigInt(0);
  for (let i2 = bytes4.byteLength - 1; i2 >= 0; i2--) {
    value = value * BigInt(128) + BigInt(128 - (bytes4[i2] & 127) - 1);
  }
  return -value - BigInt(1);
}
function writeUIntLE(value, byteLength) {
  if (BigInt(value) < BigInt(0)) {
    throw new Error("Cannot write negative values.");
  }
  return writeIntLE(value, byteLength);
}
function writeIntLE(value, byteLength) {
  value = BigInt(value);
  const pipe = new PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);
  let i2 = 0;
  let mul = BigInt(256);
  let sub = BigInt(0);
  let byte = Number(value % mul);
  pipe.write(new Uint8Array([byte]));
  while (++i2 < byteLength) {
    if (value < 0 && sub === BigInt(0) && byte !== 0) {
      sub = BigInt(1);
    }
    byte = Number((value / mul - sub) % BigInt(256));
    pipe.write(new Uint8Array([byte]));
    mul *= BigInt(256);
  }
  return pipe.buffer;
}
function readUIntLE(pipe, byteLength) {
  let val = BigInt(safeReadUint8(pipe));
  let mul = BigInt(1);
  let i2 = 0;
  while (++i2 < byteLength) {
    mul *= BigInt(256);
    const byte = BigInt(safeReadUint8(pipe));
    val = val + mul * byte;
  }
  return val;
}
function readIntLE(pipe, byteLength) {
  let val = readUIntLE(pipe, byteLength);
  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));
  if (val >= mul) {
    val -= mul * BigInt(2);
  }
  return val;
}

// node_modules/azle/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js
function iexp2(n5) {
  const nBig = BigInt(n5);
  if (n5 < 0) {
    throw new RangeError("Input must be non-negative");
  }
  return BigInt(1) << nBig;
}

// node_modules/azle/node_modules/@dfinity/candid/lib/esm/idl.js
var magicNumber = "DIDL";
var toReadableString_max = 400;
function zipWith(xs, ys, f4) {
  return xs.map((x, i2) => f4(x, ys[i2]));
}
var TypeTable = class {
  constructor() {
    this._typs = [];
    this._idx = /* @__PURE__ */ new Map();
  }
  has(obj) {
    return this._idx.has(obj.name);
  }
  add(type, buf) {
    const idx = this._typs.length;
    this._idx.set(type.name, idx);
    this._typs.push(buf);
  }
  merge(obj, knot) {
    const idx = this._idx.get(obj.name);
    const knotIdx = this._idx.get(knot);
    if (idx === void 0) {
      throw new Error("Missing type index for " + obj);
    }
    if (knotIdx === void 0) {
      throw new Error("Missing type index for " + knot);
    }
    this._typs[idx] = this._typs[knotIdx];
    this._typs.splice(knotIdx, 1);
    this._idx.delete(knot);
  }
  encode() {
    const len = lebEncode(this._typs.length);
    const buf = concat(...this._typs);
    return concat(len, buf);
  }
  indexOf(typeName) {
    if (!this._idx.has(typeName)) {
      throw new Error("Missing type index for " + typeName);
    }
    return slebEncode(this._idx.get(typeName) || 0);
  }
};
var Visitor = class {
  visitType(t2, data) {
    throw new Error("Not implemented");
  }
  visitPrimitive(t2, data) {
    return this.visitType(t2, data);
  }
  visitEmpty(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitBool(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitNull(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitReserved(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitText(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitNumber(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitInt(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitNat(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitFloat(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitFixedInt(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitFixedNat(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitPrincipal(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitConstruct(t2, data) {
    return this.visitType(t2, data);
  }
  visitVec(t2, ty, data) {
    return this.visitConstruct(t2, data);
  }
  visitOpt(t2, ty, data) {
    return this.visitConstruct(t2, data);
  }
  visitRecord(t2, fields, data) {
    return this.visitConstruct(t2, data);
  }
  visitTuple(t2, components, data) {
    const fields = components.map((ty, i2) => [`_${i2}_`, ty]);
    return this.visitRecord(t2, fields, data);
  }
  visitVariant(t2, fields, data) {
    return this.visitConstruct(t2, data);
  }
  visitRec(t2, ty, data) {
    return this.visitConstruct(ty, data);
  }
  visitFunc(t2, data) {
    return this.visitConstruct(t2, data);
  }
  visitService(t2, data) {
    return this.visitConstruct(t2, data);
  }
};
var Type = class {
  /* Display type name */
  display() {
    return this.name;
  }
  valueToString(x) {
    return toReadableString(x);
  }
  /* Implement `T` in the IDL spec, only needed for non-primitive types */
  buildTypeTable(typeTable) {
    if (!typeTable.has(this)) {
      this._buildTypeTableImpl(typeTable);
    }
  }
};
var PrimitiveType = class extends Type {
  checkType(t2) {
    if (this.name !== t2.name) {
      throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
    }
    return t2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _buildTypeTableImpl(typeTable) {
    return;
  }
};
var ConstructType = class extends Type {
  checkType(t2) {
    if (t2 instanceof RecClass) {
      const ty = t2.getType();
      if (typeof ty === "undefined") {
        throw new Error("type mismatch with uninitialized type");
      }
      return ty;
    }
    throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
  }
  encodeType(typeTable) {
    return typeTable.indexOf(this.name);
  }
};
var EmptyClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitEmpty(this, d);
  }
  covariant(x) {
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue() {
    throw new Error("Empty cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Empty cannot appear as a value");
  }
  encodeType() {
    return slebEncode(
      -17
      /* IDLTypeIds.Empty */
    );
  }
  decodeValue() {
    throw new Error("Empty cannot appear as an output");
  }
  get name() {
    return "empty";
  }
};
var UnknownClass = class extends Type {
  checkType(t2) {
    throw new Error("Method not implemented for unknown.");
  }
  accept(v2, d) {
    throw v2.visitType(this, d);
  }
  covariant(x) {
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue() {
    throw new Error("Unknown cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Unknown cannot appear as a value");
  }
  encodeType() {
    throw new Error("Unknown cannot be serialized");
  }
  decodeValue(b4, t2) {
    let decodedValue = t2.decodeValue(b4, t2);
    if (Object(decodedValue) !== decodedValue) {
      decodedValue = Object(decodedValue);
    }
    let typeFunc;
    if (t2 instanceof RecClass) {
      typeFunc = () => t2.getType();
    } else {
      typeFunc = () => t2;
    }
    Object.defineProperty(decodedValue, "type", {
      value: typeFunc,
      writable: true,
      enumerable: false,
      configurable: true
    });
    return decodedValue;
  }
  _buildTypeTableImpl() {
    throw new Error("Unknown cannot be serialized");
  }
  get name() {
    return "Unknown";
  }
};
var BoolClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitBool(this, d);
  }
  covariant(x) {
    if (typeof x === "boolean")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return new Uint8Array([x ? 1 : 0]);
  }
  encodeType() {
    return slebEncode(
      -2
      /* IDLTypeIds.Bool */
    );
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    switch (safeReadUint8(b4)) {
      case 0:
        return false;
      case 1:
        return true;
      default:
        throw new Error("Boolean value out of range");
    }
  }
  get name() {
    return "bool";
  }
};
var NullClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitNull(this, d);
  }
  covariant(x) {
    if (x === null)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue() {
    return new ArrayBuffer(0);
  }
  encodeType() {
    return slebEncode(
      -1
      /* IDLTypeIds.Null */
    );
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    return null;
  }
  get name() {
    return "null";
  }
};
var ReservedClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitReserved(this, d);
  }
  covariant(x) {
    return true;
  }
  encodeValue() {
    return new ArrayBuffer(0);
  }
  encodeType() {
    return slebEncode(
      -16
      /* IDLTypeIds.Reserved */
    );
  }
  decodeValue(b4, t2) {
    if (t2.name !== this.name) {
      t2.decodeValue(b4, t2);
    }
    return null;
  }
  get name() {
    return "reserved";
  }
};
var TextClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitText(this, d);
  }
  covariant(x) {
    if (typeof x === "string")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = new TextEncoder().encode(x);
    const len = lebEncode(buf.byteLength);
    return concat(len, buf);
  }
  encodeType() {
    return slebEncode(
      -15
      /* IDLTypeIds.Text */
    );
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    const len = lebDecode(b4);
    const buf = safeRead(b4, Number(len));
    const decoder = new TextDecoder("utf8", { fatal: true });
    return decoder.decode(buf);
  }
  get name() {
    return "text";
  }
  valueToString(x) {
    return '"' + x + '"';
  }
};
var IntClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitInt(this, d);
  }
  covariant(x) {
    if (typeof x === "bigint" || Number.isInteger(x))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return slebEncode(x);
  }
  encodeType() {
    return slebEncode(
      -4
      /* IDLTypeIds.Int */
    );
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    return slebDecode(b4);
  }
  get name() {
    return "int";
  }
  valueToString(x) {
    return x.toString();
  }
};
var NatClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitNat(this, d);
  }
  covariant(x) {
    if (typeof x === "bigint" && x >= BigInt(0) || Number.isInteger(x) && x >= 0)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return lebEncode(x);
  }
  encodeType() {
    return slebEncode(
      -3
      /* IDLTypeIds.Nat */
    );
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    return lebDecode(b4);
  }
  get name() {
    return "nat";
  }
  valueToString(x) {
    return x.toString();
  }
};
var FloatClass = class extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
    if (_bits !== 32 && _bits !== 64) {
      throw new Error("not a valid float type");
    }
  }
  accept(v2, d) {
    return v2.visitFloat(this, d);
  }
  covariant(x) {
    if (typeof x === "number" || x instanceof Number)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = new ArrayBuffer(this._bits / 8);
    const view = new DataView(buf);
    if (this._bits === 32) {
      view.setFloat32(0, x, true);
    } else {
      view.setFloat64(0, x, true);
    }
    return buf;
  }
  encodeType() {
    const opcode = this._bits === 32 ? -13 : -14;
    return slebEncode(opcode);
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    const bytes4 = safeRead(b4, this._bits / 8);
    const view = new DataView(bytes4);
    if (this._bits === 32) {
      return view.getFloat32(0, true);
    } else {
      return view.getFloat64(0, true);
    }
  }
  get name() {
    return "float" + this._bits;
  }
  valueToString(x) {
    return x.toString();
  }
};
var FixedIntClass = class extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v2, d) {
    return v2.visitFixedInt(this, d);
  }
  covariant(x) {
    const min2 = iexp2(this._bits - 1) * BigInt(-1);
    const max = iexp2(this._bits - 1) - BigInt(1);
    let ok = false;
    if (typeof x === "bigint") {
      ok = x >= min2 && x <= max;
    } else if (Number.isInteger(x)) {
      const v2 = BigInt(x);
      ok = v2 >= min2 && v2 <= max;
    } else {
      ok = false;
    }
    if (ok)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return writeIntLE(x, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode(-9 - offset);
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    const num = readIntLE(b4, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `int${this._bits}`;
  }
  valueToString(x) {
    return x.toString();
  }
};
var FixedNatClass = class extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v2, d) {
    return v2.visitFixedNat(this, d);
  }
  covariant(x) {
    const max = iexp2(this._bits);
    let ok = false;
    if (typeof x === "bigint" && x >= BigInt(0)) {
      ok = x < max;
    } else if (Number.isInteger(x) && x >= 0) {
      const v2 = BigInt(x);
      ok = v2 < max;
    } else {
      ok = false;
    }
    if (ok)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return writeUIntLE(x, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode(-5 - offset);
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    const num = readUIntLE(b4, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `nat${this._bits}`;
  }
  valueToString(x) {
    return x.toString();
  }
};
var VecClass = class _VecClass extends ConstructType {
  constructor(_type) {
    super();
    this._type = _type;
    this._blobOptimization = false;
    if (_type instanceof FixedNatClass && _type._bits === 8) {
      this._blobOptimization = true;
    }
  }
  accept(v2, d) {
    return v2.visitVec(this, this._type, d);
  }
  covariant(x) {
    const bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;
    if (ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8 || Array.isArray(x) && x.every((v2, idx) => {
      try {
        return this._type.covariant(v2);
      } catch (e3) {
        throw new Error(`Invalid ${this.display()} argument: 

index ${idx} -> ${e3.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const len = lebEncode(x.length);
    if (this._blobOptimization) {
      return concat(len, new Uint8Array(x));
    }
    if (ArrayBuffer.isView(x)) {
      return concat(len, new Uint8Array(x.buffer));
    }
    const buf = new PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);
    buf.write(len);
    for (const d of x) {
      const encoded = this._type.encodeValue(d);
      buf.write(new Uint8Array(encoded));
    }
    return buf.buffer;
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode(
      -19
      /* IDLTypeIds.Vector */
    );
    const buffer = this._type.encodeType(typeTable);
    typeTable.add(this, concat(opCode, buffer));
  }
  decodeValue(b4, t2) {
    const vec = this.checkType(t2);
    if (!(vec instanceof _VecClass)) {
      throw new Error("Not a vector type");
    }
    const len = Number(lebDecode(b4));
    if (this._type instanceof FixedNatClass) {
      if (this._type._bits == 8) {
        return new Uint8Array(b4.read(len));
      }
      if (this._type._bits == 16) {
        return new Uint16Array(b4.read(len * 2));
      }
      if (this._type._bits == 32) {
        return new Uint32Array(b4.read(len * 4));
      }
      if (this._type._bits == 64) {
        return new BigUint64Array(b4.read(len * 8));
      }
    }
    if (this._type instanceof FixedIntClass) {
      if (this._type._bits == 8) {
        return new Int8Array(b4.read(len));
      }
      if (this._type._bits == 16) {
        return new Int16Array(b4.read(len * 2));
      }
      if (this._type._bits == 32) {
        return new Int32Array(b4.read(len * 4));
      }
      if (this._type._bits == 64) {
        return new BigInt64Array(b4.read(len * 8));
      }
    }
    const rets = [];
    for (let i2 = 0; i2 < len; i2++) {
      rets.push(this._type.decodeValue(b4, vec._type));
    }
    return rets;
  }
  get name() {
    return `vec ${this._type.name}`;
  }
  display() {
    return `vec ${this._type.display()}`;
  }
  valueToString(x) {
    const elements = x.map((e3) => this._type.valueToString(e3));
    return "vec {" + elements.join("; ") + "}";
  }
};
var OptClass = class _OptClass extends ConstructType {
  constructor(_type) {
    super();
    this._type = _type;
  }
  accept(v2, d) {
    return v2.visitOpt(this, this._type, d);
  }
  covariant(x) {
    try {
      if (Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0])))
        return true;
    } catch (e3) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} 

-> ${e3.message}`);
    }
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    if (x.length === 0) {
      return new Uint8Array([0]);
    } else {
      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));
    }
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode(
      -18
      /* IDLTypeIds.Opt */
    );
    const buffer = this._type.encodeType(typeTable);
    typeTable.add(this, concat(opCode, buffer));
  }
  decodeValue(b4, t2) {
    if (t2 instanceof NullClass) {
      return [];
    }
    if (t2 instanceof ReservedClass) {
      return [];
    }
    let wireType = t2;
    if (t2 instanceof RecClass) {
      const ty = t2.getType();
      if (typeof ty === "undefined") {
        throw new Error("type mismatch with uninitialized type");
      } else
        wireType = ty;
    }
    if (wireType instanceof _OptClass) {
      switch (safeReadUint8(b4)) {
        case 0:
          return [];
        case 1: {
          const checkpoint = b4.save();
          try {
            const v2 = this._type.decodeValue(b4, wireType._type);
            return [v2];
          } catch (e3) {
            b4.restore(checkpoint);
            const skipped = wireType._type.decodeValue(b4, wireType._type);
            return [];
          }
        }
        default:
          throw new Error("Not an option value");
      }
    } else if (this._type instanceof NullClass || this._type instanceof _OptClass || this._type instanceof ReservedClass) {
      const skipped = wireType.decodeValue(b4, wireType);
      return [];
    } else {
      const checkpoint = b4.save();
      try {
        const v2 = this._type.decodeValue(b4, t2);
        return [v2];
      } catch (e3) {
        b4.restore(checkpoint);
        const skipped = wireType.decodeValue(b4, t2);
        return [];
      }
    }
  }
  get name() {
    return `opt ${this._type.name}`;
  }
  display() {
    return `opt ${this._type.display()}`;
  }
  valueToString(x) {
    if (x.length === 0) {
      return "null";
    } else {
      return `opt ${this._type.valueToString(x[0])}`;
    }
  }
};
var RecordClass = class _RecordClass extends ConstructType {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a2, b4) => idlLabelToId(a2[0]) - idlLabelToId(b4[0]));
  }
  accept(v2, d) {
    return v2.visitRecord(this, this._fields, d);
  }
  tryAsTuple() {
    const res = [];
    for (let i2 = 0; i2 < this._fields.length; i2++) {
      const [key, type] = this._fields[i2];
      if (key !== `_${i2}_`) {
        return null;
      }
      res.push(type);
    }
    return res;
  }
  covariant(x) {
    if (typeof x === "object" && this._fields.every(([k, t2]) => {
      if (!x.hasOwnProperty(k)) {
        throw new Error(`Record is missing key "${k}".`);
      }
      try {
        return t2.covariant(x[k]);
      } catch (e3) {
        throw new Error(`Invalid ${this.display()} argument: 

field ${k} -> ${e3.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const values = this._fields.map(([key]) => x[key]);
    const bufs = zipWith(this._fields, values, ([, c2], d) => c2.encodeValue(d));
    return concat(...bufs);
  }
  _buildTypeTableImpl(T) {
    this._fields.forEach(([_, value]) => value.buildTypeTable(T));
    const opCode = slebEncode(
      -20
      /* IDLTypeIds.Record */
    );
    const len = lebEncode(this._fields.length);
    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(T)));
    T.add(this, concat(opCode, len, concat(...fields)));
  }
  decodeValue(b4, t2) {
    const record = this.checkType(t2);
    if (!(record instanceof _RecordClass)) {
      throw new Error("Not a record type");
    }
    const x = {};
    let expectedRecordIdx = 0;
    let actualRecordIdx = 0;
    while (actualRecordIdx < record._fields.length) {
      const [hash3, type] = record._fields[actualRecordIdx];
      if (expectedRecordIdx >= this._fields.length) {
        type.decodeValue(b4, type);
        actualRecordIdx++;
        continue;
      }
      const [expectKey, expectType] = this._fields[expectedRecordIdx];
      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);
      const actualId = idlLabelToId(hash3);
      if (expectedId === actualId) {
        x[expectKey] = expectType.decodeValue(b4, type);
        expectedRecordIdx++;
        actualRecordIdx++;
      } else if (actualId > expectedId) {
        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
          x[expectKey] = [];
          expectedRecordIdx++;
        } else {
          throw new Error("Cannot find required field " + expectKey);
        }
      } else {
        type.decodeValue(b4, type);
        actualRecordIdx++;
      }
    }
    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {
      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
        x[expectKey] = [];
      } else {
        throw new Error("Cannot find required field " + expectKey);
      }
    }
    return x;
  }
  get name() {
    const fields = this._fields.map(([key, value]) => key + ":" + value.name);
    return `record {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, value]) => key + ":" + value.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(x) {
    const values = this._fields.map(([key]) => x[key]);
    const fields = zipWith(this._fields, values, ([k, c2], d) => k + "=" + c2.valueToString(d));
    return `record {${fields.join("; ")}}`;
  }
};
var TupleClass = class _TupleClass extends RecordClass {
  constructor(_components) {
    const x = {};
    _components.forEach((e3, i2) => x["_" + i2 + "_"] = e3);
    super(x);
    this._components = _components;
  }
  accept(v2, d) {
    return v2.visitTuple(this, this._components, d);
  }
  covariant(x) {
    if (Array.isArray(x) && x.length >= this._fields.length && this._components.every((t2, i2) => {
      try {
        return t2.covariant(x[i2]);
      } catch (e3) {
        throw new Error(`Invalid ${this.display()} argument: 

index ${i2} -> ${e3.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const bufs = zipWith(this._components, x, (c2, d) => c2.encodeValue(d));
    return concat(...bufs);
  }
  decodeValue(b4, t2) {
    const tuple = this.checkType(t2);
    if (!(tuple instanceof _TupleClass)) {
      throw new Error("not a tuple type");
    }
    if (tuple._components.length < this._components.length) {
      throw new Error("tuple mismatch");
    }
    const res = [];
    for (const [i2, wireType] of tuple._components.entries()) {
      if (i2 >= this._components.length) {
        wireType.decodeValue(b4, wireType);
      } else {
        res.push(this._components[i2].decodeValue(b4, wireType));
      }
    }
    return res;
  }
  display() {
    const fields = this._components.map((value) => value.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(values) {
    const fields = zipWith(this._components, values, (c2, d) => c2.valueToString(d));
    return `record {${fields.join("; ")}}`;
  }
};
var VariantClass = class _VariantClass extends ConstructType {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a2, b4) => idlLabelToId(a2[0]) - idlLabelToId(b4[0]));
  }
  accept(v2, d) {
    return v2.visitVariant(this, this._fields, d);
  }
  covariant(x) {
    if (typeof x === "object" && Object.entries(x).length === 1 && this._fields.every(([k, v2]) => {
      try {
        return !x.hasOwnProperty(k) || v2.covariant(x[k]);
      } catch (e3) {
        throw new Error(`Invalid ${this.display()} argument: 

variant ${k} -> ${e3.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    for (let i2 = 0; i2 < this._fields.length; i2++) {
      const [name, type] = this._fields[i2];
      if (x.hasOwnProperty(name)) {
        const idx = lebEncode(i2);
        const buf = type.encodeValue(x[name]);
        return concat(idx, buf);
      }
    }
    throw Error("Variant has no data: " + x);
  }
  _buildTypeTableImpl(typeTable) {
    this._fields.forEach(([, type]) => {
      type.buildTypeTable(typeTable);
    });
    const opCode = slebEncode(
      -21
      /* IDLTypeIds.Variant */
    );
    const len = lebEncode(this._fields.length);
    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)));
    typeTable.add(this, concat(opCode, len, ...fields));
  }
  decodeValue(b4, t2) {
    const variant = this.checkType(t2);
    if (!(variant instanceof _VariantClass)) {
      throw new Error("Not a variant type");
    }
    const idx = Number(lebDecode(b4));
    if (idx >= variant._fields.length) {
      throw Error("Invalid variant index: " + idx);
    }
    const [wireHash, wireType] = variant._fields[idx];
    for (const [key, expectType] of this._fields) {
      if (idlLabelToId(wireHash) === idlLabelToId(key)) {
        const value = expectType.decodeValue(b4, wireType);
        return { [key]: value };
      }
    }
    throw new Error("Cannot find field hash " + wireHash);
  }
  get name() {
    const fields = this._fields.map(([key, type]) => key + ":" + type.name);
    return `variant {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, type]) => key + (type.name === "null" ? "" : `:${type.display()}`));
    return `variant {${fields.join("; ")}}`;
  }
  valueToString(x) {
    for (const [name, type] of this._fields) {
      if (x.hasOwnProperty(name)) {
        const value = type.valueToString(x[name]);
        if (value === "null") {
          return `variant {${name}}`;
        } else {
          return `variant {${name}=${value}}`;
        }
      }
    }
    throw new Error("Variant has no data: " + x);
  }
};
var RecClass = class _RecClass extends ConstructType {
  constructor() {
    super(...arguments);
    this._id = _RecClass._counter++;
    this._type = void 0;
  }
  accept(v2, d) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return v2.visitRec(this, this._type, d);
  }
  fill(t2) {
    this._type = t2;
  }
  getType() {
    return this._type;
  }
  covariant(x) {
    if (this._type ? this._type.covariant(x) : false)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.encodeValue(x);
  }
  _buildTypeTableImpl(typeTable) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    typeTable.add(this, new Uint8Array([]));
    this._type.buildTypeTable(typeTable);
    typeTable.merge(this, this._type.name);
  }
  decodeValue(b4, t2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.decodeValue(b4, t2);
  }
  get name() {
    return `rec_${this._id}`;
  }
  display() {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return `\u03BC${this.name}.${this._type.name}`;
  }
  valueToString(x) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.valueToString(x);
  }
};
RecClass._counter = 0;
function decodePrincipalId(b4) {
  const x = safeReadUint8(b4);
  if (x !== 1) {
    throw new Error("Cannot decode principal");
  }
  const len = Number(lebDecode(b4));
  return Principal.fromUint8Array(new Uint8Array(safeRead(b4, len)));
}
var PrincipalClass = class extends PrimitiveType {
  accept(v2, d) {
    return v2.visitPrincipal(this, d);
  }
  covariant(x) {
    if (x && x._isPrincipal)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = x.toUint8Array();
    const len = lebEncode(buf.byteLength);
    return concat(new Uint8Array([1]), len, buf);
  }
  encodeType() {
    return slebEncode(
      -24
      /* IDLTypeIds.Principal */
    );
  }
  decodeValue(b4, t2) {
    this.checkType(t2);
    return decodePrincipalId(b4);
  }
  get name() {
    return "principal";
  }
  valueToString(x) {
    return `${this.name} "${x.toText()}"`;
  }
};
var FuncClass = class extends ConstructType {
  constructor(argTypes, retTypes, annotations = []) {
    super();
    this.argTypes = argTypes;
    this.retTypes = retTypes;
    this.annotations = annotations;
  }
  static argsToString(types, v2) {
    if (types.length !== v2.length) {
      throw new Error("arity mismatch");
    }
    return "(" + types.map((t2, i2) => t2.valueToString(v2[i2])).join(", ") + ")";
  }
  accept(v2, d) {
    return v2.visitFunc(this, d);
  }
  covariant(x) {
    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === "string")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue([principal, methodName]) {
    const buf = principal.toUint8Array();
    const len = lebEncode(buf.byteLength);
    const canister = concat(new Uint8Array([1]), len, buf);
    const method = new TextEncoder().encode(methodName);
    const methodLen = lebEncode(method.byteLength);
    return concat(new Uint8Array([1]), canister, methodLen, method);
  }
  _buildTypeTableImpl(T) {
    this.argTypes.forEach((arg) => arg.buildTypeTable(T));
    this.retTypes.forEach((arg) => arg.buildTypeTable(T));
    const opCode = slebEncode(
      -22
      /* IDLTypeIds.Func */
    );
    const argLen = lebEncode(this.argTypes.length);
    const args2 = concat(...this.argTypes.map((arg) => arg.encodeType(T)));
    const retLen = lebEncode(this.retTypes.length);
    const rets = concat(...this.retTypes.map((arg) => arg.encodeType(T)));
    const annLen = lebEncode(this.annotations.length);
    const anns = concat(...this.annotations.map((a2) => this.encodeAnnotation(a2)));
    T.add(this, concat(opCode, argLen, args2, retLen, rets, annLen, anns));
  }
  decodeValue(b4) {
    const x = safeReadUint8(b4);
    if (x !== 1) {
      throw new Error("Cannot decode function reference");
    }
    const canister = decodePrincipalId(b4);
    const mLen = Number(lebDecode(b4));
    const buf = safeRead(b4, mLen);
    const decoder = new TextDecoder("utf8", { fatal: true });
    const method = decoder.decode(buf);
    return [canister, method];
  }
  get name() {
    const args2 = this.argTypes.map((arg) => arg.name).join(", ");
    const rets = this.retTypes.map((arg) => arg.name).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args2}) -> (${rets})${annon}`;
  }
  valueToString([principal, str]) {
    return `func "${principal.toText()}".${str}`;
  }
  display() {
    const args2 = this.argTypes.map((arg) => arg.display()).join(", ");
    const rets = this.retTypes.map((arg) => arg.display()).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args2}) \u2192 (${rets})${annon}`;
  }
  encodeAnnotation(ann) {
    if (ann === "query") {
      return new Uint8Array([1]);
    } else if (ann === "oneway") {
      return new Uint8Array([2]);
    } else if (ann === "composite_query") {
      return new Uint8Array([3]);
    } else {
      throw new Error("Illegal function annotation");
    }
  }
};
var ServiceClass = class extends ConstructType {
  constructor(fields) {
    super();
    this._fields = Object.entries(fields).sort((a2, b4) => {
      if (a2[0] < b4[0]) {
        return -1;
      }
      if (a2[0] > b4[0]) {
        return 1;
      }
      return 0;
    });
  }
  accept(v2, d) {
    return v2.visitService(this, d);
  }
  covariant(x) {
    if (x && x._isPrincipal)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = x.toUint8Array();
    const len = lebEncode(buf.length);
    return concat(new Uint8Array([1]), len, buf);
  }
  _buildTypeTableImpl(T) {
    this._fields.forEach(([_, func]) => func.buildTypeTable(T));
    const opCode = slebEncode(
      -23
      /* IDLTypeIds.Service */
    );
    const len = lebEncode(this._fields.length);
    const meths = this._fields.map(([label, func]) => {
      const labelBuf = new TextEncoder().encode(label);
      const labelLen = lebEncode(labelBuf.length);
      return concat(labelLen, labelBuf, func.encodeType(T));
    });
    T.add(this, concat(opCode, len, ...meths));
  }
  decodeValue(b4) {
    return decodePrincipalId(b4);
  }
  get name() {
    const fields = this._fields.map(([key, value]) => key + ":" + value.name);
    return `service {${fields.join("; ")}}`;
  }
  valueToString(x) {
    return `service "${x.toText()}"`;
  }
};
function toReadableString(x) {
  const str = JSON.stringify(x, (_key, value) => typeof value === "bigint" ? `BigInt(${value})` : value);
  return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + "..." : str;
}
function encode4(argTypes, args2) {
  if (args2.length < argTypes.length) {
    throw Error("Wrong number of message arguments");
  }
  const typeTable = new TypeTable();
  argTypes.forEach((t2) => t2.buildTypeTable(typeTable));
  const magic = new TextEncoder().encode(magicNumber);
  const table = typeTable.encode();
  const len = lebEncode(args2.length);
  const typs = concat(...argTypes.map((t2) => t2.encodeType(typeTable)));
  const vals = concat(...zipWith(argTypes, args2, (t2, x) => {
    try {
      t2.covariant(x);
    } catch (e3) {
      const err3 = new Error(e3.message + "\n\n");
      throw err3;
    }
    return t2.encodeValue(x);
  }));
  return concat(magic, table, len, typs, vals);
}
function decode4(retTypes, bytes4) {
  const b4 = new PipeArrayBuffer(bytes4);
  if (bytes4.byteLength < magicNumber.length) {
    throw new Error("Message length smaller than magic number");
  }
  const magicBuffer = safeRead(b4, magicNumber.length);
  const magic = new TextDecoder().decode(magicBuffer);
  if (magic !== magicNumber) {
    throw new Error("Wrong magic number: " + JSON.stringify(magic));
  }
  function readTypeTable(pipe) {
    const typeTable = [];
    const len = Number(lebDecode(pipe));
    for (let i2 = 0; i2 < len; i2++) {
      const ty = Number(slebDecode(pipe));
      switch (ty) {
        case -18:
        case -19: {
          const t2 = Number(slebDecode(pipe));
          typeTable.push([ty, t2]);
          break;
        }
        case -20:
        case -21: {
          const fields = [];
          let objectLength = Number(lebDecode(pipe));
          let prevHash;
          while (objectLength--) {
            const hash3 = Number(lebDecode(pipe));
            if (hash3 >= Math.pow(2, 32)) {
              throw new Error("field id out of 32-bit range");
            }
            if (typeof prevHash === "number" && prevHash >= hash3) {
              throw new Error("field id collision or not sorted");
            }
            prevHash = hash3;
            const t2 = Number(slebDecode(pipe));
            fields.push([hash3, t2]);
          }
          typeTable.push([ty, fields]);
          break;
        }
        case -22: {
          const args2 = [];
          let argLength = Number(lebDecode(pipe));
          while (argLength--) {
            args2.push(Number(slebDecode(pipe)));
          }
          const returnValues = [];
          let returnValuesLength = Number(lebDecode(pipe));
          while (returnValuesLength--) {
            returnValues.push(Number(slebDecode(pipe)));
          }
          const annotations = [];
          let annotationLength = Number(lebDecode(pipe));
          while (annotationLength--) {
            const annotation = Number(lebDecode(pipe));
            switch (annotation) {
              case 1: {
                annotations.push("query");
                break;
              }
              case 2: {
                annotations.push("oneway");
                break;
              }
              case 3: {
                annotations.push("composite_query");
                break;
              }
              default:
                throw new Error("unknown annotation");
            }
          }
          typeTable.push([ty, [args2, returnValues, annotations]]);
          break;
        }
        case -23: {
          let servLength = Number(lebDecode(pipe));
          const methods = [];
          while (servLength--) {
            const nameLength = Number(lebDecode(pipe));
            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));
            const funcType = slebDecode(pipe);
            methods.push([funcName, funcType]);
          }
          typeTable.push([ty, methods]);
          break;
        }
        default:
          throw new Error("Illegal op_code: " + ty);
      }
    }
    const rawList = [];
    const length = Number(lebDecode(pipe));
    for (let i2 = 0; i2 < length; i2++) {
      rawList.push(Number(slebDecode(pipe)));
    }
    return [typeTable, rawList];
  }
  const [rawTable, rawTypes] = readTypeTable(b4);
  if (rawTypes.length < retTypes.length) {
    throw new Error("Wrong number of return values");
  }
  const table = rawTable.map((_) => Rec());
  function getType(t2) {
    if (t2 < -24) {
      throw new Error("future value not supported");
    }
    if (t2 < 0) {
      switch (t2) {
        case -1:
          return Null;
        case -2:
          return Bool;
        case -3:
          return Nat;
        case -4:
          return Int;
        case -5:
          return Nat8;
        case -6:
          return Nat16;
        case -7:
          return Nat32;
        case -8:
          return Nat64;
        case -9:
          return Int8;
        case -10:
          return Int16;
        case -11:
          return Int32;
        case -12:
          return Int64;
        case -13:
          return Float32;
        case -14:
          return Float64;
        case -15:
          return Text;
        case -16:
          return Reserved;
        case -17:
          return Empty;
        case -24:
          return Principal2;
        default:
          throw new Error("Illegal op_code: " + t2);
      }
    }
    if (t2 >= rawTable.length) {
      throw new Error("type index out of range");
    }
    return table[t2];
  }
  function buildType(entry) {
    switch (entry[0]) {
      case -19: {
        const ty = getType(entry[1]);
        return Vec(ty);
      }
      case -18: {
        const ty = getType(entry[1]);
        return Opt(ty);
      }
      case -20: {
        const fields = {};
        for (const [hash3, ty] of entry[1]) {
          const name = `_${hash3}_`;
          fields[name] = getType(ty);
        }
        const record = Record(fields);
        const tuple = record.tryAsTuple();
        if (Array.isArray(tuple)) {
          return Tuple(...tuple);
        } else {
          return record;
        }
      }
      case -21: {
        const fields = {};
        for (const [hash3, ty] of entry[1]) {
          const name = `_${hash3}_`;
          fields[name] = getType(ty);
        }
        return Variant(fields);
      }
      case -22: {
        const [args2, returnValues, annotations] = entry[1];
        return Func(args2.map((t2) => getType(t2)), returnValues.map((t2) => getType(t2)), annotations);
      }
      case -23: {
        const rec = {};
        const methods = entry[1];
        for (const [name, typeRef] of methods) {
          let type = getType(typeRef);
          if (type instanceof RecClass) {
            type = type.getType();
          }
          if (!(type instanceof FuncClass)) {
            throw new Error("Illegal service definition: services can only contain functions");
          }
          rec[name] = type;
        }
        return Service(rec);
      }
      default:
        throw new Error("Illegal op_code: " + entry[0]);
    }
  }
  rawTable.forEach((entry, i2) => {
    if (entry[0] === -22) {
      const t2 = buildType(entry);
      table[i2].fill(t2);
    }
  });
  rawTable.forEach((entry, i2) => {
    if (entry[0] !== -22) {
      const t2 = buildType(entry);
      table[i2].fill(t2);
    }
  });
  const types = rawTypes.map((t2) => getType(t2));
  const output3 = retTypes.map((t2, i2) => {
    return t2.decodeValue(b4, types[i2]);
  });
  for (let ind = retTypes.length; ind < types.length; ind++) {
    types[ind].decodeValue(b4, types[ind]);
  }
  if (b4.byteLength > 0) {
    throw new Error("decode: Left-over bytes");
  }
  return output3;
}
var Empty = new EmptyClass();
var Reserved = new ReservedClass();
var Unknown = new UnknownClass();
var Bool = new BoolClass();
var Null = new NullClass();
var Text = new TextClass();
var Int = new IntClass();
var Nat = new NatClass();
var Float32 = new FloatClass(32);
var Float64 = new FloatClass(64);
var Int8 = new FixedIntClass(8);
var Int16 = new FixedIntClass(16);
var Int32 = new FixedIntClass(32);
var Int64 = new FixedIntClass(64);
var Nat8 = new FixedNatClass(8);
var Nat16 = new FixedNatClass(16);
var Nat32 = new FixedNatClass(32);
var Nat64 = new FixedNatClass(64);
var Principal2 = new PrincipalClass();
function Tuple(...types) {
  return new TupleClass(types);
}
function Vec(t2) {
  return new VecClass(t2);
}
function Opt(t2) {
  return new OptClass(t2);
}
function Record(t2) {
  return new RecordClass(t2);
}
function Variant(fields) {
  return new VariantClass(fields);
}
function Rec() {
  return new RecClass();
}
function Func(args2, ret, annotations = []) {
  return new FuncClass(args2, ret, annotations);
}
function Service(t2) {
  return new ServiceClass(t2);
}

// node_modules/azle/src/stable/lib/ic_apis/msg_arg_data.ts
function msgArgData() {
  if (globalThis._azleIcExperimental !== void 0) {
    return new Uint8Array(globalThis._azleIcExperimental.msgArgData());
  }
  if (globalThis._azleIc !== void 0) {
    return globalThis._azleIc.msgArgData();
  }
  return new Uint8Array();
}

// node_modules/azle/src/stable/lib/ic_apis/msg_method_name.ts
function msgMethodName() {
  if (globalThis._azleIcExperimental !== void 0) {
    return globalThis._azleIcExperimental.msgMethodName();
  }
  if (globalThis._azleIc !== void 0) {
    return globalThis._azleIc.msgMethodName();
  }
  return "";
}

// node_modules/azle/src/stable/lib/ic_apis/msg_reply.ts
function msgReply(data) {
  if (globalThis._azleIcExperimental !== void 0) {
    globalThis._azleIcExperimental.msgReply(
      data.buffer instanceof ArrayBuffer ? data.buffer : new Uint8Array(data).buffer
    );
  }
  if (globalThis._azleIc !== void 0) {
    globalThis._azleIc.msgReply(data);
  }
}

// node_modules/azle/src/stable/lib/execute_and_reply_with_candid_serde.ts
async function executeAndReplyWithCandidSerde(mode, callback, paramIdlTypes, returnIdlType, manual, canisterMethodIdlParamTypes) {
  const decodedArgs = decodeArgs(
    mode,
    manual,
    paramIdlTypes,
    canisterMethodIdlParamTypes
  );
  const unencodedResult = await getUnencodedResult(
    mode,
    manual,
    decodedArgs,
    callback
  );
  if (globalThis._azleIc !== void 0) {
    globalThis._azleIc.drainMicrotasks();
  }
  if (globalThis._azleIcExperimental !== void 0) {
    globalThis._azleIcExperimental.drainMicrotasks();
  }
  encodeResultAndReply(mode, manual, unencodedResult, returnIdlType);
}
function decodeArgs(mode, manual, paramIdlTypes, canisterMethodIdlParamTypes) {
  if (manual === true) {
    return [];
  }
  if (mode === "init" || mode === "postUpgrade" || mode === "query" || mode === "update") {
    return idlDecode(paramIdlTypes, msgArgData());
  }
  if (mode === "inspectMessage") {
    const methodName = msgMethodName();
    if (methodName === "_azle_reject_callbacks_len" || methodName === "_azle_resolve_callbacks_len" || methodName === "_azle_timer_callbacks_len" || methodName === "_azle_actions_len" || methodName === "_azle_inter_canister_call_futures_len" || methodName === "_azle_is_job_queue_empty") {
      return [];
    }
    const paramIdlTypes2 = canisterMethodIdlParamTypes?.[methodName]?.argTypes;
    if (paramIdlTypes2 === void 0) {
      throw new Error(
        `@inspectMessage could not find the IDL types for method ${methodName}`
      );
    }
    return idlDecode(paramIdlTypes2, msgArgData());
  }
  return [];
}
async function getUnencodedResult(mode, manual, args2, callback) {
  if (mode === "inspectMessage") {
    const result2 = await callback(
      ...manual === true ? [] : [msgMethodName(), ...args2]
    );
    if (result2 === true) {
      if (globalThis._azleIc === void 0 && globalThis._azleIcExperimental === void 0) {
        throw new Error(
          "Neither globalThis._azleIc nor globalThis._azleIcExperimental are defined"
        );
      }
      if (globalThis._azleIc !== void 0) {
        globalThis._azleIc.acceptMessage();
      }
      if (globalThis._azleIcExperimental !== void 0) {
        globalThis._azleIcExperimental.acceptMessage();
      }
    }
  } else {
    return await callback(...args2);
  }
}
function encodeResultAndReply(mode, manual, unencodedResult, returnIdlType) {
  if (mode !== "query" && mode !== "update" || manual === true) {
    return;
  }
  const encodedResult = idlEncode(
    [...returnIdlType !== void 0 ? [returnIdlType] : []],
    [...unencodedResult !== void 0 ? [unencodedResult] : []]
  );
  msgReply(encodedResult);
}
function idlEncode(argTypes, args2) {
  try {
    const result2 = idl_exports.encode(argTypes, args2);
    return result2 instanceof Uint8Array ? result2 : new Uint8Array(result2);
  } catch (error2) {
    throw new Error(`Failed to encode Candid arguments: ${error2}`);
  }
}
function idlDecode(retTypes, bytes4) {
  try {
    return idl_exports.decode(
      retTypes,
      bytes4.buffer instanceof ArrayBuffer ? bytes4.buffer : new Uint8Array(bytes4).buffer
    );
  } catch (error2) {
    throw new Error(`Failed to decode Candid bytes: ${error2}`);
  }
}

// node_modules/azle/src/stable/lib/ic_apis/call.ts
async function call(canisterId2, method, options) {
  if (globalThis._azleIc === void 0 && globalThis._azleIcExperimental === void 0) {
    return void 0;
  }
  if (typeof options?.timeout === "number") {
    throw new Error("timeout is not yet implemented");
  }
  const canisterIdBytes = getCanisterIdBytes(canisterId2);
  const argsRaw2 = getArgsRaw(options);
  const cyclesString = getCyclesString(options);
  if (options?.oneway === true) {
    return handleOneWay(
      canisterIdBytes,
      method,
      argsRaw2,
      cyclesString
    );
  } else {
    return await handleTwoWay(
      canisterIdBytes,
      method,
      argsRaw2,
      cyclesString,
      options?.raw ?? false,
      options?.returnIdlType
    );
  }
}
function getCanisterIdBytes(canisterId2) {
  return typeof canisterId2 === "string" ? Principal.fromText(canisterId2).toUint8Array() : canisterId2.toUint8Array();
}
function getArgsRaw(callOptions) {
  if (callOptions?.raw === true) {
    if (callOptions?.args === void 0) {
      return new Uint8Array([68, 73, 68, 76, 0, 0]);
    }
    if (callOptions.args instanceof Uint8Array === false) {
      throw new Error(
        `args must be a Uint8Array. If you did not intend to make a raw call, then consider setting the raw property of the call options to undefined or false`
      );
    }
    return callOptions.args;
  } else {
    if (callOptions?.args instanceof Uint8Array === true) {
      throw new Error(
        `args must be an array of JavaScript values. If you intended to make a raw call, then consider setting the raw property of the call options to true`
      );
    }
    if (callOptions?.paramIdlTypes === void 0 && callOptions?.args === void 0) {
      return new Uint8Array([68, 73, 68, 76, 0, 0]);
    }
    return idlEncode(
      callOptions?.paramIdlTypes ?? [],
      callOptions?.args ?? []
    );
  }
}
function getCyclesString(options) {
  const cycles2 = options?.cycles ?? 0n;
  return cycles2.toString();
}
function handleOneWay(canisterIdBytes, method, argsRaw2, cyclesString) {
  return globalThis._azleIc !== void 0 ? globalThis._azleIc.notifyRaw(
    canisterIdBytes,
    method,
    argsRaw2,
    cyclesString
  ) : globalThis._azleIcExperimental !== void 0 ? globalThis._azleIcExperimental.notifyRaw(
    canisterIdBytes.buffer instanceof ArrayBuffer ? canisterIdBytes.buffer : new Uint8Array(canisterIdBytes).buffer,
    method,
    argsRaw2.buffer instanceof ArrayBuffer ? argsRaw2.buffer : new Uint8Array(argsRaw2).buffer,
    cyclesString
  ) : (() => {
    throw new Error(
      "Neither globalThis._azleIc nor globalThis._azleIcExperimental are defined"
    );
  })();
}
function handleTwoWay(canisterIdBytes, method, argsRaw2, cyclesString, raw, returnIdlType) {
  return new Promise((resolve3, reject) => {
    const promiseId = v4_default();
    const globalResolveId = `_resolve_${promiseId}`;
    const globalRejectId = `_reject_${promiseId}`;
    createResolveCallback(
      globalResolveId,
      resolve3,
      raw,
      returnIdlType
    );
    createRejectCallback(globalRejectId, reject);
    if (globalThis._azleIcExperimental === void 0 && globalThis._azleIc === void 0) {
      throw new Error(
        "Neither globalThis._azleIc nor globalThis._azleIcExperimental are defined"
      );
    }
    if (globalThis._azleIcExperimental !== void 0) {
      globalThis._azleIcExperimental.callRaw(
        globalResolveId,
        globalRejectId,
        canisterIdBytes.buffer instanceof ArrayBuffer ? canisterIdBytes.buffer : new Uint8Array(canisterIdBytes).buffer,
        method,
        argsRaw2.buffer instanceof ArrayBuffer ? argsRaw2.buffer : new Uint8Array(argsRaw2).buffer,
        cyclesString
      );
    }
    if (globalThis._azleIc !== void 0) {
      globalThis._azleIc.callRaw(
        globalResolveId,
        globalRejectId,
        canisterIdBytes,
        method,
        argsRaw2,
        cyclesString
      );
    }
  });
}
function createResolveCallback(globalResolveId, resolve3, raw, returnIdlType) {
  globalThis._azleDispatch({
    type: "SET_AZLE_RESOLVE_CALLBACK",
    payload: {
      globalResolveId,
      resolveCallback: (result2) => {
        if (raw === true) {
          resolve3(
            result2 instanceof Uint8Array ? result2 : new Uint8Array(result2)
          );
        } else {
          resolve3(
            idlDecode(
              returnIdlType === void 0 ? [] : [returnIdlType],
              result2 instanceof Uint8Array ? result2 : new Uint8Array(result2)
            )[0]
          );
        }
      }
    },
    location: {
      filepath: "azle/src/stable/lib/ic_apis/call.ts",
      functionName: "createResolveCallback"
    }
  });
}
function createRejectCallback(globalRejectId, reject) {
  globalThis._azleDispatch({
    type: "SET_AZLE_REJECT_CALLBACK",
    payload: {
      globalRejectId,
      rejectCallback: (error2) => {
        reject(error2);
      }
    },
    location: {
      filepath: "azle/src/stable/lib/ic_apis/call.ts",
      functionName: "createRejectCallback"
    }
  });
}

// node_modules/azle/src/stable/lib/ic_apis/trap.ts
function trap(message) {
  if (globalThis._azleIcExperimental !== void 0) {
    return globalThis._azleIcExperimental.trap(message);
  }
  if (globalThis._azleIc !== void 0) {
    return globalThis._azleIc.trap(message);
  }
  throw new Error(
    "Neither globalThis._azleIc nor globalThis._azleIcExperimental are defined"
  );
}

// node_modules/azle/src/stable/lib/error.ts
function handleUncaughtError(rawError) {
  const executingWithinCleanupCallback = rawError.type === "CleanupCallback" && rawError.rejectCode === 10001 && rawError.rejectMessage === "executing within cleanup callback";
  if (executingWithinCleanupCallback === true) {
    return;
  }
  if (rawError instanceof Error) {
    const error2 = rawError;
    trap(`Uncaught ${error2.name}: ${error2.message}
${error2.stack}`);
  } else {
    const error2 = new Error(rawError);
    trap(`Uncaught: ${error2.message}
${error2.stack}`);
  }
}

// node_modules/azle/src/stable/lib/ic_apis/performance_counter.ts
function performanceCounter(counterType) {
  if (globalThis._azleIcExperimental !== void 0) {
    return BigInt(
      globalThis._azleIcExperimental.performanceCounter(
        counterType.toString()
      )
    );
  }
  if (globalThis._azleIc !== void 0) {
    return globalThis._azleIc.performanceCounter(counterType);
  }
  return 0n;
}

// node_modules/azle/src/experimental/lib/ic/accept_message.ts
function acceptMessage() {
  if (globalThis._azleIcExperimental === void 0) {
    return;
  }
  globalThis._azleIcExperimental.acceptMessage();
}

// node_modules/azle/src/experimental/lib/ic/candid_compiler.ts
function candidCompiler(candidPath2) {
  if (globalThis._azleIcExperimental === void 0) {
    return "";
  }
  return globalThis._azleIcExperimental.candidCompiler(candidPath2);
}

// node_modules/azle/src/experimental/lib/ic/set_outgoing_http_options.ts
function setOutgoingHttpOptions(options) {
  globalThis._azleOutgoingHttpOptionsMaxResponseBytes = options.maxResponseBytes;
  globalThis._azleOutgoingHttpOptionsSubnetSize = options.subnetSize;
  globalThis._azleOutgoingHttpOptionsCycles = options.cycles;
  globalThis._azleOutgoingHttpOptionsTransformMethodName = options.transformMethodName;
  globalThis._azleOutgoingHttpOptionsTransformContext = options.transformContext;
}

// node_modules/azle/src/experimental/lib/ic/index.ts
var ic = {
  acceptMessage,
  candidCompiler,
  setOutgoingHttpOptions
};

// node_modules/azle/src/experimental/lib/fetch/icp.ts
async function fetchIcp(input, init) {
  const url = getUrl(input);
  const canisterId = url.hostname;
  const canisterMethod = url.pathname.replace("/", "");
  const { body } = init ?? {};
  const { args, cycles } = body ?? {};
  const candidPath = determineCandidPath(
    canisterId,
    body?.candidPath
  );
  const idlString = ic.candidCompiler(candidPath);
  const normalizedIdlString = idlString.replace(/export const idlFactory/g, "const idlFactory").replace(/export const init/g, "const init");
  const idlFactory = eval(`
        try {
            ${normalizedIdlString}

            idlFactory;
        }
        catch(error) {
            console.info('eval error');
            console.info(error);
        }
    `);
  const serviceIdl = idlFactory({ IDL: idl_exports });
  const [_funcName, funcIdl] = serviceIdl._fields.find(
    ([funcName]) => funcName === canisterMethod
  );
  const argsRaw = new Uint8Array(idl_exports.encode(funcIdl.argTypes, args ?? []));
  const canisterPrincipal = Principal.fromText(canisterId);
  const result = await call(
    canisterPrincipal,
    canisterMethod,
    {
      args: argsRaw,
      cycles: BigInt(cycles ?? 0),
      raw: true
    }
  );
  const decodedResult = idl_exports.decode(
    funcIdl.retTypes,
    new Uint8Array(result).buffer
  );
  return {
    ok: true,
    arrayBuffer: async () => {
      return result.buffer;
    },
    json: async () => {
      return decodedResult[0];
    },
    text: async () => {
      return Buffer.from(result.buffer).toString();
    }
  };
}
function determineCandidPath(canisterId2, candidPath2) {
  if (candidPath2 !== void 0) {
    return candidPath2;
  }
  if (canisterId2 === "aaaaa-aa") {
    return `/candid/icp/management.did`;
  }
  throw new Error(
    "azleFetch: Candid path doesn't exist, please specify a valid candid path"
  );
}

// node_modules/azle/src/experimental/lib/fetch/index.ts
async function azleFetch(input2, init6) {
  logWarnings(init6);
  if (process.env.AZLE_TEST_FETCH === "true") {
    console.info("azleFetch has been called");
  }
  const url2 = getUrl(input2);
  if (url2.protocol === "file:") {
    return await fetchFile(input2);
  }
  if (url2.protocol === "https:") {
    return await fetchHttp(input2, init6);
  }
  if (url2.protocol === "icp:") {
    return await fetchIcp(input2, init6);
  }
  throw new Error(`azleFetch: protocol ${url2.protocol} not supported`);
}
function serialize(param) {
  return param;
}
function logWarnings(init6) {
  if (init6 === void 0) {
    return;
  }
  if (init6.cache !== void 0) {
    logWarning(`cache`);
  }
  if (init6.credentials !== void 0) {
    logWarning(`credentials`);
  }
  if (init6.integrity !== void 0) {
    logWarning(`integrity`);
  }
  if (init6.keepalive !== void 0) {
    logWarning(`keepalive`);
  }
  if (init6.mode !== void 0) {
    logWarning(`mode`);
  }
  if (init6.redirect !== void 0) {
    logWarning(`redirect`);
  }
  if (init6.referrer !== void 0) {
    logWarning(`referrer`);
  }
  if (init6.referrerPolicy !== void 0) {
    logWarning(`referrerPolicy`);
  }
  if (init6.signal !== void 0) {
    logWarning(`signal`);
  }
  if (init6.window !== void 0) {
    logWarning(`window`);
  }
}
function logWarning(method) {
  console.warn(
    `azleFetch: init.${method} has no effect when using an identity as the Authorization header`
  );
}

// node_modules/azle/src/experimental/lib/globals.ts
if (globalThis._azleIcpReplicaWasmEnvironment === true || globalThis._azleNodejsWasmEnvironment === true) {
  globalThis.TextDecoder = import_text_encoding3.TextDecoder;
  globalThis.TextEncoder = import_text_encoding3.TextEncoder;
  globalThis.window = globalThis;
  const originalSetTimeout = setTimeout;
  globalThis.setTimeout = (handler, timeout) => {
    if (timeout !== void 0 && timeout !== 0) {
      console.warn(
        `Azle Warning: setTimeout may not behave as expected with milliseconds above 0; called with ${timeout} milliseconds`,
        new Error().stack
      );
    }
    return originalSetTimeout(handler, 0);
  };
  globalThis.Buffer = Buffer2;
  globalThis.process = process_exports;
  globalThis.process = {
    ...process_exports,
    stdout: {
      write: (message) => {
        stdioWrite(message);
      }
    },
    stderr: {
      write: (message) => {
        stdioWrite(message);
      }
    }
  };
  globalThis.clearInterval = () => {
  };
  globalThis.global = globalThis;
  globalThis.self = globalThis;
  globalThis.TypeError = globalThis.Error;
  globalThis.WebAssembly = {
    instantiate: (...args2) => {
      const uuid = v4_default();
      const instantiatedSource = globalThis._azleWebAssembly.instantiate(
        uuid,
        ...args2
      );
      const exportEntries = Object.entries(
        instantiatedSource.instance.exports
      );
      for (const [key, value] of exportEntries) {
        if (typeof value === "function") {
          instantiatedSource.instance.exports[key] = value.bind({
            instanceUuid: uuid,
            exportName: key
          });
        }
      }
      return instantiatedSource;
    }
  };
  globalThis.fetch = azleFetch;
  globalThis.URL = _URL;
  const originalExec = RegExp.prototype.exec;
  Object.defineProperty(RegExp.prototype, "leftContext", {
    value: "",
    writable: true,
    configurable: true
  });
  RegExp.prototype.exec = function(string) {
    const match = originalExec.call(this, string);
    if (match !== null) {
      RegExp.leftContext = (string ?? "").substring(0, match.index);
    }
    return match;
  };
  global.Intl = require_intl();
  require_en();
}
function stdioWrite(message) {
  const ansiEscapeRegex = /\u001b\[.*?m/g;
  const newlineRegex = /\n/g;
  const messageAnsiCodesRemoved = message.replace(ansiEscapeRegex, "").replace(newlineRegex, "");
  console.info(messageAnsiCodesRemoved);
}

// <stdin>
var import_reflect_metadata = __toESM(require_Reflect());

// node_modules/azle/src/experimental/lib/candid/manual.ts
function Manual(candidType) {
  return candidType;
}

// node_modules/azle/src/experimental/lib/candid/to_idl_type.ts
function toIdlType(candidType, parents = []) {
  if ("azleName" in candidType) {
    const parent = parents.find(
      (parent2) => parent2.name === candidType.azleName
    );
    if (parent !== void 0) {
      return parent.idlType;
    }
  }
  if ("isCanister" in candidType && candidType.isCanister) {
    return toIdlType(candidType(), parents);
  }
  return candidType.getIdlType(parents);
}
function toIdlTypeArray(candidTypes, parents = []) {
  if (Array.isArray(candidTypes)) {
    return candidTypes.map((value) => toIdlType(value, parents));
  }
  const idlType = toIdlType(candidTypes, parents);
  return Array.isArray(idlType) ? idlType : [idlType];
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/record.ts
function visitRecord(visitor, fields, data) {
  const candidFields = fields.reduce((acc, [memberName, memberIdlTypes]) => {
    const fieldData = data.js_data[memberName];
    const fieldClass = data.candidType[memberName];
    return {
      ...acc,
      [memberName]: memberIdlTypes.accept(visitor, {
        js_data: fieldData,
        candidType: fieldClass
      })
    };
  }, {});
  return candidFields;
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/recursive.ts
function visitRec(visitor, ty, data) {
  let candidType = data.candidType();
  if (candidType.isCanister) {
    candidType = candidType([]);
  }
  return ty.accept(visitor, {
    ...data,
    candidType
  });
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/tuple.ts
function visitTuple(visitor, components, data) {
  const fields = components.map(
    (value, index) => value.accept(visitor, {
      js_data: data.js_data[index],
      candidType: data.candidType.innerTypes[index]
    })
  );
  return [...fields];
}

// node_modules/azle/src/experimental/lib/system_types/result.ts
var AzleResult = class {
  constructor(ok, err3) {
    this.Ok = ok;
    this.Err = err3;
  }
  Ok;
  Err;
  getIdlType(parents) {
    return idl_exports.Variant({
      Ok: toIdlType(this.Ok, parents),
      Err: toIdlType(this.Err, parents)
    });
  }
};
function Result(ok, err3) {
  return new AzleResult(ok, err3);
}
((Result4) => {
  function Ok(value) {
    return { Ok: value };
  }
  Result4.Ok = Ok;
  function Err(value) {
    return { Err: value };
  }
  Result4.Err = Err;
})(Result || (Result = {}));

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/variant/azle_result.ts
function visitAzleResult(visitor, fields, data) {
  if ("Ok" in data.js_data) {
    const OK_FIELD_INDEX = 0;
    const okField = fields[OK_FIELD_INDEX];
    const okData = data.js_data["Ok"];
    const okClass = data.candidType.Ok;
    return Result.Ok(
      okField[1].accept(visitor, {
        js_data: okData,
        candidType: okClass
      })
    );
  }
  if ("Err" in data.js_data) {
    const ERR_FIELD_INDEX = 1;
    const errField = fields[ERR_FIELD_INDEX];
    const errData = data.js_data["Err"];
    const errClass = data.candidType.Err;
    return Result.Err(
      errField[1].accept(visitor, {
        js_data: errData,
        candidType: errClass
      })
    );
  }
  throw new Error("Invalid Result");
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/variant/azle_variant.ts
function visitAzleVariant(visitor, fields, data) {
  const candidFields = fields.reduce((acc, [memberName, memberIdlTypes]) => {
    const fieldData = data.js_data[memberName];
    const fieldClass = data.candidType[memberName];
    if (fieldData === void 0) {
      return acc;
    }
    return {
      ...acc,
      [memberName]: memberIdlTypes.accept(visitor, {
        candidType: fieldClass,
        js_data: fieldData
      })
    };
  }, {});
  return candidFields;
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/variant/index.ts
function visitVariant(visitor, fields, data) {
  if (data.candidType instanceof AzleResult) {
    return visitAzleResult(visitor, fields, data);
  }
  return visitAzleVariant(visitor, fields, data);
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/visit/vec.ts
function visitVec(visitor, ty, data) {
  if (ty instanceof idl_exports.PrimitiveType) {
    return data.js_data;
  }
  return data.js_data.map((array_elem) => {
    return ty.accept(visitor, {
      js_data: array_elem,
      candidType: data.candidType.innerType
    });
  });
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/decode_visitor.ts
var DecodeVisitor = class extends idl_exports.Visitor {
  visitService(t2, data) {
    return data.candidType(data.js_data);
  }
  visitFunc(t2, data) {
    return data.js_data;
  }
  visitPrimitive(t2, data) {
    return data.js_data;
  }
  visitTuple(t2, components, data) {
    return visitTuple(this, components, data);
  }
  /**
   * Converts empty arrays to `{None: null}` and an array with one item into
   * `{Some: value}`, transforming the value as needed as well.
   * @param t the IDL of the Opt class.
   * @param ty the IDL type of the `Some` value.
   * @param data {VisitorData<[] | [CandidType], AzleOpt<CandidType>>}
   * `data.js_data` is the raw array opt value. `data.js_class` is an
   * `AzleOpt<T>`.
   * @returns an object representation of an opt with a transformed some value
   * if necessary.
   */
  visitOpt(t2, ty, data) {
    if (data.js_data.length === 0) {
      return { None: null };
    }
    const candid = ty.accept(this, {
      js_data: data.js_data[0],
      candidType: data.candidType.innerType
    });
    return {
      Some: candid
    };
  }
  visitVec(t2, ty, data) {
    return visitVec(this, ty, data);
  }
  visitRec(t2, ty, data) {
    return visitRec(this, ty, data);
  }
  visitRecord(t2, fields, data) {
    return visitRecord(this, fields, data);
  }
  visitVariant(t2, fields, data) {
    return visitVariant(this, fields, data);
  }
};

// node_modules/azle/src/experimental/lib/candid/serde/decode.ts
function decode5(candidType, data) {
  const dataBuffer = data instanceof ArrayBuffer ? data : data.buffer instanceof ArrayBuffer ? data.buffer : new Uint8Array(data).buffer;
  if (Array.isArray(candidType)) {
    return decodeMultiple(candidType, dataBuffer);
  }
  return decodeSingle(candidType, dataBuffer);
}
function decodeSingle(candidType, data) {
  const idlType = toIdlType(candidType);
  const candidTypeWasAzleVoid = Array.isArray(idlType);
  if (candidTypeWasAzleVoid === true) {
    return void 0;
  }
  const candidDecodedValue = idl_exports.decode([idlType], data)[0];
  return idlType.accept(new DecodeVisitor(), {
    candidType,
    js_data: candidDecodedValue
  });
}
function decodeMultiple(candidTypes, data) {
  const idlTypes = toIdlTypeArray(candidTypes);
  const decoded = idl_exports.decode(idlTypes, data);
  return idlTypes.map(
    (idlType, index) => idlType.accept(new DecodeVisitor(), {
      candidType: candidTypes[index],
      js_data: decoded[index]
    })
  );
}

// node_modules/azle/src/experimental/lib/candid/serde/visitors/encode_visitor.ts
var EncodeVisitor = class extends idl_exports.Visitor {
  visitService(t2, data) {
    return data.js_data.principal;
  }
  visitFunc(t2, data) {
    return data.js_data;
  }
  visitPrimitive(t2, data) {
    return data.js_data;
  }
  visitTuple(t2, components, data) {
    return visitTuple(this, components, data);
  }
  /**
   * Converts `Some` values (`{Some: value}`) to `[value]` and `None` values
   * (`{None: null}`) to `[]` (the empty array), transforming any `Some`
   * values.
   *
   * @param t the IDL of the Opt class.
   * @param ty the IDL type of the `Some` value.
   * @param data {VisitorData<Variant<{Some: CandidType; None: null;}>,
   * AzleOpt<CandidType>>} `data.js_data` is the raw Some/None object.
   * `data.js_class` is an `AzleOpt<T>`.
   * @returns an array representation of an opt with a transformed some value
   * if necessary.
   */
  visitOpt(t2, ty, data) {
    if ("Some" in data.js_data) {
      const candid = ty.accept(this, {
        js_data: data.js_data.Some,
        candidType: data.candidType.innerType
      });
      return [candid];
    }
    return [];
  }
  visitVec(t2, ty, data) {
    return visitVec(this, ty, data);
  }
  visitRec(t2, ty, data) {
    return visitRec(this, ty, data);
  }
  visitRecord(t2, fields, data) {
    return visitRecord(this, fields, data);
  }
  visitVariant(t2, fields, data) {
    return visitVariant(this, fields, data);
  }
};

// node_modules/azle/src/experimental/lib/candid/serde/encode.ts
function encode5(candidType, data) {
  if (Array.isArray(candidType)) {
    if (Array.isArray(data)) {
      return encodeMultiple(candidType, data);
    }
    throw new Error(
      "If multiple candid types are given then multiple data entries are expected."
    );
  }
  return encodeSingle(candidType, data);
}
function encodeSingle(candidType, data) {
  const idlType = toIdlType(candidType);
  const candidTypeWasAzleVoid = Array.isArray(idlType);
  if (candidTypeWasAzleVoid === true) {
    return new Uint8Array(idl_exports.encode([], []));
  }
  const encodeReadyKey = idlType.accept(new EncodeVisitor(), {
    candidType,
    js_data: data
  });
  return new Uint8Array(idl_exports.encode([idlType], [encodeReadyKey]));
}
function encodeMultiple(candidTypes, data) {
  const idlTypes = toIdlTypeArray(candidTypes);
  const values = data.map(
    (datum, index) => idlTypes[index].accept(new EncodeVisitor(), {
      candidType: candidTypes[index],
      js_data: datum
    })
  );
  return new Uint8Array(idl_exports.encode(idlTypes, values));
}

// node_modules/azle/src/experimental/lib/candid/types/constructed/blob.ts
var AzleBlob = class {
  _azleKind = "AzleBlob";
  static _azleKind = "AzleBlob";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Vec(idl_exports.Nat8);
  }
};
var blob = AzleBlob;

// node_modules/azle/src/experimental/lib/candid/types/constructed/opt.ts
function Opt2(t2) {
  return new AzleOpt(t2);
}
var AzleOpt = class {
  constructor(t2) {
    this.innerType = t2;
  }
  tsType = {};
  innerType;
  _azleKind = "AzleOpt";
  static _azleKind = "AzleOpt";
  toBytes(data) {
    return encode5(this, data);
  }
  // TODO make this function's return type explicit https://github.com/demergent-labs/azle/issues/1860
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  getIdlType(parents) {
    return idl_exports.Opt(toIdlType(this.innerType, parents));
  }
};

// node_modules/azle/src/experimental/lib/candid/types/constructed/to_idl_map.ts
function toIdlTypeMap(candidMap, parent) {
  const idlTypeMap = {};
  for (const key in candidMap) {
    if (Object.prototype.hasOwnProperty.call(candidMap, key)) {
      const candidType = candidMap[key];
      idlTypeMap[key] = toIdlType(candidType, parent);
    }
  }
  return idlTypeMap;
}

// node_modules/azle/src/experimental/lib/candid/types/constructed/record.ts
function Record2(obj) {
  return {
    ...obj,
    tsType: {},
    toBytes(data) {
      return encode5(this, data);
    },
    // TODO make this function's return type explicit https://github.com/demergent-labs/azle/issues/1860
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    fromBytes(bytes4) {
      return decode5(this, bytes4);
    },
    getIdlType(parents) {
      return idl_exports.Record(toIdlTypeMap(obj, parents));
    }
  };
}

// node_modules/azle/src/experimental/lib/candid/types/constructed/tuple.ts
var AzleTuple = class {
  constructor(t2) {
    this.innerTypes = t2;
  }
  tsType = {};
  innerTypes;
  _azleKind = "AzleTuple";
  static _azleKind = "AzleTuple";
  toBytes(data) {
    return encode5(this, data);
  }
  // TODO make this function's return type explicit https://github.com/demergent-labs/azle/issues/1860
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  getIdlType(parents) {
    const idlTypes = this.innerTypes.map((value) => {
      return toIdlType(value, parents);
    });
    return idl_exports.Tuple(...idlTypes);
  }
};
function Tuple2(...types) {
  return new AzleTuple(types);
}

// node_modules/azle/src/experimental/lib/candid/types/constructed/variant.ts
function Variant2(obj) {
  return {
    ...obj,
    tsType: {},
    toBytes(data) {
      return encode5(this, data);
    },
    // TODO make this function's return type explicit https://github.com/demergent-labs/azle/issues/1860
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    fromBytes(bytes4) {
      return decode5(this, bytes4);
    },
    getIdlType(parents) {
      return idl_exports.Variant(toIdlTypeMap(obj, parents));
    }
  };
}

// node_modules/azle/src/experimental/lib/candid/types/constructed/vec.ts
var AzleVec = class {
  constructor(t2) {
    this.innerType = t2;
  }
  tsType = {};
  innerType;
  _azleKind = "AzleVec";
  static _azleKind = "AzleVec";
  toBytes(data) {
    return encode5(this, data);
  }
  fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  getIdlType(parents) {
    return idl_exports.Vec(toIdlType(this.innerType, parents));
  }
};
function Vec2(t2) {
  return new AzleVec(t2);
}

// node_modules/azle/src/experimental/lib/candid/types/primitive/bool.ts
var AzleBool = class {
  _azleKind = "AzleBool";
  static _azleKind = "AzleBool";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Bool;
  }
};
var bool = AzleBool;

// node_modules/azle/src/experimental/lib/candid/types/primitive/empty.ts
var AzleEmpty = class {
  _azleKind = "AzleEmpty";
  static _azleKind = "AzleEmpty";
  static tsType;
  static getIdlType() {
    return idl_exports.Empty;
  }
};
var empty = AzleEmpty;

// node_modules/azle/src/experimental/lib/candid/types/primitive/floats/float32.ts
var AzleFloat32 = class {
  _azleKind = "AzleFloat32";
  static _azleKind = "AzleFloat32";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Float32;
  }
};
var float32 = AzleFloat32;

// node_modules/azle/src/experimental/lib/candid/types/primitive/floats/float64.ts
var AzleFloat64 = class {
  _azleKind = "AzleFloat64";
  static _azleKind = "AzleFloat64";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Float64;
  }
};
var float64 = AzleFloat64;

// node_modules/azle/src/experimental/lib/candid/types/primitive/ints/int.ts
var AzleInt = class {
  _azleKind = "AzleInt";
  static _azleKind = "AzleInt";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Int;
  }
};
var int = AzleInt;

// node_modules/azle/src/experimental/lib/candid/types/primitive/ints/int8.ts
var AzleInt8 = class {
  _azleKind = "AzleInt8";
  static _azleKind = "AzleInt8";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Int8;
  }
};
var int8 = AzleInt8;

// node_modules/azle/src/experimental/lib/candid/types/primitive/ints/int16.ts
var AzleInt16 = class {
  _azleKind = "AzleInt16";
  static _azleKind = "AzleInt16";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Int16;
  }
};
var int16 = AzleInt16;

// node_modules/azle/src/experimental/lib/candid/types/primitive/ints/int32.ts
var AzleInt32 = class {
  _azleKind = "AzleInt32";
  static _azleKind = "AzleInt32";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Int32;
  }
};
var int32 = AzleInt32;

// node_modules/azle/src/experimental/lib/candid/types/primitive/ints/int64.ts
var AzleInt64 = class {
  _azleKind = "AzleInt64";
  static _azleKind = "AzleInt64";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Int64;
  }
};
var int64 = AzleInt64;

// node_modules/azle/src/experimental/lib/candid/types/primitive/nats/nat.ts
var AzleNat = class {
  _azleKind = "AzleNat";
  static _azleKind = "AzleNat";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Nat;
  }
};
var nat = AzleNat;

// node_modules/azle/src/experimental/lib/candid/types/primitive/nats/nat8.ts
var AzleNat8 = class {
  _azleKind = "AzleNat8";
  static _azleKind = "AzleNat8";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Nat8;
  }
};
var nat8 = AzleNat8;

// node_modules/azle/src/experimental/lib/candid/types/primitive/nats/nat16.ts
var AzleNat16 = class {
  _azleKind = "AzleNat16";
  static _azleKind = "AzleNat16";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Nat16;
  }
};
var nat16 = AzleNat16;

// node_modules/azle/src/experimental/lib/candid/types/primitive/nats/nat32.ts
var AzleNat32 = class {
  _azleKind = "AzleNat32";
  static _azleKind = "AzleNat32";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Nat32;
  }
};
var nat32 = AzleNat32;

// node_modules/azle/src/experimental/lib/candid/types/primitive/nats/nat64.ts
var AzleNat64 = class {
  _azleKind = "AzleNat64";
  static _azleKind = "AzleNat64";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Nat64;
  }
};
var nat64 = AzleNat64;

// node_modules/azle/src/experimental/lib/candid/types/primitive/null.ts
var AzleNull = class {
  _azleKind = "AzleNull";
  static _azleKind = "AzleNull";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Null;
  }
};
var Null2 = AzleNull;

// node_modules/azle/src/experimental/lib/candid/types/primitive/reserved.ts
var AzleReserved = class {
  _azleKind = "AzleReserved";
  static _azleKind = "AzleReserved";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Reserved;
  }
};
var reserved = AzleReserved;

// node_modules/azle/src/experimental/lib/candid/types/primitive/text.ts
var AzleText = class {
  _azleKind = "AzleText";
  static _azleKind = "AzleText";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return idl_exports.Text;
  }
};
var text = AzleText;

// node_modules/azle/src/experimental/lib/candid/types/primitive/void.ts
var AzleVoid = class {
  _azleKind = "AzleVoid";
  static _azleKind = "AzleVoid";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType() {
    return [];
  }
};
var Void = AzleVoid;

// node_modules/azle/src/experimental/lib/candid/types/reference/func.ts
var modeToCandid = {
  query: ["query"],
  oneway: ["oneway"],
  update: []
};
function Func2(paramCandidTypes, returnCandidTypes, mode) {
  return {
    tsType: {},
    toBytes(data) {
      return encode5(this, data);
    },
    fromBytes(bytes4) {
      return decode5(this, bytes4);
    },
    getIdlType(parents) {
      return idl_exports.Func(
        toIdlTypeArray(paramCandidTypes, parents),
        toIdlTypeArray(returnCandidTypes, parents),
        modeToCandid[mode]
      );
    }
  };
}

// node_modules/azle/src/experimental/lib/candid/types/reference/principal.ts
var Principal3 = class extends Principal {
  static _azleKind = "Principal";
  static tsType;
  static toBytes(data) {
    return encode5(this, data);
  }
  static fromBytes(bytes4) {
    return decode5(this, bytes4);
  }
  static getIdlType(_parents) {
    return idl_exports.Principal;
  }
};

// node_modules/azle/src/stable/lib/did_file/visitor/extract_candid.ts
function extractCandid(paramInfo) {
  const paramCandid = paramInfo.map(([candid, _candidTypeDefs]) => {
    return candid;
  });
  const candidTypeDefs = paramInfo.reduce(
    (acc, [_candid, candidTypeDefs2]) => {
      return { ...acc, ...candidTypeDefs2 };
    },
    {}
  );
  return [paramCandid, candidTypeDefs];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/func.ts
function visitFunc(t2, didVisitor, data) {
  const argsTypes = t2.argTypes.map(
    (value) => value.accept(didVisitor, { ...data, isOnService: false })
  );
  const candidArgs = extractCandid(argsTypes);
  const retsTypes = t2.retTypes.map(
    (value) => value.accept(didVisitor, { ...data, isOnService: false })
  );
  const candidRets = extractCandid(retsTypes);
  const args2 = candidArgs[0].join(", ");
  const rets = candidRets[0].join(", ");
  const annon = t2.annotations.length === 0 ? "" : ` ${t2.annotations.join(" ")}`;
  return [
    `${data.isOnService ? "" : "func "}(${args2}) -> (${rets})${annon}`,
    { ...candidArgs[1], ...candidRets[1] }
  ];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/opt.ts
function visitOpt(ty, didVisitor, data) {
  const candid = ty.accept(didVisitor, { ...data, isOnService: false });
  return [`opt ${candid[0]}`, candid[1]];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/primitive.ts
function visitPrimitive(t2) {
  return [t2.display(), {}];
}

// node_modules/azle/src/stable/lib/did_file/visitor/escape_candid_name.ts
var CANDID_KEYWORDS = [
  "blob",
  "bool",
  "float32",
  "float64",
  "func",
  "int",
  "int16",
  "int32",
  "int64",
  "int8",
  "nat",
  "nat16",
  "nat32",
  "nat64",
  "nat8",
  "null",
  "opt",
  "principal",
  "query",
  "record",
  "service",
  "text",
  "variant",
  "vec"
];
function escapeCandidName(key) {
  const isId = /^[A-Za-z_][A-Za-z0-9_]*$/.test(key);
  if (isId === true) {
    return escapeId(key);
  }
  return escapeText(key);
}
function escapeId(key) {
  if (CANDID_KEYWORDS.includes(key) === true) {
    return `"${key}"`;
  }
  return key;
}
function escapeText(key) {
  if (containsBackslashOrQuote(key) === true) {
    const escapedKey = key.replace(
      /[\\"]/g,
      (match) => `\\${match}`
    );
    return `"${escapedKey}"`;
  }
  return `"${key}"`;
}
function containsBackslashOrQuote(key) {
  return ['"', "\\"].some((ch) => key.includes(ch) === true);
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/record.ts
function visitRecord2(fields, didVisitor, data) {
  const candidFields = fields.map(
    ([_key, value]) => value.accept(didVisitor, { ...data, isOnService: false })
  );
  const candid = extractCandid(candidFields);
  const field_strings = fields.map(
    ([key, _value], index) => `${escapeCandidName(key)}:${candid[0][index]}`
  );
  return [`record {${field_strings.join("; ")}}`, candid[1]];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/recursive.ts
function visitRecursive(t2, ty, didVisitor, data) {
  const usedRecClasses = data.usedRecClasses;
  if (!usedRecClasses.includes(t2)) {
    const candid = ty.accept(didVisitor, {
      ...data,
      usedRecClasses: [...usedRecClasses, t2],
      isOnService: false,
      isFirstService: false
    });
    return [t2.name, { ...candid[1], [t2.name]: candid[0] }];
  }
  return [t2.name, {}];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/service.ts
function visitService(t2, didVisitor, data) {
  const queryAndUpdateMethods = getQueryAndUpdateMethods(t2, didVisitor, data);
  const initAndPostUpgradeMethodCandid = getInitAndPostUpgradeMethodCandid(
    didVisitor,
    data
  );
  const candidTypes = {
    ...queryAndUpdateMethods[1],
    ...initAndPostUpgradeMethodCandid[1]
  };
  return serviceToCandidString(
    t2,
    queryAndUpdateMethods[0],
    initAndPostUpgradeMethodCandid[0],
    candidTypes,
    data.isFirstService
  );
}
function serviceToCandidString(t2, canisterMethodCandidStrings, initAndPostUpgradeMethodCandidString, candidTypes, isFirstService) {
  const tab = isFirstService ? "    " : "";
  const func_separator = isFirstService ? "\n" : " ";
  const funcStrings = canisterMethodCandidStrings.map((value, index) => {
    return `${tab}${escapeCandidName(t2._fields[index][0])}: ${value};`;
  }).join(func_separator);
  const canisterParamsString = createCanisterParamsString(
    initAndPostUpgradeMethodCandidString
  );
  if (isFirstService === true) {
    return [
      `service: ${canisterParamsString} -> {
${funcStrings}
}`,
      candidTypes
    ];
  }
  return [`service {${funcStrings}}`, candidTypes];
}
function getInitAndPostUpgradeMethodCandid(didVisitor, data) {
  const result2 = idl_exports.Func(data.initAndPostUpgradeParamIdlTypes, []).accept(
    didVisitor,
    {
      ...data,
      isOnService: true,
      isFirstService: false
    }
  );
  return extractCandid([result2]);
}
function getQueryAndUpdateMethods(t2, didVisitor, data) {
  return extractCandid(
    t2._fields.map(
      ([_name, func]) => func.accept(didVisitor, {
        ...data,
        isOnService: true,
        isFirstService: false
      })
    )
  );
}
function createCanisterParamsString(initMethodCandidString) {
  const parts = initMethodCandidString[0].split("->");
  if (parts.length >= 2) {
    return parts.slice(0, -1).join("->").trim();
  }
  return "()";
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/tuple.ts
function visitTuple2(components, didVisitor, data) {
  const fields = components.map(
    (value) => value.accept(didVisitor, { ...data, isOnService: false })
  );
  const candid = extractCandid(fields);
  return [`record {${candid[0].join("; ")}}`, candid[1]];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/variant.ts
function visitVariant2(fields, didVisitor, data) {
  const candidFields = fields.map(
    ([_key, value]) => value.accept(didVisitor, { ...data, isOnService: false })
  );
  const candid = extractCandid(candidFields);
  const fields_string = fields.map(
    ([key, value], index) => escapeCandidName(key) + (value.name === "null" ? "" : `:${candid[0][index]}`)
  );
  return [`variant {${fields_string.join("; ")}}`, candid[1]];
}

// node_modules/azle/src/stable/lib/did_file/visitor/visit/vec.ts
function visitVec2(ty, didVisitor, data) {
  const candid = ty.accept(didVisitor, { ...data, isOnService: false });
  return [`vec ${candid[0]}`, candid[1]];
}

// node_modules/azle/src/stable/lib/did_file/visitor/did_visitor.ts
function getDefaultVisitorData() {
  return {
    usedRecClasses: [],
    isOnService: false,
    isFirstService: false,
    initAndPostUpgradeParamIdlTypes: []
  };
}
var DidVisitor = class extends idl_exports.Visitor {
  visitService(t2, data) {
    return visitService(t2, this, data);
  }
  visitPrimitive(t2, _data) {
    return visitPrimitive(t2);
  }
  visitTuple(_t, components, data) {
    return visitTuple2(components, this, data);
  }
  visitOpt(_t, ty, data) {
    return visitOpt(ty, this, data);
  }
  visitVec(_t, ty, data) {
    return visitVec2(ty, this, data);
  }
  visitFunc(t2, data) {
    return visitFunc(t2, this, data);
  }
  visitRec(t2, ty, data) {
    return visitRecursive(t2, ty, this, data);
  }
  visitRecord(_t, fields, data) {
    return visitRecord2(fields, this, data);
  }
  visitVariant(_t, fields, data) {
    return visitVariant2(fields, this, data);
  }
};

// node_modules/azle/src/stable/lib/did_file/idl_to_string.ts
function idlToString(type, startingData = getDefaultVisitorData()) {
  const result2 = type.accept(new DidVisitor(), startingData);
  return toDidString(result2);
}
function toDidString(result2) {
  const [candid, candidTypeDefs] = result2;
  const candidTypesString = namedTypeToCandidString(candidTypeDefs);
  return `${candidTypesString + candid}
`;
}
function namedTypeToCandidString(newTypes) {
  return Object.entries(newTypes).length > 0 ? `${namedTypesToStingArr(newTypes).join("\n")}
` : "";
}
function namedTypesToStingArr(newTypes) {
  return Object.entries(newTypes).map(
    ([name, candid]) => `type ${name} = ${candid};`
  );
}

// node_modules/azle/src/experimental/lib/candid/types/reference/service/canister_function/system_methods.ts
function createGetInitAndPostUpgradeParamIdlTypes(canisterOptions) {
  return (parents) => {
    const serviceFunctionInfo = canisterOptions;
    const initMethod = Object.entries(serviceFunctionInfo).find(
      ([_, info]) => info.mode === "init"
    );
    const postUpgradeMethod = Object.entries(serviceFunctionInfo).find(
      ([_, info]) => info.mode === "postUpgrade"
    );
    if (initMethod !== void 0 && postUpgradeMethod !== void 0) {
      const initParams = toIdlTypeArray(
        initMethod[1].paramCandidTypes,
        parents
      );
      const postUpgradeParams = toIdlTypeArray(
        postUpgradeMethod[1].paramCandidTypes,
        parents
      );
      const initSignature = idlToString(idl_exports.Func(initParams, []));
      const postUpgradeSignature = idlToString(
        idl_exports.Func(postUpgradeParams, [])
      );
      if (initSignature !== postUpgradeSignature) {
        throw new Error(
          `'@init' and '@postUpgrade' methods must have the same parameters.
Found:
${initSignature}
${postUpgradeSignature}`
        );
      }
      return initParams;
    }
    if (initMethod !== void 0) {
      return toIdlTypeArray(initMethod[1].paramCandidTypes, parents);
    }
    if (postUpgradeMethod !== void 0) {
      return toIdlTypeArray(
        postUpgradeMethod[1].paramCandidTypes,
        parents
      );
    }
    return [];
  };
}

// node_modules/azle/src/experimental/lib/candid/types/reference/service/canister_function/index.ts
function createCanisterFunction(canisterOptions) {
  let canister = createCanisterFunctionBase(canisterOptions);
  const { callbacks, methodMeta } = createCallbacksAndMethodMeta(canisterOptions);
  canister.callbacks = callbacks;
  canister.methodMeta = methodMeta;
  canister.getIdlType = createGetIdlTypeFunction(canisterOptions);
  canister.getInitAndPostUpgradeParamIdlTypes = createGetInitAndPostUpgradeParamIdlTypes(canisterOptions);
  return canister;
}
function createGetIdlTypeFunction(canisterOptions) {
  return (parents) => {
    const serviceFunctionInfo = canisterOptions;
    const isQueryOrUpdate = (mode) => {
      return mode === "query" || mode === "update";
    };
    const record = Object.entries(serviceFunctionInfo).filter(
      ([_methodName, functionInfo]) => isQueryOrUpdate(functionInfo.mode)
    ).reduce(
      (accumulator, [methodName, functionInfo]) => {
        return {
          ...accumulator,
          [methodName]: createUpdateOrQueryFunctionIdlType(
            functionInfo,
            parents
          )
        };
      },
      {}
    );
    return idl_exports.Service(record);
  };
}
function createAnnotation(mode) {
  if (mode === "query") {
    return ["query"];
  }
  return [];
}
function createUpdateOrQueryFunctionIdlType(functionInfo, parents) {
  const annotations = createAnnotation(functionInfo.mode);
  const paramIdlTypes = toIdlTypeArray(
    functionInfo.paramCandidTypes,
    parents
  );
  const returnIdlType = toIdlTypeArray(
    functionInfo.returnCandidType,
    parents
  );
  return idl_exports.Func(paramIdlTypes, returnIdlType, annotations);
}
function createCallbacksAndMethodMeta(canisterOptions) {
  return Object.entries(canisterOptions).reduce(
    (acc, [canisterMethodName, canisterMethodInfo], index) => {
      const methodMeta = getMethodMeta(
        canisterMethodName,
        index,
        canisterMethodInfo
      );
      const queries = [
        ...acc.methodMeta.queries ?? [],
        ...methodMeta.queries ?? []
      ];
      const updates = [
        ...acc.methodMeta.updates ?? [],
        ...methodMeta.updates ?? []
      ];
      return {
        callbacks: {
          ...acc.callbacks,
          [index.toString()]: canisterMethodInfo.callback
        },
        methodMeta: {
          ...acc.methodMeta,
          ...methodMeta,
          queries,
          updates
        }
      };
    },
    {
      callbacks: {},
      methodMeta: {}
    }
  );
}
function getMethodMeta(canisterMethodName, index, canisterMethodInfo) {
  const method = {
    name: canisterMethodName,
    index,
    composite: canisterMethodInfo.mode === "query" ? canisterMethodInfo.async : void 0
  };
  if (canisterMethodInfo.mode === "init") {
    return {
      init: method
    };
  }
  if (canisterMethodInfo.mode === "postUpgrade") {
    return {
      post_upgrade: method
    };
  }
  if (canisterMethodInfo.mode === "preUpgrade") {
    return {
      pre_upgrade: method
    };
  }
  if (canisterMethodInfo.mode === "inspectMessage") {
    return {
      inspect_message: method
    };
  }
  if (canisterMethodInfo.mode === "heartbeat") {
    return {
      heartbeat: method
    };
  }
  if (canisterMethodInfo.mode === "query") {
    return {
      queries: [method]
    };
  }
  if (canisterMethodInfo.mode === "update") {
    return {
      updates: [method]
    };
  }
  throw new Error(
    `Invalid method mode: ${canisterMethodInfo.mode} for method: ${canisterMethodName}`
  );
}
function createCanisterFunctionBase(canisterOptions) {
  return (principal) => {
    const callbacks = Object.entries(canisterOptions).reduce(
      (acc, entry) => {
        const key = entry[0];
        const value = entry[1];
        return {
          ...acc,
          [key]: (isNotify, cycles2, args2) => {
            return serviceCall(
              principal,
              key,
              value.paramCandidTypes,
              value.returnCandidType
            )(isNotify, cycles2, args2);
          }
        };
      },
      {}
    );
    return {
      ...callbacks,
      principal
    };
  };
}
function serviceCall(canisterId2, methodName, paramCandidTypes, returnCandidType) {
  return (isNotify, cycles2, args2) => {
    const encodedArgs = encode5(paramCandidTypes, args2);
    if (isNotify === true) {
      return call(canisterId2, methodName, {
        args: encodedArgs,
        cycles: cycles2,
        oneway: true,
        raw: true
      });
    } else {
      return (async () => {
        const encodedResult = await call(
          canisterId2,
          methodName,
          {
            args: encodedArgs,
            cycles: cycles2,
            raw: true
          }
        );
        return decode5(returnCandidType, encodedResult);
      })();
    }
  };
}

// node_modules/azle/src/experimental/lib/candid/types/reference/service/index.ts
function Canister(canisterOptions) {
  let result2 = (parentOrPrincipal) => {
    const canisterFunction = createCanisterFunction(canisterOptions);
    if (parentOrPrincipal !== void 0 && parentOrPrincipal._isPrincipal) {
      return canisterFunction(parentOrPrincipal);
    }
    return canisterFunction;
  };
  result2.isCanister = true;
  return result2;
}

// node_modules/azle/src/experimental/lib/canister_methods/is_async.ts
function isAsync(originalFunction) {
  if (originalFunction[Symbol.toStringTag] === "AsyncFunction") {
    return true;
  } else if (originalFunction.constructor.name === "AsyncFunction") {
    return true;
  } else if (originalFunction.toString().includes("async ")) {
    return true;
  } else {
    return false;
  }
}

// node_modules/azle/src/experimental/lib/canister_methods/execute_method.ts
function executeMethod(mode, callback, paramCandidTypes, returnCandidType, manual) {
  const args2 = msgArgData();
  const decodedArgs = mode === "inspectMessage" ? args2 : decode5(paramCandidTypes, args2);
  const result2 = getResult(decodedArgs, callback);
  if (mode === "init" || mode === "postUpgrade" || mode === "inspectMessage") {
    return;
  }
  if (result2 !== void 0 && result2 !== null && typeof result2.then === "function") {
    result2.then((result3) => {
      if (!manual) {
        msgReply(encode5(returnCandidType, result3));
      }
      reportFinalInstructions();
    }).catch((error2) => {
      handleUncaughtError(error2);
    });
  } else {
    if (!manual) {
      msgReply(encode5(returnCandidType, result2));
    }
    reportFinalInstructions();
  }
}
function getResult(args2, callback) {
  try {
    return callback(...args2);
  } catch (error2) {
    handleUncaughtError(error2);
  }
}
function reportFinalInstructions() {
  if (process.env.AZLE_INSTRUCTION_COUNT === "true") {
    console.info(`final instructions: ${performanceCounter(1)}`);
  }
}

// node_modules/azle/src/experimental/lib/canister_methods/methods/init.ts
function init2(paramCandidTypes, callback) {
  const finalCallback = callback === void 0 ? void 0 : () => {
    executeMethod(
      "init",
      callback,
      paramCandidTypes,
      Void,
      false
    );
  };
  return {
    mode: "init",
    callback: finalCallback,
    paramCandidTypes,
    returnCandidType: Void,
    async: false
  };
}

// node_modules/azle/src/experimental/lib/canister_methods/methods/post_upgrade.ts
function postUpgrade(paramCandidTypes, callback) {
  const finalCallback = callback === void 0 ? void 0 : () => {
    executeMethod(
      "postUpgrade",
      callback,
      paramCandidTypes,
      Void,
      false
    );
  };
  return {
    mode: "postUpgrade",
    callback: finalCallback,
    paramCandidTypes,
    returnCandidType: Void,
    async: false
  };
}

// node_modules/azle/src/experimental/lib/canister_methods/methods/query.ts
function query(paramCandidTypes, returnCandidType, callback, methodArgs) {
  const finalCallback = callback === void 0 ? void 0 : () => {
    executeMethod(
      "query",
      callback,
      paramCandidTypes,
      returnCandidType,
      methodArgs?.manual ?? false
    );
  };
  return {
    mode: "query",
    callback: finalCallback,
    paramCandidTypes,
    returnCandidType,
    async: callback === void 0 ? false : isAsync(callback)
  };
}

// node_modules/azle/src/experimental/lib/canister_methods/methods/update.ts
function update(paramCandidTypes, returnCandidType, callback, methodArgs) {
  const finalCallback = callback === void 0 ? void 0 : () => {
    executeMethod(
      "update",
      callback,
      paramCandidTypes,
      returnCandidType,
      methodArgs?.manual ?? false
    );
  };
  return {
    mode: "update",
    callback: finalCallback,
    paramCandidTypes,
    returnCandidType,
    async: callback === void 0 ? false : isAsync(callback)
  };
}

// ../../../../../../node_modules/wasmedge_quickjs/modules/http.js
import * as net from "wasi_net";
import * as httpx from "wasi_http";
init_buffer();
function chunkToU8(chunk2) {
  if (typeof chunk2 === "string") {
    return Buffer2.from(chunk2);
  }
  if (isTypedArray(chunk2)) {
    return Buffer2.from(chunk2);
  }
  return chunk2;
}
var ServerResponse = class extends writable_default {
  statusCode = void 0;
  statusMessage = void 0;
  #headers = {};
  headersSent = false;
  #conn;
  #firstChunk = null;
  #_end = false;
  finished = false;
  constructor(conn) {
    super({
      autoDestroy: true,
      defaultEncoding: "utf-8",
      emitClose: true,
      write: (chunk2, _encoding, cb) => {
        if (!this.headersSent) {
          if (this.#firstChunk === null) {
            this.#firstChunk = chunk2;
            if (!this.#_end) {
              this.respond(false, this.#firstChunk);
              this.#firstChunk = null;
            }
            return cb();
          } else {
            this.respond(false, this.#firstChunk);
            this.#firstChunk = null;
          }
        }
        this.#conn.write(chunk2);
        return cb();
      },
      final: (cb) => {
        if (this.#firstChunk) {
          this.respond(true, this.#firstChunk);
        } else if (!this.headersSent) {
          this.respond(true);
        }
        if (this.#conn.connection == "close") {
          this.#conn.close();
        } else {
          this.#conn.end();
        }
        return cb();
      },
      destroy: (err3, cb) => {
        return cb(null);
      }
    });
    this.#conn = conn;
  }
  setHeader(name, value) {
    this.#headers[name.toLowerCase()] = value;
    return this;
  }
  getHeader(name) {
    return this.#headers[name.toLowerCase()];
  }
  removeHeader(name) {
    return delete this.#headers[name.toLowerCase()];
  }
  getHeaderNames() {
    return Array.from(Object.keys(this.#headers));
  }
  hasHeader(name) {
    return this.#headers[name.toLowerCase()] != void 0;
  }
  writeHead(status, headers) {
    this.statusCode = status;
    for (const k in headers) {
      this.#headers[k.toLowerCase()] = headers[k];
    }
    return this;
  }
  getHeaders() {
    return this.#headers;
  }
  #ensureHeaders(singleChunk) {
    if (this.statusCode === void 0) {
      this.statusCode = 200;
      this.statusMessage = "OK";
    }
    if (typeof singleChunk === "string" && !this.hasHeader("content-type")) {
      this.setHeader("content-type", "text/plain;charset=UTF-8");
    }
  }
  respond(final2, singleChunk) {
    this.headersSent = true;
    this.#ensureHeaders(singleChunk);
    if (final2) {
      this.#conn.respondWith(
        singleChunk,
        {
          headers: this.#headers,
          status: this.statusCode,
          statusText: this.statusMessage
        },
        final2
      ).catch(() => {
      });
    } else {
      this.#conn.chunk({
        headers: this.#headers,
        status: this.statusCode,
        statusText: this.statusMessage
      });
      this.#conn.write(singleChunk);
    }
  }
  // deno-lint-ignore no-explicit-any
  end(chunk2, encoding2, cb) {
    if (!this.headersSent) {
      if (!chunk2 && this.hasHeader("transfer-encoding")) {
        this.setHeader("content-length", "0");
        this.removeHeader("transfer-encoding");
      }
    }
    this.#_end = true;
    return super.end(chunk2, encoding2, cb);
  }
};
var IncomingMessageForServer = class extends readable_default {
  #req;
  url;
  constructor(req, conn) {
    let value = req.body;
    super({
      autoDestroy: true,
      emitClose: true,
      objectMode: false,
      read: async function(_size) {
        if (!value) {
          this.push(null);
        } else {
          this.push(Buffer2.from(value));
          value = null;
        }
      },
      destroy: (err3, cb) => {
        cb(err3);
      }
    });
    this.#req = req;
    this.url = req.uri;
  }
  get aborted() {
    return false;
  }
  get httpVersion() {
    return this.#req.version;
  }
  get headers() {
    return this.#req.headers;
  }
  get method() {
    return this.#req.method;
  }
};
var HttpConn = class {
  #chunk = void 0;
  #connection = "close";
  #version = "HTTP/1.1";
  #chunkBuffer = void 0;
  #respHeaders;
  constructor(socket) {
    this.socket = socket;
  }
  get connection() {
    return this.#connection;
  }
  get version() {
    return this.#version;
  }
  async nextRequest() {
    let buffer = new httpx.Buffer();
    while (true) {
      let d = await this.socket.read();
      if (d == void 0 || d.byteLength <= 0) {
        return null;
      }
      buffer.append(d);
      try {
        let req = buffer.parseRequest();
        if (req instanceof httpx.WasiRequest) {
          this.#version = req.version;
          if (this.#version == "HTTP/1.1") {
            this.#connection = (req.getHeader("connection") ?? "keep-alive").toLowerCase();
          } else if (this.#version == "HTTP/1.0") {
            this.#connection = (req.getHeader("connection") ?? "close").toLowerCase();
          }
          return req;
        }
      } catch (e3) {
        return null;
      }
    }
  }
  respondWith(body2, resp_header, final2) {
    if (!this.socket) {
      return;
    }
    if (body2) {
      body2 = chunkToU8(body2)?.buffer;
    }
    let resp = new httpx.WasiResponse();
    resp.version = this.#version;
    resp.headers = resp_header.headers;
    resp.status = resp_header.status;
    resp.statusText = resp_header.statusText;
    this.socket.write(resp.encode(body2));
    if (final2 === true) {
      this.socket.end("0\r\n\r\n");
    }
  }
  chunk(resp_header) {
    if (this.#version == "HTTP/1.1") {
      let resp = new httpx.WasiResponse();
      resp.version = this.#version;
      resp.headers = resp_header.headers;
      resp.status = resp_header.status;
      resp.statusText = resp_header.statusText;
      this.#chunk = resp.chunk(this.socket);
    } else {
      this.#chunkBuffer = new httpx.Buffer();
      this.#respHeaders = resp_header;
    }
  }
  write(chunk2) {
    if (chunk2) {
      let conn = this.#chunkBuffer ?? this.#chunk ?? this.socket;
      conn?.write(chunkToU8(chunk2).buffer);
    }
  }
  end(chunk2) {
    if (this.#chunk) {
      this.#chunk.end(chunk2);
      this.#chunk = void 0;
      return;
    }
    if (this.#chunkBuffer && chunk2) {
      this.#chunkBuffer.write(chunk2);
    }
    if (this.#chunkBuffer) {
      this.respondWith(this.#chunkBuffer, this.#respHeaders);
      this.#chunkBuffer = null;
    }
  }
  close() {
    this.end();
    this.socket = void 0;
  }
};
function Server(handler) {
  return new ServerImpl(handler);
}
function _normalizeArgs(args2) {
  let arr;
  if (args2.length === 0) {
    arr = [{}, null];
    return arr;
  }
  const arg0 = args2[0];
  let options = {};
  if (typeof arg0 === "object" && arg0 !== null) {
    options = arg0;
  } else {
    options.port = arg0;
    if (args2.length > 1 && typeof args2[1] === "string") {
      options.host = args2[1];
    }
  }
  const cb = args2[args2.length - 1];
  if (typeof cb !== "function") {
    arr = [options, null];
  } else {
    arr = [options, cb];
  }
  return arr;
}
var ServerImpl = class extends EventEmitter {
  #httpConnections = /* @__PURE__ */ new Set();
  #listener = void 0;
  #listening = false;
  constructor(handler) {
    super();
    if (handler !== void 0) {
      this.on("request", handler);
    }
  }
  listen(...args2) {
    const normalized = _normalizeArgs(args2);
    const options = normalized[0];
    const cb = normalized[1];
    if (cb != null) {
      this.once("listening", cb);
    }
    let port = 0;
    if (typeof options.port === "number" || typeof options.port === "string") {
      validatePort(options.port, "options.port");
      port = options.port | 0;
    }
    globalThis._azleNodeServer = this;
    return this;
  }
  async #listenLoop() {
    const go = async (httpConn) => {
      try {
        for (; ; ) {
          let request = null;
          try {
            request = await httpConn.nextRequest();
          } catch {
          }
          if (request === null) {
            break;
          }
          const req = new IncomingMessageForServer(request, httpConn);
          const res = new ServerResponse(httpConn);
          this.emit("request", req, res);
        }
      } finally {
        this.#httpConnections.delete(httpConn);
        httpConn.close();
      }
    };
    const listener = this.#listener;
    if (listener !== void 0) {
      this.emit("listening");
      try {
        while (this.#listening) {
          let tcp_conn = await listener.accept();
          try {
            let httpConn = new HttpConn(tcp_conn);
            this.#httpConnections.add(httpConn);
            go(httpConn);
          } catch {
            continue;
          }
        }
      } catch (e3) {
        this.emit("error", e3);
      } finally {
        this.listening = false;
      }
    }
  }
  get listening() {
    return this.#listening !== void 0;
  }
  close(cb) {
    const listening = this.#listening;
    if (typeof cb === "function") {
      if (listening) {
        this.once("close", cb);
      } else {
        this.once("close", function close2() {
          cb(new ERR_SERVER_NOT_RUNNING());
        });
      }
    }
    process2.nextTick(() => this.emit("close"));
    if (listening) {
      this.#listener.close();
      this.#listener = void 0;
      this.#listening = false;
      for (const httpConn of this.#httpConnections) {
        try {
          httpConn.close();
        } catch {
        }
      }
      this.#httpConnections.clear();
    }
    return this;
  }
  get listening() {
    return this.#listener;
  }
  address() {
    const addr = this.#listener.addr;
    return {
      port: addr.port,
      address: addr.hostname
    };
  }
};
Server.prototype = ServerImpl.prototype;

// node_modules/azle/src/experimental/lib/server.ts
var import_http_message_parser = __toESM(require_http_message_parser(), 1);
var HeaderField = Tuple2(text, text);
var HttpRequest = Record2({
  method: text,
  url: text,
  headers: Vec2(HeaderField),
  body: blob,
  certificate_version: Opt2(nat16)
});
var HttpUpdateRequest = Record2({
  method: text,
  url: text,
  headers: Vec2(HeaderField),
  body: blob
});
var DefaultToken = blob;
function StreamingCallbackHttpResponse(token) {
  return Record2({
    body: blob,
    token: Opt2(token)
  });
}
function Callback(token) {
  return Func2([token], Opt2(StreamingCallbackHttpResponse(token)), "query");
}
function CallbackStrategy(token) {
  return Record2({
    callback: Callback(token),
    token
  });
}
function StreamingStrategy(token) {
  return Variant2({
    Callback: CallbackStrategy(token)
  });
}
function HttpResponse(token) {
  return Record2({
    status_code: nat16,
    headers: Vec2(HeaderField),
    body: blob,
    upgrade: Opt2(bool),
    streaming_strategy: Opt2(StreamingStrategy(token ?? DefaultToken))
  });
}
var nodeServer = void 0;
function serverInit(serverCallback) {
  return init2([], async () => {
    nodeServer = await serverCallback();
  });
}
function serverPostUpgrade(serverCallback) {
  return postUpgrade([], async () => {
    nodeServer = await serverCallback();
  });
}
var serverHttpRequest = query(
  [HttpRequest],
  Manual(HttpResponse()),
  async (httpRequest) => {
    await httpHandler(httpRequest, true);
  },
  {
    manual: true
  }
);
var serverHttpRequestUpdate = update(
  [HttpUpdateRequest],
  Manual(HttpResponse()),
  async (httpRequest) => {
    await httpHandler(httpRequest, false);
  },
  {
    manual: true
  }
);
function serverCanisterMethods(serverCallback) {
  return {
    init: serverInit(serverCallback),
    postUpgrade: serverPostUpgrade(serverCallback),
    http_request: serverHttpRequest,
    http_request_update: serverHttpRequestUpdate
  };
}
function Server2(serverCallback, canisterOptions) {
  const canisterOptionsNodeServerized = Object.entries(
    canisterOptions ?? {}
  ).reduce((acc, [key, value]) => {
    const valueServerized = value.mode === "init" || value.mode === "postUpgrade" ? {
      ...value,
      callback: async (...args2) => {
        if (value.callback !== void 0) {
          value.callback(...args2);
        }
        setNodeServer(await serverCallback());
      }
    } : value;
    return {
      ...acc,
      [key]: valueServerized
    };
  }, {});
  return Canister({
    ...serverCanisterMethods(serverCallback),
    ...canisterOptionsNodeServerized
  });
}
async function httpHandler(httpRequest, query3) {
  if (nodeServer === void 0) {
    throw new Error(`The server was not initialized`);
  }
  if (shouldUpgrade(httpRequest, query3)) {
    const encoded = idlEncode(
      [HttpResponse().getIdlType([])],
      [
        {
          status_code: 204,
          headers: [],
          body: Uint8Array.from([]),
          streaming_strategy: [],
          upgrade: [true]
        }
      ]
    );
    msgReply(encoded);
    return;
  }
  class AzleSocket {
    responseData = Buffer.from([]);
    readable = true;
    writeable = true;
    res = null;
    async read() {
      const httpLine1 = `${httpRequest.method} ${httpRequest.url} HTTP/1.1\r
`;
      const httpHeaders = httpRequest.headers.map((header) => {
        return `${header[0]}: ${header[1]}`;
      }).join("\r\n");
      const httpString = `${httpLine1}${httpHeaders}\r
\r
`;
      return Buffer.concat([Buffer.from(httpString), httpRequest.body]).buffer;
    }
    async write(data) {
      if (data.byteLength !== void 0) {
        this.responseData = Buffer.concat([
          this.responseData,
          Buffer.from(data)
        ]);
        return;
      }
      if (typeof data === "string") {
        this.responseData = Buffer.concat([
          this.responseData,
          Buffer.from(data)
        ]);
        return;
      }
      if (typeof data === "object") {
        this.responseData = Buffer.concat([
          this.responseData,
          Buffer.from(data.toString())
        ]);
        return;
      }
    }
    end(_data) {
      const startIndex = this.responseData.indexOf(Buffer.from("\r\n\r\n")) + 4;
      const parsedHttpResponse = (0, import_http_message_parser.default)(
        this.responseData.slice(0, startIndex)
      );
      const isChunked = Object.keys(parsedHttpResponse.headers).map((key) => key.toLowerCase()).includes("transfer-encoding");
      const slicedBody = this.responseData.slice(startIndex);
      const unchunkedBody = isChunked ? processChunkedBody(slicedBody) : slicedBody;
      if (this.res === null) {
        throw new Error("res must be defined");
      }
      const encoded = idlEncode(
        [HttpResponse().getIdlType([])],
        [
          {
            status_code: this.res.statusCode,
            headers: Object.entries(this.res.getHeaders()).map((entry) => entry).filter((header) => {
              return header[0].toLowerCase() !== "content-length" && header[0].toLowerCase() !== "transfer-encoding";
            }),
            body: new Uint8Array(unchunkedBody),
            streaming_strategy: [],
            upgrade: []
          }
        ]
      );
      msgReply(encoded);
    }
  }
  const azleSocket = new AzleSocket();
  const httpConn = new HttpConn(azleSocket);
  const request = await httpConn.nextRequest();
  const req = new IncomingMessageForServer(request, httpConn);
  const res = new ServerResponse(httpConn);
  azleSocket.res = res;
  nodeServer.emit("request", req, res);
}
function shouldUpgrade(httpRequest, query3) {
  const forceQueryHeaderExists = forceHeaderExists(
    "X-Ic-Force-Query",
    httpRequest.headers
  );
  const forceUpdateHeaderExists = forceHeaderExists(
    "X-Ic-Force-Update",
    httpRequest.headers
  );
  return query3 === true && !forceQueryHeaderExists && (httpRequest.method === "POST" || httpRequest.method === "PUT" || httpRequest.method === "PATCH" || httpRequest.method === "DELETE" || forceUpdateHeaderExists);
}
function forceHeaderExists(headerName, headers) {
  return headers.find(
    ([key, value]) => key.toLowerCase() === headerName.toLowerCase() && value === "true"
  ) !== void 0;
}
function processChunkedBody(buffer) {
  let result2 = Buffer.alloc(0);
  let remaining = buffer;
  while (remaining.length > 0) {
    const sizeEnd = remaining.indexOf("\r\n");
    if (sizeEnd === -1) {
      throw new Error("Invalid chunked body: missing size line end");
    }
    const sizeLine = remaining.slice(0, sizeEnd).toString();
    const chunkSize = parseInt(sizeLine, 16);
    if (chunkSize === 0) {
      break;
    }
    const chunkStart = sizeEnd + 2;
    const chunkEnd = chunkStart + chunkSize;
    if (chunkEnd > remaining.length) {
      throw new Error("Invalid chunked body: incomplete chunk");
    }
    const chunk2 = remaining.slice(chunkStart, chunkEnd);
    result2 = Buffer.concat([result2, chunk2]);
    remaining = remaining.slice(chunkEnd + 2);
  }
  return result2;
}
function setNodeServer(newNodeServer) {
  nodeServer = newNodeServer;
}

// node_modules/azle/src/experimental/lib/stable_structures/stable_b_tree_map.ts
function StableBTreeMap(memoryIdNumber, keySerializable = stableJson, valueSerializable = stableJson) {
  const memoryId = memoryIdNumber.toString();
  if (globalThis._azleIcExperimental !== void 0 && globalThis._azleNodejsWasmEnvironment !== true) {
    globalThis._azleIcExperimental.stableBTreeMapInit(memoryId);
  }
  isSerializable(keySerializable);
  isSerializable(valueSerializable);
  return {
    /**
     * Checks if the given key exists in the map.
     * @param key the key to check.
     * @returns `true` if the key exists in the map, `false` otherwise.
     */
    containsKey(key) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedKey = keySerializable.toBytes(key);
      return globalThis._azleIcExperimental.stableBTreeMapContainsKey(
        memoryId,
        encodedKey.buffer instanceof ArrayBuffer ? encodedKey.buffer : new Uint8Array(encodedKey).buffer
      );
    },
    /**
     * Retrieves the value stored at the provided key.
     * @param key the location from which to retrieve.
     * @returns the value associated with the given key, if it exists.
     */
    get(key) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedKey = keySerializable.toBytes(key);
      const encodedResult = globalThis._azleIcExperimental.stableBTreeMapGet(
        memoryId,
        encodedKey.buffer instanceof ArrayBuffer ? encodedKey.buffer : new Uint8Array(encodedKey).buffer
      );
      if (encodedResult === void 0) {
        return null;
      } else {
        return valueSerializable.fromBytes(
          new Uint8Array(encodedResult)
        );
      }
    },
    /**
     * Inserts a value into the map at the provided key.
     * @param key the location at which to insert.
     * @param value the value to insert.
     * @returns the previous value of the key, if present.
     */
    insert(key, value) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedKey = keySerializable.toBytes(key);
      const encodedValue = valueSerializable.toBytes(value);
      const encodedResult = globalThis._azleIcExperimental.stableBTreeMapInsert(
        memoryId,
        encodedKey.buffer instanceof ArrayBuffer ? encodedKey.buffer : new Uint8Array(encodedKey).buffer,
        encodedValue.buffer instanceof ArrayBuffer ? encodedValue.buffer : new Uint8Array(encodedValue).buffer
      );
      if (encodedResult === void 0) {
        return null;
      } else {
        return valueSerializable.fromBytes(
          new Uint8Array(encodedResult)
        );
      }
    },
    /**
     * Checks if the map is empty.
     * @returns `true` if the map contains no elements, `false` otherwise.
     */
    isEmpty() {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      return globalThis._azleIcExperimental.stableBTreeMapIsEmpty(
        memoryId
      );
    },
    /**
     * Retrieves the items in the map in sorted order.
     * @param startIndex the starting index to begin retrieval
     * @param length the number of items to retrieve
     * @returns tuples representing key/value pairs.
     */
    items(startIndex, length) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedItems = globalThis._azleIcExperimental.stableBTreeMapItems(
        memoryId,
        startIndex?.toString() ?? "0",
        length?.toString() ?? "NOT_SET"
      );
      return encodedItems.map(([encodedKey, encodedValue]) => {
        return [
          keySerializable.fromBytes(new Uint8Array(encodedKey)),
          valueSerializable.fromBytes(new Uint8Array(encodedValue))
        ];
      });
    },
    /**
     * The keys for each element in the map in sorted order.
     * @param startIndex the starting index to begin retrieval
     * @param length the number of keys to retrieve
     * @returns they keys in the map.
     */
    keys(startIndex, length) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedKeys = globalThis._azleIcExperimental.stableBTreeMapKeys(
        memoryId,
        startIndex?.toString() ?? "0",
        length?.toString() ?? "NOT_SET"
      );
      return encodedKeys.map((encodedKey) => {
        return keySerializable.fromBytes(new Uint8Array(encodedKey));
      });
    },
    /**
     * Checks to see how many elements are in the map.
     * @returns the number of elements in the map.
     */
    len() {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      return Number(
        globalThis._azleIcExperimental.stableBTreeMapLen(memoryId)
      );
    },
    /**
     * Removes a key from the map.
     * @param key the location from which to remove.
     * @returns the previous value at the key if it exists, `null` otherwise.
     */
    remove(key) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedKey = keySerializable.toBytes(key);
      const encodedValue = globalThis._azleIcExperimental.stableBTreeMapRemove(
        memoryId,
        encodedKey.buffer instanceof ArrayBuffer ? encodedKey.buffer : new Uint8Array(encodedKey).buffer
      );
      if (encodedValue === void 0) {
        return null;
      } else {
        return valueSerializable.fromBytes(
          new Uint8Array(encodedValue)
        );
      }
    },
    /**
     * The values in the map in sorted order.
     * @param startIndex the starting index to begin retrieval
     * @param length the number of values to retrieve
     * @returns the values in the map.
     */
    values(startIndex, length) {
      if (globalThis._azleIcExperimental === void 0) {
        return void 0;
      }
      const encodedValues = globalThis._azleIcExperimental.stableBTreeMapValues(
        memoryId,
        startIndex?.toString() ?? "0",
        length?.toString() ?? "NOT_SET"
      );
      return encodedValues.map((encodedValue) => {
        return valueSerializable.fromBytes(
          new Uint8Array(encodedValue)
        );
      });
    }
  };
}
function isSerializable(obj) {
  if (obj.toBytes === void 0) {
    throw new Error(`value must have a toBytes method`);
  }
  if (obj.fromBytes === void 0) {
    throw new Error(`value must have a fromBytes method`);
  }
}

// node_modules/azle/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  AbiCoder: () => AbiCoder,
  AbstractProvider: () => AbstractProvider,
  AbstractSigner: () => AbstractSigner,
  AlchemyProvider: () => AlchemyProvider,
  AnkrProvider: () => AnkrProvider,
  BaseContract: () => BaseContract,
  BaseWallet: () => BaseWallet,
  Block: () => Block,
  BrowserProvider: () => BrowserProvider,
  ChainstackProvider: () => ChainstackProvider,
  CloudflareProvider: () => CloudflareProvider,
  ConstructorFragment: () => ConstructorFragment,
  Contract: () => Contract,
  ContractEventPayload: () => ContractEventPayload,
  ContractFactory: () => ContractFactory,
  ContractTransactionReceipt: () => ContractTransactionReceipt,
  ContractTransactionResponse: () => ContractTransactionResponse,
  ContractUnknownEventPayload: () => ContractUnknownEventPayload,
  EnsPlugin: () => EnsPlugin,
  EnsResolver: () => EnsResolver,
  ErrorDescription: () => ErrorDescription,
  ErrorFragment: () => ErrorFragment,
  EtherSymbol: () => EtherSymbol,
  EtherscanPlugin: () => EtherscanPlugin,
  EtherscanProvider: () => EtherscanProvider,
  EventFragment: () => EventFragment,
  EventLog: () => EventLog,
  EventPayload: () => EventPayload,
  FallbackFragment: () => FallbackFragment,
  FallbackProvider: () => FallbackProvider,
  FeeData: () => FeeData,
  FeeDataNetworkPlugin: () => FeeDataNetworkPlugin,
  FetchCancelSignal: () => FetchCancelSignal,
  FetchRequest: () => FetchRequest,
  FetchResponse: () => FetchResponse,
  FetchUrlFeeDataNetworkPlugin: () => FetchUrlFeeDataNetworkPlugin,
  FixedNumber: () => FixedNumber,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  GasCostPlugin: () => GasCostPlugin,
  HDNodeVoidWallet: () => HDNodeVoidWallet,
  HDNodeWallet: () => HDNodeWallet,
  Indexed: () => Indexed,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  Interface: () => Interface,
  IpcSocketProvider: () => IpcSocketProvider,
  JsonRpcApiProvider: () => JsonRpcApiProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  LangEn: () => LangEn,
  Log: () => Log,
  LogDescription: () => LogDescription,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MessagePrefix: () => MessagePrefix,
  MinInt256: () => MinInt256,
  Mnemonic: () => Mnemonic,
  MulticoinProviderPlugin: () => MulticoinProviderPlugin,
  N: () => N,
  NamedFragment: () => NamedFragment,
  Network: () => Network,
  NetworkPlugin: () => NetworkPlugin,
  NonceManager: () => NonceManager,
  ParamType: () => ParamType,
  PocketProvider: () => PocketProvider,
  QuickNodeProvider: () => QuickNodeProvider,
  Result: () => Result2,
  Signature: () => Signature,
  SigningKey: () => SigningKey,
  SocketBlockSubscriber: () => SocketBlockSubscriber,
  SocketEventSubscriber: () => SocketEventSubscriber,
  SocketPendingSubscriber: () => SocketPendingSubscriber,
  SocketProvider: () => SocketProvider,
  SocketSubscriber: () => SocketSubscriber,
  StructFragment: () => StructFragment,
  Transaction: () => Transaction,
  TransactionDescription: () => TransactionDescription,
  TransactionReceipt: () => TransactionReceipt,
  TransactionResponse: () => TransactionResponse,
  Typed: () => Typed,
  TypedDataEncoder: () => TypedDataEncoder,
  UndecodedEventLog: () => UndecodedEventLog,
  UnmanagedSubscriber: () => UnmanagedSubscriber,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  WebSocketProvider: () => WebSocketProvider,
  WeiPerEther: () => WeiPerEther,
  Wordlist: () => Wordlist,
  WordlistOwl: () => WordlistOwl,
  WordlistOwlA: () => WordlistOwlA,
  ZeroAddress: () => ZeroAddress,
  ZeroHash: () => ZeroHash,
  accessListify: () => accessListify,
  assert: () => assert4,
  assertArgument: () => assertArgument,
  assertArgumentCount: () => assertArgumentCount,
  assertNormalize: () => assertNormalize,
  assertPrivate: () => assertPrivate,
  checkResultErrors: () => checkResultErrors,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  concat: () => concat2,
  copyRequest: () => copyRequest,
  dataLength: () => dataLength,
  dataSlice: () => dataSlice,
  decodeBase58: () => decodeBase58,
  decodeBase64: () => decodeBase64,
  decodeBytes32String: () => decodeBytes32String,
  decodeRlp: () => decodeRlp,
  decryptCrowdsaleJson: () => decryptCrowdsaleJson,
  decryptKeystoreJson: () => decryptKeystoreJson,
  decryptKeystoreJsonSync: () => decryptKeystoreJsonSync,
  defaultPath: () => defaultPath2,
  defineProperties: () => defineProperties,
  dnsEncode: () => dnsEncode,
  encodeBase58: () => encodeBase58,
  encodeBase64: () => encodeBase64,
  encodeBytes32String: () => encodeBytes32String,
  encodeRlp: () => encodeRlp,
  encryptKeystoreJson: () => encryptKeystoreJson,
  encryptKeystoreJsonSync: () => encryptKeystoreJsonSync,
  ensNormalize: () => ensNormalize,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  fromTwos: () => fromTwos,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getBigInt: () => getBigInt,
  getBytes: () => getBytes,
  getBytesCopy: () => getBytesCopy,
  getCreate2Address: () => getCreate2Address,
  getCreateAddress: () => getCreateAddress,
  getDefaultProvider: () => getDefaultProvider,
  getIcapAddress: () => getIcapAddress,
  getIndexedAccountPath: () => getIndexedAccountPath,
  getNumber: () => getNumber,
  getUint: () => getUint,
  hashMessage: () => hashMessage,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isAddressable: () => isAddressable,
  isBytesLike: () => isBytesLike,
  isCallException: () => isCallException,
  isCrowdsaleJson: () => isCrowdsaleJson,
  isError: () => isError3,
  isHexString: () => isHexString,
  isKeystoreJson: () => isKeystoreJson,
  isValidName: () => isValidName,
  keccak256: () => keccak256,
  lock: () => lock,
  makeError: () => makeError,
  mask: () => mask,
  namehash: () => namehash,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits,
  pbkdf2: () => pbkdf22,
  randomBytes: () => randomBytes3,
  recoverAddress: () => recoverAddress,
  resolveAddress: () => resolveAddress,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd1602,
  scrypt: () => scrypt2,
  scryptSync: () => scryptSync,
  sha256: () => sha2562,
  sha512: () => sha5122,
  showThrottleMessage: () => showThrottleMessage,
  solidityPacked: () => solidityPacked,
  solidityPackedKeccak256: () => solidityPackedKeccak256,
  solidityPackedSha256: () => solidityPackedSha256,
  stripZerosLeft: () => stripZerosLeft,
  toBeArray: () => toBeArray,
  toBeHex: () => toBeHex,
  toBigInt: () => toBigInt2,
  toNumber: () => toNumber,
  toQuantity: () => toQuantity,
  toTwos: () => toTwos,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  uuidV4: () => uuidV4,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  version: () => version2,
  wordlists: () => wordlists,
  zeroPadBytes: () => zeroPadBytes,
  zeroPadValue: () => zeroPadValue
});

// node_modules/azle/node_modules/ethers/lib.esm/_version.js
var version2 = "6.13.5";

// node_modules/azle/node_modules/ethers/lib.esm/utils/properties.js
function checkType(value, type, name) {
  const types = type.split("|").map((t2) => t2.trim());
  for (let i2 = 0; i2 < types.length; i2++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error2 = new Error(`invalid value for type ${type}`);
  error2.code = "INVALID_ARGUMENT";
  error2.argument = `value.${name}`;
  error2.value = value;
  throw error2;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v2, index) => {
    accum[keys[index]] = v2;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/errors.js
function stringify2(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify2).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result2 = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      result2 += HEX[value[i2] >> 4];
      result2 += HEX[value[i2] & 15];
    }
    return result2;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify2(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify2(k)}: ${stringify2(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError3(error2, code) {
  return error2 && error2.code === code;
}
function isCallException(error2) {
  return isError3(error2, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify2(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify2(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version2}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error2;
  switch (code) {
    case "INVALID_ARGUMENT":
      error2 = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error2 = new RangeError(message);
      break;
    default:
      error2 = new Error(message);
  }
  defineProperties(error2, { code });
  if (info) {
    Object.assign(error2, info);
  }
  if (error2.shortMessage == null) {
    defineProperties(error2, { shortMessage });
  }
  return error2;
}
function assert4(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert4(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert4(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert4(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error2) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert4(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert4(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/data.js
function _getBytes(value, name, copy7) {
  if (value instanceof Uint8Array) {
    if (copy7) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result2 = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i2 = 0; i2 < result2.length; i2++) {
      result2[i2] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result2;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
var HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes4 = getBytes(data);
  let result2 = "0x";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    const v2 = bytes4[i2];
    result2 += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
  }
  return result2;
}
function concat2(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes4 = getBytes(data);
  if (end != null && end > bytes4.length) {
    assert4(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes4,
      length: bytes4.length,
      offset: end
    });
  }
  return hexlify(bytes4.slice(start == null ? 0 : start, end == null ? bytes4.length : end));
}
function stripZerosLeft(data) {
  let bytes4 = hexlify(data).substring(2);
  while (bytes4.startsWith("00")) {
    bytes4 = bytes4.substring(2);
  }
  return "0x" + bytes4;
}
function zeroPad(data, length, left) {
  const bytes4 = getBytes(data);
  assert4(length >= bytes4.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes4),
    length,
    offset: length + 1
  });
  const result2 = new Uint8Array(length);
  result2.fill(0);
  if (left) {
    result2.set(bytes4, length - bytes4.length);
  } else {
    result2.set(bytes4, 0);
  }
  return hexlify(result2);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/maths.js
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
function fromTwos(_value, _width) {
  const value = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert4(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_1) {
    const mask3 = (BN_1 << width) - BN_1;
    return -((~value & mask3) + BN_1);
  }
  return value;
}
function toTwos(_value, _width) {
  let value = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    assert4(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask3 = (BN_1 << width) - BN_1;
    return (~value & mask3) + BN_1;
  } else {
    assert4(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask(_value, _bits) {
  const value = getUint(_value, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits) - BN_1;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e3) {
        assertArgument(false, `invalid BigNumberish string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result2 = getBigInt(value, name);
  assert4(result2 >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result2;
}
var Nibbles = "0123456789abcdef";
function toBigInt2(value) {
  if (value instanceof Uint8Array) {
    let result2 = "0x0";
    for (const v2 of value) {
      result2 += Nibbles[v2 >> 4];
      result2 += Nibbles[v2 & 15];
    }
    return BigInt(result2);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e3) {
        assertArgument(false, `invalid numeric string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt2(value));
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result2 = value.toString(16);
  if (_width == null) {
    if (result2.length % 2) {
      result2 = "0" + result2;
    }
  } else {
    const width = getNumber(_width, "width");
    assert4(width * 2 >= result2.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result2.length < width * 2) {
      result2 = "0" + result2;
    }
  }
  return "0x" + result2;
}
function toBeArray(_value) {
  const value = getUint(_value, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result2 = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < result2.length; i2++) {
    const offset = i2 * 2;
    result2[i2] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result2;
}
function toQuantity(value) {
  let result2 = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result2.startsWith("0")) {
    result2 = result2.substring(1);
  }
  if (result2 === "") {
    result2 = "0";
  }
  return "0x" + result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/base58.js
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i2 = 0; i2 < Alphabet.length; i2++) {
      Lookup[Alphabet[i2]] = BigInt(i2);
    }
  }
  const result2 = Lookup[letter];
  assertArgument(result2 != null, `invalid base58 value`, "letter", letter);
  return result2;
}
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
function encodeBase58(_value) {
  const bytes4 = getBytes(_value);
  let value = toBigInt2(bytes4);
  let result2 = "";
  while (value) {
    result2 = Alphabet[Number(value % BN_58)] + result2;
    value /= BN_58;
  }
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    if (bytes4[i2]) {
      break;
    }
    result2 = Alphabet[0] + result2;
  }
  return result2;
}
function decodeBase58(value) {
  let result2 = BN_02;
  for (let i2 = 0; i2 < value.length; i2++) {
    result2 *= BN_58;
    result2 += getAlpha(value[i2]);
  }
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/base64-browser.js
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i2 = 0; i2 < textData.length; i2++) {
    data[i2] = textData.charCodeAt(i2);
  }
  return getBytes(data);
}
function encodeBase64(_data) {
  const data = getBytes(_data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/events.js
var EventPayload = class {
  /**
   *  The event filter.
   */
  filter;
  /**
   *  The **EventEmitterable**.
   */
  emitter;
  #listener;
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc(reason, offset, bytes4, output3, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes4);
}
function ignoreFunc(reason, offset, bytes4, output3, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i2 = 0;
    for (let o3 = offset + 1; o3 < bytes4.length; o3++) {
      if (bytes4[o3] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === "OVERRUN") {
    return bytes4.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes4, output3, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output3.push(badCodepoint);
    return 0;
  }
  output3.push(65533);
  return ignoreFunc(reason, offset, bytes4, output3, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes4 = getBytes(_bytes, "bytes");
  const result2 = [];
  let i2 = 0;
  while (i2 < bytes4.length) {
    const c2 = bytes4[i2++];
    if (c2 >> 7 === 0) {
      result2.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError("UNEXPECTED_CONTINUE", i2 - 1, bytes4, result2);
      } else {
        i2 += onError("BAD_PREFIX", i2 - 1, bytes4, result2);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes4.length) {
      i2 += onError("OVERRUN", i2 - 1, bytes4, result2);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes4[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError("MISSING_CONTINUE", i2, bytes4, result2);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError("OUT_OF_RANGE", i2 - 1 - extraLength, bytes4, result2, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError("UTF16_SURROGATE", i2 - 1 - extraLength, bytes4, result2, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError("OVERLONG", i2 - 1 - extraLength, bytes4, result2, res);
      continue;
    }
    result2.push(res);
  }
  return result2;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result2 = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result2.push(c2);
    } else if (c2 < 2048) {
      result2.push(c2 >> 6 | 192);
      result2.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      assertArgument(i2 < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result2.push(pair >> 18 | 240);
      result2.push(pair >> 12 & 63 | 128);
      result2.push(pair >> 6 & 63 | 128);
      result2.push(pair & 63 | 128);
    } else {
      result2.push(c2 >> 12 | 224);
      result2.push(c2 >> 6 & 63 | 128);
      result2.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result2);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes4, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes4, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/geturl-browser.js
function createGetUrl(options) {
  async function getUrl3(req, _signal) {
    assert4(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert4(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert4(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error2 = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error2 = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal) {
      _signal.addListener(() => {
        error2 = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init6 = {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    };
    let resp;
    try {
      resp = await fetch(req.url, init6);
    } catch (_error) {
      clearTimeout(timer);
      if (error2) {
        throw error2;
      }
      throw _error;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body2 = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body: body2
    };
  }
  return getUrl3;
}
var defaultGetUrl = createGetUrl({});

// node_modules/azle/node_modules/ethers/lib.esm/utils/fetch.js
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
var defaultGetUrlFunc = createGetUrl();
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked = false;
async function dataGatewayFunc(url2, signal) {
  try {
    const match = url2.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error2) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url2));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url2, signal) {
    try {
      const match = url2.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error2) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url2));
    }
  }
  return gatewayIpfs;
}
var Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals = /* @__PURE__ */ new WeakMap();
var FetchCancelSignal = class {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert4(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert4(!this.cancelled, "cancelled", "CANCELLED", {});
  }
};
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
var FetchRequest = class _FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  // Hooks
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  /**
   *  The fetch URL to request.
   */
  get url() {
    return this.#url;
  }
  set url(url2) {
    this.#url = String(url2);
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body2) {
    if (body2 == null) {
      this.#body = void 0;
      this.#bodyType = void 0;
    } else if (typeof body2 === "string") {
      this.#body = toUtf8Bytes(body2);
      this.#bodyType = "text/plain";
    } else if (body2 instanceof Uint8Array) {
      this.#body = body2;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body2 === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body2));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
    }
    ;
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return this.#creds || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process3) {
    this.#process = process3;
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url2) {
    this.#url = String(url2);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 3e5;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async #send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert4(getTime() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result2 = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result2 instanceof FetchResponse) {
        let response2 = result2;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error2) {
            if (error2.throttle == null || typeof error2.stall !== "number") {
              response2.makeServerError("error in post-processing function", error2).assertOk();
            }
          }
        }
        return response2;
      }
      req = result2;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error2) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error2) {
        if (error2.throttle == null || typeof error2.stall !== "number") {
          response.makeServerError("error in post-processing function", error2).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        ;
        if (error2.stall >= 0) {
          delay2 = error2.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert4(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert4(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert4(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    clone.#throttle = Object.assign({}, this.#throttle);
    clone.#getUrlFunc = this.#getUrlFunc;
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl3) {
    if (locked) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl3;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
var FetchResponse = class _FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return this.#statusCode;
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return this.#statusMessage;
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, this.#headers);
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error2) {
      assert4(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error2) {
      assert4(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body2, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body2 == null ? null : new Uint8Array(body2);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error2) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
    response.#error = { message, error: error2 };
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall9) {
    if (stall9 == null) {
      stall9 = -1;
    } else {
      assertArgument(Number.isInteger(stall9) && stall9 >= 0, "invalid stall timeout", "stall", stall9);
    }
    const error2 = new Error(message || "throttling requests");
    defineProperties(error2, { stall: stall9, throttle: true });
    throw error2;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return this.#request;
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error: error2 } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String(this.#body);
      }
    } catch (e3) {
    }
    assert4(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: error2,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve3) => setTimeout(resolve3, delay));
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/fixednumber.js
var BN_N1 = BigInt(-1);
var BN_03 = BigInt(0);
var BN_12 = BigInt(1);
var BN_5 = BigInt(5);
var _guard = {};
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}
function getTens(decimals) {
  let result2 = Zeros;
  while (result2.length < decimals) {
    result2 += result2;
  }
  return BigInt("1" + result2.substring(0, decimals));
}
function checkValue(val, format3, safeOp) {
  const width = BigInt(format3.width);
  if (format3.signed) {
    const limit = BN_12 << width - BN_12;
    assert4(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_03) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_12 << width;
    assert4(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_12;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed3 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") {
    } else if (value === "ufixed") {
      signed3 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed3 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v2 = value;
    const check = (key, type, defaultValue) => {
      if (v2[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v2[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v2[key]);
      return v2[key];
    };
    signed3 = check("signed", "boolean", signed3);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed3 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed3, width, decimals, name };
}
function toString2(val, decimals) {
  let negative = "";
  if (val < BN_03) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
var FixedNumber = class _FixedNumber {
  /**
   *  The specific fixed-point arithmetic field for this value.
   */
  format;
  #format;
  // The actual value (accounting for decimals)
  #val;
  // A base-10 value to multiple values by to maintain the magnitude
  #tens;
  /**
   *  This is a property so console.log shows a human-meaningful value.
   *
   *  @private
   */
  _value;
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format3) {
    assertPrivate(guard, _guard, "FixedNumber");
    this.#val = value;
    this.#format = format3;
    const _value = toString2(value, format3.decimals);
    defineProperties(this, { format: format3.name, _value });
    this.#tens = getTens(format3.decimals);
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return this.#format.signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return this.#format.width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return this.#format.decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue(val, this.#format, safeOp);
    return new _FixedNumber(_guard, val, this.#format);
  }
  #add(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val + o3.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return this.#add(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val - o3.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return this.#sub(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val * o3.#val / this.#tens, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return this.#mul(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return this.#mul(other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    this.#checkFormat(other);
    const value = this.#val * other.#val;
    assert4(value % this.#tens === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / this.#tens, "mulSignal");
  }
  #div(o3, safeOp) {
    assert4(o3.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o3);
    return this.#checkValue(this.#val * this.#tens / o3.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return this.#div(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return this.#div(other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert4(other.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value = this.#val * this.#tens;
    assert4(value % other.#val === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / other.#val, "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b4 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b4 *= getTens(delta);
    } else if (delta < 0) {
      a2 *= getTens(-delta);
    }
    if (a2 < b4) {
      return -1;
    }
    if (a2 > b4) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = this.#val;
    if (this.#val < BN_03) {
      val -= this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_03) {
      val += this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, this.#format, "round");
    return new _FixedNumber(_guard, value, this.#format);
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return this.#val === BN_03;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return this.#val < BN_03;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format3) {
    return _FixedNumber.fromString(this.toString(), format3);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value, _decimals, _format) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format3 = getFormat(_format);
    let value = getBigInt(_value, "value");
    const delta = decimals - format3.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert4(value % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format3, "fromValue");
    return new _FixedNumber(_guard, value, format3);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value, _format) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format3 = getFormat(_format);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format3.decimals) {
      decimal += Zeros;
    }
    assert4(decimal.substring(format3.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format3.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format3, "fromString");
    return new _FixedNumber(_guard, value, format3);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value, _format) {
    let value = toBigInt2(getBytes(_value, "value"));
    const format3 = getFormat(_format);
    if (format3.signed) {
      value = fromTwos(value, format3.width);
    }
    checkValue(value, format3, "fromBytes");
    return new _FixedNumber(_guard, value, format3);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte(value) {
  let result2 = value.toString(16);
  while (result2.length < 2) {
    result2 = "0" + result2;
  }
  return "0x" + result2;
}
function unarrayifyInteger(data, offset, length) {
  let result2 = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result2 = result2 * 256 + data[offset + i2];
  }
  return result2;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result2 = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result2.push(decoded.result);
    childOffset += decoded.consumed;
    assert4(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result: result2 };
}
function _decode(data, offset) {
  assert4(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert4(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result2 = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result: result2 };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result2 = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result: result2 };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data) {
  const data = getBytes(_data, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger(value) {
  const result2 = [];
  while (value) {
    result2.unshift(value & 255);
    value >>= 8;
  }
  return result2;
}
function _encode(object3) {
  if (Array.isArray(object3)) {
    let payload = [];
    object3.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object3, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
var nibbles = "0123456789abcdef";
function encodeRlp(object3) {
  let result2 = "0x";
  for (const v2 of _encode(object3)) {
    result2 += nibbles[v2 >> 4];
    result2 += nibbles[v2 & 15];
  }
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/units.js
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

// node_modules/azle/node_modules/ethers/lib.esm/utils/uuid.js
function uuidV4(randomBytes7) {
  const bytes4 = getBytes(randomBytes7, "randomBytes");
  bytes4[6] = bytes4[6] & 15 | 64;
  bytes4[8] = bytes4[8] & 63 | 128;
  const value = hexlify(bytes4);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
var passProperties = ["then"];
var _guard2 = {};
var resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result2) {
  return resultNames.get(result2);
}
function setNames(result2, names3) {
  resultNames.set(result2, names3);
}
function throwError(name, error2) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error2;
  throw wrapped;
}
function toObject(names3, items, deep) {
  if (names3.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result2) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names3.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result2) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
var Result2 = class _Result extends Array {
  // No longer used; but cannot be removed as it will remove the
  // #private field from the .d.ts which may break backwards
  // compatibility
  #names;
  /**
   *  @private
   */
  constructor(...args2) {
    const guard = args2[0];
    let items = args2[1];
    let names3 = (args2[2] || []).slice();
    let wrap2 = true;
    if (guard !== _guard2) {
      items = args2;
      names3 = [];
      wrap2 = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names3.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names3[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      void this.#names;
    }
    if (!wrap2) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args3) {
              return value.apply(this === receiver ? target : this, args3);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result2 = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result2.push(item);
    });
    return result2;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names3 = getNames(this);
    return names3.reduce((accum, name, index) => {
      assert4(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names3, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames(this);
    const result2 = [], names3 = [];
    for (let i2 = start; i2 < end; i2++) {
      result2.push(this[i2]);
      names3.push(_names[i2]);
    }
    return new _Result(_guard2, result2, names3);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names = getNames(this);
    const result2 = [], names3 = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      const item = this[i2];
      if (item instanceof Error) {
        throwError(`index ${i2}`, item);
      }
      if (callback.call(thisArg, item, i2, this)) {
        result2.push(item);
        names3.push(_names[i2]);
      }
    }
    return new _Result(_guard2, result2, names3);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result2 = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      const item = this[i2];
      if (item instanceof Error) {
        throwError(`index ${i2}`, item);
      }
      result2.push(callback.call(thisArg, item, i2, this));
    }
    return result2;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard2, items, keys);
  }
};
function checkResultErrors(result2) {
  const errors2 = [];
  const checkErrors = function(path2, object3) {
    if (!Array.isArray(object3)) {
      return;
    }
    for (let key in object3) {
      const childPath = path2.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object3[key]);
      } catch (error2) {
        errors2.push({ path: childPath, error: error2 });
      }
    }
  };
  checkErrors([], result2);
  return errors2;
}
function getValue(value) {
  let bytes4 = toBeArray(value);
  assert4(bytes4.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes4, length: WordSize, offset: bytes4.length });
  if (bytes4.length !== WordSize) {
    bytes4 = getBytesCopy(concat2([Padding.slice(bytes4.length % WordSize), bytes4]));
  }
  return bytes4;
}
var Coder = class {
  // The coder name:
  //   - address, uint256, tuple, array, etc.
  name;
  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
  type;
  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz
  localName;
  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
};
var Writer = class {
  // An array of WordSize lengthed objects to concatenation
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat2(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data) {
    this.#data.push(data);
    this.#dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes4 = getBytesCopy(value);
    const paddingOffset = bytes4.length % WordSize;
    if (paddingOffset) {
      bytes4 = getBytesCopy(concat2([bytes4, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes4);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return this.#writeData(getValue(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value) => {
      this.#data[offset] = getValue(value);
    };
  }
};
var Reader = class _Reader {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data, allowLoose, maxInflation) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert4(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert4(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes4 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes4.length;
    return bytes4.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt2(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js
function number(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0)
    throw new Error(`Wrong positive integer: ${n5}`);
}
function bytes2(b4, ...lengths) {
  if (!(b4 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b4.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes2(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/utils.js
var u8a = (a2) => a2 instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var nextTick3 = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i2 = 0; i2 < iters; i2++) {
    cb(i2);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick3();
    ts += diff;
  }
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a(a2))
      throw new Error("Uint8Array expected");
    r3.set(a2, pad2);
    pad2 += a2.length;
  });
  return r3;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes2(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash3, _password, _salt, _opts) {
  hash(hash3);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  number(c2);
  number(dkLen);
  number(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes2(_password);
  const salt = toBytes2(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK;
}
function pbkdf2(hash3, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView2(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti.set(u2.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u2[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l2 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l2, wl, isLE3);
}
var SHA2 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a2, b4, c2) => a2 & b4 ^ ~a2 & c2;
var Maj2 = (a2, b4, c2) => a2 & b4 ^ a2 & c2 ^ b4 & c2;
var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
var SHA2562 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F: F2, G, H } = this;
    return [A, B, C, D, E, F2, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F2, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W2[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W2[i2 - 15];
      const W2 = SHA256_W2[i2 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F: F2, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T15 = H + sigma1 + Chi2(E, F2, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T23 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F2;
      F2 = E;
      E = D + T15 | 0;
      D = C;
      C = B;
      B = A;
      A = T15 + T23 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F2, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor2(() => new SHA2562());

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n5, le = false) {
  if (le)
    return { h: Number(n5 & U32_MASK64), l: Number(n5 >> _32n & U32_MASK64) };
  return { h: Number(n5 >> _32n & U32_MASK64) | 0, l: Number(n5 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l2 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h2, l2];
  }
  return [Ah, Al];
}
var toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
var shrSH = (h2, _l, s) => h2 >>> s;
var shrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
var rotrSH = (h2, l2, s) => h2 >>> s | l2 << 32 - s;
var rotrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
var rotrBH = (h2, l2, s) => h2 << 64 - s | l2 >>> s - 32;
var rotrBL = (h2, l2, s) => h2 >>> s - 32 | l2 << 64 - s;
var rotr32H = (_h, l2) => l2;
var rotr32L = (h2, _l) => h2;
var rotlSH = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
var rotlSL = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
var rotlBH = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
var rotlBL = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha512 = /* @__PURE__ */ wrapConstructor2(() => new SHA512());

// node_modules/azle/node_modules/ethers/lib.esm/crypto/crypto-browser.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto3 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256.create();
    case "sha512":
      return sha512.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes2(length) {
  assert4(crypto3 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result2 = new Uint8Array(length);
  crypto3.getRandomValues(result2);
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/crypto/hmac.js
var locked2 = false;
var _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
var __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked2 = true;
};
computeHmac.register = function(func) {
  if (locked2) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n, x = 1, y2 = 0; round < 24; round++) {
  [x, y2] = [y2, (2 * x + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t2);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h2, l2, s) => s > 32 ? rotlBH(h2, l2, s) : rotlSH(h2, l2, s);
var rotlL = (h2, l2, s) => s > 32 ? rotlBL(h2, l2, s) : rotlSL(h2, l2, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x + y2] ^= Th;
        s[x + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y2 + x];
      for (let x = 0; x < 10; x++)
        s[y2 + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash2 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists2(this);
    const { blockLen, state } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists2(this, false);
    bytes2(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes4) {
    number(bytes4);
    return this.xofInto(new Uint8Array(bytes4));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

// node_modules/azle/node_modules/ethers/lib.esm/crypto/keccak.js
var locked3 = false;
var _keccak256 = function(data) {
  return keccak_256(data);
};
var __keccak256 = _keccak256;
function keccak256(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked3 = true;
};
keccak256.register = function(func) {
  if (locked3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i2) => i2);
var Pi = /* @__PURE__ */ Id.map((i2) => (9 * i2 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i2 = 0; i2 < 4; i2++)
  for (let j of [idxL, idxR])
    j.push(j[i2].map((k) => Rho[k]));
var shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => new Uint8Array(i2));
var shiftsL = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j) => shifts[i2][j]));
var shiftsR = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j) => shifts[i2][j]));
var Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f2(group, x, y2, z) {
  if (group === 0)
    return x ^ y2 ^ z;
  else if (group === 1)
    return x & y2 | ~x & z;
  else if (group === 2)
    return (x | ~y2) ^ z;
  else if (group === 3)
    return x & z | y2 & ~z;
  else
    return x ^ (y2 | ~z);
}
var BUF = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + f2(group, bl, cl, dl) + BUF[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar + f2(rGroup, br, cr, dr) + BUF[rr[i2]] + hbr, sr[i2]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ wrapConstructor2(() => new RIPEMD160());

// node_modules/azle/node_modules/ethers/lib.esm/crypto/ripemd160.js
var locked4 = false;
var _ripemd160 = function(data) {
  return ripemd160(data);
};
var __ripemd160 = _ripemd160;
function ripemd1602(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__ripemd160(data));
}
ripemd1602._ = _ripemd160;
ripemd1602.lock = function() {
  locked4 = true;
};
ripemd1602.register = function(func) {
  if (locked4) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1602);

// node_modules/azle/node_modules/ethers/lib.esm/crypto/pbkdf2.js
var locked5 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
function pbkdf22(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf22._ = _pbkdf2;
pbkdf22.lock = function() {
  locked5 = true;
};
pbkdf22.register = function(func) {
  if (locked5) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf22);

// node_modules/azle/node_modules/ethers/lib.esm/crypto/random.js
var locked6 = false;
var _randomBytes = function(length) {
  return new Uint8Array(randomBytes2(length));
};
var __randomBytes = _randomBytes;
function randomBytes3(length) {
  return __randomBytes(length);
}
randomBytes3._ = _randomBytes;
randomBytes3.lock = function() {
  locked6 = true;
};
randomBytes3.register = function(func) {
  if (locked6) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes3);

// node_modules/azle/node_modules/ethers/node_modules/@noble/hashes/esm/scrypt.js
var rotl2 = (a2, b4) => a2 << b4 | a2 >>> 32 - b4;
function XorAndSalsa(prev, pi, input2, ii, out, oi) {
  let y00 = prev[pi++] ^ input2[ii++], y01 = prev[pi++] ^ input2[ii++];
  let y02 = prev[pi++] ^ input2[ii++], y03 = prev[pi++] ^ input2[ii++];
  let y04 = prev[pi++] ^ input2[ii++], y05 = prev[pi++] ^ input2[ii++];
  let y06 = prev[pi++] ^ input2[ii++], y07 = prev[pi++] ^ input2[ii++];
  let y08 = prev[pi++] ^ input2[ii++], y09 = prev[pi++] ^ input2[ii++];
  let y10 = prev[pi++] ^ input2[ii++], y11 = prev[pi++] ^ input2[ii++];
  let y12 = prev[pi++] ^ input2[ii++], y13 = prev[pi++] ^ input2[ii++];
  let y14 = prev[pi++] ^ input2[ii++], y15 = prev[pi++] ^ input2[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i2 = 0; i2 < 8; i2 += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input2, ii, out, oi, r3) {
  let head = oi + 0;
  let tail = oi + 16 * r3;
  for (let i2 = 0; i2 < 16; i2++)
    out[tail + i2] = input2[ii + (2 * r3 - 1) * 16 + i2];
  for (let i2 = 0; i2 < r3; i2++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input2, ii, out, head);
    if (i2 > 0)
      tail += 16;
    XorAndSalsa(out, head, input2, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N5, r: r3, p: p3, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N5);
  number(r3);
  number(p3);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r3;
  const blockSize32 = blockSize / 4;
  if (N5 <= 1 || (N5 & N5 - 1) !== 0 || N5 >= 2 ** (blockSize / 8) || N5 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p3 < 0 || p3 > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N5 + p3);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p3 });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N5));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N5 * p3;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N5, r: r3, p: p3, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt(password, salt, opts) {
  const { N: N5, r: r3, p: p3, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p3; pi++) {
    const Pi3 = blockSize32 * pi;
    for (let i2 = 0; i2 < blockSize32; i2++)
      V[i2] = B32[Pi3 + i2];
    for (let i2 = 0, pos = 0; i2 < N5 - 1; i2++) {
      BlockMix(V, pos, V, pos += blockSize32, r3);
      blockMixCb();
    }
    BlockMix(V, (N5 - 1) * blockSize32, B32, Pi3, r3);
    blockMixCb();
    for (let i2 = 0; i2 < N5; i2++) {
      const j = B32[Pi3 + blockSize32 - 16] % N5;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi3 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi3, r3);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N5, r: r3, p: p3, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p3; pi++) {
    const Pi3 = blockSize32 * pi;
    for (let i2 = 0; i2 < blockSize32; i2++)
      V[i2] = B32[Pi3 + i2];
    let pos = 0;
    await asyncLoop(N5 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r3);
      blockMixCb();
    });
    BlockMix(V, (N5 - 1) * blockSize32, B32, Pi3, r3);
    blockMixCb();
    await asyncLoop(N5, asyncTick, () => {
      const j = B32[Pi3 + blockSize32 - 16] % N5;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi3 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi3, r3);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/azle/node_modules/ethers/lib.esm/crypto/scrypt.js
var lockedSync = false;
var lockedAsync = false;
var _scryptAsync = async function(passwd, salt, N5, r3, p3, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N5, r: r3, p: p3, dkLen, onProgress });
};
var _scryptSync = function(passwd, salt, N5, r3, p3, dkLen) {
  return scrypt(passwd, salt, { N: N5, r: r3, p: p3, dkLen });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
async function scrypt2(_passwd, _salt, N5, r3, p3, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N5, r3, p3, dkLen, progress));
}
scrypt2._ = _scryptAsync;
scrypt2.lock = function() {
  lockedAsync = true;
};
scrypt2.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt2);
function scryptSync(_passwd, _salt, N5, r3, p3, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N5, r3, p3, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);

// node_modules/azle/node_modules/ethers/lib.esm/crypto/sha2.js
var _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
var _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
function sha2562(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha256(data));
}
sha2562._ = _sha256;
sha2562.lock = function() {
  locked256 = true;
};
sha2562.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2562);
function sha5122(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha512(data));
}
sha5122._ = _sha512;
sha5122.lock = function() {
  locked512 = true;
};
sha5122.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2562);

// node_modules/azle/node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject3
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a2) => a2 instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes4) {
  if (!u8a2(bytes4))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    hex += hexes[bytes4[i2]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes4) {
  return hexToNumber(bytesToHex(bytes4));
}
function bytesToNumberLE(bytes4) {
  if (!u8a2(bytes4))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes4).reverse()));
}
function numberToBytesBE(n5, len) {
  return hexToBytes(n5.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n5, len) {
  return numberToBytesBE(n5, len).reverse();
}
function numberToVarBytesBE(n5) {
  return hexToBytes(numberToHexUnpadded(n5));
}
function ensureBytes(title2, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e3) {
      throw new Error(`${title2} must be valid hex string, got "${hex}". Cause: ${e3}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title2} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title2} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a2(a2))
      throw new Error("Uint8Array expected");
    r3.set(a2, pad2);
    pad2 += a2.length;
  });
  return r3;
}
function equalBytes(b1, b22) {
  if (b1.length !== b22.length)
    return false;
  for (let i2 = 0; i2 < b1.length; i2++)
    if (b1[i2] !== b22[i2])
      return false;
  return true;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n5) {
  let len;
  for (len = 0; n5 > _0n2; n5 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n5, pos) {
  return n5 >> BigInt(pos) & _1n2;
}
var bitSet = (n5, pos, value) => {
  return n5 | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n5) => (_2n2 << BigInt(n5 - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v2.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h2 = (...b4) => hmacFn(k, v2, ...b4);
  const reseed = (seed = u8n()) => {
    k = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v2 = h2();
  };
  const gen3 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl = v2.slice();
      out.push(sl);
      len += v2.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen3())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object3) => object3.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject3(object3, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object3[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object3)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object3;
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a2, b4) {
  const result2 = a2 % b4;
  return result2 >= _0n3 ? result2 : b4 + result2;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a2 = mod(number3, modulo);
  let b4 = modulo;
  let x = _0n3, y2 = _1n3, u2 = _1n3, v2 = _0n3;
  while (a2 !== _0n3) {
    const q = b4 / a2;
    const r3 = b4 % a2;
    const m2 = x - u2 * q;
    const n5 = y2 - v2 * q;
    b4 = a2, a2 = r3, x = u2, y2 = v2, u2 = m2, v2 = n5;
  }
  const gcd = b4;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n3) / _2n3;
  let Q, S3, Z;
  for (Q = P2 - _1n3, S3 = 0; Q % _2n3 === _0n3; Q /= _2n3, S3++)
    ;
  for (Z = _2n3; Z < P2 && pow(Z, legendreC, P2) !== P2 - _1n3; Z++)
    ;
  if (S3 === 1) {
    const p1div4 = (P2 + _1n3) / _4n;
    return function tonelliFast(Fp3, n5) {
      const root = Fp3.pow(n5, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp3, n5) {
    if (Fp3.pow(n5, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r3 = S3;
    let g2 = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n5, Q1div2);
    let b4 = Fp3.pow(n5, Q);
    while (!Fp3.eql(b4, Fp3.ONE)) {
      if (Fp3.eql(b4, Fp3.ZERO))
        return Fp3.ZERO;
      let m2 = 1;
      for (let t2 = Fp3.sqr(b4); m2 < r3; m2++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g2, _1n3 << BigInt(r3 - m2 - 1));
      g2 = Fp3.sqr(ge);
      x = Fp3.mul(x, ge);
      b4 = Fp3.mul(b4, g2);
      r3 = m2;
    }
    return x;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n) {
    const p1div4 = (P2 + _1n3) / _4n;
    return function sqrt3mod4(Fp3, n5) {
      const root = Fp3.pow(n5, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp3, n5) {
      const n22 = Fp3.mul(n5, _2n3);
      const v2 = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n5, v2);
      const i2 = Fp3.mul(Fp3.mul(nv, _2n3), v2);
      const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _16n === _9n) {
  }
  return tonelliShanks(P2);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject3(field, opts);
}
function FpPow(f4, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f4.ONE;
  if (power === _1n3)
    return num;
  let p3 = f4.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p3 = f4.mul(p3, d);
    d = f4.sqr(d);
    power >>= _1n3;
  }
  return p3;
}
function FpInvertBatch(f4, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f4.is0(num))
      return acc;
    tmp[i2] = acc;
    return f4.mul(acc, num);
  }, f4.ONE);
  const inverted = f4.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f4.is0(num))
      return acc;
    tmp[i2] = f4.mul(acc, tmp[i2]);
    return f4.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n5, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen3, isLE3 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f4 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f4, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n5) => sqrtP(f4, n5)),
    invertBatch: (lst) => FpInvertBatch(f4, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b4, c2) => c2 ? b4 : a2,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes4) => {
      if (bytes4.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes4.length}`);
      return isLE3 ? bytesToNumberLE(bytes4) : bytesToNumberBE(bytes4);
    }
  });
  return Object.freeze(f4);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n5) {
      let p3 = c2.ZERO;
      let d = elm;
      while (n5 > _0n4) {
        if (n5 & _1n4)
          p3 = p3.add(d);
        d = d.double();
        n5 >>= _1n4;
      }
      return p3;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p3 = elm;
      let base2 = p3;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p3;
        points.push(base2);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base2 = base2.add(p3);
          points.push(base2);
        }
        p3 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n5) {
      const { windows, windowSize } = opts(W);
      let p3 = c2.ZERO;
      let f4 = c2.BASE;
      const mask3 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n5 & mask3);
        n5 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n5 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f4 = f4.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p3 = p3.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p3, f: f4 };
    },
    wNAFCached(P2, precomputesMap, n5, transform) {
      const W = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W);
        if (W !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W, comp, n5);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject3(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject3(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a2 } = opts;
  if (endo) {
    if (!Fp3.eql(a2, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r3, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r: r3, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h2(sig.s));
    const r3 = slice(h2(sig.r));
    const shl = s.length / 2;
    const rhl = r3.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r3}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a2.x), Fp3.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes4) => {
    const tail = bytes4.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y: y2 };
  });
  function weierstrassEquation(x) {
    const { a: a2, b: b4 } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a2)), b4);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n5 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error2) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n5);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p3) {
      const { x, y: y2 } = p3 || {};
      if (!p3 || !Fp3.isValid(x) || !Fp3.isValid(y2))
        throw new Error("invalid affine point");
      if (p3 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp3.eql(i2, Fp3.ZERO);
      if (is0(x) && is0(y2))
        return Point3.ZERO;
      return new Point3(x, y2, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p3) => p3.pz));
      return points.map((p3, i2) => p3.toAffine(toInv[i2])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: y2 } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y2);
      const right = weierstrassEquation(x);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U13 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U23 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U13 && U23;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b4 } = CURVE;
      const b32 = Fp3.mul(b4, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a2, Z3);
      Y3 = Fp3.mul(b32, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b32, Z3);
      t2 = Fp3.mul(a2, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a2, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a2 = CURVE.a;
      const b32 = Fp3.mul(CURVE.b, _3n2);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a2, t4);
      X3 = Fp3.mul(b32, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.mul(b32, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n5) {
      return wnaf.wNAFCached(this, pointPrecomputes, n5, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p3) => p3.pz));
        return comp.map((p3, i2) => p3.toAffine(toInv[i2])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n5) {
      const I = Point3.ZERO;
      if (n5 === _0n5)
        return I;
      assertGE(n5);
      if (n5 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n5);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n5);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n5 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n5);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p3, f: f4 } = this.wNAF(n5);
        point = p3;
        fake = f4;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a2, b4) {
      const G = Point3.BASE;
      const mul = (P2, a3) => a3 === _0n5 || a3 === _1n5 || !P2.equals(G) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul(this, a2).add(mul(Q, b4));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y2, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y2, iz);
      const zz = Fp3.mul(z, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes5(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject3(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp3.ORDER;
  }
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a2 = point.toAffine();
      const x = Fp3.toBytes(a2.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a2.y));
      }
    },
    fromBytes(bytes4) {
      const len = bytes4.length;
      const head = bytes4[0];
      const tail = bytes4.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y3 = Fp3.sqrt(y2);
        const isYOdd = (y3 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp3.neg(y3);
        return { x, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n5;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b4, from, to) => bytesToNumberBE(b4.slice(from, to));
  class Signature3 {
    constructor(r3, s, recovery) {
      this.r = r3;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l2 * 2);
      return new Signature3(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r3, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature3(r3, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature3(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r3, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE.n : r3;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature3(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b4 = Point3.fromHex(publicB);
    return b4.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes4) {
    const num = bytesToNumberBE(bytes4);
    const delta = bytes4.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes4) {
    return modN(bits2int(bytes4));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes7 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e3 = ent === true ? randomBytes7(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r3 = modN(q.x);
      if (r3 === _0n5)
        return;
      const s = modN(ik * modN(m2 + r3 * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r3 ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature3(r3, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature3.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature3.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r4, s: s2 } = sg;
        _sig = new Signature3(r4, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point3.fromHex(publicKey);
    } catch (error2) {
      if (error2.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r3, s } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h2 * is);
    const u2 = modN(r3 * is);
    const R = Point3.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v2 = modN(R.x);
    return v2 === r3;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature: Signature3,
    utils
  };
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/azle/node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a2, b4) => (a2 + b4 / _2n5) / b4;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y2 * y2 * y2 % P2;
  const b32 = b22 * b22 * y2 % P2;
  const b6 = pow2(b32, _3n5, P2) * b32 % P2;
  const b9 = pow2(b6, _3n5, P2) * b32 % P2;
  const b11 = pow2(b9, _2n5, P2) * b22 % P2;
  const b222 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b222, _22n, P2) * b222 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n5, P2) * b32 % P2;
  const t1 = pow2(b223, _23n, P2) * b222 % P2;
  const t2 = pow2(t1, _6n, P2) * b22 % P2;
  const root = pow2(t2, _2n5, P2);
  if (!Fp.eql(Fp.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n5 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k, n5);
      const c2 = divNearest(-b1 * k, n5);
      let k1 = mod(k - c1 * a1 - c2 * a2, n5);
      let k2 = mod(-c1 * b1 - c2 * b22, n5);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n5 - k1;
      if (k2neg)
        k2 = n5 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// node_modules/azle/node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress = "0x0000000000000000000000000000000000000000";

// node_modules/azle/node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/azle/node_modules/ethers/lib.esm/constants/numbers.js
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther = BigInt("1000000000000000000");
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/azle/node_modules/ethers/lib.esm/constants/strings.js
var EtherSymbol = "\u039E";
var MessagePrefix = "Ethereum Signed Message:\n";

// node_modules/azle/node_modules/ethers/lib.esm/crypto/signature.js
var BN_04 = BigInt(0);
var BN_13 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
var Signature = class _Signature {
  #r;
  #s;
  #v;
  #networkV;
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    this.#r = hexlify(value);
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    const value = hexlify(_value);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    this.#s = value;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return this.#v;
  }
  set v(value) {
    const v2 = getNumber(value, "value");
    assertArgument(v2 === 27 || v2 === 28, "invalid v", "v", value);
    this.#v = v2;
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return this.#networkV;
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v2 = this.networkV;
    if (v2 == null) {
      return null;
    }
    return _Signature.getChainId(v2);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat2([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat2([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  @private
   */
  constructor(guard, r3, s, v2) {
    assertPrivate(guard, _guard3, "Signature");
    this.#r = r3;
    this.#s = s;
    this.#v = v2;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard3, this.r, this.s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v2) {
    const bv = getBigInt(v2, "v");
    if (bv == BN_27 || bv == BN_28) {
      return BN_04;
    }
    assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v2);
    return (bv - BN_35) / BN_2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v2) {
    return getBigInt(chainId) * BN_2 + BigInt(35 + v2 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v2) {
    const bv = getBigInt(v2);
    if (bv === BN_04 || bv === BN_27) {
      return 27;
    }
    if (bv === BN_13 || bv === BN_28) {
      return 28;
    }
    assertArgument(bv >= BN_35, "invalid v", "v", v2);
    return bv & BN_13 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    ;
    if (sig == null) {
      return new _Signature(_guard3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes4 = getBytes(sig, "signature");
      if (bytes4.length === 64) {
        const r4 = hexlify(bytes4.slice(0, 32));
        const s2 = bytes4.slice(32, 64);
        const v3 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _Signature(_guard3, r4, hexlify(s2), v3);
      }
      if (bytes4.length === 65) {
        const r4 = hexlify(bytes4.slice(0, 32));
        const s2 = bytes4.slice(32, 64);
        assertError((s2[0] & 128) === 0, "non-canonical s");
        const v3 = _Signature.getNormalizedV(bytes4[64]);
        return new _Signature(_guard3, r4, hexlify(s2), v3);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r3 = toUint256(_r);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes4 = getBytes(yParityAndS);
        bytes4[0] &= 127;
        return hexlify(bytes4);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v2 } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v3 = getBigInt(_v);
        return {
          networkV: v3 >= BN_35 ? v3 : void 0,
          v: _Signature.getNormalizedV(v3)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result2 = new _Signature(_guard3, r3, s, v2);
    if (networkV) {
      result2.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result2.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result2.yParityAndS, "yParityAndS mismatch");
    return result2;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/crypto/signing-key.js
var SigningKey = class _SigningKey {
  #privateKey;
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return this.#privateKey;
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(this.#privateKey);
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(this.#privateKey, true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes4 = getBytes(key, "key");
    if (bytes4.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes4, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes4.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes4, 1);
      bytes4 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes4);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat2([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/crypto/index.js
function lock() {
  computeHmac.lock();
  keccak256.lock();
  pbkdf22.lock();
  randomBytes3.lock();
  ripemd1602.lock();
  scrypt2.lock();
  scryptSync.lock();
  sha2562.lock();
  sha5122.lock();
  randomBytes3.lock();
}

// node_modules/azle/node_modules/ethers/lib.esm/address/address.js
var BN_05 = BigInt(0);
var BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var ibanLookup = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum3 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum3.length < 2) {
    checksum3 = "0" + checksum3;
  }
  return checksum3;
}
var Base36 = function() {
  ;
  const result2 = {};
  for (let i2 = 0; i2 < 36; i2++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i2];
    result2[key] = BigInt(i2);
  }
  return result2;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result2 = BN_05;
  for (let i2 = 0; i2 < value.length; i2++) {
    result2 = result2 * BN_36 + Base36[value[i2]];
  }
  return result2;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result2 = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result2 === address, "bad address checksum", "address", address);
    return result2;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result2 = fromBase36(address.substring(4)).toString(16);
    while (result2.length < 40) {
      result2 = "0" + result2;
    }
    return getChecksumAddress("0x" + result2);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}

// node_modules/azle/node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from2, _salt, _initCodeHash) {
  const from = getAddress(_from2);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat2(["0xff", from, salt, initCodeHash])), 12));
}

// node_modules/azle/node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error2) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result2 = await promise;
  if (result2 == null || result2 === "0x0000000000000000000000000000000000000000") {
    assert4(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result2);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert4(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}

// node_modules/azle/node_modules/ethers/lib.esm/abi/typed.js
var _gaurd = {};
function n3(value, width) {
  let signed3 = false;
  if (width < 0) {
    signed3 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed3 ? "" : "u"}int${width}`, value, { signed: signed3, width });
}
function b2(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
var _typedSymbol = Symbol.for("_ethers_typed");
var Typed = class _Typed {
  /**
   *  The type, as a Solidity-compatible type.
   */
  type;
  /**
   *  The actual value.
   */
  value;
  #options;
  /**
   *  @_ignore:
   */
  _typedSymbol;
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    this.#options = options;
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v2) => v2.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v2) {
    return n3(v2, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v2) {
    return n3(v2, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v2) {
    return n3(v2, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v2) {
    return n3(v2, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v2) {
    return n3(v2, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v2) {
    return n3(v2, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v2) {
    return n3(v2, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v2) {
    return n3(v2, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v2) {
    return n3(v2, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v2) {
    return n3(v2, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v2) {
    return n3(v2, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v2) {
    return n3(v2, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v2) {
    return n3(v2, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v2) {
    return n3(v2, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v2) {
    return n3(v2, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v2) {
    return n3(v2, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v2) {
    return n3(v2, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v2) {
    return n3(v2, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v2) {
    return n3(v2, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v2) {
    return n3(v2, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v2) {
    return n3(v2, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v2) {
    return n3(v2, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v2) {
    return n3(v2, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v2) {
    return n3(v2, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v2) {
    return n3(v2, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v2) {
    return n3(v2, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v2) {
    return n3(v2, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v2) {
    return n3(v2, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v2) {
    return n3(v2, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v2) {
    return n3(v2, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v2) {
    return n3(v2, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v2) {
    return n3(v2, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v2) {
    return n3(v2, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v2) {
    return n3(v2, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v2) {
    return n3(v2, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v2) {
    return n3(v2, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v2) {
    return n3(v2, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v2) {
    return n3(v2, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v2) {
    return n3(v2, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v2) {
    return n3(v2, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v2) {
    return n3(v2, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v2) {
    return n3(v2, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v2) {
    return n3(v2, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v2) {
    return n3(v2, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v2) {
    return n3(v2, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v2) {
    return n3(v2, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v2) {
    return n3(v2, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v2) {
    return n3(v2, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v2) {
    return n3(v2, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v2) {
    return n3(v2, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v2) {
    return n3(v2, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v2) {
    return n3(v2, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v2) {
    return n3(v2, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v2) {
    return n3(v2, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v2) {
    return n3(v2, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v2) {
    return n3(v2, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v2) {
    return n3(v2, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v2) {
    return n3(v2, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v2) {
    return n3(v2, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v2) {
    return n3(v2, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v2) {
    return n3(v2, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v2) {
    return n3(v2, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v2) {
    return n3(v2, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v2) {
    return n3(v2, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v2) {
    return n3(v2, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v2) {
    return n3(v2, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v2) {
    return b2(v2, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v2) {
    return b2(v2, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v2) {
    return b2(v2, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v2) {
    return b2(v2, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v2) {
    return b2(v2, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v2) {
    return b2(v2, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v2) {
    return b2(v2, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v2) {
    return b2(v2, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v2) {
    return b2(v2, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v2) {
    return b2(v2, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v2) {
    return b2(v2, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v2) {
    return b2(v2, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v2) {
    return b2(v2, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v2) {
    return b2(v2, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v2) {
    return b2(v2, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v2) {
    return b2(v2, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v2) {
    return b2(v2, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v2) {
    return b2(v2, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v2) {
    return b2(v2, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v2) {
    return b2(v2, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v2) {
    return b2(v2, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v2) {
    return b2(v2, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v2) {
    return b2(v2, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v2) {
    return b2(v2, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v2) {
    return b2(v2, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v2) {
    return b2(v2, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v2) {
    return b2(v2, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v2) {
    return b2(v2, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v2) {
    return b2(v2, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v2) {
    return b2(v2, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v2) {
    return b2(v2, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v2) {
    return b2(v2, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v2) {
    return new _Typed(_gaurd, "address", v2);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v2) {
    return new _Typed(_gaurd, "bool", !!v2);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v2) {
    return new _Typed(_gaurd, "bytes", v2);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v2) {
    return new _Typed(_gaurd, "string", v2);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v2, dynamic) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd, "array", v2, dynamic);
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v2, name) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd, "tuple", v2, name);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v2) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v2));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed.dereference(_value, "string");
    try {
      value = getAddress(value);
    } catch (error2) {
      return this._throwError(error2.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert4(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert4(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error2) {
        if (isError3(error2, "BUFFER_OVERRUN")) {
          throw error2;
        }
        value = error2;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error2) {
        if (isError3(error2, "BUFFER_OVERRUN")) {
          throw error2;
        }
        value = error2;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result2.fromItems(values, keys);
}
var ArrayCoder = class extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result2 = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      result2.push(defaultChild);
    }
    return result2;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert4(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i2 = 0; i2 < count; i2++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data = getBytesCopy(Typed.dereference(_value, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/null.js
var Empty2 = new Uint8Array([]);
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty2);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06 = BigInt(0);
var BN_14 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var NumberCoder = class extends Coder {
  size;
  signed;
  constructor(size, signed3, localName) {
    const name = (signed3 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed: signed3 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_14)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_06 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/coders/tuple.js
var TupleCoder = class extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/hash/id.js
function id(value) {
  return keccak256(toUtf8Bytes(value));
}

// node_modules/azle/node_modules/@adraffy/ens-normalize/dist/index.mjs
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes4) {
  let pos = 0;
  function u16() {
    return bytes4[pos++] << 8 | bytes4[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes4[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N5 = 31;
  const FULL = 2 ** N5;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N5; i2++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a2 = low + Math.floor(range * acc[start] / total);
    let b4 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a2 ^ b4) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b4 = b4 << 1 & MASK | 1;
    }
    while (a2 & ~b4 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b4 = (b4 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b4 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes4[pos_payload++] << 16 | bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
      case 2:
        return offset + 256 + (bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
      case 1:
        return offset + bytes4[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i2) => lookup[c2.charCodeAt(0)] = i2);
  let n5 = s.length;
  let ret = new Uint8Array(6 * n5 >> 3);
  for (let i2 = 0, pos = 0, width = 0, carry = 0; i2 < n5; i2++) {
    carry = carry << 6 | lookup[s.charCodeAt(i2)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
function read_deltas(n5, next) {
  let v2 = Array(n5);
  for (let i2 = 0, x = 0; i2 < n5; i2++) v2[i2] = x += signed(next());
  return v2;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n5 = next();
    if (!n5) break;
    prev += x;
    for (let i2 = 0; i2 < n5; i2++) {
      ret.push(prev + i2);
    }
    prev += n5 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v2 = read_sorted(next);
    if (v2.length) return v2;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v2 = [];
  while (true) {
    let x = next(v2.length);
    if (!x) break;
    v2.push(x);
  }
  return v2;
}
function read_transposed(n5, w, next) {
  let m2 = Array(n5).fill().map(() => []);
  for (let i2 = 0; i2 < w; i2++) {
    read_deltas(n5, next).forEach((x, j) => m2[j].push(x));
  }
  return m2;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m2 = read_transposed(vN.length, 1 + w, next);
  return m2.flatMap((v2, i2) => {
    let [x, ...ys] = v2;
    return Array(vN[i2]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y2) => y2 + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n5 = 1 + next();
  let m2 = read_transposed(n5, 1 + w, next);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode9([]), []);
  return ret;
  function decode9(Q) {
    let S3 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i2) => sorted[i2]);
      if (cps.length) return decode9(cps);
    });
    return { S: S3, B, Q };
  }
  function expand({ S: S3, B }, cps, saved) {
    if (S3 & 4 && saved === cps[cps.length - 1]) return;
    if (S3 & 2) saved = cps[cps.length - 1];
    if (S3 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp3 of br.Q) {
        expand(br, [...cps, cp3], saved);
      }
    }
  }
}
function hex_cp(cp3) {
  return cp3.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp3) {
  return `{${hex_cp(cp3)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp3 = s.codePointAt(pos);
    pos += cp3 < 65536 ? 1 : 2;
    cps.push(cp3);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk2 = 4096;
  let len = cps.length;
  if (len < chunk2) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i2 = 0; i2 < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i2, i2 += chunk2)));
  }
  return buf.join("");
}
function compare_arrays(a2, b4) {
  let n5 = a2.length;
  let c2 = n5 - b4.length;
  for (let i2 = 0; c2 == 0 && i2 < n5; i2++) c2 = a2[i2] - b4[i2];
  return c2;
}
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
function init$1() {
  let r3 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r3).flatMap((v2, i2) => v2.map((x) => [x, i2 + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r3));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp3, cps] of read_mapped(r3)) {
    if (!EXCLUSIONS.has(cp3) && cps.length == 2) {
      let [a2, b4] = cps;
      let bucket = RECOMP.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a2, bucket);
      }
      bucket.set(b4, cp3);
    }
    DECOMP.set(cp3, cps.reverse());
  }
}
function is_hangul(cp3) {
  return cp3 >= S0 && cp3 < S1;
}
function compose_pair(a2, b4) {
  if (a2 >= L0 && a2 < L1 && b4 >= V0 && b4 < V1) {
    return S0 + (a2 - L0) * N_COUNT + (b4 - V0) * T_COUNT;
  } else if (is_hangul(a2) && b4 > T0 && b4 < T1 && (a2 - S0) % T_COUNT == 0) {
    return a2 + (b4 - T0);
  } else {
    let recomp = RECOMP.get(a2);
    if (recomp) {
      recomp = recomp.get(b4);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add3(cp3) {
    let cc = SHIFTED_RANK.get(cp3);
    if (cc) {
      check_order = true;
      cp3 |= cc;
    }
    ret.push(cp3);
  }
  for (let cp3 of cps) {
    while (true) {
      if (cp3 < 128) {
        ret.push(cp3);
      } else if (is_hangul(cp3)) {
        let s_index = cp3 - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add3(L0 + l_index);
        add3(V0 + v_index);
        if (t_index > 0) add3(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp3);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add3(cp3);
        }
      }
      if (!buf.length) break;
      cp3 = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i2 = 1; i2 < ret.length; i2++) {
      let cc = unpack_cc(ret[i2]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i2 - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i2]);
    }
  }
  return ret;
}
function composed_from_decomposed(v2) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v2) {
    let cc = unpack_cc(packed);
    let cp3 = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp3;
      } else {
        ret.push(cp3);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp3;
      } else {
        stack.push(cp3);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp3);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp3;
      } else {
        stack.push(cp3);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);
function group_has_cp(g2, cp3) {
  return g2.P.has(cp3) || g2.Q.has(cp3);
}
var Emoji = class extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
};
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
function init3() {
  if (MAPPED) return;
  let r3 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r3);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v2) => v2.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r3));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i2) => CM[i2]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r3);
  let unrestricted = r3();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i2) => set_add_many(set, chunks[i2]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i2) => {
    let N5 = read_array_while(r3).map((x) => x + 96);
    if (N5.length) {
      let R = i2 >= unrestricted;
      N5[0] -= 32;
      N5 = str_from_cps(N5);
      if (R) N5 = `Restricted[${N5}]`;
      let P2 = read_chunked();
      let Q = read_chunked();
      let M = !r3();
      return { N: N5, P: P2, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a2, b4) => a2 - b4);
  wholes.forEach((cp3, i2) => {
    let d = r3();
    let w = wholes[i2] = d ? wholes[i2 - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp3);
    if (!WHOLE_VALID.has(cp3)) {
      WHOLE_MAP.set(cp3, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp3 of V) {
      let gs = GROUPS.filter((g2) => group_has_cp(g2, cp3));
      let rec = recs.find(({ G }) => gs.some((g2) => G.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp3);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g2) => !G.has(g2)));
      for (let cp3 of V2) {
        M.set(cp3, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp3) => VALID.has(cp3) ? multi.add(cp3) : VALID.add(cp3);
  for (let g2 of GROUPS) {
    for (let cp3 of g2.P) add_to_union(cp3);
    for (let cp3 of g2.Q) add_to_union(cp3);
  }
  for (let cp3 of VALID) {
    if (!WHOLE_MAP.has(cp3) && !multi.has(cp3)) {
      WHOLE_MAP.set(cp3, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r3).map((v2) => Emoji.from(v2)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp3 of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp3);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp3, child);
        }
        return child;
      });
      if (cp3 === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp3) {
  return (should_escape(cp3) ? "" : `${bidi_qq(safe_str_from_cps([cp3]))} `) + quote_cp(cp3);
}
function bidi_qq(s) {
  return `"${s}"\u200E`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i2 = cps.lastIndexOf(UNDERSCORE); i2 > 0; ) {
    if (cps[--i2] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp3 = cps[0];
  let prev = FENCED.get(cp3);
  if (prev) throw error_placement(`leading ${prev}`);
  let n5 = cps.length;
  let last = -1;
  for (let i2 = 1; i2 < n5; i2++) {
    cp3 = cps[i2];
    let match = FENCED.get(cp3);
    if (match) {
      if (last == i2) throw error_placement(`${prev} + ${match}`);
      last = i2 + 1;
      prev = match;
    }
  }
  if (last == n5) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("\u25CC");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n5 = cps.length;
  for (let i2 = 0; i2 < n5; i2++) {
    let cp3 = cps[i2];
    if (should_escape(cp3)) {
      buf.push(str_from_cps(cps.slice(prev, i2)));
      buf.push(quoter(cp3));
      prev = i2 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n5)));
  return buf.join("");
}
function is_combining_mark(cp3) {
  init3();
  return CM.has(cp3);
}
function should_escape(cp3) {
  init3();
  return ESCAPE.has(cp3);
}
function ens_normalize(name) {
  return flatten(split2(name, nfc, filter_fe0f));
}
function split2(name, nf, ef) {
  if (!name) return [];
  init3();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input2 = explode_cp(label);
    let info = {
      input: input2,
      offset
      // codepoint, not substring!
    };
    offset += input2.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input2, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp3) => cp3 < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i2 = 1; i2 < token_count; i2++) {
            let cps = tokens[i2];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i2 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g2] = determine_group(unique);
          check_group(g2, chars);
          check_whole(g2, unique);
          type = g2.N;
        }
      }
      info.type = type;
    } catch (err3) {
      info.error = err3;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp3 of unique) {
    let whole = WHOLE_MAP.get(cp3);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp3);
      maker = maker ? maker.filter((g2) => set.has(g2)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp3);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp3) => group_has_cp(g2, cp3))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp3 of unique) {
    let gs = groups.filter((g2) => group_has_cp(g2, cp3));
    if (!gs.length) {
      if (!GROUPS.some((g2) => group_has_cp(g2, cp3))) {
        throw error_disallowed(cp3);
      } else {
        throw error_group_member(groups[0], cp3);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split5) {
  return split5.map(({ input: input2, error: error2, output: output3 }) => {
    if (error2) {
      let msg = error2.message;
      throw new Error(split5.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input2, 63))}: ${msg}`);
    }
    return str_from_cps(output3);
  }).join(STOP_CH);
}
function error_disallowed(cp3) {
  return new Error(`disallowed character: ${quoted_cp(cp3)}`);
}
function error_group_member(g2, cp3) {
  let quoted = quoted_cp(cp3);
  let gg = GROUPS.find((g3) => g3.P.has(cp3));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g2, cps) {
  for (let cp3 of cps) {
    if (!group_has_cp(g2, cp3)) {
      throw error_group_member(g2, cp3);
    }
  }
  if (g2.M) {
    let decomposed3 = nfd(cps);
    for (let i2 = 1, e3 = decomposed3.length; i2 < e3; i2++) {
      if (NSM.has(decomposed3[i2])) {
        let j = i2 + 1;
        for (let cp3; j < e3 && NSM.has(cp3 = decomposed3[j]); j++) {
          for (let k = i2; k < j; k++) {
            if (decomposed3[k] == cp3) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp3)}`);
            }
          }
        }
        if (j - i2 > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed3.slice(i2 - 1, j)))} (${j - i2}/${NSM_MAX})`);
        }
        i2 = j;
      }
    }
  }
}
function tokens_from_str(input2, nf, ef) {
  let ret = [];
  let chars = [];
  input2 = input2.slice().reverse();
  while (input2.length) {
    let emoji = consume_emoji_reversed(input2);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp3 = input2.pop();
      if (VALID.has(cp3)) {
        chars.push(cp3);
      } else {
        let cps = MAPPED.get(cp3);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp3)) {
          throw error_disallowed(cp3);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp3) => cp3 != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten) eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// node_modules/azle/node_modules/ethers/lib.esm/hash/namehash.js
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes4 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    const d = bytes4[i2];
    if (d === 46) {
      comps.push(checkComponent(bytes4.slice(last, i2)));
      last = i2 + 1;
    }
  }
  assertArgument(last < bytes4.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes4.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error2) {
    assertArgument(false, `invalid ENS name (${error2.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error2) {
  }
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result2 = Zeros2;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result2 = keccak256(concat2([result2, keccak256(comps.pop())]));
  }
  return hexlify(result2);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat2(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes4 = new Uint8Array(comp.length + 1);
    bytes4.set(comp, 1);
    bytes4[0] = bytes4.length - 1;
    return bytes4;
  }))) + "00";
}

// node_modules/azle/node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result2 = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result2.sort((a2, b4) => a2.address.localeCompare(b4.address));
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/transaction/address.js
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}

// node_modules/azle/node_modules/ethers/lib.esm/transaction/transaction.js
var BN_07 = BigInt(0);
var BN_22 = BigInt(2);
var BN_272 = BigInt(27);
var BN_282 = BigInt(28);
var BN_352 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE = 4096 * 32;
function getVersionedHash(version4, hash3) {
  let versioned = version4.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha2562(hash3).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error2) {
    assertArgument(false, error2.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_07;
  }
  const value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber2(_value, name) {
  const value = getBigInt(_value, "value");
  const result2 = toBeArray(value);
  assertArgument(result2.length <= 32, `value too large`, `tx.${name}`, value);
  return result2;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i2 = 0; i2 < value.length; i2++) {
    assertArgument(isHexString(value[i2], 32), "invalid ${ param } hash", `value[${i2}]`, value[i2]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_07
  };
  if (fields.length === 6) {
    return tx;
  }
  const v2 = handleUint(fields[6], "v");
  const r3 = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r3 === BN_07 && s === BN_07) {
    tx.chainId = v2;
  } else {
    let chainId = (v2 - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v2 === BN_272 || v2 === BN_282), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v2
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.gasPrice || 0, "gasPrice"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber2(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_07;
  if (tx.chainId != BN_07) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v2 = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v2 = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v2) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v2));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error2) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r3 = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r: r3, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId, "chainId"),
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber2(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId, "chainId"),
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.gasPrice || 0, "gasPrice"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber2(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i2 = 0; i2 < fields[1].length; i2++) {
      blobs.push({
        data: fBlobs[i2],
        commitment: fCommits[i2],
        proof: fProofs[i2]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i2 = 0; i2 < tx.blobVersionedHashes.length; i2++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i2], 32), `invalid blobVersionedHash at index ${i2}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber2(tx.chainId, "chainId"),
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber2(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber2(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat2([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b4) => b4.data),
          blobs.map((b4) => b4.commitment),
          blobs.map((b4) => b4.proof)
        ])
      ]);
    }
  }
  return concat2(["0x03", encodeRlp(fields)]);
}
var Transaction = class _Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress(value);
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber(value, "value");
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt(value);
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_07;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify(value);
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt(value, "value");
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value);
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature.from(value);
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify(value);
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_07;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, "maxFeePerBlobGas");
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i2 = 0; i2 < value.length; i2++) {
        assertArgument(isHexString(value[i2], 32), "invalid blobVersionedHash", `value[${i2}]`, value[i2]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b4) => Object.assign({}, b4));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i2 = 0; i2 < _blobs.length; i2++) {
      const blob2 = _blobs[i2];
      if (isBytesLike(blob2)) {
        assert4(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob2);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i2}]`, blob2);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data);
        const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob2.commitment);
        blobs.push({
          data: hexlify(blob2.data),
          commitment: commit,
          proof: hexlify(blob2.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    this.#kzg = kzg;
  }
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_07;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_07;
    this.#chainId = BN_07;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#blobs = null;
    this.#kzg = null;
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(this.#getSerialized(true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed3, sidecar) {
    assert4(!signed3 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed3 ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
    }
    assert4(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return this.#getSerialized(true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert4(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert4(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert4(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v2) => {
      if (v2 == null) {
        return null;
      }
      return v2.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert4(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result2 = new _Transaction();
    if (tx.type != null) {
      result2.type = tx.type;
    }
    if (tx.to != null) {
      result2.to = tx.to;
    }
    if (tx.nonce != null) {
      result2.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result2.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result2.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result2.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result2.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result2.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result2.data = tx.data;
    }
    if (tx.value != null) {
      result2.value = tx.value;
    }
    if (tx.chainId != null) {
      result2.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result2.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result2.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result2.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result2.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result2.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result2.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result2.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result2.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result2.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result2;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/hash/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat2([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}

// node_modules/azle/node_modules/ethers/lib.esm/hash/solidity.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray2) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed3 = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray2) {
      size = 256;
    }
    if (signed3) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray2) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
    const result2 = [];
    value.forEach(function(value2) {
      result2.push(_pack(baseType, value2, true));
    });
    return getBytes(concat2(result2));
  }
  assertArgument(false, "invalid type", "type", type);
}
function solidityPacked(types, values) {
  assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat2(tight));
}
function solidityPackedKeccak256(types, values) {
  return keccak256(solidityPacked(types, values));
}
function solidityPackedSha256(types, values) {
  return sha2562(solidityPacked(types, values));
}

// node_modules/azle/node_modules/ethers/lib.esm/hash/typed-data.js
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_08 = BigInt(0);
var BN_15 = BigInt(1);
var BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes4 = getBytes(value);
  const padOffset = bytes4.length % 32;
  if (padOffset) {
    return concat2([bytes4, padding.slice(padOffset)]);
  }
  return hexlify(bytes4);
}
var hexTrue = toBeHex(BN_15, 32);
var hexFalse = toBeHex(BN_08, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value = getBigInt(_value, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error2) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes4 = getBytes(value, "domain.salt");
    assertArgument(bytes4.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes4);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed3 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT2562, signed3 ? width - 1 : width);
      const boundsLower = signed3 ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value) {
        const value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed3 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes4 = getBytes(value);
        assertArgument(bytes4.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
var TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  The primary type for the structured [[types]].
   *
   *  This is derived automatically from the [[types]], since no
   *  recursion is possible, once the DAG for the types is consturcted
   *  internally, the primary type must be the only remaining type with
   *  no parent nodes.
   */
  primaryType;
  #types;
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types) {
    this.#fullTypes = /* @__PURE__ */ new Map();
    this.#encoderCache = /* @__PURE__ */ new Map();
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types).forEach((type) => {
      types[type] = _types[type].map(({ name, type: type2 }) => {
        let { base: base2, index } = splitArray(type2);
        if (base2 === "int" && !_types["int"]) {
          base2 = "int256";
        }
        if (base2 === "uint" && !_types["uint"]) {
          base2 = "uint256";
        }
        return { name, type: base2 + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n5) => parents.get(n5).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", _types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t2) => encodeType(t2, types[t2])).join(""));
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result2 = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result2 = result2.map(keccak256);
        }
        return keccak256(concat2(result2));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result2 = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak256(result2);
          }
          return result2;
        });
        values.unshift(encodedType);
        return concat2(values);
      };
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result2 = this.#fullTypes.get(name);
    assertArgument(result2, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result2;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v2) => this._visit(array.prefix, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain3) {
    const domainFields = [];
    for (const name in domain3) {
      if (domain3[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain3);
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b4) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b4.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain3);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain3, types, value) {
    return concat2([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain3),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain3, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain3, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain3, types, value, resolveName) {
    domain3 = Object.assign({}, domain3);
    for (const key in domain3) {
      if (domain3[key] == null) {
        delete domain3[key];
      }
    }
    const ensCache = {};
    if (domain3.verifyingContract && !isHexString(domain3.verifyingContract, 20)) {
      ensCache[domain3.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain3.verifyingContract && ensCache[domain3.verifyingContract]) {
      domain3.verifyingContract = ensCache[domain3.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain: domain3, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain3, types, value) {
    _TypedDataEncoder.hashDomain(domain3);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain3[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
function verifyTypedData(domain3, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain3, types, value), signature);
}

// node_modules/azle/node_modules/ethers/lib.esm/abi/fragments.js
function setify(items) {
  const result2 = /* @__PURE__ */ new Set();
  items.forEach((k) => result2.add(k));
  return Object.freeze(result2);
}
var _kwVisibDeploy = "external public payable override";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
var _kwVisib = "constant external internal payable private public pure view override";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var TokenString = class _TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new _TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new _TokenString(this.#tokens.slice(from, to).map((t2) => {
      return Object.freeze(Object.assign({}, t2, {
        match: t2.match - from,
        linkBack: t2.linkBack - from,
        linkNext: t2.linkNext - from
      }));
    }));
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result2 = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result2;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result2 = [];
    while (this.#offset < top.match - 1) {
      const link3 = this.peek().linkNext;
      result2.push(this.#subTokenString(this.#offset + 1, link3));
      this.#offset = link3;
    }
    this.#offset = top.match + 1;
    return result2;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result2 = this.peek();
    this.#offset++;
    return result2;
  }
  toString() {
    const tokens = [];
    for (let i2 = this.#offset; i2 < this.#tokens.length; i2++) {
      const token = this.#tokens[i2];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
function lex(text3) {
  const tokens = [];
  const throwError3 = (message) => {
    const token = offset < text3.length ? JSON.stringify(text3[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text3.length) {
    let cur = text3.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text3.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError3("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t2) => Object.freeze(t2)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t2) => ParamType.from(t2, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard4 = {};
var internal = Symbol.for("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";
var ParamType = class _ParamType {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */
  name;
  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */
  type;
  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */
  baseType;
  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */
  indexed;
  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */
  components;
  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */
  arrayLength;
  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */
  arrayChildren;
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate(guard, _guard4, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result4 = JSON.parse(this.arrayChildren.format("json"));
        result4.name = name;
        result4.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result4);
      }
      const result3 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result3.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result3.components = this.components.map((c2) => JSON.parse(c2.format(format3)));
      }
      return JSON.stringify(result3);
    }
    let result2 = "";
    if (this.isArray()) {
      result2 += this.arrayChildren.format(format3);
      result2 += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result2 += "(" + this.components.map((comp) => comp.format(format3)).join(format3 === "full" ? ", " : ",") + ")";
      } else {
        result2 += this.type;
      }
    }
    if (format3 !== "sighash") {
      if (this.indexed === true) {
        result2 += " indexed";
      }
      if (format3 === "full" && this.name) {
        result2 += " " + this.name;
      }
    }
    return result2;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process3) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2) => _this.arrayChildren.walk(v2, process3));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2, i2) => _this.components[i2].walk(v2, process3));
    }
    return process3(this.type, value);
  }
  #walkAsync(promises2, value, process3, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result3 = value.slice();
      result3.forEach((value2, index) => {
        childType.#walkAsync(promises2, value2, process3, (value3) => {
          result3[index] = value3;
        });
      });
      setValue(result3);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result3;
      if (Array.isArray(value)) {
        result3 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result3 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result3.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result3.forEach((value2, index) => {
        components[index].#walkAsync(promises2, value2, process3, (value3) => {
          result3[index] = value3;
        });
      });
      setValue(result3);
      return;
    }
    const result2 = process3(this.type, value);
    if (result2.then) {
      promises2.push(async function() {
        setValue(await result2);
      }());
    } else {
      setValue(result2);
    }
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process3) {
    const promises2 = [];
    const result2 = [value];
    this.#walkAsync(promises2, value, process3, (value2) => {
      result2[0] = value2;
    });
    if (promises2.length) {
      await Promise.all(promises2);
    }
    return result2[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error2) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t2) => _ParamType.from(t2));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard4, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard4, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard4, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard4, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard4, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal] === ParamTypeInternal;
  }
};
var Fragment = class _Fragment {
  /**
   *  The type of the fragment.
   */
  type;
  /**
   *  The inputs for the fragment.
   */
  inputs;
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    assertPrivate(guard, _guard4, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        _Fragment.from(JSON.parse(obj));
      } catch (e3) {
      }
      return _Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert4(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
};
var NamedFragment = class extends Fragment {
  /**
   *  The name of the fragment.
   */
  name;
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
};
function joinParams(format3, params) {
  return "(" + params.map((p3) => p3.format(format3)).join(format3 === "full" ? ", " : ",") + ")";
}
var ErrorFragment = class _ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format3)))
      });
    }
    const result2 = [];
    if (format3 !== "sighash") {
      result2.push("error");
    }
    result2.push(this.name + joinParams(format3, this.inputs));
    return result2.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new _ErrorFragment(_guard4, name, inputs);
    }
    return new _ErrorFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ErrorFragmentInternal;
  }
};
var EventFragment = class _EventFragment extends NamedFragment {
  /**
   *  Whether this event is anonymous.
   */
  anonymous;
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i2) => JSON.parse(i2.format(format3)))
      });
    }
    const result2 = [];
    if (format3 !== "sighash") {
      result2.push("event");
    }
    result2.push(this.name + joinParams(format3, this.inputs));
    if (format3 !== "sighash" && this.anonymous) {
      result2.push("anonymous");
    }
    return result2.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p3) => ParamType.from(p3));
    const fragment = new _EventFragment(_guard4, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (_EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _EventFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new _EventFragment(_guard4, name, inputs, anonymous);
    }
    return new _EventFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map((p3) => ParamType.from(p3, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === EventFragmentInternal;
  }
};
var ConstructorFragment = class _ConstructorFragment extends Fragment {
  /**
   *  Whether the constructor can receive an endowment.
   */
  payable;
  /**
   *  The recommended gas limit for deployment or ``null``.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format3) {
    assert4(format3 != null && format3 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format3 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i2) => JSON.parse(i2.format(format3)))
      });
    }
    const result2 = [`constructor${joinParams(format3, this.inputs)}`];
    if (this.payable) {
      result2.push("payable");
    }
    if (this.gas != null) {
      result2.push(`@${this.gas.toString()}`);
    }
    return result2.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ConstructorFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new _ConstructorFragment(_guard4, "constructor", inputs, payable, gas);
    }
    return new _ConstructorFragment(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ConstructorFragmentInternal;
  }
};
var FallbackFragment = class _FallbackFragment extends Fragment {
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format3) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format3 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FallbackFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new _FallbackFragment(_guard4, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i2) => i2.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i2) => i2.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new _FallbackFragment(_guard4, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new _FallbackFragment(_guard4, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new _FallbackFragment(_guard4, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FallbackFragmentInternal;
  }
};
var FunctionFragment = class _FunctionFragment extends NamedFragment {
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */
  constant;
  /**
   *  The returned types for the result of calling this function.
   */
  outputs;
  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */
  stateMutability;
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  /**
   *  The recommended gas limit to send when calling this function.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i2) => JSON.parse(i2.format(format3))),
        outputs: this.outputs.map((o3) => JSON.parse(o3.format(format3)))
      });
    }
    const result2 = [];
    if (format3 !== "sighash") {
      result2.push("function");
    }
    result2.push(this.name + joinParams(format3, this.inputs));
    if (format3 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result2.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result2.push("returns");
        result2.push(joinParams(format3, this.outputs));
      }
      if (this.gas != null) {
        result2.push(`@${this.gas.toString()}`);
      }
    }
    return result2.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p3) => ParamType.from(p3));
    const fragment = new _FunctionFragment(_guard4, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FunctionFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new _FunctionFragment(_guard4, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new _FunctionFragment(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FunctionFragmentInternal;
  }
};
var StructFragment = class _StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return _StructFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new _StructFragment(_guard4, name, inputs);
    }
    return new _StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === StructFragmentInternal;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/abi-coder.js
var PanicReasons = /* @__PURE__ */ new Map();
PanicReasons.set(0, "GENERIC_PANIC");
PanicReasons.set(1, "ASSERT_FALSE");
PanicReasons.set(17, "OVERFLOW");
PanicReasons.set(18, "DIVIDE_BY_ZERO");
PanicReasons.set(33, "ENUM_RANGE_ERROR");
PanicReasons.set(34, "BAD_STORAGE_DATA");
PanicReasons.set(49, "STACK_UNDERFLOW");
PanicReasons.set(50, "ARRAY_RANGE_ERROR");
PanicReasons.set(65, "OUT_OF_MEMORY");
PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
var defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes4 = getBytes(data);
    data = hexlify(data);
    if (bytes4.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes4.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes4.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes4.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error2) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes4.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes4.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error2) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
var AbiCoder = class _AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c2) => this.#getCoder(c2)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String(text3) {
  const bytes4 = toUtf8Bytes(text3);
  if (bytes4.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes(bytes4, 32);
}
function decodeBytes32String(_bytes) {
  const data = getBytes(_bytes, "bytes");
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}

// node_modules/azle/node_modules/ethers/lib.esm/abi/interface.js
var LogDescription = class {
  /**
   *  The matching fragment for the ``topic0``.
   */
  fragment;
  /**
   *  The name of the Event.
   */
  name;
  /**
   *  The full Event signature.
   */
  signature;
  /**
   *  The topic hash for the Event.
   */
  topic;
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  args;
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args2) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args: args2
    });
  }
};
var TransactionDescription = class {
  /**
   *  The matching fragment from the transaction ``data``.
   */
  fragment;
  /**
   *  The name of the Function from the transaction ``data``.
   */
  name;
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  args;
  /**
   *  The full Function signature from the transaction ``data``.
   */
  signature;
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  selector;
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  value;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args2, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args: args2,
      signature,
      selector,
      value
    });
  }
};
var ErrorDescription = class {
  /**
   *  The matching fragment.
   */
  fragment;
  /**
   *  The name of the Error.
   */
  name;
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  args;
  /**
   *  The full Error signature.
   */
  signature;
  /**
   *  The selector for the Error.
   */
  selector;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args2) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args: args2,
      signature,
      selector
    });
  }
};
var Indexed = class {
  /**
   *  The ``keccak256`` of the value logged.
   */
  hash;
  /**
   *  @_ignore:
   */
  _isIndexed;
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  /**
   *  @_ignore:
   */
  constructor(hash3) {
    defineProperties(this, { hash: hash3, _isIndexed: true });
  }
};
var PanicReasons2 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
        reason = PanicReasons2[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
var Interface = class _Interface {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */
  fragments;
  /**
   *  The Contract constructor.
   */
  deploy;
  /**
   *  The Fallback method, if any.
   */
  fallback;
  /**
   *  If receiving ether is supported.
   */
  receive;
  #errors;
  #events;
  #functions;
  //    #structs: Map<string, StructFragment>;
  #abiCoder;
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    this.#functions = /* @__PURE__ */ new Map();
    this.#errors = /* @__PURE__ */ new Map();
    this.#events = /* @__PURE__ */ new Map();
    const frags = [];
    for (const a2 of abi) {
      try {
        frags.push(Fragment.from(a2));
      } catch (error2) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error2.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format3 = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f4) => f4.format(format3));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f4) => f4.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  #getFunction(key, values, forceUnique) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          const inputs = matching[i2].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i2, 1);
          }
        }
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          const inputs = matching[i2].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i2, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i2, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result2 = this.#functions.get(FunctionFragment.from(key).format());
    if (result2) {
      return result2;
    }
    return null;
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names3 = Array.from(this.#functions.keys());
    names3.sort((a2, b4) => a2.localeCompare(b4));
    for (let i2 = 0; i2 < names3.length; i2++) {
      const name = names3[i2];
      callback(this.#functions.get(name), i2);
    }
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  #getEvent(key, values, forceUnique) {
    if (isHexString(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          if (matching[i2].inputs.length < values.length) {
            matching.splice(i2, 1);
          }
        }
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          const inputs = matching[i2].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i2, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result2 = this.#events.get(EventFragment.from(key).format());
    if (result2) {
      return result2;
    }
    return null;
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names3 = Array.from(this.#events.keys());
    names3.sort((a2, b4) => a2.localeCompare(b4));
    for (let i2 = 0; i2 < names3.length; i2++) {
      const name = names3[i2];
      callback(this.#events.get(name), i2);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result2 = this.#errors.get(key);
    if (result2) {
      return result2;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names3 = Array.from(this.#errors.keys());
    names3.sort((a2, b4) => a2.localeCompare(b4));
    for (let i2 = 0; i2 < names3.length; i2++) {
      const name = names3[i2];
      callback(this.#errors.get(name), i2);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return this.#abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f4 = this.getError(fragment);
      assertArgument(f4, "unknown error", "fragment", fragment);
      fragment = f4;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getError(fragment);
      assertArgument(f4, "unknown error", "fragment", fragment);
      fragment = f4;
    }
    return concat2([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    return concat2([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    let message = "invalid length for result data";
    const bytes4 = getBytesCopy(data);
    if (bytes4.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes4);
      } catch (error2) {
        message = "could not decode result data";
      }
    }
    assert4(false, message, "BAD_DATA", {
      value: hexlify(bytes4),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data = getBytes(_data, "data");
    const error2 = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error2.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args2 = this.#abiCoder.decode(ef.inputs, data.slice(4));
          error2.revert = {
            name: ef.name,
            signature: ef.format(),
            args: args2
          };
          error2.reason = error2.revert.signature;
          error2.message = `execution reverted: ${error2.reason}`;
        } catch (e3) {
          error2.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error2.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error2;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    assert4(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat2(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error2) {
            value = error2;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error2) {
          value = error2;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result2.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args2 = this.#abiCoder.decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args2, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log3) {
    const fragment = this.getEvent(log3.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log3.data, log3.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args2 = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args2);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider.js
var BN_09 = BigInt(0);
function getValue2(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
var FeeData = class {
  /**
   *  The gas price for legacy networks.
   */
  gasPrice;
  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxFeePerGas;
  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxPriorityFeePerGas;
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue2(gasPrice),
      maxFeePerGas: getValue2(maxFeePerGas),
      maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
};
function copyRequest(req) {
  const result2 = {};
  if (req.to) {
    result2.to = req.to;
  }
  if (req.from) {
    result2.from = req.from;
  }
  if (req.data) {
    result2.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result2[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result2[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result2.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result2.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result2.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result2.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result2.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result2.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result2.blobs = req.blobs.map((b4) => {
      if (isBytesLike(b4)) {
        return hexlify(b4);
      }
      return Object.assign({}, b4);
    });
  }
  return result2;
}
var Block = class {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */
  number;
  /**
   *  The block hash.
   *
   *  This hash includes all properties, so can be safely used to identify
   *  an exact set of block properties.
   */
  hash;
  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */
  timestamp;
  /**
   *  The block hash of the parent block.
   */
  parentHash;
  /**
   *  The hash tree root of the parent beacon block for the given
   *  execution block. See [[link-eip-4788]].
   */
  parentBeaconBlockRoot;
  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */
  nonce;
  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */
  difficulty;
  /**
   *  The total gas limit for this block.
   */
  gasLimit;
  /**
   *  The total gas used in this block.
   */
  gasUsed;
  /**
   *  The root hash for the global state after applying changes
   *  in this block.
   */
  stateRoot;
  /**
   *  The hash of the transaction receipts trie.
   */
  receiptsRoot;
  /**
   *  The total amount of blob gas consumed by the transactions
   *  within the block. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The running total of blob gas consumed in excess of the
   *  target, prior to the block. See [[link-eip-4844]].
   */
  excessBlobGas;
  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */
  miner;
  /**
   *  The latest RANDAO mix of the post beacon state of
   *  the previous block.
   */
  prevRandao;
  /**
   *  Any extra data the validator wished to include.
   */
  extraData;
  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */
  baseFeePerGas;
  #transactions;
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    });
    defineProperties(this, {
      provider,
      hash: getValue2(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue2(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue2(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert4(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash3, miner, prevRandao, nonce, number: number3, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp: timestamp2, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash3,
      miner,
      prevRandao,
      nonce,
      number: number3,
      parentHash,
      timestamp: timestamp2,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return this.#transactions.length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash3 = indexOrHash.toLowerCase();
      for (const v2 of this.#transactions) {
        if (typeof v2 === "string") {
          if (v2 !== hash3) {
            continue;
          }
          tx = v2;
          break;
        } else {
          if (v2.hash !== hash3) {
            continue;
          }
          tx = v2;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
};
var Log = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The transaction hash of the transaction this log occurred in. Use the
   *  [[Log-getTransaction]] to get the [[TransactionResponse]].
   */
  transactionHash;
  /**
   *  The block hash of the block this log occurred in. Use the
   *  [[Log-getBlock]] to get the [[Block]].
   */
  blockHash;
  /**
   *  The block number of the block this log occurred in. It is preferred
   *  to use the [[Block-hash]] when fetching the related [[Block]],
   *  since in the case of an orphaned block, the block at that height may
   *  have changed.
   */
  blockNumber;
  /**
   *  If the **Log** represents a block that was removed due to an orphaned
   *  block, this will be true.
   *
   *  This can only happen within an orphan event listener.
   */
  removed;
  /**
   *  The address of the contract that emitted this log.
   */
  address;
  /**
   *  The data included in this log when it was emitted.
   */
  data;
  /**
   *  The indexed topics included in this log when it was emitted.
   *
   *  All topics are included in the bloom filters, so they can be
   *  efficiently filtered using the [[Provider-getLogs]] method.
   */
  topics;
  /**
   *  The index within the block this log occurred at. This is generally
   *  not useful to developers, but can be used with the various roots
   *  to proof inclusion within a block.
   */
  index;
  /**
   *  The index within the transaction of this log.
   */
  transactionIndex;
  /**
   *  @_ignore:
   */
  constructor(log3, provider) {
    this.provider = provider;
    const topics = Object.freeze(log3.topics.slice());
    defineProperties(this, {
      transactionHash: log3.transactionHash,
      blockHash: log3.blockHash,
      blockNumber: log3.blockNumber,
      removed: log3.removed,
      address: log3.address,
      data: log3.data,
      topics,
      index: log3.index,
      transactionIndex: log3.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert4(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert4(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert4(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
};
var TransactionReceipt = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The address the transaction was sent to.
   */
  to;
  /**
   *  The sender of the transaction.
   */
  from;
  /**
   *  The address of the contract if the transaction was directly
   *  responsible for deploying one.
   *
   *  This is non-null **only** if the ``to`` is empty and the ``data``
   *  was successfully executed as initcode.
   */
  contractAddress;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The index of this transaction within the block transactions.
   */
  index;
  /**
   *  The block hash of the [[Block]] this transaction was included in.
   */
  blockHash;
  /**
   *  The block number of the [[Block]] this transaction was included in.
   */
  blockNumber;
  /**
   *  The bloom filter bytes that represent all logs that occurred within
   *  this transaction. This is generally not useful for most developers,
   *  but can be used to validate the included logs.
   */
  logsBloom;
  /**
   *  The actual amount of gas used by this transaction.
   *
   *  When creating a transaction, the amount of gas that will be used can
   *  only be approximated, but the sender must pay the gas fee for the
   *  entire gas limit. After the transaction, the difference is refunded.
   */
  gasUsed;
  /**
   *  The gas used for BLObs. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The amount of gas used by all transactions within the block for this
   *  and all transactions with a lower ``index``.
   *
   *  This is generally not useful for developers but can be used to
   *  validate certain aspects of execution.
   */
  cumulativeGasUsed;
  /**
   *  The actual gas price used during execution.
   *
   *  Due to the complexity of [[link-eip-1559]] this value can only
   *  be caluclated after the transaction has been mined, snce the base
   *  fee is protocol-enforced.
   */
  gasPrice;
  /**
   *  The price paid per BLOB in gas. See [[link-eip-4844]].
   */
  blobGasPrice;
  /**
   *  The [[link-eip-2718]] transaction type.
   */
  type;
  //readonly byzantium!: boolean;
  /**
   *  The status of this transaction, indicating success (i.e. ``1``) or
   *  a revert (i.e. ``0``).
   *
   *  This is available in post-byzantium blocks, but some backends may
   *  backfill this value.
   */
  status;
  /**
   *  The root hash of this transaction.
   *
   *  This is no present and was only included in pre-byzantium blocks, but
   *  could be used to validate certain parts of the receipt.
   */
  root;
  #logs;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log3) => {
      return new Log(log3, provider);
    }));
    let gasPrice = BN_09;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return this.#logs;
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash3,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash3,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert4(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
};
var TransactionResponse = class _TransactionResponse {
  /**
   *  The provider this is connected to, which will influence how its
   *  methods will resolve its async inspection methods.
   */
  provider;
  /**
   *  The block number of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockNumber;
  /**
   *  The blockHash of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockHash;
  /**
   *  The index within the block that this transaction resides at.
   */
  index;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The [[link-eip-2718]] transaction envelope type. This is
   *  ``0`` for legacy transactions types.
   */
  type;
  /**
   *  The receiver of this transaction.
   *
   *  If ``null``, then the transaction is an initcode transaction.
   *  This means the result of executing the [[data]] will be deployed
   *  as a new contract on chain (assuming it does not revert) and the
   *  address may be computed using [[getCreateAddress]].
   */
  to;
  /**
   *  The sender of this transaction. It is implicitly computed
   *  from the transaction pre-image hash (as the digest) and the
   *  [[signature]] using ecrecover.
   */
  from;
  /**
   *  The nonce, which is used to prevent replay attacks and offer
   *  a method to ensure transactions from a given sender are explicitly
   *  ordered.
   *
   *  When sending a transaction, this must be equal to the number of
   *  transactions ever sent by [[from]].
   */
  nonce;
  /**
   *  The maximum units of gas this transaction can consume. If execution
   *  exceeds this, the entries transaction is reverted and the sender
   *  is charged for the full amount, despite not state changes being made.
   */
  gasLimit;
  /**
   *  The gas price can have various values, depending on the network.
   *
   *  In modern networks, for transactions that are included this is
   *  the //effective gas price// (the fee per gas that was actually
   *  charged), while for transactions that have not been included yet
   *  is the [[maxFeePerGas]].
   *
   *  For legacy transactions, or transactions on legacy networks, this
   *  is the fee that will be charged per unit of gas the transaction
   *  consumes.
   */
  gasPrice;
  /**
   *  The maximum priority fee (per unit of gas) to allow a
   *  validator to charge the sender. This is inclusive of the
   *  [[maxFeeFeePerGas]].
   */
  maxPriorityFeePerGas;
  /**
   *  The maximum fee (per unit of gas) to allow this transaction
   *  to charge the sender.
   */
  maxFeePerGas;
  /**
   *  The [[link-eip-4844]] max fee per BLOb gas.
   */
  maxFeePerBlobGas;
  /**
   *  The data.
   */
  data;
  /**
   *  The value, in wei. Use [[formatEther]] to format this value
   *  as ether.
   */
  value;
  /**
   *  The chain ID.
   */
  chainId;
  /**
   *  The signature.
   */
  signature;
  /**
   *  The [[link-eip-2930]] access list for transaction types that
   *  support it, otherwise ``null``.
   */
  accessList;
  /**
   *  The [[link-eip-4844]] BLOb versioned hashes.
   */
  blobVersionedHashes;
  #startBlock;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.#startBlock = -1;
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash3, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash3,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash3 of block) {
          if (hash3 === this.hash) {
            return;
          }
        }
        for (let i2 = 0; i2 < block.length; i2++) {
          const tx = await block.getTransaction(i2);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
              reason = "cancelled";
            }
            assert4(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert4(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve3, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve3(checkReceipt(receipt2));
          } catch (error2) {
            reject(error2);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error2) {
            if (isError3(error2, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error2);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert4(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert4(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert4(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
};
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log3) {
  return { orphan: "drop-log", log: {
    transactionHash: log3.transactionHash,
    blockHash: log3.blockHash,
    blockNumber: log3.blockNumber,
    address: log3.address,
    data: log3.data,
    topics: Object.freeze(log3.topics.slice()),
    index: log3.index
  } };
}

// node_modules/azle/node_modules/ethers/lib.esm/contract/wrappers.js
var EventLog = class extends Log {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The matching event.
   */
  fragment;
  /**
   *  The parsed arguments passed to the event by ``emit``.
   */
  args;
  /**
   * @_ignore:
   */
  constructor(log3, iface, fragment) {
    super(log3, log3.provider);
    const args2 = iface.decodeEventLog(fragment, log3.data, log3.topics);
    defineProperties(this, { args: args2, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};
var UndecodedEventLog = class extends Log {
  /**
   *  The error encounted when trying to decode the log.
   */
  error;
  /**
   * @_ignore:
   */
  constructor(log3, error2) {
    super(log3, log3.provider);
    defineProperties(this, { error: error2 });
  }
};
var ContractTransactionReceipt = class extends TransactionReceipt {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log3) => {
      const fragment = log3.topics.length ? this.#iface.getEvent(log3.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log3, this.#iface, fragment);
        } catch (error2) {
          return new UndecodedEventLog(log3, error2);
        }
      }
      return log3;
    });
  }
};
var ContractTransactionResponse = class extends TransactionResponse {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
};
var ContractUnknownEventPayload = class extends EventPayload {
  /**
   *  The log with no matching events.
   */
  log;
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log3) {
    super(contract, listener, filter);
    defineProperties(this, { log: log3 });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
};
var ContractEventPayload = class extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args2 = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args: args2, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/contract/contract.js
var BN_010 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
var PreparedTopicFilter = class {
  #filter;
  fragment;
  constructor(contract, fragment, args2) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args2.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args2[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args2[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v2) => resolveAddress(v2, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
};
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args2) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args2[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert4(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error2) {
      if (isCallException(error2) && error2.data) {
        throw contract.interface.makeError(error2.data, tx);
      }
      throw error2;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert4(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert4(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args2) {
    const fragment = contract.interface.getFunction(key, args2);
    assert4(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args: args2 }
    });
    return fragment;
  };
  const populateTransaction = async function(...args2) {
    const fragment = getFragment(...args2);
    let overrides = {};
    if (fragment.inputs.length + 1 === args2.length) {
      overrides = await copyOverrides(args2.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args2.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args2);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args2) {
    const result2 = await staticCallResult(...args2);
    if (result2.length === 1) {
      return result2[0];
    }
    return result2;
  };
  const send = async function(...args2) {
    const runner = contract.runner;
    assert4(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args2));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args2) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert4(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args2));
  };
  const staticCallResult = async function(...args2) {
    const runner = getRunner(contract.runner, "call");
    assert4(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args2);
    let result2 = "0x";
    try {
      result2 = await runner.call(tx);
    } catch (error2) {
      if (isCallException(error2) && error2.data) {
        throw contract.interface.makeError(error2.data, tx);
      }
      throw error2;
    }
    const fragment = getFragment(...args2);
    return contract.interface.decodeFunctionResult(fragment, result2);
  };
  const method = async (...args2) => {
    const fragment = getFragment(...args2);
    if (fragment.constant) {
      return await staticCall(...args2);
    }
    return await send(...args2);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert4(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args2) {
    const fragment = contract.interface.getEvent(key, args2);
    assert4(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args: args2 }
    });
    return fragment;
  };
  const method = function(...args2) {
    return new PreparedTopicFilter(contract, getFragment(...args2), args2);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert4(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
var internal2 = Symbol.for("_ethersInternal_contract");
var internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal2], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal2]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e3) => {
      if (e3 == null) {
        return null;
      }
      if (Array.isArray(e3)) {
        return e3.map(topicHashify);
      }
      return topicHashify(e3);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t2) => {
    if (t2 == null) {
      return null;
    }
    if (Array.isArray(t2)) {
      const items = Array.from(new Set(t2.map((t3) => t3.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t2.toLowerCase();
  });
  const tag = topics.map((t2) => {
    if (t2 == null) {
      return "null";
    }
    if (Array.isArray(t2)) {
      return t2.join("|");
    }
    return t2;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert4(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log3) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log3.topics[0]);
        } catch (error2) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args2 = fragment ? contract.interface.decodeEventLog(fragment, log3.data, log3.topics) : [];
        emit3(contract, event, args2, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log3);
        });
      } else {
        emit3(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log3);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
var lastEmit = Promise.resolve();
async function _emit(contract, event, args2, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once: once4 }) => {
    const passArgs = Array.from(args2);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once4 ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error2) {
    }
    return !once4;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit3(contract, event, args2, payloadFunc) {
  try {
    await lastEmit;
  } catch (error2) {
  }
  const resultPromise = _emit(contract, event, args2, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
var passProperties2 = ["then"];
var BaseContract = class _BaseContract {
  /**
   *  The target to connect to.
   *
   *  This can be an address, ENS name or any [[Addressable]], such as
   *  another contract. To get the resovled address, use the ``getAddress``
   *  method.
   */
  target;
  /**
   *  The contract Interface.
   */
  interface;
  /**
   *  The connected runner. This is generally a [[Provider]] or a
   *  [[Signer]], which dictates what operations are supported.
   *
   *  For example, a **Contract** connected to a [[Provider]] may
   *  only execute read-only operations.
   */
  runner;
  /**
   *  All the Events available on this contract.
   */
  filters;
  /**
   *  @_ignore:
   */
  [internal2];
  /**
   *  The fallback or receive function if any.
   */
  fallback;
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal2, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error2) {
          if (!isError3(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
            throw error2;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error2) {
          if (!isError3(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
            throw error2;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert4(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert4(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve3, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve3(this);
          }
          provider.once("block", checkCode);
        } catch (error2) {
          reject(error2);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash3) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert4(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log3) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log3.topics[0]);
        } catch (error2) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log3, this.interface, foundFragment);
        } catch (error2) {
          return new UndecodedEventLog(log3, error2);
        }
      }
      return new Log(log3, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args2) {
    return await emit3(this, event, args2, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners: listeners3 } of subs.values()) {
      total += listeners3.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result2 = [];
    for (const { listeners: listeners3 } of subs.values()) {
      result2 = result2.concat(listeners3.map(({ listener }) => listener));
    }
    return result2;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
function _ContractBase() {
  return BaseContract;
}
var Contract = class extends _ContractBase() {
};

// node_modules/azle/node_modules/ethers/lib.esm/contract/factory.js
var ContractFactory = class _ContractFactory {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The Contract deployment bytecode. Often called the initcode.
   */
  bytecode;
  /**
   *  The ContractRunner to deploy the Contract as.
   */
  runner;
  /**
   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
   *  optionally connected to %%runner%%.
   *
   *  The %%bytecode%% may be the ``bytecode`` property within the
   *  standard Solidity JSON output.
   */
  constructor(abi, bytecode, runner) {
    const iface = Interface.from(abi);
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify(getBytes(bytecode));
    } else {
      if (typeof bytecode === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify(getBytes(bytecode));
    }
    defineProperties(this, {
      bytecode,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Resolves to the transaction to deploy the contract, passing %%args%%
   *  into the constructor.
   */
  async getDeployTransaction(...args2) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args2.length) {
      overrides = await copyOverrides(args2.pop());
    }
    if (fragment.inputs.length !== args2.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args2);
    const data = concat2([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data });
  }
  /**
   *  Resolves to the Contract deployed by passing %%args%% into the
   *  constructor.
   *
   *  This will resolve to the Contract before it has been deployed to the
   *  network, so the [[BaseContract-waitForDeployment]] should be used before
   *  sending any transactions to it.
   */
  async deploy(...args2) {
    const tx = await this.getDeployTransaction(...args2);
    assert4(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx);
    const address = getCreateAddress(sentTx);
    return new BaseContract(address, this.interface, this.runner, sentTx);
  }
  /**
   *  Return a new **ContractFactory** with the same ABI and bytecode,
   *  but connected to %%runner%%.
   */
  connect(runner) {
    return new _ContractFactory(this.interface, this.bytecode, runner);
  }
  /**
   *  Create a new **ContractFactory** from the standard Solidity JSON output.
   */
  static fromSolidity(output3, runner) {
    assertArgument(output3 != null, "bad compiler output", "output", output3);
    if (typeof output3 === "string") {
      output3 = JSON.parse(output3);
    }
    const abi = output3.abi;
    let bytecode = "";
    if (output3.bytecode) {
      bytecode = output3.bytecode;
    } else if (output3.evm && output3.evm.bytecode) {
      bytecode = output3.evm.bytecode;
    }
    return new this(abi, bytecode, runner);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink(link3) {
  if (link3.match(/^ipfs:\/\/ipfs\//i)) {
    link3 = link3.substring(12);
  } else if (link3.match(/^ipfs:\/\//i)) {
    link3 = link3.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link3);
  }
  return `https://gateway.ipfs.io/ipfs/${link3}`;
}
var MulticoinProviderPlugin = class {
  /**
   *  The name.
   */
  name;
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
};
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var EnsResolver = class _EnsResolver {
  /**
   *  The connected provider.
   */
  provider;
  /**
   *  The address of the resolver.
   */
  address;
  /**
   *  The name this resolver was resolved against.
   */
  name;
  // For EIP-2544 names, the ancestor that provided the resolver
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error2) {
          if (isError3(error2, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error2;
        }
      })();
    }
    return await this.#supports2544;
  }
  async #fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert4(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result2 = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result2)[0];
      }
      return result2;
    } catch (error2) {
      if (!isError3(error2, "CALL_EXCEPTION")) {
        throw error2;
      }
    }
    return null;
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result2 = await this.#fetch("addr(bytes32)");
        if (result2 == null || result2 === ZeroAddress) {
          return null;
        }
        return result2;
      } catch (error2) {
        if (isError3(error2, "CALL_EXCEPTION")) {
          return null;
        }
        throw error2;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert4(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await this.#fetch("text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await this.#fetch("contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert4(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i2 = 0; i2 < matchers.length; i2++) {
        const match = avatar.match(matchers[i2]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url2 = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url2 });
            return { linkage, url: url2 };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error2) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error3) {
                const bytes4 = response.body;
                if (bytes4) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes4) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error2) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert4(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async #getResolver(provider, name) {
    const ensAddr = await _EnsResolver.getEnsAddress(provider);
    try {
      const contract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error2) {
      throw error2;
    }
    return null;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await _EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/format.js
var BN_011 = BigInt(0);
function allowNull(format3, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format3(value);
  };
}
function arrayOf(format3, allowNull3) {
  return (array) => {
    if (allowNull3 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i2) => format3(i2));
  };
}
function object(format3, altNames) {
  return (value) => {
    const result2 = {};
    for (const key in format3) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format3[key](value[srcKey]);
        if (nv !== void 0) {
          result2[key] = nv;
        }
      } catch (error2) {
        const message = error2 instanceof Error ? error2.message : "not-an-error";
        assert4(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result2;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
var _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
var _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result2 = _formatBlock(value);
  result2.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result2;
}
var _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
var _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_011) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result2 = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result2.to == null && result2.creates == null) {
    result2.creates = getCreateAddress(result2);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result2.accessList = [];
  }
  if (value.signature) {
    result2.signature = Signature.from(value.signature);
  } else {
    result2.signature = Signature.from(value);
  }
  if (result2.chainId == null) {
    const chainId = result2.signature.legacyChainId;
    if (chainId != null) {
      result2.chainId = chainId;
    }
  }
  if (result2.blockHash && getBigInt(result2.blockHash) === BN_011) {
    result2.blockHash = null;
  }
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
var NetworkPlugin = class _NetworkPlugin {
  /**
   *  The name of the plugin.
   *
   *  It is recommended to use reverse-domain-notation, which permits
   *  unique names with a known authority as well as hierarchal entries.
   */
  name;
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new _NetworkPlugin(this.name);
  }
};
var GasCostPlugin = class _GasCostPlugin extends NetworkPlugin {
  /**
   *  The block number to treat these values as valid from.
   *
   *  This allows a hardfork to have updated values included as well as
   *  mulutiple hardforks to be supported.
   */
  effectiveBlock;
  /**
   *  The transactions base fee.
   */
  txBase;
  /**
   *  The fee for creating a new account.
   */
  txCreate;
  /**
   *  The fee per zero-byte in the data.
   */
  txDataZero;
  /**
   *  The fee per non-zero-byte in the data.
   */
  txDataNonzero;
  /**
   *  The fee per storage key in the [[link-eip-2930]] access list.
   */
  txAccessListStorageKey;
  /**
   *  The fee per address in the [[link-eip-2930]] access list.
   */
  txAccessListAddress;
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new _GasCostPlugin(this.effectiveBlock, this);
  }
};
var EnsPlugin = class _EnsPlugin extends NetworkPlugin {
  /**
   *  The ENS Registrty Contract address.
   */
  address;
  /**
   *  The chain ID that the ENS contract lives on.
   */
  targetNetwork;
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new _EnsPlugin(this.address, this.targetNetwork);
  }
};
var FeeDataNetworkPlugin = class _FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new _FeeDataNetworkPlugin(this.#feeDataFunc);
  }
};
var FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
  #url;
  #processFunc;
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return this.#url;
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return this.#processFunc;
  }
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url2, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url2;
    this.#processFunc = processFunc;
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/network.js
var Networks = /* @__PURE__ */ new Map();
var Network = class _Network {
  #name;
  #chainId;
  #plugins;
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = /* @__PURE__ */ new Map();
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error2) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error2) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error2) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename2) {
    return this.plugins.filter((p3) => p3.name.split("#")[0] === basename2);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i2 = 2; i2 < tx.data.length; i2 += 2) {
        if (tx.data.substring(i2, i2 + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
function parseUnits2(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url2) {
  return new FetchUrlFeeDataNetworkPlugin(url2, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits2(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits2(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error2) {
      assert4(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error: error2 });
    }
  });
}
var injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}

// node_modules/azle/node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var PollingBlockSubscriber = class {
  #provider;
  #poller;
  #interval;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4e3;
    this.#blockNumber = -2;
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async #poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b4 = this.#blockNumber + 1; b4 <= blockNumber; b4++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b4);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error2) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};
var OnBlockSubscriber = class {
  #provider;
  #poll;
  #running;
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
};
var PollingBlockTagSubscriber = class extends OnBlockSubscriber {
  #tag;
  #lastBlock;
  constructor(provider, tag) {
    super(provider);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
};
var PollingOrphanSubscriber = class extends OnBlockSubscriber {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
};
var PollingTransactionSubscriber = class extends OnBlockSubscriber {
  #hash;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash3) {
    super(provider);
    this.#hash = hash3;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
};
var PollingEventSubscriber = class {
  #provider;
  #filter;
  #poller;
  #running;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async #poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log3 of logs) {
      this.#provider.emit(this.#filter, log3);
      this.#blockNumber = log3.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/abstract-provider.js
var BN_23 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;
function isPromise2(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v2) => {
    if (v2 == null) {
      return "null";
    }
    if (typeof v2 === "bigint") {
      return `bigint:${v2.toString()}`;
    }
    if (typeof v2 === "string") {
      return v2.toLowerCase();
    }
    if (typeof v2 === "object" && !Array.isArray(v2)) {
      const keys = Object.keys(v2);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v2[key];
        return accum;
      }, {});
    }
    return v2;
  });
}
var UnmanagedSubscriber = class {
  /**
   *  The name fof the event.
   */
  name;
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
};
function copy2(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString(_event, 32)) {
    const hash3 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash3 }), hash: hash3 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t2) => {
        if (t2 == null) {
          return null;
        }
        if (Array.isArray(t2)) {
          return concisify(t2.map((t3) => t3.toLowerCase()));
        }
        return t2.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises2 = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises2.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises2.length) {
        await Promise.all(promises2);
      }
      filter.address = concisify(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime2() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var defaultOptions = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var AbstractProvider = class {
  #subs;
  #plugins;
  // null=unpaused, true=paused+dropWhilePaused, false=paused
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  // The most recent block number if running an event or -1 if no "block" event
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#plugins = /* @__PURE__ */ new Map();
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = /* @__PURE__ */ new Map();
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  // Shares multiple identical requests made during the same 250ms
  async #perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i2 = 0; i2 < urls.length; i2++) {
      const url2 = urls[i2];
      const href = url2.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest(href);
      if (url2.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i2, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error2) {
        errorMessages.push(error2.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error: error2 } });
        continue;
      }
      try {
        const result2 = resp.bodyJson;
        if (result2.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result: result2 });
          return result2.data;
        }
        if (result2.message) {
          errorMessage = result2.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: result2 });
      } catch (error2) {
      }
      assert4(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url: url2, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert4(false, `error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert4(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert4(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b4) => toQuantity(b4 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t2) => {
      if (t2 == null) {
        return null;
      }
      if (Array.isArray(t2)) {
        return concisify(t2.map((t3) => t3.toLowerCase()));
      }
      return t2.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve3 = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result2) => {
        return resolve3(result2[0], result2[1], result2[2]);
      });
    }
    return resolve3(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request) {
    const request = copyRequest(_request);
    const promises2 = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise2(addr)) {
        promises2.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise2(blockTag)) {
        promises2.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises2.length) {
      return async function() {
        await Promise.all(promises2);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error2) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error2;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert4(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error2) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error2) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise2(tx)) {
      tx = await tx;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async #call(tx, blockTag, attempt) {
    assert4(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest(tx);
    try {
      return hexlify(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error2) {
      if (!this.disableCcipRead && isCallException(error2) && error2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error2.data, 0, 4) === "0x556f1830") {
        const data = error2.data;
        const txSender = await resolveAddress(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error2.data, 4));
        } catch (error3) {
          assert4(false, error3.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data }
          });
        }
        assert4(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert4(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error2.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat2([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result2 = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result: result2 });
          return result2;
        } catch (error3) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error3 });
          throw error3;
        }
      }
      throw error2;
    }
  }
  async #checkNetwork(promise) {
    const { value } = await resolveProperties({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  // Account
  async #getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash3, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash3) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async #getBlock(block, includeTransactions) {
    if (isHexString(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash3) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash3 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash3) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash3 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash3 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash3) {
    const { result: result2 } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash3 })
    });
    if (result2 == null) {
      return null;
    }
    return hexlify(result2);
  }
  // Bloom-filter Queries
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise2(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p3) => this._wrapLog(p3, network));
  }
  // ENS
  _getProvider(chainId) {
    assert4(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error2) {
      if (isError3(error2, "BAD_DATA") && error2.value === "0x") {
        return null;
      }
      if (isError3(error2, "CALL_EXCEPTION")) {
        return null;
      }
      throw error2;
    }
    return null;
  }
  async waitForTransaction(hash3, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash3);
    }
    return new Promise(async (resolve3, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash3);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve3(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error2) {
          console.log("EEE", error2);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert4(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime2() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of this.#subs.values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of this.#subs.values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async #hasSub(event, emitArgs) {
    let sub = await getSubscription(event, this);
    if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub.tag) || null;
  }
  async #getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag = subscription.tag;
    let sub = this.#subs.get(tag);
    if (!sub) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = /* @__PURE__ */ new WeakMap();
      const nameMap = /* @__PURE__ */ new Map();
      sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub);
    }
    return sub;
  }
  async on(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args2) {
    const sub = await this.#hasSub(event, args2);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    ;
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once: once4 }) => {
      const payload = new EventPayload(this, once4 ? null : listener, event);
      try {
        listener.call(this, ...args2, payload);
      } catch (error2) {
      }
      return !once4;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners: listeners3 } of this.#subs.values()) {
      total += listeners3.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result2 = [];
    for (const { listeners: listeners3 } of this.#subs.values()) {
      result2 = result2.concat(listeners3.map(({ listener }) => listener));
    }
    return result2;
  }
  async off(event, listener) {
    const sub = await this.#hasSub(event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert4(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime2() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime2();
      setTimeout(timer.func, timeout);
    }
  }
};
function _parseString(result2, start) {
  try {
    const bytes4 = _parseBytes(result2, start);
    if (bytes4) {
      return toUtf8String(bytes4);
    }
  } catch (error2) {
  }
  return null;
}
function _parseBytes(result2, start) {
  if (result2 === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result2, start, start + 32));
    const length = getNumber(dataSlice(result2, offset, offset + 32));
    return dataSlice(result2, offset + 32, offset + 32 + length);
  } catch (error2) {
  }
  return null;
}
function numPad(value) {
  const result2 = toBeArray(value);
  if (result2.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result2, 32 - result2.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result2 = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result2.set(value);
  return result2;
}
var empty2 = new Uint8Array([]);
function encodeBytes(datas) {
  const result2 = [];
  let byteCount = 0;
  for (let i2 = 0; i2 < datas.length; i2++) {
    result2.push(empty2);
    byteCount += 32;
  }
  for (let i2 = 0; i2 < datas.length; i2++) {
    const data = getBytes(datas[i2]);
    result2[i2] = numPad(byteCount);
    result2.push(numPad(data.length));
    result2.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat2(result2);
}
var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result2 = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert4(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert4(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result2.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u2 = 0; u2 < urlsLength; u2++) {
      const url2 = _parseString(urlsData, u2 * 32);
      if (url2 == null) {
        throw new Error("abort");
      }
      urls.push(url2);
    }
    result2.urls = urls;
  } catch (error2) {
    assert4(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result2.calldata = calldata;
  } catch (error2) {
    assert4(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert4(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result2.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result2.extraData = extraData;
  } catch (error2) {
    assert4(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result2.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result2[k]);
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert4(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
var AbstractSigner = class {
  /**
   *  The provider this signer is connected to.
   */
  provider;
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert4(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert4(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert4(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
};
var VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  The signer address.
   */
  address;
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
  #throwUnsupported(suffix, operation) {
    assert4(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain3, types, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/community.js
var shown = /* @__PURE__ */ new Set();
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}

// node_modules/azle/node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy3(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var FilterIdSubscriber = class {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result2) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async #poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error2) {
        if (!isError3(error2, "UNSUPPORTED_OPERATION") || error2.operation !== "eth_newFilter") {
          throw error2;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result2 = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result2);
    } catch (error2) {
      console.log("@TODO", error2);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
};
var FilterIdEventSubscriber = class extends FilterIdSubscriber {
  #event;
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    this.#event = copy3(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result2 of results) {
      provider.emit(this.#event, provider._wrapLog(result2, provider._network));
    }
  }
};
var FilterIdPendingSubscriber = class extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result2 of results) {
      provider.emit("pending", result2);
    }
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall(duration) {
  return new Promise((resolve3) => {
    setTimeout(resolve3, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions2 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var JsonRpcSigner = class extends AbstractSigner {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert4(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises2 = [];
    if (tx.from) {
      const _from2 = tx.from;
      promises2.push((async () => {
        const from = await resolveAddress(_from2, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises2.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises2.push((async () => {
        tx.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises2.length) {
      await Promise.all(promises2);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash3 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve3, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash3);
          if (tx2 != null) {
            resolve3(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error2) {
          if (isError3(error2, "CANCELLED") || isError3(error2, "BAD_DATA") || isError3(error2, "NETWORK_ERROR") || isError3(error2, "UNSUPPORTED_OPERATION")) {
            if (error2.info == null) {
              error2.info = {};
            }
            error2.info.sendTransactionHash = hash3;
            reject(error2);
            return;
          }
          if (isError3(error2, "INVALID_ARGUMENT")) {
            invalids++;
            if (error2.info == null) {
              error2.info = {};
            }
            error2.info.sendTransactionHash = hash3;
            if (invalids > 10) {
              reject(error2);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: error2 }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain3, types, _value) {
    const value = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain3, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
};
var JsonRpcApiProvider = class extends AbstractProvider {
  #options;
  // The next ID to use for the JSON-RPC ID field
  #nextId;
  // Payloads are queued and triggered in batches using the drainTimer
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes4 = JSON.stringify(batch.map((p3) => p3.payload));
          if (bytes4.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p3) => p3.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result2 = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result: result2 });
            for (const { resolve: resolve3, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result2.filter((r3) => r3.id === payload2.id)[0];
              if (resp == null) {
                const error2 = makeError("missing response for request", "BAD_DATA", {
                  value: result2,
                  info: { payload: payload2 }
                });
                this.emit("error", error2);
                reject(error2);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve3(resp.result);
            }
          } catch (error2) {
            this.emit("debug", { action: "receiveRpcError", error: error2 });
            for (const { reject } of batch) {
              reject(error2);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions2, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve3 = null;
      const promise = new Promise((_resolve) => {
        resolve3 = _resolve;
      });
      this.#notReady = { promise, resolve: resolve3 };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network.from(network);
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return this.#options[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert4(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result2 = Network.from(getBigInt(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result2;
        } catch (error2) {
          this.#pendingDetectNetwork = null;
          throw error2;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result2;
      try {
        result2 = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error2) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error: error2 });
        throw error2;
      }
      this.emit("debug", { action: "receiveRpcResult", result: result2 });
      if ("result" in result2) {
        return Network.from(getBigInt(result2.result));
      }
      throw this.getRpcError(payload, result2);
    })();
    return await this.#pendingDetectNetwork;
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error2) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: error2 } }));
          await stall(1e3);
        }
      }
      this.#scheduleDrain();
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return this.#notReady == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result2 = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result2[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result2[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result2["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result2["blobVersionedHashes"] = tx.blobVersionedHashes.map((h2) => h2.toLowerCase());
    }
    return result2;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error: error2 } = _error;
    if (method === "eth_estimateGas" && error2.message) {
      const msg = error2.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error: error2 }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result2 = spelunkData(error2);
      const e3 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result2 ? result2.data : null);
      e3.info = { error: error2, payload };
      return e3;
    }
    const message = JSON.stringify(spelunkMessage(error2));
    if (typeof error2.message === "string" && error2.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error: error2 }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error: error2 }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error: error2 } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error: error2 } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error: error2 } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error2 && error2.details && error2.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error: error2, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error: error2, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id3 = this.#nextId++;
    const promise = new Promise((resolve3, reject) => {
      this.#payloads.push({
        resolve: resolve3,
        reject,
        payload: { method, params, id: id3, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner(this, a2));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
};
var JsonRpcApiPollingProvider = class extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions2.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = this.#pollingInterval;
      }
    });
  }
};
var JsonRpcProvider = class extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url2, network, options) {
    if (url2 == null) {
      url2 = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url2 === "string") {
      this.#connect = new FetchRequest(url2);
    } else {
      this.#connect = url2.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
};
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result2 = spelunkData(value[key]);
      if (result2) {
        return result2;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error2) {
    }
  }
  return null;
}
function _spelunkMessage(value, result2) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result2.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result2);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result2);
    } catch (error2) {
    }
  }
}
function spelunkMessage(value) {
  const result2 = [];
  _spelunkMessage(value, result2);
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-ankr.js
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var AnkrProvider = class _AnkrProvider extends JsonRpcProvider {
  /**
   *  The API key for the Ankr connection.
   */
  apiKey;
  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const options = { polling: true, staticNetwork: network };
    const request = _AnkrProvider.getRequest(network, apiKey);
    super(request, network, options);
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AnkrProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%apiKey%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request = new FetchRequest(`https://${getHost(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error2) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error2 && error2.error && error2.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error2.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error2);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-alchemy.js
var defaultApiKey2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost2(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var AlchemyProvider = class _AlchemyProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = _AlchemyProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AlchemyProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data;
      let error2 = false;
      try {
        data = trace[0].result.output;
        error2 = trace[0].error === "Reverted";
      } catch (error3) {
      }
      if (data) {
        assert4(!error2, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
          // @TODO
        });
        return data;
      }
      assert4(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = new FetchRequest(`https://${getHost2(network.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("alchemy");
        return true;
      };
    }
    return request;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-chainstack.js
function getApiKey(name) {
  switch (name) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  assertArgument(false, "unsupported network", "network", name);
}
function getHost3(name) {
  switch (name) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var ChainstackProvider = class _ChainstackProvider extends JsonRpcProvider {
  /**
   *  The API key for the Chainstack connection.
   */
  apiKey;
  /**
   *  Creates a new **ChainstackProvider**.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    const request = _ChainstackProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _ChainstackProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === getApiKey(this._network.name);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%apiKey%% and %%projectSecret%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    const request = new FetchRequest(`https://${getHost3(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === getApiKey(network.name)) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("ChainstackProvider");
        return true;
      };
    }
    return request;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-cloudflare.js
var CloudflareProvider = class extends JsonRpcProvider {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    assertArgument(network.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network, { staticNetwork: network });
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-etherscan.js
var THROTTLE = 2e3;
function isPromise3(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
var EtherscanPlugin = class _EtherscanPlugin extends NetworkPlugin {
  /**
   *  The Etherscan API base URL.
   */
  baseUrl;
  /**
   *  Creates a new **EtherscanProvider** which will use
   *  %%baseUrl%%.
   */
  constructor(baseUrl) {
    super(EtherscanPluginId);
    defineProperties(this, { baseUrl });
  }
  clone() {
    return new _EtherscanPlugin(this.baseUrl);
  }
};
var skipKeys = ["enableCcipRead"];
var nextId = 1;
var EtherscanProvider = class extends AbstractProvider {
  /**
   *  The connected network.
   */
  network;
  /**
   *  The API key or null if using the community provided bandwidth.
   */
  apiKey;
  #plugin;
  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network = Network.from(_network);
    this.#plugin = network.getPlugin(EtherscanPluginId);
    defineProperties(this, { apiKey, network });
    this.getBaseUrl();
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "base":
        return "https://api.basescan.org";
      case "base-sepolia":
        return "https://api-sepolia.basescan.org";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-amoy":
        return "https://api-amoy.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    assertArgument(false, "unsupported network", "network", this.network);
  }
  /**
   *  Returns the URL for the %%module%% and %%params%%.
   */
  getUrl(module, params) {
    const query3 = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.getBaseUrl()}/api?module=${module}${query3}${apiKey}`;
  }
  /**
   *  Returns the URL for using POST requests.
   */
  getPostUrl() {
    return `${this.getBaseUrl()}/api`;
  }
  /**
   *  Returns the parameters for using POST requests.
   */
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the result of calling %%module%% with %%params%%.
   *
   *  If %%post%%, the request is made as a POST request.
   */
  async fetch(module, params, post) {
    const id3 = nextId++;
    const url2 = post ? this.getPostUrl() : this.getUrl(module, params);
    const payload = post ? this.getPostData(module, params) : null;
    this.emit("debug", { action: "sendRequest", id: id3, url: url2, payload });
    const request = new FetchRequest(url2);
    request.setThrottleParams({ slotInterval: 1e3 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result3 = response2.hasBody() ? JSON.parse(toUtf8String(response2.body)) : {};
      const throttle = (typeof result3.result === "string" ? result3.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module === "proxy") {
        if (result3 && result3.status == 0 && result3.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result3 });
          response2.throwThrottleError(result3.result, THROTTLE);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result3.result });
          response2.throwThrottleError(result3.result, THROTTLE);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error2) {
      this.emit("debug", { action: "receiveError", id: id3, error: error2, reason: "assertOk" });
      assert4(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
      assert4(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result2 = JSON.parse(toUtf8String(response.body));
    if (module === "proxy") {
      if (result2.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id3, result: result2, reason: "invalid JSON-RPC" });
        assert4(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result: result2 } });
      }
      if (result2.error) {
        this.emit("debug", { action: "receiveError", id: id3, result: result2, reason: "JSON-RPC error" });
        assert4(false, "error response", "SERVER_ERROR", { request, response, info: { result: result2 } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result: result2 });
      return result2.result;
    } else {
      if (result2.status == 0 && (result2.message === "No records found" || result2.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id3, result: result2 });
        return result2.result;
      }
      if (result2.status != 1 || typeof result2.message === "string" && !result2.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id3, result: result2 });
        assert4(false, "error response", "SERVER_ERROR", { request, response, info: { result: result2 } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result: result2 });
      return result2.result;
    }
  }
  /**
   *  Returns %%transaction%% normalized for the Etherscan API.
   */
  _getTransactionPostData(transaction) {
    const result2 = {};
    for (let key in transaction) {
      if (skipKeys.indexOf(key) >= 0) {
        continue;
      }
      if (transaction[key] == null) {
        continue;
      }
      let value = transaction[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if (key === "blockTag" && value === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity(value);
      } else if (key === "accessList") {
        value = "[" + accessListify(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else if (key === "blobVersionedHashes") {
        if (value.length === 0) {
          continue;
        }
        assert4(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
          operation: "_getTransactionPostData",
          info: { transaction }
        });
      } else {
        value = hexlify(value);
      }
      result2[key] = value;
    }
    return result2;
  }
  /**
   *  Throws the normalized Etherscan error.
   */
  _checkError(req, error2, transaction) {
    let message = "";
    if (isError3(error2, "SERVER_ERROR")) {
      try {
        message = error2.info.result.error.message;
      } catch (e3) {
      }
      if (!message) {
        try {
          message = error2.info.message;
        } catch (e3) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert4(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data = "";
        try {
          data = error2.info.result.error.data;
        } catch (error3) {
        }
        const e3 = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
        e3.info = { request: req, error: error2 };
        throw e3;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction2 = Transaction.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert4(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction2
          });
        }
        if (message.match(/insufficient funds/)) {
          assert4(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction2
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert4(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction2
          });
        }
      }
    }
    throw error2;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      /* Working with Etherscan to get this added:
      try {
          const test = await this.fetch("proxy", {
              action: "eth_maxPriorityFeePerGas"
          });
          console.log(test);
          return test;
      } catch (e) {
          console.log("DEBUG", e);
          throw e;
      }
      */
      /* This might be safe; but due to rounding neither myself
         or Etherscan are necessarily comfortable with this. :)
      try {
          const result = await this.fetch("gastracker", { action: "gasoracle" });
          console.log(result);
          const gasPrice = parseUnits(result.SafeGasPrice, "gwei");
          const baseFee = parseUnits(result.suggestBaseFee, "gwei");
          const priorityFee = gasPrice - baseFee;
          if (priorityFee < 0) { throw new Error("negative priority fee; defer to abstract provider default"); }
          return priorityFee;
      } catch (error) {
          console.log("DEBUG", error);
          throw error;
      }
      */
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error2) => {
          return this._checkError(req, error2, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert4(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error2) {
          return this._checkError(req, error2, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error2) {
          return this._checkError(req, error2, req.transaction);
        }
      }
      /*
                  case "getLogs": {
                      // Needs to complain if more than one address is passed in
                      const args: Record<string, any> = { action: "getLogs" }
      
                      if (params.filter.fromBlock) {
                          args.fromBlock = checkLogTag(params.filter.fromBlock);
                      }
      
                      if (params.filter.toBlock) {
                          args.toBlock = checkLogTag(params.filter.toBlock);
                      }
      
                      if (params.filter.address) {
                          args.address = params.filter.address;
                      }
      
                      // @TODO: We can handle slightly more complicated logs using the logs API
                      if (params.filter.topics && params.filter.topics.length > 0) {
                          if (params.filter.topics.length > 1) {
                              logger.throwError("unsupported topic count", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                          }
                          if (params.filter.topics.length === 1) {
                              const topic0 = params.filter.topics[0];
                              if (typeof(topic0) !== "string" || topic0.length !== 66) {
                                  logger.throwError("unsupported topic format", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                              }
                              args.topic0 = topic0;
                          }
                      }
      
                      const logs: Array<any> = await this.fetch("logs", args);
      
                      // Cache txHash => blockHash
                      let blocks: { [tag: string]: string } = {};
      
                      // Add any missing blockHash to the logs
                      for (let i = 0; i < logs.length; i++) {
                          const log = logs[i];
                          if (log.blockHash != null) { continue; }
                          if (blocks[log.blockNumber] == null) {
                              const block = await this.getBlock(log.blockNumber);
                              if (block) {
                                  blocks[log.blockNumber] = block.hash;
                              }
                          }
      
                          log.blockHash = blocks[log.blockNumber];
                      }
      
                      return logs;
                  }
      */
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the current price of ether.
   *
   *  This returns ``0`` on any network other than ``mainnet``.
   */
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  /**
   *  Resolves to a [Contract]] for %%address%%, using the
   *  Etherscan API to retreive the Contract ABI.
   */
  async getContract(_address) {
    let address = this._getAddress(_address);
    if (isPromise3(address)) {
      address = await address;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address
      });
      const abi = JSON.parse(resp);
      return new Contract(address, abi, this);
    } catch (error2) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/ws-browser.js
function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var _WebSocket = getGlobal2().WebSocket;

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-socket.js
var SocketSubscriber = class {
  #provider;
  #filter;
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = JSON.stringify(filter);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      ;
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      if (this.#provider.destroyed) {
        return;
      }
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(dropWhilePaused) {
    assert4(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  /**
   *  @_ignore:
   */
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(provider, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
};
var SocketBlockSubscriber = class extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newHeads"]);
  }
  async _emit(provider, message) {
    provider.emit("block", parseInt(message.number));
  }
};
var SocketPendingSubscriber = class extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newPendingTransactions"]);
  }
  async _emit(provider, message) {
    provider.emit("pending", message);
  }
};
var SocketEventSubscriber = class extends SocketSubscriber {
  #logFilter;
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  /**
   *  @_ignore:
   */
  constructor(provider, filter) {
    super(provider, ["logs", filter]);
    this.#logFilter = JSON.stringify(filter);
  }
  async _emit(provider, message) {
    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
  }
};
var SocketProvider = class extends JsonRpcApiProvider {
  #callbacks;
  // Maps each filterId to its subscriber
  #subs;
  // If any events come in before a subscriber has finished
  // registering, queue them
  #pending;
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(network, _options) {
    const options = Object.assign({}, _options != null ? _options : {});
    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network, options);
    this.#callbacks = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#pending = /* @__PURE__ */ new Map();
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub.filter);
      case "orphan":
        if (sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve3, reject) => {
      this.#callbacks.set(payload.id, { payload, resolve: resolve3, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(message) {
    const result2 = JSON.parse(message);
    if (result2 && typeof result2 === "object" && "id" in result2) {
      const callback = this.#callbacks.get(result2.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result: result2
        }));
        return;
      }
      this.#callbacks.delete(result2.id);
      callback.resolve(result2);
    } else if (result2 && result2.method === "eth_subscription") {
      const filterId = result2.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result2.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result2.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result: result2
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-websocket.js
var WebSocketProvider = class extends SocketProvider {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url2, network, options) {
    super(network, options);
    if (typeof url2 === "string") {
      this.#connect = () => {
        return new _WebSocket(url2);
      };
      this.#websocket = this.#connect();
    } else if (typeof url2 === "function") {
      this.#connect = url2;
      this.#websocket = url2();
    } else {
      this.#connect = null;
      this.#websocket = url2;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error2) {
        console.log("failed to start WebsocketProvider", error2);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-infura.js
var defaultProjectId = "84842078b09946638c03157f83405213";
function getHost4(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bnbsmartchain-mainnet.infura.io";
    case "bnbt":
      return "bnbsmartchain-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var InfuraWebSocketProvider = class extends WebSocketProvider {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(network, projectId) {
    const provider = new InfuraProvider(network, projectId);
    const req = provider._getConnection();
    assert4(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url2 = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url2, provider._network);
    defineProperties(this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class _InfuraProvider extends JsonRpcProvider {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = _InfuraProvider.getRequest(network, projectId, projectSecret);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new _InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(network, projectId) {
    return new InfuraWebSocketProvider(network, projectId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(network, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest(`https://${getHost4(network.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-quicknode.js
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost5(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var QuickNodeProvider = class _QuickNodeProvider extends JsonRpcProvider {
  /**
   *  The API token.
   */
  token;
  /**
   *  Creates a new **QuickNodeProvider**.
   */
  constructor(_network, token) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    const request = _QuickNodeProvider.getRequest(network, token);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new _QuickNodeProvider(chainId, this.token);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken;
  }
  /**
   *  Returns a new request prepared for %%network%% and the
   *  %%token%%.
   */
  static getRequest(network, token) {
    if (token == null) {
      token = defaultToken;
    }
    const request = new FetchRequest(`https://${getHost5(network.name)}/${token}`);
    request.allowGzip = true;
    if (token === defaultToken) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("QuickNodeProvider");
        return true;
      };
    }
    return request;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-fallback.js
var BN_16 = BigInt("1");
var BN_24 = BigInt("2");
function shuffle(array) {
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j];
    array[j] = tmp;
  }
}
function stall2(duration) {
  return new Promise((resolve3) => {
    setTimeout(resolve3, duration);
  });
}
function getTime3() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stringify3(value) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
}
var defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};
async function waitForSync(config2, blockNumber) {
  while (config2.blockNumber < 0 || config2.blockNumber < blockNumber) {
    if (!config2._updateNumber) {
      config2._updateNumber = (async () => {
        try {
          const blockNumber2 = await config2.provider.getBlockNumber();
          if (blockNumber2 > config2.blockNumber) {
            config2.blockNumber = blockNumber2;
          }
        } catch (error2) {
          config2.blockNumber = -2;
          config2._lastFatalError = error2;
          config2._lastFatalErrorTimestamp = getTime3();
        }
        config2._updateNumber = null;
      })();
    }
    await config2._updateNumber;
    config2.outOfSync++;
    if (config2._lastFatalError) {
      break;
    }
  }
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(value) {
  if ("error" in value) {
    const error2 = value.error;
    return { tag: _normalize(error2), value: error2 };
  }
  const result2 = value.result;
  return { tag: _normalize(result2), value: result2 };
}
function checkQuorum(quorum, results) {
  const tally = /* @__PURE__ */ new Map();
  for (const { value, tag, weight } of results) {
    const t2 = tally.get(tag) || { value, weight: 0 };
    t2.weight += weight;
    tally.set(tag, t2);
  }
  let best = null;
  for (const r3 of tally.values()) {
    if (r3.weight >= quorum && (!best || r3.weight > best.weight)) {
      best = r3;
    }
  }
  if (best) {
    return best.value;
  }
  return void 0;
}
function getMedian(quorum, results) {
  let resultWeight = 0;
  const errorMap2 = /* @__PURE__ */ new Map();
  let bestError = null;
  const values = [];
  for (const { value, tag, weight } of results) {
    if (value instanceof Error) {
      const e3 = errorMap2.get(tag) || { value, weight: 0 };
      e3.weight += weight;
      errorMap2.set(tag, e3);
      if (bestError == null || e3.weight > bestError.weight) {
        bestError = e3;
      }
    } else {
      values.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return void 0;
  }
  values.sort((a2, b4) => a2 < b4 ? -1 : b4 > a2 ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_16) / BN_24;
}
function getAnyResult(quorum, results) {
  const result2 = checkQuorum(quorum, results);
  if (result2 !== void 0) {
    return result2;
  }
  for (const r3 of results) {
    if (r3.value) {
      return r3.value;
    }
  }
  return void 0;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  const tally = /* @__PURE__ */ new Map();
  const add3 = (result2, weight) => {
    const t2 = tally.get(result2) || { result: result2, weight: 0 };
    t2.weight += weight;
    tally.set(result2, t2);
  };
  for (const { weight, value } of results) {
    const r3 = getNumber(value);
    add3(r3 - 1, weight);
    add3(r3, weight);
    add3(r3 + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = void 0;
  for (const { weight, result: result2 } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result2 > bestResult)) {
      bestWeight = weight;
      bestResult = result2;
    }
  }
  return bestResult;
}
var FallbackProvider = class extends AbstractProvider {
  /**
   *  The number of backends that must agree on a value before it is
   *  accpeted.
   */
  quorum;
  /**
   *  @_ignore:
   */
  eventQuorum;
  /**
   *  @_ignore:
   */
  eventWorkers;
  #configs;
  #height;
  #initialSyncPromise;
  /**
   *  Creates a new **FallbackProvider** with %%providers%% connected to
   *  %%network%%.
   *
   *  If a [[Provider]] is included in %%providers%%, defaults are used
   *  for the configuration.
   */
  constructor(providers, network, options) {
    super(network, options);
    this.#configs = providers.map((p3) => {
      if (p3 instanceof AbstractProvider) {
        return Object.assign({ provider: p3 }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p3, defaultState);
      }
    });
    this.#height = -2;
    this.#initialSyncPromise = null;
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(this.#configs.reduce((accum, config2) => {
        accum += config2.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument(this.quorum <= this.#configs.reduce((a2, c2) => a2 + c2.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
  }
  get providerConfigs() {
    return this.#configs.map((c2) => {
      const result2 = Object.assign({}, c2);
      for (const key in result2) {
        if (key[0] === "_") {
          delete result2[key];
        }
      }
      return result2;
    });
  }
  async _detectNetwork() {
    return Network.from(getBigInt(await this._perform({ method: "chainId" })));
  }
  // @TODO: Add support to select providers to be the event subscriber
  //_getSubscriber(sub: Subscription): Subscriber {
  //    throw new Error("@TODO");
  //}
  /**
   *  Transforms a %%req%% into the correct method call on %%provider%%.
   */
  async _translatePerform(provider, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider.getNetwork()).chainId;
      case "estimateGas":
        return await provider.estimateGas(req.transaction);
      case "getBalance":
        return await provider.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider.getBlock(block, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider.getBlockNumber();
      case "getCode":
        return await provider.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider.getFeeData()).gasPrice;
      case "getPriorityFee":
        return (await provider.getFeeData()).maxPriorityFeePerGas;
      case "getLogs":
        return await provider.getLogs(req.filter);
      case "getStorage":
        return await provider.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider.getTransactionResult(req.hash);
    }
  }
  // Grab the next (random) config that is not already part of
  // the running set
  #getNextConfig(running) {
    const configs = Array.from(running).map((r3) => r3.config);
    const allConfigs = this.#configs.slice();
    shuffle(allConfigs);
    allConfigs.sort((a2, b4) => a2.priority - b4.priority);
    for (const config2 of allConfigs) {
      if (config2._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config2) === -1) {
        return config2;
      }
    }
    return null;
  }
  // Adds a new runner (if available) to running.
  #addRunner(running, req) {
    const config2 = this.#getNextConfig(running);
    if (config2 == null) {
      return null;
    }
    const runner = {
      config: config2,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    const now = getTime3();
    runner.perform = (async () => {
      try {
        config2.requests++;
        const result2 = await this._translatePerform(config2.provider, req);
        runner.result = { result: result2 };
      } catch (error2) {
        config2.errorResponses++;
        runner.result = { error: error2 };
      }
      const dt = getTime3() - now;
      config2._totalTime += dt;
      config2.rollingDuration = 0.95 * config2.rollingDuration + 0.05 * dt;
      runner.perform = null;
    })();
    runner.staller = (async () => {
      await stall2(config2.stallTimeout);
      runner.staller = null;
    })();
    running.add(runner);
    return runner;
  }
  // Initializes the blockNumber and network for each runner and
  // blocks until initialized
  async #initialSync() {
    let initialSync = this.#initialSyncPromise;
    if (!initialSync) {
      const promises2 = [];
      this.#configs.forEach((config2) => {
        promises2.push((async () => {
          await waitForSync(config2, 0);
          if (!config2._lastFatalError) {
            config2._network = await config2.provider.getNetwork();
          }
        })());
      });
      this.#initialSyncPromise = initialSync = (async () => {
        await Promise.all(promises2);
        let chainId = null;
        for (const config2 of this.#configs) {
          if (config2._lastFatalError) {
            continue;
          }
          const network = config2._network;
          if (chainId == null) {
            chainId = network.chainId;
          } else if (network.chainId !== chainId) {
            assert4(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
              operation: "new FallbackProvider"
            });
          }
        }
      })();
    }
    await initialSync;
  }
  async #checkQuorum(running, req) {
    const results = [];
    for (const runner of running) {
      if (runner.result != null) {
        const { tag, value } = normalizeResult(runner.result);
        results.push({ tag, value, weight: runner.config.weight });
      }
    }
    if (results.reduce((a2, r3) => a2 + r3.weight, 0) < this.quorum) {
      return void 0;
    }
    switch (req.method) {
      case "getBlockNumber": {
        if (this.#height === -2) {
          this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c2) => !c2._lastFatalError).map((c2) => ({
            value: c2.blockNumber,
            tag: getNumber(c2.blockNumber).toString(),
            weight: c2.weight
          })))));
        }
        const mode = getFuzzyMode(this.quorum, results);
        if (mode === void 0) {
          return void 0;
        }
        if (mode > this.#height) {
          this.#height = mode;
        }
        return this.#height;
      }
      case "getGasPrice":
      case "getPriorityFee":
      case "estimateGas":
        return getMedian(this.quorum, results);
      case "getBlock":
        if ("blockTag" in req && req.blockTag === "pending") {
          return getAnyResult(this.quorum, results);
        }
        return checkQuorum(this.quorum, results);
      case "call":
      case "chainId":
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorage":
      case "getTransaction":
      case "getTransactionReceipt":
      case "getLogs":
        return checkQuorum(this.quorum, results);
      case "broadcastTransaction":
        return getAnyResult(this.quorum, results);
    }
    assert4(false, "unsupported method", "UNSUPPORTED_OPERATION", {
      operation: `_perform(${stringify3(req.method)})`
    });
  }
  async #waitForQuorum(running, req) {
    if (running.size === 0) {
      throw new Error("no runners?!");
    }
    const interesting = [];
    let newRunners = 0;
    for (const runner of running) {
      if (runner.perform) {
        interesting.push(runner.perform);
      }
      if (runner.staller) {
        interesting.push(runner.staller);
        continue;
      }
      if (runner.didBump) {
        continue;
      }
      runner.didBump = true;
      newRunners++;
    }
    const value = await this.#checkQuorum(running, req);
    if (value !== void 0) {
      if (value instanceof Error) {
        throw value;
      }
      return value;
    }
    for (let i2 = 0; i2 < newRunners; i2++) {
      this.#addRunner(running, req);
    }
    assert4(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
      request: "%sub-requests",
      info: { request: req, results: Array.from(running).map((r3) => stringify3(r3.result)) }
    });
    await Promise.race(interesting);
    return await this.#waitForQuorum(running, req);
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results = this.#configs.map((c2) => null);
      const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {
        try {
          const result4 = await provider._perform(req);
          results[index] = Object.assign(normalizeResult({ result: result4 }), { weight });
        } catch (error2) {
          results[index] = Object.assign(normalizeResult({ error: error2 }), { weight });
        }
      });
      while (true) {
        const done = results.filter((r3) => r3 != null);
        for (const { value } of done) {
          if (!(value instanceof Error)) {
            return value;
          }
        }
        const result4 = checkQuorum(this.quorum, results.filter((r3) => r3 != null));
        if (isError3(result4, "INSUFFICIENT_FUNDS")) {
          throw result4;
        }
        const waiting = broadcasts.filter((b4, i2) => results[i2] == null);
        if (waiting.length === 0) {
          break;
        }
        await Promise.race(waiting);
      }
      const result3 = getAnyResult(this.quorum, results);
      assert4(result3 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results.map(stringify3) }
      });
      if (result3 instanceof Error) {
        throw result3;
      }
      return result3;
    }
    await this.#initialSync();
    const running = /* @__PURE__ */ new Set();
    let inflightQuorum = 0;
    while (true) {
      const runner = this.#addRunner(running, req);
      if (runner == null) {
        break;
      }
      inflightQuorum += runner.config.weight;
      if (inflightQuorum >= this.quorum) {
        break;
      }
    }
    const result2 = await this.#waitForQuorum(running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result2;
  }
  async destroy() {
    for (const { provider } of this.#configs) {
      provider.destroy();
    }
    super.destroy();
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/default-provider.js
function isWebSocketLike(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
function getDefaultProvider(network, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name) => {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network === "string" && network.match(/^https?:/)) {
    return new JsonRpcProvider(network);
  }
  if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
    return new WebSocketProvider(network);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network.from(network);
  } catch (error2) {
  }
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new JsonRpcProvider("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider(network, options.alchemy));
    } catch (error2) {
    }
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider(network, options.ankr));
    } catch (error2) {
    }
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new ChainstackProvider(network, options.chainstack));
    } catch (error2) {
    }
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider(network));
    } catch (error2) {
    }
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider(network, options.etherscan));
    } catch (error2) {
    }
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = void 0;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network, projectId, projectSecret));
    } catch (error2) {
    }
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider(network, token));
    } catch (error2) {
    }
  }
  assert4(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider(providers, void 0, { quorum });
}

// node_modules/azle/node_modules/ethers/lib.esm/providers/signer-noncemanager.js
var NonceManager = class _NonceManager extends AbstractSigner {
  /**
   *  The Signer being managed.
   */
  signer;
  #noncePromise;
  #delta;
  /**
   *  Creates a new **NonceManager** to manage %%signer%%.
   */
  constructor(signer) {
    super(signer.provider);
    defineProperties(this, { signer });
    this.#noncePromise = null;
    this.#delta = 0;
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider) {
    return new _NonceManager(this.signer.connect(provider));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (this.#noncePromise == null) {
        this.#noncePromise = super.getNonce("pending");
      }
      const delta = this.#delta;
      return await this.#noncePromise + delta;
    }
    return super.getNonce(blockTag);
  }
  /**
   *  Manually increment the nonce. This may be useful when managng
   *  offline transactions.
   */
  increment() {
    this.#delta++;
  }
  /**
   *  Resets the nonce, causing the **NonceManager** to reload the current
   *  nonce from the blockchain on the next transaction.
   */
  reset() {
    this.#delta = 0;
    this.#noncePromise = null;
  }
  async sendTransaction(tx) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx = await this.signer.populateTransaction(tx);
    tx.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx);
  }
  signTransaction(tx) {
    return this.signer.signTransaction(tx);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain3, types, value) {
    return this.signer.signTypedData(domain3, types, value);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-browser.js
var BrowserProvider = class extends JsonRpcApiPollingProvider {
  #request;
  /**
   *  Connect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network, _options) {
    const options = Object.assign({}, _options != null ? _options : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    this.#request = async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result2 = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result: result2 });
        return result2;
      } catch (e3) {
        const error2 = new Error(e3.message);
        error2.code = e3.code;
        error2.data = e3.data;
        error2.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error: error2 });
        throw error2;
      }
    };
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result2 = await this.#request(payload.method, payload.params || []);
      return [{ id: payload.id, result: result2 }];
    } catch (e3) {
      return [{
        id: payload.id,
        error: { code: e3.code, data: e3.data, message: e3.message }
      }];
    }
  }
  getRpcError(payload, error2) {
    error2 = JSON.parse(JSON.stringify(error2));
    switch (error2.error.code || -1) {
      case 4001:
        error2.error.message = `ethers-user-denied: ${error2.error.message}`;
        break;
      case 4200:
        error2.error.message = `ethers-unsupported: ${error2.error.message}`;
        break;
    }
    return super.getRpcError(payload, error2);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await this.#request("eth_requestAccounts", []);
      } catch (error2) {
        const payload = error2.payload;
        throw this.getRpcError(payload, { id: payload.id, error: error2 });
      }
    }
    return await super.getSigner(address);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-pocket.js
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost6(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var PocketProvider = class _PocketProvider extends JsonRpcProvider {
  /**
   *  The Application ID for the Pocket connection.
   */
  applicationId;
  /**
   *  The Application Secret for making authenticated requests
   *  to the Pocket connection.
   */
  applicationSecret;
  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network };
    const request = _PocketProvider.getRequest(network, applicationId, applicationSecret);
    super(request, network, options);
    defineProperties(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new _PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%applicationId%%.
   */
  static getRequest(network, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    const request = new FetchRequest(`https://${getHost6(network.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js
var IpcSocketProvider = void 0;

// node_modules/azle/node_modules/ethers/lib.esm/wallet/base-wallet.js
var BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  The wallet address.
   */
  address;
  #signingKey;
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return this.#signingKey;
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _BaseWallet(this.#signingKey, provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this.provider) : void 0,
      from: tx.from ? resolveAddress(tx.from, this.provider) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  async signTypedData(domain3, types, value) {
    const populated = await TypedDataEncoder.resolveNames(domain3, types, value, async (name) => {
      assert4(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert4(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/decode-owl.js
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;
function unfold(words3, sep2) {
  let initial = 97;
  return words3.reduce((accum, word) => {
    if (word === sep2) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode6(data, subs) {
  for (let i2 = subsChrs.length - 1; i2 >= 0; i2--) {
    data = data.split(subsChrs[i2]).join(subs.substring(2 * i2, 2 * i2 + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i2 = parseInt(semi); i2 >= 0; i2--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode6(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/wordlist.js
var Wordlist = class {
  locale;
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words3) {
    return words3.join(" ");
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
var WordlistOwl = class extends Wordlist {
  #data;
  #checksum;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum3) {
    super(locale);
    this.#data = data;
    this.#checksum = checksum3;
    this.#words = null;
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return this.#data;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words3 = this._decodeWords();
      const checksum3 = id(words3.join("\n") + "\n");
      if (checksum3 !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words3;
    }
    return this.#words;
  }
  getWord(index) {
    const words3 = this.#loadWords();
    assertArgument(index >= 0 && index < words3.length, `invalid word index: ${index}`, "index", index);
    return words3[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/lang-en.js
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist = null;
var LangEn = class _LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new _LangEn();
    }
    return wordlist;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist3) {
  assertNormalize("NFKD");
  if (wordlist3 == null) {
    wordlist3 = LangEn.wordlist();
  }
  const words3 = wordlist3.split(mnemonic);
  assertArgument(words3.length % 3 === 0 && words3.length >= 12 && words3.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words3.length / 8));
  let offset = 0;
  for (let i2 = 0; i2 < words3.length; i2++) {
    let index = wordlist3.getWordIndex(words3[i2].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i2}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words3.length / 3;
  const checksumBits = words3.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum3 = getBytes(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum3 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist3) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist3 == null) {
    wordlist3 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum3 = parseInt(sha2562(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum3 >> 8 - checksumBits;
  return wordlist3.join(indices.map((index) => wordlist3.getWord(index)));
}
var _guard5 = {};
var Mnemonic = class _Mnemonic {
  /**
   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
   *
   *  Use the [[wordlist]] ``split`` method to get the individual words.
   */
  phrase;
  /**
   *  The password used for this mnemonic. If no password is used this
   *  is the empty string (i.e. ``""``) as per the specification.
   */
  password;
  /**
   *  The wordlist for this mnemonic.
   */
  wordlist;
  /**
   *  The underlying entropy which the mnemonic encodes.
   */
  entropy;
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard5, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist3, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf22(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist3) {
    const entropy = mnemonicToEntropy(phrase, wordlist3);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist3);
    return new _Mnemonic(_guard5, entropy, phrase, password, wordlist3);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist3) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist3);
    return new _Mnemonic(_guard5, hexlify(entropy), phrase, password, wordlist3);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist3) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist3);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist3) {
    return mnemonicToEntropy(phrase, wordlist3);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist3) {
    try {
      mnemonicToEntropy(phrase, wordlist3);
      return true;
    } catch (error2) {
    }
    return false;
  }
};

// node_modules/azle/node_modules/aes-js/lib.esm/aes.js
var __classPrivateFieldGet = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
};
var _AES_key;
var _AES_Kd;
var _AES_Ke;
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes4) {
  const result2 = [];
  for (let i2 = 0; i2 < bytes4.length; i2 += 4) {
    result2.push(bytes4[i2] << 24 | bytes4[i2 + 1] << 16 | bytes4[i2 + 2] << 8 | bytes4[i2 + 3]);
  }
  return result2;
}
var AES = class _AES {
  get key() {
    return __classPrivateFieldGet(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof _AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet(this, _AES_Ke, [], "f");
    __classPrivateFieldSet(this, _AES_Kd, [], "f");
    for (let i2 = 0; i2 <= rounds; i2++) {
      __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i2 = 0; i2 < KC; i2++) {
      index = i2 >> 2;
      __classPrivateFieldGet(this, _AES_Ke, "f")[index][i2 % 4] = tk[i2];
      __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i2 % 4] = tk[i2];
    }
    let rconpointer = 0;
    let t2 = KC, tt;
    while (t2 < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i3 = 1; i3 < KC; i3++) {
          tk[i3] ^= tk[i3 - 1];
        }
      } else {
        for (let i3 = 1; i3 < KC / 2; i3++) {
          tk[i3] ^= tk[i3 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i3 = KC / 2 + 1; i3 < KC; i3++) {
          tk[i3] ^= tk[i3 - 1];
        }
      }
      let i2 = 0, r3, c2;
      while (i2 < KC && t2 < roundKeyCount) {
        r3 = t2 >> 2;
        c2 = t2 % 4;
        __classPrivateFieldGet(this, _AES_Ke, "f")[r3][c2] = tk[i2];
        __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r3][c2] = tk[i2++];
        t2++;
      }
    }
    for (let r3 = 1; r3 < rounds; r3++) {
      for (let c2 = 0; c2 < 4; c2++) {
        tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r3][c2];
        __classPrivateFieldGet(this, _AES_Kd, "f")[r3][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t2 = convertToInt32(plaintext);
    for (let i2 = 0; i2 < 4; i2++) {
      t2[i2] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i2];
    }
    for (let r3 = 1; r3 < rounds; r3++) {
      for (let i2 = 0; i2 < 4; i2++) {
        a2[i2] = T12[t2[i2] >> 24 & 255] ^ T2[t2[(i2 + 1) % 4] >> 16 & 255] ^ T3[t2[(i2 + 2) % 4] >> 8 & 255] ^ T4[t2[(i2 + 3) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r3][i2];
      }
      t2 = a2.slice();
    }
    const result2 = new Uint8Array(16);
    let tt = 0;
    for (let i2 = 0; i2 < 4; i2++) {
      tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i2];
      result2[4 * i2] = (S[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
      result2[4 * i2 + 1] = (S[t2[(i2 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result2[4 * i2 + 2] = (S[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result2[4 * i2 + 3] = (S[t2[(i2 + 3) % 4] & 255] ^ tt) & 255;
    }
    return result2;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t2 = convertToInt32(ciphertext);
    for (let i2 = 0; i2 < 4; i2++) {
      t2[i2] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i2];
    }
    for (let r3 = 1; r3 < rounds; r3++) {
      for (let i2 = 0; i2 < 4; i2++) {
        a2[i2] = T5[t2[i2] >> 24 & 255] ^ T6[t2[(i2 + 3) % 4] >> 16 & 255] ^ T7[t2[(i2 + 2) % 4] >> 8 & 255] ^ T8[t2[(i2 + 1) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r3][i2];
      }
      t2 = a2.slice();
    }
    const result2 = new Uint8Array(16);
    let tt = 0;
    for (let i2 = 0; i2 < 4; i2++) {
      tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i2];
      result2[4 * i2] = (Si[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
      result2[4 * i2 + 1] = (Si[t2[(i2 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result2[4 * i2 + 2] = (Si[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result2[4 * i2 + 3] = (Si[t2[(i2 + 1) % 4] & 255] ^ tt) & 255;
    }
    return result2;
  }
};
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();

// node_modules/azle/node_modules/aes-js/lib.esm/mode.js
var ModeOfOperation = class {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
};

// node_modules/azle/node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CBC_iv;
var _CBC_lastBlock;
var CBC = class _CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, _CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet2(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet2(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i2 = 0; i2 < plaintext.length; i2 += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] ^= plaintext[i2 + j];
      }
      __classPrivateFieldSet2(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet2(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet2(this, _CBC_lastBlock, "f"), i2);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i2 = 0; i2 < ciphertext.length; i2 += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i2, i2 + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i2 + j] = block[j] ^ __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] = ciphertext[i2 + j];
      }
    }
    return plaintext;
  }
};
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();

// node_modules/azle/node_modules/aes-js/lib.esm/mode-cfb.js
var __classPrivateFieldGet3 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CFB_instances;
var _CFB_iv;
var _CFB_shiftRegister;
var _CFB_shift;
_CFB_iv = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister = /* @__PURE__ */ new WeakMap(), _CFB_instances = /* @__PURE__ */ new WeakSet(), _CFB_shift = function _CFB_shift2(data) {
  const segmentSize = this.segmentSize / 8;
  __classPrivateFieldGet3(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet3(this, _CFB_shiftRegister, "f").subarray(segmentSize));
  __classPrivateFieldGet3(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
};

// node_modules/azle/node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CTR_remaining;
var _CTR_remainingIndex;
var _CTR_counter;
var CTR = class _CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, _CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet3(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet4(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet3(this, _CTR_remaining, __classPrivateFieldGet4(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet3(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet4(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet4(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet4(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i2 = 15; i2 >= 0; i2--) {
      if (__classPrivateFieldGet4(this, _CTR_counter, "f")[i2] === 255) {
        __classPrivateFieldGet4(this, _CTR_counter, "f")[i2] = 0;
      } else {
        __classPrivateFieldGet4(this, _CTR_counter, "f")[i2]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i2 = 0; i2 < crypttext.length; i2++) {
      if (__classPrivateFieldGet4(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet3(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet4(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet3(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i2] ^= __classPrivateFieldGet4(this, _CTR_remaining, "f")[__classPrivateFieldSet3(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet4(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
};
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();

// node_modules/azle/node_modules/aes-js/lib.esm/mode-ofb.js
var _OFB_iv;
var _OFB_lastPrecipher;
var _OFB_lastPrecipherIndex;
_OFB_iv = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex = /* @__PURE__ */ new WeakMap();

// node_modules/azle/node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i2 = 0; i2 < padder; i2++) {
    if (data[length + i2] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}

// node_modules/azle/node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object3, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path2 = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object3;
  for (const comp of path2.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path2);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path2);
  }
  return cur;
}

// node_modules/azle/node_modules/ethers/lib.esm/wallet/json-keystore.js
var defaultPath = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data = JSON.parse(json);
    const version4 = data.version != null ? parseInt(data.version) : 0;
    if (version4 === 3) {
      return true;
    }
  } catch (error2) {
  }
  return false;
}
function decrypt(data, key, ciphertext) {
  const cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert4(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat2([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account = { address, privateKey };
  const version4 = spelunk(data, "x-ethers.version:string");
  if (version4 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  const kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const N5 = spelunk(data, "crypto.kdfparams.n:int!");
      const r3 = spelunk(data, "crypto.kdfparams.r:int!");
      const p3 = spelunk(data, "crypto.kdfparams.p:int!");
      assertArgument(N5 > 0 && (N5 & N5 - 1) === 0, "invalid kdf.N", "kdf.N", N5);
      assertArgument(r3 > 0 && p3 > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N5, r: r3, p: p3, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf22(password, salt2, count, dkLen2, algorithm);
    return getAccount(data, key2);
  }
  assert4(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N5, r: r3, p: p3, dkLen } = params;
  const key = scryptSync(password, salt, N5, r3, p3, dkLen);
  return getAccount(data, key);
}
function stall3(duration) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall3(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf22(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall3(0);
    }
    return getAccount(data, key2);
  }
  assert4(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N5, r: r3, p: p3, dkLen } = params;
  const key = await scrypt2(password, salt, N5, r3, p3, dkLen, progress);
  return getAccount(data, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes3(32);
  let N5 = 1 << 17, r3 = 8, p3 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N5 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r3 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p3 = options.scrypt.p;
    }
  }
  assertArgument(typeof N5 === "number" && N5 > 0 && Number.isSafeInteger(N5) && (BigInt(N5) & BigInt(N5 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N5);
  assertArgument(typeof r3 === "number" && r3 > 0 && Number.isSafeInteger(r3), "invalid scrypt r parameter", "options.r", r3);
  assertArgument(typeof p3 === "number" && p3 > 0 && Number.isSafeInteger(p3), "invalid scrypt p parameter", "options.p", p3);
  return { name: "scrypt", dkLen: 32, salt, N: N5, r: r3, p: p3 };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes3(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes3(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat2([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version2}`;
    const path2 = account.mnemonic.path || defaultPath;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes3(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp2 = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp2 + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path: path2,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}

// node_modules/azle/node_modules/ethers/lib.esm/wallet/hdwallet.js
var defaultPath2 = "m/44'/60'/0'/0/0";
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 2147483648;
var N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles2 = "0123456789abcdef";
function zpad2(value, length) {
  let result2 = "";
  while (value) {
    result2 = Nibbles2[value % 16] + result2;
    value = Math.trunc(value / 16);
  }
  while (result2.length < length * 2) {
    result2 = "0" + result2;
  }
  return "0x" + result2;
}
function encodeBase58Check(_value) {
  const value = getBytes(_value);
  const check = dataSlice(sha2562(sha2562(value)), 0, 4);
  const bytes4 = concat2([value, check]);
  return encodeBase58(bytes4);
}
var _guard6 = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert4(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i2 = 24; i2 >= 0; i2 -= 8) {
    data[33 + (i2 >> 3)] = index >> 24 - i2 & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path2) {
  const components = path2.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path2);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path2);
    components.shift();
  }
  let result2 = node;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i2}]`, component);
      result2 = result2.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i2}]`, component);
      result2 = result2.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i2}]`, component);
    }
  }
  return result2;
}
var HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent fingerprint.
   */
  parentFingerprint;
  /**
   *  The mnemonic used to create this HD Node, if available.
   *
   *  Sources such as extended keys do not encode the mnemonic, in
   *  which case this will be ``null``.
   */
  mnemonic;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provide full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  encode it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path2, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    assertPrivate(guard, _guard6, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path: path2,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new _HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m2 = this.mnemonic;
    if (this.path && m2 && m2.wordlist.locale === "en" && m2.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m2.entropy
      };
    }
    return account;
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert4(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat2([
      "0x0488ADE4",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      concat2(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt2(IL) + BigInt(this.privateKey)) % N2, 32));
    return new _HDNodeWallet(_guard6, ki, this.fingerprint, hexlify(IR), path2, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path2) {
    return derivePath(this, path2);
  }
  static #fromSeed(_seed, mnemonic) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new _HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes4 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes4.length === 82 || encodeBase58Check(bytes4.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes4[4];
    const parentFingerprint = hexlify(bytes4.slice(5, 9));
    const index = parseInt(hexlify(bytes4.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes4.slice(13, 45));
    const key = bytes4.slice(45, 78);
    switch (hexlify(bytes4.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard6, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard6, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path2, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath2;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes3(16), password, wordlist3);
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path2) {
    if (!path2) {
      path2 = defaultPath2;
    }
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path2, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath2;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist3);
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    return _HDNodeWallet.#fromSeed(seed, null);
  }
};
var HDNodeVoidWallet = class _HDNodeVoidWallet extends VoidSigner {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent node fingerprint.
   */
  parentFingerprint;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path2, index, depth, provider) {
    super(address, provider);
    assertPrivate(guard, _guard6, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path: path2,
      index,
      depth
    });
  }
  connect(provider) {
    return new _HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert4(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat2([
      "0x0488B21E",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new _HDNodeVoidWallet(_guard6, address, Ki, this.fingerprint, hexlify(IR), path2, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path2) {
    return derivePath(this, path2);
  }
};
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}

// node_modules/azle/node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error2) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf22(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i2 = 0; i2 < seed.length; i2++) {
    seedHex += String.fromCharCode(seed[i2]);
  }
  return { address, privateKey: id(seedHex) };
}

// node_modules/azle/node_modules/ethers/lib.esm/wallet/wallet.js
function stall4(duration) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3();
    }, duration);
  });
}
var Wallet = class _Wallet extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new _Wallet(this.signingKey, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  static #fromAccount(account) {
    assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new _Wallet(account.privateKey);
    assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall4(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall4(0);
      }
    }
    return _Wallet.#fromAccount(account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return _Wallet.#fromAccount(account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider) {
    const wallet = HDNodeWallet.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/bit-reader.js
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
function decodeBits(width, data) {
  const maxValue3 = (1 << width) - 1;
  const result2 = [];
  let accum = 0, bits = 0, flood = 0;
  for (let i2 = 0; i2 < data.length; i2++) {
    accum = accum << 6 | Base64.indexOf(data[i2]);
    bits += 6;
    while (bits >= width) {
      const value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      if (value === 0) {
        flood += maxValue3;
      } else {
        result2.push(value + flood);
        flood = 0;
      }
    }
  }
  return result2;
}

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA(data, accents) {
  let words3 = decodeOwl(data).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words3 = words3.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words3.split(",");
}

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
var WordlistOwlA = class extends WordlistOwl {
  #accent;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
   *  and %%accent%% data and validated against the %%checksum%%.
   */
  constructor(locale, data, accent, checksum3) {
    super(locale, data, checksum3);
    this.#accent = accent;
  }
  /**
   *  The OWLA-encoded accent data.
   */
  get _accent() {
    return this.#accent;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwlA(this._data, this._accent);
  }
};

// node_modules/azle/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js
var wordlists = {
  en: LangEn.wordlist()
};

// node_modules/azle/src/experimental/lib/threshold_wallet/calculate_rsv_for_tecdsa.ts
function calculateRsvForTEcdsa(chainId, address, digest, signature) {
  const r3 = ethers_exports.hexlify(signature.slice(0, 32));
  const s = ethers_exports.hexlify(signature.slice(32, 64));
  const vPartial = chainId * 2 + 35;
  const v0 = vPartial;
  const v1 = vPartial + 1;
  const rsv0 = {
    r: r3,
    s,
    v: v0
  };
  if (address.toLowerCase() === ethers_exports.recoverAddress(digest, rsv0).toLowerCase()) {
    return rsv0;
  }
  const rsv1 = {
    r: r3,
    s,
    v: v1
  };
  if (address.toLowerCase() === ethers_exports.recoverAddress(digest, rsv1).toLowerCase()) {
    return rsv1;
  }
  throw new Error(`ThresholdWallet: v could not be calculated correctly`);
}

// node_modules/azle/src/experimental/lib/threshold_wallet/ecdsa_public_key.ts
async function ecdsaPublicKey(thresholdKeyInfo) {
  const response = await fetch("icp://aaaaa-aa/ecdsa_public_key", {
    body: serialize({
      args: [
        {
          derivation_path: thresholdKeyInfo.derivationPath,
          canister_id: thresholdKeyInfo.canisterId === void 0 ? [] : [Principal.from(thresholdKeyInfo.canisterId)],
          key_id: {
            curve: {
              [thresholdKeyInfo.keyId?.curve ?? "secp256k1"]: null
            },
            name: thresholdKeyInfo.keyId?.name ?? "dfx_test_key"
          }
        }
      ]
    })
  });
  const responseJson = await response.json();
  return responseJson.public_key;
}

// node_modules/azle/src/experimental/lib/threshold_wallet/register_get_url.ts
async function ethersGetUrl(fetchRequest) {
  const response = await fetch(fetchRequest.url, {
    method: fetchRequest.method,
    headers: fetchRequest.headers,
    body: fetchRequest.body
  });
  const fetchResponse = new ethers_exports.FetchResponse(
    response.status,
    response.statusText,
    Array.from(response.headers.entries()).reduce((acc, [key, value]) => {
      return {
        ...acc,
        [key]: value
      };
    }, {}),
    new Uint8Array(await response.arrayBuffer()),
    fetchRequest
  );
  return fetchResponse;
}

// node_modules/azle/src/experimental/lib/threshold_wallet/sign_with_ecdsa.ts
async function signWithEcdsa(thresholdKeyInfo, messageHash) {
  const publicKeyResponse = await fetch(`icp://aaaaa-aa/sign_with_ecdsa`, {
    body: serialize({
      args: [
        {
          message_hash: messageHash,
          derivation_path: thresholdKeyInfo.derivationPath,
          key_id: {
            curve: {
              [thresholdKeyInfo.keyId?.curve ?? "secp256k1"]: null
            },
            name: thresholdKeyInfo.keyId?.name ?? "dfx_test_key"
          }
        }
      ]
    })
  });
  return (await publicKeyResponse.json()).signature;
}

// node_modules/azle/src/experimental/lib/threshold_wallet/wallet.ts
var ThresholdWallet = class _ThresholdWallet extends ethers_exports.AbstractSigner {
  thresholdKeyInfo;
  address = null;
  constructor(thresholdKeyInfo, provider = null) {
    super(provider);
    this.thresholdKeyInfo = thresholdKeyInfo;
  }
  connect(provider) {
    return new _ThresholdWallet(this.thresholdKeyInfo, provider);
  }
  async getAddress() {
    if (this.address === null) {
      this.address = ethers_exports.computeAddress(
        ethers_exports.hexlify(await ecdsaPublicKey(this.thresholdKeyInfo))
      );
    }
    return this.address;
  }
  async signTransaction(txRequest) {
    let tx = ethers_exports.Transaction.from(txRequest);
    const unsignedSerializedTx = tx.unsignedSerialized;
    const unsignedSerializedTxHash = ethers_exports.keccak256(unsignedSerializedTx);
    const signedSerializedTxHash = await signWithEcdsa(
      this.thresholdKeyInfo,
      ethers_exports.getBytes(unsignedSerializedTxHash)
    );
    if (this.provider === null) {
      throw new Error(`ThresholdWallet: provider must not be null`);
    }
    const network = await this.provider.getNetwork();
    const chainId = Number(network.chainId);
    const { r: r3, s, v: v2 } = calculateRsvForTEcdsa(
      chainId,
      await this.getAddress(),
      unsignedSerializedTxHash,
      signedSerializedTxHash
    );
    tx.signature = {
      r: r3,
      s,
      v: v2
    };
    const rawTransaction = tx.serialized;
    return rawTransaction;
  }
  // TODO implement?
  async signMessage(_message) {
    throw new Error(`ThresholdWallet: signMessage is not implemented`);
  }
  // TODO implement?
  async signTypedData(_domain, _types, _value) {
    throw new Error(`ThresholdWallet: signTypedData is not implemented`);
  }
};

// node_modules/azle/src/experimental/test/type/assert_type.ts
function testCandidType(_value) {
}
function testSerializable(_value) {
}

// node_modules/azle/src/experimental/test/type/candid/constructed/blob.ts
testCandidType(blob);
testSerializable(blob);

// node_modules/azle/src/experimental/test/type/candid/constructed/opt.ts
testCandidType(Opt2(float32));
testSerializable(Opt2(float32));
var _testTypeMapping = Opt2(float32);
testCandidType(Opt2(Opt2(float32)));
testSerializable(Opt2(Opt2(float32)));
var _testTypeMappingDouble = Opt2(Opt2(float32));
testCandidType(Opt2(Opt2(Opt2(float32))));
testSerializable(Opt2(Opt2(Opt2(float32))));
var _testTypeMappingTriple = Opt2(Opt2(Opt2(float32)));
var OptRecord = Record2({
  id: text,
  username: text
});
Opt2(float32);
Opt2(int16);
Opt2(OptRecord);
Opt2({});
Opt2(5);
Opt2("not CandidType");
Opt2(null);
Opt2(void 0);
Opt2(Symbol("not CandidType"));

// node_modules/azle/src/experimental/test/type/candid/constructed/record.ts
var ExampleRecord = Record2({
  bool,
  float32,
  float64,
  int,
  int8,
  int16,
  int32,
  int64,
  nat,
  nat8,
  nat16,
  nat32,
  nat64,
  null: Null2,
  reserved,
  text,
  void: Void
});
testCandidType(ExampleRecord);
testSerializable(ExampleRecord);
var TestExampleRecord = ExampleRecord.tsType;

// node_modules/azle/src/experimental/test/type/candid/constructed/tuple.ts
var ExampleTuple = Tuple2(
  bool,
  float32,
  float64,
  int,
  int8,
  int16,
  int32,
  int64,
  nat,
  nat8,
  nat16,
  nat32,
  nat64,
  Null2,
  reserved,
  text,
  Void
);
testCandidType(ExampleTuple);
testSerializable(ExampleTuple);
var TestExampleTuple = ExampleTuple.tsType;
var TupleRecord = Record2({
  id: text,
  username: text
});
Tuple2(float32);
Tuple2(int16);
Tuple2(TupleRecord);
Tuple2({});
Tuple2(5);
Tuple2("not CandidType");
Tuple2(null);
Tuple2(void 0);
Tuple2(Symbol("not CandidType"));

// node_modules/azle/src/experimental/test/type/candid/constructed/variant.ts
var ExampleVariant = Variant2({
  bool: Null2,
  float32,
  float64,
  int: Null2,
  int8,
  int16,
  int32,
  int64: Null2,
  nat,
  nat8,
  nat16,
  nat32: Null2,
  nat64,
  null: Null2,
  reserved,
  text,
  void: Null2
});
testCandidType(ExampleVariant);
testSerializable(ExampleVariant);
var TestExampleVariant = ExampleVariant.tsType;

// node_modules/azle/src/experimental/test/type/candid/constructed/vec.ts
testCandidType(Vec2(float32));
testSerializable(Vec2(float32));
var _testTypeMapping2 = Vec2(float32);
testCandidType(Vec2(Vec2(float32)));
testSerializable(Vec2(Vec2(float32)));
var _testTypeMappingDouble2 = Vec2(Vec2(float32));
testCandidType(Vec2(Vec2(Vec2(float32))));
testSerializable(Vec2(Vec2(Vec2(float32))));
var _testTypeMappingTriple2 = Vec2(Vec2(Vec2(float32)));
testCandidType(Vec2(nat64));
testSerializable(Vec2(nat64));
var _testTypeMappingNat64 = Vec2(nat64);
testCandidType(Vec2(nat32));
testSerializable(Vec2(nat32));
var _testTypeMappingNat32 = Vec2(nat32);
testCandidType(Vec2(nat16));
testSerializable(Vec2(nat16));
var _testTypeMappingNat16 = Vec2(nat16);
testCandidType(Vec2(nat8));
testSerializable(Vec2(nat8));
var _testTypeMappingNat8 = Vec2(nat8);
testCandidType(Vec2(int64));
testSerializable(Vec2(int64));
var _testTypeMappingInt64 = Vec2(int64);
testCandidType(Vec2(int32));
testSerializable(Vec2(int32));
var _testTypeMappingInt32 = Vec2(int32);
testCandidType(Vec2(int16));
testSerializable(Vec2(int16));
var _testTypeMappingInt16 = Vec2(int16);
testCandidType(Vec2(int8));
testSerializable(Vec2(int8));
var _testTypeMappingInt8 = Vec2(int8);
var VecRecord = Record2({
  id: text,
  username: text
});
Vec2(float32);
Vec2(int16);
Vec2(VecRecord);
Vec2({});
Vec2(5);
Vec2("not CandidType");
Vec2(null);
Vec2(void 0);
Vec2(Symbol("not CandidType"));

// node_modules/azle/src/experimental/test/type/candid/manual.ts
testCandidType(Manual(text));
var _testTypeMapping3 = Manual(text);

// node_modules/azle/src/experimental/test/type/candid/primitive/bool.ts
testCandidType(bool);
testSerializable(bool);

// node_modules/azle/src/experimental/test/type/candid/primitive/empty.ts
testCandidType(empty);

// node_modules/azle/src/experimental/test/type/candid/primitive/floats/float32.ts
testCandidType(float32);
testSerializable(float32);

// node_modules/azle/src/experimental/test/type/candid/primitive/floats/float64.ts
testCandidType(float64);
testSerializable(float64);

// node_modules/azle/src/experimental/test/type/candid/primitive/ints/int.ts
testCandidType(int);
testSerializable(int);

// node_modules/azle/src/experimental/test/type/candid/primitive/ints/int8.ts
testCandidType(int8);
testSerializable(int8);

// node_modules/azle/src/experimental/test/type/candid/primitive/ints/int16.ts
testCandidType(int16);
testSerializable(int16);

// node_modules/azle/src/experimental/test/type/candid/primitive/ints/int32.ts
testCandidType(int32);
testSerializable(int32);

// node_modules/azle/src/experimental/test/type/candid/primitive/ints/int64.ts
testCandidType(int64);
testSerializable(int64);

// node_modules/azle/src/experimental/test/type/candid/primitive/nats/nat.ts
testCandidType(nat);
testSerializable(nat);

// node_modules/azle/src/experimental/test/type/candid/primitive/nats/nat8.ts
testCandidType(nat8);
testSerializable(nat8);

// node_modules/azle/src/experimental/test/type/candid/primitive/nats/nat16.ts
testCandidType(nat16);
testSerializable(nat16);

// node_modules/azle/src/experimental/test/type/candid/primitive/nats/nat32.ts
testCandidType(nat32);
testSerializable(nat32);

// node_modules/azle/src/experimental/test/type/candid/primitive/nats/nat64.ts
testCandidType(nat64);
testSerializable(nat64);

// node_modules/azle/src/experimental/test/type/candid/primitive/null.ts
testCandidType(Null2);
testSerializable(Null2);

// node_modules/azle/src/experimental/test/type/candid/primitive/reserved.ts
testCandidType(reserved);
testSerializable(reserved);

// node_modules/azle/src/experimental/test/type/candid/primitive/text.ts
testCandidType(text);
testSerializable(text);

// node_modules/azle/src/experimental/test/type/candid/primitive/void.ts
testCandidType(Void);
testSerializable(Void);

// node_modules/azle/src/experimental/test/type/candid/reference/func.ts
var TestFunc = Func2([], Void, "query");
testCandidType(TestFunc);
testSerializable(TestFunc);

// node_modules/azle/src/experimental/test/type/candid/reference/principal.ts
testCandidType(Principal3);
testSerializable(Principal3);

// node_modules/azle/src/experimental/test/type/candid/reference/service.ts
var TestCanister = Canister({});
testCandidType(TestCanister);

// node_modules/azle/src/experimental/test/type/canister_methods/init.ts
var User = Record2({
  id: text
});
var Reaction = Variant2({
  Happy: Null2,
  Sad: Null2
});
init2(
  [bool, nat, text, User, Reaction],
  (param0, param1, param2, param3, _param4) => {
  }
);

// node_modules/azle/src/experimental/test/type/canister_methods/post_upgrade.ts
var User2 = Record2({
  id: text
});
var Reaction2 = Variant2({
  Happy: Null2,
  Sad: Null2
});
postUpgrade(
  [bool, nat, text, User2, Reaction2],
  (param0, param1, param2, param3, _param4) => {
  }
);

// node_modules/azle/src/experimental/test/type/canister_methods/query.ts
var User3 = Record2({
  id: text
});
var Reaction3 = Variant2({
  Happy: Null2,
  Sad: Null2
});
query(
  [bool, nat, text, User3, Reaction3],
  text,
  (param0, param1, param2, param3, _param4) => {
    return param2;
  },
  void 0
);

// node_modules/azle/src/experimental/test/type/canister_methods/update.ts
var User4 = Record2({
  id: text
});
var Reaction4 = Variant2({
  Happy: Null2,
  Sad: Null2
});
update(
  [bool, nat, text, User4, Reaction4],
  text,
  (param0, param1, param2, param3, _param4) => {
    return param2;
  },
  void 0
);

// node_modules/azle/src/experimental/test/type/stable_structures/stable_b_tree_map.ts
var _mapText = StableBTreeMap(0);

// ../../../../../node_modules/ethers/lib.esm/ethers.js
var ethers_exports2 = {};
__export(ethers_exports2, {
  AbiCoder: () => AbiCoder2,
  AbstractProvider: () => AbstractProvider2,
  AbstractSigner: () => AbstractSigner2,
  AlchemyProvider: () => AlchemyProvider2,
  AnkrProvider: () => AnkrProvider2,
  BaseContract: () => BaseContract2,
  BaseWallet: () => BaseWallet2,
  Block: () => Block2,
  BlockscoutProvider: () => BlockscoutProvider,
  BrowserProvider: () => BrowserProvider2,
  ChainstackProvider: () => ChainstackProvider2,
  CloudflareProvider: () => CloudflareProvider2,
  ConstructorFragment: () => ConstructorFragment2,
  Contract: () => Contract2,
  ContractEventPayload: () => ContractEventPayload2,
  ContractFactory: () => ContractFactory2,
  ContractTransactionReceipt: () => ContractTransactionReceipt2,
  ContractTransactionResponse: () => ContractTransactionResponse2,
  ContractUnknownEventPayload: () => ContractUnknownEventPayload2,
  EnsPlugin: () => EnsPlugin2,
  EnsResolver: () => EnsResolver2,
  ErrorDescription: () => ErrorDescription2,
  ErrorFragment: () => ErrorFragment2,
  EtherSymbol: () => EtherSymbol2,
  EtherscanPlugin: () => EtherscanPlugin2,
  EtherscanProvider: () => EtherscanProvider2,
  EventFragment: () => EventFragment2,
  EventLog: () => EventLog2,
  EventPayload: () => EventPayload2,
  FallbackFragment: () => FallbackFragment2,
  FallbackProvider: () => FallbackProvider2,
  FeeData: () => FeeData2,
  FeeDataNetworkPlugin: () => FeeDataNetworkPlugin2,
  FetchCancelSignal: () => FetchCancelSignal2,
  FetchRequest: () => FetchRequest2,
  FetchResponse: () => FetchResponse2,
  FetchUrlFeeDataNetworkPlugin: () => FetchUrlFeeDataNetworkPlugin2,
  FixedNumber: () => FixedNumber2,
  Fragment: () => Fragment2,
  FunctionFragment: () => FunctionFragment2,
  GasCostPlugin: () => GasCostPlugin2,
  HDNodeVoidWallet: () => HDNodeVoidWallet2,
  HDNodeWallet: () => HDNodeWallet2,
  Indexed: () => Indexed2,
  InfuraProvider: () => InfuraProvider2,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider2,
  Interface: () => Interface2,
  IpcSocketProvider: () => IpcSocketProvider2,
  JsonRpcApiProvider: () => JsonRpcApiProvider2,
  JsonRpcProvider: () => JsonRpcProvider2,
  JsonRpcSigner: () => JsonRpcSigner2,
  LangEn: () => LangEn2,
  Log: () => Log2,
  LogDescription: () => LogDescription2,
  MaxInt256: () => MaxInt2562,
  MaxUint256: () => MaxUint2562,
  MessagePrefix: () => MessagePrefix2,
  MinInt256: () => MinInt2562,
  Mnemonic: () => Mnemonic2,
  MulticoinProviderPlugin: () => MulticoinProviderPlugin2,
  N: () => N3,
  NamedFragment: () => NamedFragment2,
  Network: () => Network2,
  NetworkPlugin: () => NetworkPlugin2,
  NonceManager: () => NonceManager2,
  ParamType: () => ParamType2,
  PocketProvider: () => PocketProvider2,
  QuickNodeProvider: () => QuickNodeProvider2,
  Result: () => Result3,
  Signature: () => Signature2,
  SigningKey: () => SigningKey2,
  SocketBlockSubscriber: () => SocketBlockSubscriber2,
  SocketEventSubscriber: () => SocketEventSubscriber2,
  SocketPendingSubscriber: () => SocketPendingSubscriber2,
  SocketProvider: () => SocketProvider2,
  SocketSubscriber: () => SocketSubscriber2,
  StructFragment: () => StructFragment2,
  Transaction: () => Transaction2,
  TransactionDescription: () => TransactionDescription2,
  TransactionReceipt: () => TransactionReceipt2,
  TransactionResponse: () => TransactionResponse2,
  Typed: () => Typed2,
  TypedDataEncoder: () => TypedDataEncoder2,
  UndecodedEventLog: () => UndecodedEventLog2,
  UnmanagedSubscriber: () => UnmanagedSubscriber2,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs2,
  VoidSigner: () => VoidSigner2,
  Wallet: () => Wallet2,
  WebSocketProvider: () => WebSocketProvider2,
  WeiPerEther: () => WeiPerEther2,
  Wordlist: () => Wordlist2,
  WordlistOwl: () => WordlistOwl2,
  WordlistOwlA: () => WordlistOwlA2,
  ZeroAddress: () => ZeroAddress2,
  ZeroHash: () => ZeroHash2,
  accessListify: () => accessListify2,
  assert: () => assert5,
  assertArgument: () => assertArgument2,
  assertArgumentCount: () => assertArgumentCount2,
  assertNormalize: () => assertNormalize2,
  assertPrivate: () => assertPrivate2,
  authorizationify: () => authorizationify,
  checkResultErrors: () => checkResultErrors2,
  computeAddress: () => computeAddress2,
  computeHmac: () => computeHmac2,
  concat: () => concat3,
  copyRequest: () => copyRequest2,
  dataLength: () => dataLength2,
  dataSlice: () => dataSlice2,
  decodeBase58: () => decodeBase582,
  decodeBase64: () => decodeBase642,
  decodeBytes32String: () => decodeBytes32String2,
  decodeRlp: () => decodeRlp2,
  decryptCrowdsaleJson: () => decryptCrowdsaleJson2,
  decryptKeystoreJson: () => decryptKeystoreJson2,
  decryptKeystoreJsonSync: () => decryptKeystoreJsonSync2,
  defaultPath: () => defaultPath4,
  defineProperties: () => defineProperties2,
  dnsEncode: () => dnsEncode2,
  encodeBase58: () => encodeBase582,
  encodeBase64: () => encodeBase642,
  encodeBytes32String: () => encodeBytes32String2,
  encodeRlp: () => encodeRlp2,
  encryptKeystoreJson: () => encryptKeystoreJson2,
  encryptKeystoreJsonSync: () => encryptKeystoreJsonSync2,
  ensNormalize: () => ensNormalize2,
  formatEther: () => formatEther2,
  formatUnits: () => formatUnits2,
  fromTwos: () => fromTwos2,
  getAccountPath: () => getAccountPath2,
  getAddress: () => getAddress2,
  getBigInt: () => getBigInt2,
  getBytes: () => getBytes2,
  getBytesCopy: () => getBytesCopy2,
  getCreate2Address: () => getCreate2Address2,
  getCreateAddress: () => getCreateAddress2,
  getDefaultProvider: () => getDefaultProvider2,
  getIcapAddress: () => getIcapAddress2,
  getIndexedAccountPath: () => getIndexedAccountPath2,
  getNumber: () => getNumber2,
  getUint: () => getUint2,
  hashAuthorization: () => hashAuthorization,
  hashMessage: () => hashMessage2,
  hexlify: () => hexlify2,
  id: () => id2,
  isAddress: () => isAddress2,
  isAddressable: () => isAddressable2,
  isBytesLike: () => isBytesLike2,
  isCallException: () => isCallException2,
  isCrowdsaleJson: () => isCrowdsaleJson2,
  isError: () => isError4,
  isHexString: () => isHexString2,
  isKeystoreJson: () => isKeystoreJson2,
  isValidName: () => isValidName2,
  keccak256: () => keccak2562,
  lock: () => lock2,
  makeError: () => makeError2,
  mask: () => mask2,
  namehash: () => namehash2,
  parseEther: () => parseEther2,
  parseUnits: () => parseUnits3,
  pbkdf2: () => pbkdf24,
  randomBytes: () => randomBytes6,
  recoverAddress: () => recoverAddress2,
  resolveAddress: () => resolveAddress2,
  resolveProperties: () => resolveProperties2,
  ripemd160: () => ripemd1604,
  scrypt: () => scrypt4,
  scryptSync: () => scryptSync2,
  sha256: () => sha2564,
  sha512: () => sha5124,
  showThrottleMessage: () => showThrottleMessage2,
  solidityPacked: () => solidityPacked2,
  solidityPackedKeccak256: () => solidityPackedKeccak2562,
  solidityPackedSha256: () => solidityPackedSha2562,
  stripZerosLeft: () => stripZerosLeft2,
  toBeArray: () => toBeArray2,
  toBeHex: () => toBeHex2,
  toBigInt: () => toBigInt3,
  toNumber: () => toNumber2,
  toQuantity: () => toQuantity2,
  toTwos: () => toTwos2,
  toUtf8Bytes: () => toUtf8Bytes2,
  toUtf8CodePoints: () => toUtf8CodePoints2,
  toUtf8String: () => toUtf8String2,
  uuidV4: () => uuidV42,
  verifyAuthorization: () => verifyAuthorization,
  verifyMessage: () => verifyMessage2,
  verifyTypedData: () => verifyTypedData2,
  version: () => version3,
  wordlists: () => wordlists2,
  zeroPadBytes: () => zeroPadBytes2,
  zeroPadValue: () => zeroPadValue2
});

// ../../../../../node_modules/ethers/lib.esm/_version.js
var version3 = "6.14.0";

// ../../../../../node_modules/ethers/lib.esm/utils/properties.js
function checkType2(value, type, name) {
  const types = type.split("|").map((t2) => t2.trim());
  for (let i2 = 0; i2 < types.length; i2++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error2 = new Error(`invalid value for type ${type}`);
  error2.code = "INVALID_ARGUMENT";
  error2.argument = `value.${name}`;
  error2.value = value;
  throw error2;
}
async function resolveProperties2(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v2, index) => {
    accum[keys[index]] = v2;
    return accum;
  }, {});
}
function defineProperties2(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType2(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../../../../node_modules/ethers/lib.esm/utils/errors.js
function stringify4(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify4).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result2 = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      result2 += HEX[value[i2] >> 4];
      result2 += HEX[value[i2] & 15];
    }
    return result2;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify4(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify4(k)}: ${stringify4(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError4(error2, code) {
  return error2 && error2.code === code;
}
function isCallException2(error2) {
  return isError4(error2, "CALL_EXCEPTION");
}
function makeError2(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify4(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify4(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version3}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error2;
  switch (code) {
    case "INVALID_ARGUMENT":
      error2 = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error2 = new RangeError(message);
      break;
    default:
      error2 = new Error(message);
  }
  defineProperties2(error2, { code });
  if (info) {
    Object.assign(error2, info);
  }
  if (error2.shortMessage == null) {
    defineProperties2(error2, { shortMessage });
  }
  return error2;
}
function assert5(check, message, code, info) {
  if (!check) {
    throw makeError2(message, code, info);
  }
}
function assertArgument2(check, message, name, value) {
  assert5(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount2(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert5(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert5(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
var _normalizeForms2 = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error2) {
  }
  return accum;
}, []);
function assertNormalize2(form) {
  assert5(_normalizeForms2.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate2(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert5(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}

// ../../../../../node_modules/ethers/lib.esm/utils/data.js
function _getBytes2(value, name, copy7) {
  if (value instanceof Uint8Array) {
    if (copy7) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result2 = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i2 = 0; i2 < result2.length; i2++) {
      result2[i2] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result2;
  }
  assertArgument2(false, "invalid BytesLike value", name || "value", value);
}
function getBytes2(value, name) {
  return _getBytes2(value, name, false);
}
function getBytesCopy2(value, name) {
  return _getBytes2(value, name, true);
}
function isHexString2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike2(value) {
  return isHexString2(value, true) || value instanceof Uint8Array;
}
var HexCharacters2 = "0123456789abcdef";
function hexlify2(data) {
  const bytes4 = getBytes2(data);
  let result2 = "0x";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    const v2 = bytes4[i2];
    result2 += HexCharacters2[(v2 & 240) >> 4] + HexCharacters2[v2 & 15];
  }
  return result2;
}
function concat3(datas) {
  return "0x" + datas.map((d) => hexlify2(d).substring(2)).join("");
}
function dataLength2(data) {
  if (isHexString2(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes2(data).length;
}
function dataSlice2(data, start, end) {
  const bytes4 = getBytes2(data);
  if (end != null && end > bytes4.length) {
    assert5(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes4,
      length: bytes4.length,
      offset: end
    });
  }
  return hexlify2(bytes4.slice(start == null ? 0 : start, end == null ? bytes4.length : end));
}
function stripZerosLeft2(data) {
  let bytes4 = hexlify2(data).substring(2);
  while (bytes4.startsWith("00")) {
    bytes4 = bytes4.substring(2);
  }
  return "0x" + bytes4;
}
function zeroPad2(data, length, left) {
  const bytes4 = getBytes2(data);
  assert5(length >= bytes4.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes4),
    length,
    offset: length + 1
  });
  const result2 = new Uint8Array(length);
  result2.fill(0);
  if (left) {
    result2.set(bytes4, length - bytes4.length);
  } else {
    result2.set(bytes4, 0);
  }
  return hexlify2(result2);
}
function zeroPadValue2(data, length) {
  return zeroPad2(data, length, true);
}
function zeroPadBytes2(data, length) {
  return zeroPad2(data, length, false);
}

// ../../../../../node_modules/ethers/lib.esm/utils/maths.js
var BN_012 = BigInt(0);
var BN_17 = BigInt(1);
var maxValue2 = 9007199254740991;
function fromTwos2(_value, _width) {
  const value = getUint2(_value, "value");
  const width = BigInt(getNumber2(_width, "width"));
  assert5(value >> width === BN_012, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_17) {
    const mask3 = (BN_17 << width) - BN_17;
    return -((~value & mask3) + BN_17);
  }
  return value;
}
function toTwos2(_value, _width) {
  let value = getBigInt2(_value, "value");
  const width = BigInt(getNumber2(_width, "width"));
  const limit = BN_17 << width - BN_17;
  if (value < BN_012) {
    value = -value;
    assert5(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask3 = (BN_17 << width) - BN_17;
    return (~value & mask3) + BN_17;
  } else {
    assert5(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask2(_value, _bits) {
  const value = getUint2(_value, "value");
  const bits = BigInt(getNumber2(_bits, "bits"));
  return value & (BN_17 << bits) - BN_17;
}
function getBigInt2(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument2(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument2(value >= -maxValue2 && value <= maxValue2, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e3) {
        assertArgument2(false, `invalid BigNumberish string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument2(false, "invalid BigNumberish value", name || "value", value);
}
function getUint2(value, name) {
  const result2 = getBigInt2(value, name);
  assert5(result2 >= BN_012, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result2;
}
var Nibbles3 = "0123456789abcdef";
function toBigInt3(value) {
  if (value instanceof Uint8Array) {
    let result2 = "0x0";
    for (const v2 of value) {
      result2 += Nibbles3[v2 >> 4];
      result2 += Nibbles3[v2 & 15];
    }
    return BigInt(result2);
  }
  return getBigInt2(value);
}
function getNumber2(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument2(value >= -maxValue2 && value <= maxValue2, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument2(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument2(value >= -maxValue2 && value <= maxValue2, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber2(BigInt(value), name);
      } catch (e3) {
        assertArgument2(false, `invalid numeric string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument2(false, "invalid numeric value", name || "value", value);
}
function toNumber2(value) {
  return getNumber2(toBigInt3(value));
}
function toBeHex2(_value, _width) {
  const value = getUint2(_value, "value");
  let result2 = value.toString(16);
  if (_width == null) {
    if (result2.length % 2) {
      result2 = "0" + result2;
    }
  } else {
    const width = getNumber2(_width, "width");
    assert5(width * 2 >= result2.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result2.length < width * 2) {
      result2 = "0" + result2;
    }
  }
  return "0x" + result2;
}
function toBeArray2(_value) {
  const value = getUint2(_value, "value");
  if (value === BN_012) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result2 = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < result2.length; i2++) {
    const offset = i2 * 2;
    result2[i2] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result2;
}
function toQuantity2(value) {
  let result2 = hexlify2(isBytesLike2(value) ? value : toBeArray2(value)).substring(2);
  while (result2.startsWith("0")) {
    result2 = result2.substring(1);
  }
  if (result2 === "") {
    result2 = "0";
  }
  return "0x" + result2;
}

// ../../../../../node_modules/ethers/lib.esm/utils/base58.js
var Alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup2 = null;
function getAlpha2(letter) {
  if (Lookup2 == null) {
    Lookup2 = {};
    for (let i2 = 0; i2 < Alphabet2.length; i2++) {
      Lookup2[Alphabet2[i2]] = BigInt(i2);
    }
  }
  const result2 = Lookup2[letter];
  assertArgument2(result2 != null, `invalid base58 value`, "letter", letter);
  return result2;
}
var BN_013 = BigInt(0);
var BN_582 = BigInt(58);
function encodeBase582(_value) {
  const bytes4 = getBytes2(_value);
  let value = toBigInt3(bytes4);
  let result2 = "";
  while (value) {
    result2 = Alphabet2[Number(value % BN_582)] + result2;
    value /= BN_582;
  }
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    if (bytes4[i2]) {
      break;
    }
    result2 = Alphabet2[0] + result2;
  }
  return result2;
}
function decodeBase582(value) {
  let result2 = BN_013;
  for (let i2 = 0; i2 < value.length; i2++) {
    result2 *= BN_582;
    result2 += getAlpha2(value[i2]);
  }
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/utils/base64-browser.js
function decodeBase642(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i2 = 0; i2 < textData.length; i2++) {
    data[i2] = textData.charCodeAt(i2);
  }
  return getBytes2(data);
}
function encodeBase642(_data) {
  const data = getBytes2(_data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}

// ../../../../../node_modules/ethers/lib.esm/utils/events.js
var EventPayload2 = class {
  /**
   *  The event filter.
   */
  filter;
  /**
   *  The **EventEmitterable**.
   */
  emitter;
  #listener;
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties2(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
};

// ../../../../../node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc2(reason, offset, bytes4, output3, badCodepoint) {
  assertArgument2(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes4);
}
function ignoreFunc2(reason, offset, bytes4, output3, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i2 = 0;
    for (let o3 = offset + 1; o3 < bytes4.length; o3++) {
      if (bytes4[o3] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === "OVERRUN") {
    return bytes4.length - offset - 1;
  }
  return 0;
}
function replaceFunc2(reason, offset, bytes4, output3, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument2(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output3.push(badCodepoint);
    return 0;
  }
  output3.push(65533);
  return ignoreFunc2(reason, offset, bytes4, output3, badCodepoint);
}
var Utf8ErrorFuncs2 = Object.freeze({
  error: errorFunc2,
  ignore: ignoreFunc2,
  replace: replaceFunc2
});
function getUtf8CodePoints2(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs2.error;
  }
  const bytes4 = getBytes2(_bytes, "bytes");
  const result2 = [];
  let i2 = 0;
  while (i2 < bytes4.length) {
    const c2 = bytes4[i2++];
    if (c2 >> 7 === 0) {
      result2.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError("UNEXPECTED_CONTINUE", i2 - 1, bytes4, result2);
      } else {
        i2 += onError("BAD_PREFIX", i2 - 1, bytes4, result2);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes4.length) {
      i2 += onError("OVERRUN", i2 - 1, bytes4, result2);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes4[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError("MISSING_CONTINUE", i2, bytes4, result2);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError("OUT_OF_RANGE", i2 - 1 - extraLength, bytes4, result2, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError("UTF16_SURROGATE", i2 - 1 - extraLength, bytes4, result2, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError("OVERLONG", i2 - 1 - extraLength, bytes4, result2, res);
      continue;
    }
    result2.push(res);
  }
  return result2;
}
function toUtf8Bytes2(str, form) {
  assertArgument2(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize2(form);
    str = str.normalize(form);
  }
  let result2 = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result2.push(c2);
    } else if (c2 < 2048) {
      result2.push(c2 >> 6 | 192);
      result2.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      assertArgument2(i2 < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result2.push(pair >> 18 | 240);
      result2.push(pair >> 12 & 63 | 128);
      result2.push(pair >> 6 & 63 | 128);
      result2.push(pair & 63 | 128);
    } else {
      result2.push(c2 >> 12 | 224);
      result2.push(c2 >> 6 & 63 | 128);
      result2.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result2);
}
function _toUtf8String2(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String2(bytes4, onError) {
  return _toUtf8String2(getUtf8CodePoints2(bytes4, onError));
}
function toUtf8CodePoints2(str, form) {
  return getUtf8CodePoints2(toUtf8Bytes2(str, form));
}

// ../../../../../node_modules/ethers/lib.esm/utils/geturl-browser.js
function createGetUrl2(options) {
  async function getUrl3(req, _signal) {
    assert5(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert5(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert5(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error2 = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error2 = makeError2("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal) {
      _signal.addListener(() => {
        error2 = makeError2("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init6 = Object.assign({}, options, {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    });
    let resp;
    try {
      resp = await fetch(req.url, init6);
    } catch (_error) {
      clearTimeout(timer);
      if (error2) {
        throw error2;
      }
      throw _error;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body2 = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body: body2
    };
  }
  return getUrl3;
}
var defaultGetUrl2 = createGetUrl2({});

// ../../../../../node_modules/ethers/lib.esm/utils/fetch.js
var MAX_ATTEMPTS2 = 12;
var SLOT_INTERVAL2 = 250;
var defaultGetUrlFunc2 = createGetUrl2();
var reData2 = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs2 = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked7 = false;
async function dataGatewayFunc2(url2, signal) {
  try {
    const match = url2.match(reData2);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse2(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase642(match[3]) : unpercent2(match[3]));
  } catch (error2) {
    return new FetchResponse2(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest2(url2));
  }
}
function getIpfsGatewayFunc2(baseUrl) {
  async function gatewayIpfs(url2, signal) {
    try {
      const match = url2.match(reIpfs2);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest2(`${baseUrl}${match[2]}`);
    } catch (error2) {
      return new FetchResponse2(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest2(url2));
    }
  }
  return gatewayIpfs;
}
var Gateways2 = {
  "data": dataGatewayFunc2,
  "ipfs": getIpfsGatewayFunc2("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals2 = /* @__PURE__ */ new WeakMap();
var FetchCancelSignal2 = class {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals2.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert5(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert5(!this.cancelled, "cancelled", "CANCELLED", {});
  }
};
function checkSignal2(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
var FetchRequest2 = class _FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  // Hooks
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  /**
   *  The fetch URL to request.
   */
  get url() {
    return this.#url;
  }
  set url(url2) {
    this.#url = String(url2);
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body2) {
    if (body2 == null) {
      this.#body = void 0;
      this.#bodyType = void 0;
    } else if (typeof body2 === "string") {
      this.#body = toUtf8Bytes2(body2);
      this.#bodyType = "text/plain";
    } else if (body2 instanceof Uint8Array) {
      this.#body = body2;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body2 === "object") {
      this.#body = toUtf8Bytes2(JSON.stringify(body2));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase642(toUtf8Bytes2(this.#creds))}`;
    }
    ;
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return this.#creds || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument2(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument2(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process3) {
    this.#process = process3;
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc2;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url2) {
    this.#url = String(url2);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 3e5;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL2,
      maxAttempts: MAX_ATTEMPTS2
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify2(this.#body) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async #send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert5(getTime4() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait2(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways2) {
      const result2 = await Gateways2[scheme](req.url, checkSignal2(_request.#signal));
      if (result2 instanceof FetchResponse2) {
        let response2 = result2;
        if (this.processFunc) {
          checkSignal2(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error2) {
            if (error2.throttle == null || typeof error2.stall !== "number") {
              response2.makeServerError("error in post-processing function", error2).assertOk();
            }
          }
        }
        return response2;
      }
      req = result2;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal2(_request.#signal));
    let response = new FetchResponse2(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error2) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal2(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error2) {
        if (error2.throttle == null || typeof error2.stall !== "number") {
          response.makeServerError("error in post-processing function", error2).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        ;
        if (error2.stall >= 0) {
          delay2 = error2.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert5(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal2(this);
    return this.#send(0, getTime4() + this.timeout, 0, this, new FetchResponse2(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert5(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals2.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert5(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    clone.#throttle = Object.assign({}, this.#throttle);
    clone.#getUrlFunc = this.#getUrlFunc;
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked7 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways2[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked7) {
      throw new Error("gateways locked");
    }
    Gateways2[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl3) {
    if (locked7) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc2 = getUrl3;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl2(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc2;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc2(baseUrl);
  }
};
var FetchResponse2 = class _FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify2(this.#body) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return this.#statusCode;
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return this.#statusMessage;
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, this.#headers);
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String2(this.#body);
    } catch (error2) {
      assert5(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error2) {
      assert5(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body2, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body2 == null ? null : new Uint8Array(body2);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error2) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
    response.#error = { message, error: error2 };
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall9) {
    if (stall9 == null) {
      stall9 = -1;
    } else {
      assertArgument2(Number.isInteger(stall9) && stall9 >= 0, "invalid stall timeout", "stall", stall9);
    }
    const error2 = new Error(message || "throttling requests");
    defineProperties2(error2, { stall: stall9, throttle: true });
    throw error2;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return this.#request;
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error: error2 } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String2(this.#body);
      }
    } catch (e3) {
    }
    assert5(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: error2,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
function getTime4() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent2(value) {
  return toUtf8Bytes2(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait2(delay) {
  return new Promise((resolve3) => setTimeout(resolve3, delay));
}

// ../../../../../node_modules/ethers/lib.esm/utils/fixednumber.js
var BN_N12 = BigInt(-1);
var BN_014 = BigInt(0);
var BN_18 = BigInt(1);
var BN_52 = BigInt(5);
var _guard7 = {};
var Zeros3 = "0000";
while (Zeros3.length < 80) {
  Zeros3 += Zeros3;
}
function getTens2(decimals) {
  let result2 = Zeros3;
  while (result2.length < decimals) {
    result2 += result2;
  }
  return BigInt("1" + result2.substring(0, decimals));
}
function checkValue2(val, format3, safeOp) {
  const width = BigInt(format3.width);
  if (format3.signed) {
    const limit = BN_18 << width - BN_18;
    assert5(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_014) {
      val = fromTwos2(mask2(val, width), width);
    } else {
      val = -fromTwos2(mask2(-val, width), width);
    }
  } else {
    const limit = BN_18 << width;
    assert5(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_18;
  }
  return val;
}
function getFormat2(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed3 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") {
    } else if (value === "ufixed") {
      signed3 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument2(match, "invalid fixed format", "format", value);
      signed3 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v2 = value;
    const check = (key, type, defaultValue) => {
      if (v2[key] == null) {
        return defaultValue;
      }
      assertArgument2(typeof v2[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v2[key]);
      return v2[key];
    };
    signed3 = check("signed", "boolean", signed3);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument2(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument2(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed3 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed3, width, decimals, name };
}
function toString3(val, decimals) {
  let negative = "";
  if (val < BN_014) {
    negative = "-";
    val *= BN_N12;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros3 + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
var FixedNumber2 = class _FixedNumber {
  /**
   *  The specific fixed-point arithmetic field for this value.
   */
  format;
  #format;
  // The actual value (accounting for decimals)
  #val;
  // A base-10 value to multiple values by to maintain the magnitude
  #tens;
  /**
   *  This is a property so console.log shows a human-meaningful value.
   *
   *  @private
   */
  _value;
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format3) {
    assertPrivate2(guard, _guard7, "FixedNumber");
    this.#val = value;
    this.#format = format3;
    const _value = toString3(value, format3.decimals);
    defineProperties2(this, { format: format3.name, _value });
    this.#tens = getTens2(format3.decimals);
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return this.#format.signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return this.#format.width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return this.#format.decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument2(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue2(val, this.#format, safeOp);
    return new _FixedNumber(_guard7, val, this.#format);
  }
  #add(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val + o3.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return this.#add(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val - o3.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return this.#sub(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val * o3.#val / this.#tens, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return this.#mul(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return this.#mul(other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    this.#checkFormat(other);
    const value = this.#val * other.#val;
    assert5(value % this.#tens === BN_014, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / this.#tens, "mulSignal");
  }
  #div(o3, safeOp) {
    assert5(o3.#val !== BN_014, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o3);
    return this.#checkValue(this.#val * this.#tens / o3.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return this.#div(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return this.#div(other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert5(other.#val !== BN_014, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value = this.#val * this.#tens;
    assert5(value % other.#val === BN_014, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / other.#val, "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b4 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b4 *= getTens2(delta);
    } else if (delta < 0) {
      a2 *= getTens2(-delta);
    }
    if (a2 < b4) {
      return -1;
    }
    if (a2 > b4) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = this.#val;
    if (this.#val < BN_014) {
      val -= this.#tens - BN_18;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_014) {
      val += this.#tens - BN_18;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_52 * getTens2(delta - 1);
    let value = this.value + bump;
    const tens = getTens2(delta);
    value = value / tens * tens;
    checkValue2(value, this.#format, "round");
    return new _FixedNumber(_guard7, value, this.#format);
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return this.#val === BN_014;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return this.#val < BN_014;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format3) {
    return _FixedNumber.fromString(this.toString(), format3);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value, _decimals, _format) {
    const decimals = _decimals == null ? 0 : getNumber2(_decimals);
    const format3 = getFormat2(_format);
    let value = getBigInt2(_value, "value");
    const delta = decimals - format3.decimals;
    if (delta > 0) {
      const tens = getTens2(delta);
      assert5(value % tens === BN_014, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens2(-delta);
    }
    checkValue2(value, format3, "fromValue");
    return new _FixedNumber(_guard7, value, format3);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value, _format) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument2(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format3 = getFormat2(_format);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format3.decimals) {
      decimal += Zeros3;
    }
    assert5(decimal.substring(format3.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format3.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue2(value, format3, "fromString");
    return new _FixedNumber(_guard7, value, format3);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value, _format) {
    let value = toBigInt3(getBytes2(_value, "value"));
    const format3 = getFormat2(_format);
    if (format3.signed) {
      value = fromTwos2(value, format3.width);
    }
    checkValue2(value, format3, "fromBytes");
    return new _FixedNumber(_guard7, value, format3);
  }
};

// ../../../../../node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte2(value) {
  let result2 = value.toString(16);
  while (result2.length < 2) {
    result2 = "0" + result2;
  }
  return "0x" + result2;
}
function unarrayifyInteger2(data, offset, length) {
  let result2 = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result2 = result2 * 256 + data[offset + i2];
  }
  return result2;
}
function _decodeChildren2(data, offset, childOffset, length) {
  const result2 = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode2(data, childOffset);
    result2.push(decoded.result);
    childOffset += decoded.consumed;
    assert5(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result: result2 };
}
function _decode2(data, offset) {
  assert5(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert5(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger2(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren2(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren2(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger2(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result2 = hexlify2(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result: result2 };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result2 = hexlify2(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result: result2 };
  }
  return { consumed: 1, result: hexlifyByte2(data[offset]) };
}
function decodeRlp2(_data) {
  const data = getBytes2(_data, "data");
  const decoded = _decode2(data, 0);
  assertArgument2(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}

// ../../../../../node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger2(value) {
  const result2 = [];
  while (value) {
    result2.unshift(value & 255);
    value >>= 8;
  }
  return result2;
}
function _encode2(object3) {
  if (Array.isArray(object3)) {
    let payload = [];
    object3.forEach(function(child) {
      payload = payload.concat(_encode2(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger2(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes2(object3, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger2(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
var nibbles2 = "0123456789abcdef";
function encodeRlp2(object3) {
  let result2 = "0x";
  for (const v2 of _encode2(object3)) {
    result2 += nibbles2[v2 >> 4];
    result2 += nibbles2[v2 & 15];
  }
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/utils/units.js
var names2 = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits2(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names2.indexOf(unit);
    assertArgument2(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber2(unit, "unit");
  }
  return FixedNumber2.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits3(value, unit) {
  assertArgument2(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names2.indexOf(unit);
    assertArgument2(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber2(unit, "unit");
  }
  return FixedNumber2.fromString(value, { decimals, width: 512 }).value;
}
function formatEther2(wei) {
  return formatUnits2(wei, 18);
}
function parseEther2(ether) {
  return parseUnits3(ether, 18);
}

// ../../../../../node_modules/ethers/lib.esm/utils/uuid.js
function uuidV42(randomBytes7) {
  const bytes4 = getBytes2(randomBytes7, "randomBytes");
  bytes4[6] = bytes4[6] & 15 | 64;
  bytes4[8] = bytes4[8] & 63 | 128;
  const value = hexlify2(bytes4);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}

// ../../../../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var WordSize2 = 32;
var Padding2 = new Uint8Array(WordSize2);
var passProperties3 = ["then"];
var _guard8 = {};
var resultNames2 = /* @__PURE__ */ new WeakMap();
function getNames2(result2) {
  return resultNames2.get(result2);
}
function setNames2(result2, names3) {
  resultNames2.set(result2, names3);
}
function throwError2(name, error2) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error2;
  throw wrapped;
}
function toObject2(names3, items, deep) {
  if (names3.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result3) {
        return toObject2(getNames2(item), item, deep);
      }
      return item;
    });
  }
  return names3.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result3) {
        item = toObject2(getNames2(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
var Result3 = class _Result extends Array {
  // No longer used; but cannot be removed as it will remove the
  // #private field from the .d.ts which may break backwards
  // compatibility
  #names;
  /**
   *  @private
   */
  constructor(...args2) {
    const guard = args2[0];
    let items = args2[1];
    let names3 = (args2[2] || []).slice();
    let wrap2 = true;
    if (guard !== _guard8) {
      items = args2;
      names3 = [];
      wrap2 = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names3.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames2(this, Object.freeze(items.map((item, index) => {
      const name = names3[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      void this.#names;
    }
    if (!wrap2) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber2(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError2(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties3.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args3) {
              return value.apply(this === receiver ? target : this, args3);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames2(proxy, getNames2(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result2 = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError2(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result2.push(item);
    });
    return result2;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names3 = getNames2(this);
    return names3.reduce((accum, name, index) => {
      assert5(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject2(names3, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames2(this);
    const result2 = [], names3 = [];
    for (let i2 = start; i2 < end; i2++) {
      result2.push(this[i2]);
      names3.push(_names[i2]);
    }
    return new _Result(_guard8, result2, names3);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names = getNames2(this);
    const result2 = [], names3 = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      const item = this[i2];
      if (item instanceof Error) {
        throwError2(`index ${i2}`, item);
      }
      if (callback.call(thisArg, item, i2, this)) {
        result2.push(item);
        names3.push(_names[i2]);
      }
    }
    return new _Result(_guard8, result2, names3);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result2 = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      const item = this[i2];
      if (item instanceof Error) {
        throwError2(`index ${i2}`, item);
      }
      result2.push(callback.call(thisArg, item, i2, this));
    }
    return result2;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames2(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError2(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard8, items, keys);
  }
};
function checkResultErrors2(result2) {
  const errors2 = [];
  const checkErrors = function(path2, object3) {
    if (!Array.isArray(object3)) {
      return;
    }
    for (let key in object3) {
      const childPath = path2.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object3[key]);
      } catch (error2) {
        errors2.push({ path: childPath, error: error2 });
      }
    }
  };
  checkErrors([], result2);
  return errors2;
}
function getValue3(value) {
  let bytes4 = toBeArray2(value);
  assert5(bytes4.length <= WordSize2, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes4, length: WordSize2, offset: bytes4.length });
  if (bytes4.length !== WordSize2) {
    bytes4 = getBytesCopy2(concat3([Padding2.slice(bytes4.length % WordSize2), bytes4]));
  }
  return bytes4;
}
var Coder2 = class {
  // The coder name:
  //   - address, uint256, tuple, array, etc.
  name;
  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
  type;
  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz
  localName;
  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties2(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument2(false, message, this.localName, value);
  }
};
var Writer2 = class {
  // An array of WordSize lengthed objects to concatenation
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat3(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data) {
    this.#data.push(data);
    this.#dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy2(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes4 = getBytesCopy2(value);
    const paddingOffset = bytes4.length % WordSize2;
    if (paddingOffset) {
      bytes4 = getBytesCopy2(concat3([bytes4, Padding2.slice(paddingOffset)]));
    }
    return this.#writeData(bytes4);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return this.#writeData(getValue3(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding2);
    this.#dataLength += WordSize2;
    return (value) => {
      this.#data[offset] = getValue3(value);
    };
  }
};
var Reader2 = class _Reader {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data, allowLoose, maxInflation) {
    defineProperties2(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy2(data);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify2(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert5(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy2(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize2) * WordSize2;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert5(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy2(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes4 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes4.length;
    return bytes4.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt3(this.readBytes(WordSize2));
  }
  readIndex() {
    return toNumber2(this.readBytes(WordSize2));
  }
};

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js
function number2(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0)
    throw new Error(`Wrong positive integer: ${n5}`);
}
function bytes3(b4, ...lengths) {
  if (!(b4 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b4.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash3.outputLen);
  number2(hash3.blockLen);
}
function exists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes3(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/crypto.js
var crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/utils.js
var u8a3 = (a2) => a2 instanceof Uint8Array;
var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr3 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var nextTick4 = async () => {
};
async function asyncLoop2(iters, tick, cb) {
  let ts = Date.now();
  for (let i2 = 0; i2 < iters; i2++) {
    cb(i2);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick4();
    ts += diff;
  }
}
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  if (!u8a3(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes3(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a3(a2))
      throw new Error("Uint8Array expected");
    r3.set(a2, pad2);
    pad2 += a2.length;
  });
  return r3;
}
var Hash3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr2 = {}.toString;
function checkOpts2(defaults, opts) {
  if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor3(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts2(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes4(bytesLength = 32) {
  if (crypto4 && typeof crypto4.getRandomValues === "function") {
    return crypto4.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash3 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash2(hash3);
    const key = toBytes3(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists3(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists3(this);
    bytes3(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init2(hash3, _password, _salt, _opts) {
  hash2(hash3);
  const opts = checkOpts2({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  number2(c2);
  number2(dkLen);
  number2(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes3(_password);
  const salt = toBytes3(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output2(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK;
}
function pbkdf23(hash3, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init2(hash3, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView3(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti.set(u2.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u2[i2];
    }
  }
  return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u2);
}

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint643(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l2 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l2, wl, isLE3);
}
var SHA22 = class extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView3(this.buffer);
  }
  update(data) {
    exists3(this);
    const { view, buffer, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView3(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists3(this);
    output2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView3(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished: finished2, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js
var Chi3 = (a2, b4, c2) => a2 & b4 ^ ~a2 & c2;
var Maj3 = (a2, b4, c2) => a2 & b4 ^ a2 & c2 ^ b4 & c2;
var SHA256_K3 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W3 = /* @__PURE__ */ new Uint32Array(64);
var SHA2563 = class extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F: F2, G, H } = this;
    return [A, B, C, D, E, F2, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F2, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W3[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W3[i2 - 15];
      const W2 = SHA256_W3[i2 - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W2, 17) ^ rotr3(W2, 19) ^ W2 >>> 10;
      SHA256_W3[i2] = s1 + SHA256_W3[i2 - 7] + s0 + SHA256_W3[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F: F2, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr3(E, 6) ^ rotr3(E, 11) ^ rotr3(E, 25);
      const T15 = H + sigma1 + Chi3(E, F2, G) + SHA256_K3[i2] + SHA256_W3[i2] | 0;
      const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
      const T23 = sigma0 + Maj3(A, B, C) | 0;
      H = G;
      G = F2;
      F2 = E;
      E = D + T15 | 0;
      D = C;
      C = B;
      B = A;
      A = T15 + T23 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F2, G, H);
  }
  roundClean() {
    SHA256_W3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2563 = /* @__PURE__ */ wrapConstructor3(() => new SHA2563());

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n2 = /* @__PURE__ */ BigInt(32);
function fromBig2(n5, le = false) {
  if (le)
    return { h: Number(n5 & U32_MASK642), l: Number(n5 >> _32n2 & U32_MASK642) };
  return { h: Number(n5 >> _32n2 & U32_MASK642) | 0, l: Number(n5 & U32_MASK642) | 0 };
}
function split3(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l2 } = fromBig2(lst[i2], le);
    [Ah[i2], Al[i2]] = [h2, l2];
  }
  return [Ah, Al];
}
var toBig2 = (h2, l2) => BigInt(h2 >>> 0) << _32n2 | BigInt(l2 >>> 0);
var shrSH2 = (h2, _l, s) => h2 >>> s;
var shrSL2 = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
var rotrSH2 = (h2, l2, s) => h2 >>> s | l2 << 32 - s;
var rotrSL2 = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
var rotrBH2 = (h2, l2, s) => h2 << 64 - s | l2 >>> s - 32;
var rotrBL2 = (h2, l2, s) => h2 >>> s - 32 | l2 << 64 - s;
var rotr32H2 = (_h, l2) => l2;
var rotr32L2 = (h2, _l) => h2;
var rotlSH2 = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
var rotlSL2 = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
var rotlBH2 = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
var rotlBL2 = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
function add2(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u642 = {
  fromBig: fromBig2,
  split: split3,
  toBig: toBig2,
  shrSH: shrSH2,
  shrSL: shrSL2,
  rotrSH: rotrSH2,
  rotrSL: rotrSL2,
  rotrBH: rotrBH2,
  rotrBL: rotrBL2,
  rotr32H: rotr32H2,
  rotr32L: rotr32L2,
  rotlSH: rotlSH2,
  rotlSL: rotlSL2,
  rotlBH: rotlBH2,
  rotlBL: rotlBL2,
  add: add2,
  add3L: add3L2,
  add3H: add3H2,
  add4L: add4L2,
  add4H: add4H2,
  add5H: add5H2,
  add5L: add5L2
};
var u64_default2 = u642;

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh2, SHA512_Kl2] = /* @__PURE__ */ (() => u64_default2.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
var SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);
var SHA5122 = class extends SHA22 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H2[i2] = view.getUint32(offset);
      SHA512_W_L2[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H2[i2 - 15] | 0;
      const W15l = SHA512_W_L2[i2 - 15] | 0;
      const s0h = u64_default2.rotrSH(W15h, W15l, 1) ^ u64_default2.rotrSH(W15h, W15l, 8) ^ u64_default2.shrSH(W15h, W15l, 7);
      const s0l = u64_default2.rotrSL(W15h, W15l, 1) ^ u64_default2.rotrSL(W15h, W15l, 8) ^ u64_default2.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H2[i2 - 2] | 0;
      const W2l = SHA512_W_L2[i2 - 2] | 0;
      const s1h = u64_default2.rotrSH(W2h, W2l, 19) ^ u64_default2.rotrBH(W2h, W2l, 61) ^ u64_default2.shrSH(W2h, W2l, 6);
      const s1l = u64_default2.rotrSL(W2h, W2l, 19) ^ u64_default2.rotrBL(W2h, W2l, 61) ^ u64_default2.shrSL(W2h, W2l, 6);
      const SUMl = u64_default2.add4L(s0l, s1l, SHA512_W_L2[i2 - 7], SHA512_W_L2[i2 - 16]);
      const SUMh = u64_default2.add4H(SUMl, s0h, s1h, SHA512_W_H2[i2 - 7], SHA512_W_H2[i2 - 16]);
      SHA512_W_H2[i2] = SUMh | 0;
      SHA512_W_L2[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default2.rotrSH(Eh, El, 14) ^ u64_default2.rotrSH(Eh, El, 18) ^ u64_default2.rotrBH(Eh, El, 41);
      const sigma1l = u64_default2.rotrSL(Eh, El, 14) ^ u64_default2.rotrSL(Eh, El, 18) ^ u64_default2.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default2.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i2], SHA512_W_L2[i2]);
      const T1h = u64_default2.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i2], SHA512_W_H2[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default2.rotrSH(Ah, Al, 28) ^ u64_default2.rotrBH(Ah, Al, 34) ^ u64_default2.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default2.rotrSL(Ah, Al, 28) ^ u64_default2.rotrBL(Ah, Al, 34) ^ u64_default2.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default2.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default2.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default2.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default2.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default2.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default2.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default2.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default2.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default2.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default2.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default2.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H2.fill(0);
    SHA512_W_L2.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha5123 = /* @__PURE__ */ wrapConstructor3(() => new SHA5122());

// ../../../../../node_modules/ethers/lib.esm/crypto/crypto-browser.js
function getGlobal3() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal2 = getGlobal3();
var crypto5 = anyGlobal2.crypto || anyGlobal2.msCrypto;
function createHash2(algo) {
  switch (algo) {
    case "sha256":
      return sha2563.create();
    case "sha512":
      return sha5123.create();
  }
  assertArgument2(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac2(_algo, key) {
  const algo = { sha256: sha2563, sha512: sha5123 }[_algo];
  assertArgument2(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac2.create(algo, key);
}
function pbkdf2Sync2(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha2563, sha512: sha5123 }[_algo];
  assertArgument2(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf23(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes5(length) {
  assert5(crypto5 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument2(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result2 = new Uint8Array(length);
  crypto5.getRandomValues(result2);
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/crypto/hmac.js
var locked8 = false;
var _computeHmac2 = function(algorithm, key, data) {
  return createHmac2(algorithm, key).update(data).digest();
};
var __computeHmac2 = _computeHmac2;
function computeHmac2(algorithm, _key, _data) {
  const key = getBytes2(_key, "key");
  const data = getBytes2(_data, "data");
  return hexlify2(__computeHmac2(algorithm, key, data));
}
computeHmac2._ = _computeHmac2;
computeHmac2.lock = function() {
  locked8 = true;
};
computeHmac2.register = function(func) {
  if (locked8) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac2 = func;
};
Object.freeze(computeHmac2);

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
var _0n7 = /* @__PURE__ */ BigInt(0);
var _1n7 = /* @__PURE__ */ BigInt(1);
var _2n6 = /* @__PURE__ */ BigInt(2);
var _7n2 = /* @__PURE__ */ BigInt(7);
var _256n2 = /* @__PURE__ */ BigInt(256);
var _0x71n2 = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n7, x = 1, y2 = 0; round < 24; round++) {
  [x, y2] = [y2, (2 * x + 3 * y2) % 5];
  SHA3_PI2.push(2 * (5 * y2 + x));
  SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n7;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n7 ^ (R >> _7n2) * _0x71n2) % _256n2;
    if (R & _2n6)
      t2 ^= _1n7 << (_1n7 << /* @__PURE__ */ BigInt(j)) - _1n7;
  }
  _SHA3_IOTA2.push(t2);
}
var [SHA3_IOTA_H2, SHA3_IOTA_L2] = /* @__PURE__ */ split3(_SHA3_IOTA2, true);
var rotlH2 = (h2, l2, s) => s > 32 ? rotlBH2(h2, l2, s) : rotlSH2(h2, l2, s);
var rotlL2 = (h2, l2, s) => s > 32 ? rotlBL2(h2, l2, s) : rotlSL2(h2, l2, s);
function keccakP2(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x + y2] ^= Th;
        s[x + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL2[t2];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI = SHA3_PI2[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y2 + x];
      for (let x = 0; x < 10; x++)
        s[y2 + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H2[round];
    s[1] ^= SHA3_IOTA_L2[round];
  }
  B.fill(0);
}
var Keccak2 = class _Keccak extends Hash3 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number2(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  keccak() {
    keccakP2(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists3(this);
    const { blockLen, state } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists3(this, false);
    bytes3(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes4) {
    number2(bytes4);
    return this.xofInto(new Uint8Array(bytes4));
  }
  digestInto(out) {
    output2(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen2 = (suffix, blockLen, outputLen) => wrapConstructor3(() => new Keccak2(blockLen, suffix, outputLen));
var sha3_2242 = /* @__PURE__ */ gen2(6, 144, 224 / 8);
var sha3_2562 = /* @__PURE__ */ gen2(6, 136, 256 / 8);
var sha3_3842 = /* @__PURE__ */ gen2(6, 104, 384 / 8);
var sha3_5122 = /* @__PURE__ */ gen2(6, 72, 512 / 8);
var keccak_2242 = /* @__PURE__ */ gen2(1, 144, 224 / 8);
var keccak_2562 = /* @__PURE__ */ gen2(1, 136, 256 / 8);
var keccak_3842 = /* @__PURE__ */ gen2(1, 104, 384 / 8);
var keccak_5122 = /* @__PURE__ */ gen2(1, 72, 512 / 8);
var genShake2 = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts2((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake1282 = /* @__PURE__ */ genShake2(31, 168, 128 / 8);
var shake2562 = /* @__PURE__ */ genShake2(31, 136, 256 / 8);

// ../../../../../node_modules/ethers/lib.esm/crypto/keccak.js
var locked9 = false;
var _keccak2562 = function(data) {
  return keccak_2562(data);
};
var __keccak2562 = _keccak2562;
function keccak2562(_data) {
  const data = getBytes2(_data, "data");
  return hexlify2(__keccak2562(data));
}
keccak2562._ = _keccak2562;
keccak2562.lock = function() {
  locked9 = true;
};
keccak2562.register = function(func) {
  if (locked9) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak2562 = func;
};
Object.freeze(keccak2562);

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/ripemd160.js
var Rho2 = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id2 = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i2) => i2);
var Pi2 = /* @__PURE__ */ Id2.map((i2) => (9 * i2 + 5) % 16);
var idxL2 = [Id2];
var idxR2 = [Pi2];
for (let i2 = 0; i2 < 4; i2++)
  for (let j of [idxL2, idxR2])
    j.push(j[i2].map((k) => Rho2[k]));
var shifts2 = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => new Uint8Array(i2));
var shiftsL2 = /* @__PURE__ */ idxL2.map((idx, i2) => idx.map((j) => shifts2[i2][j]));
var shiftsR2 = /* @__PURE__ */ idxR2.map((idx, i2) => idx.map((j) => shifts2[i2][j]));
var Kl2 = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr2 = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl3 = (word, shift) => word << shift | word >>> 32 - shift;
function f3(group, x, y2, z) {
  if (group === 0)
    return x ^ y2 ^ z;
  else if (group === 1)
    return x & y2 | ~x & z;
  else if (group === 2)
    return (x | ~y2) ^ z;
  else if (group === 3)
    return x & z | y2 & ~z;
  else
    return x ^ (y2 | ~z);
}
var BUF2 = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD1602 = class extends SHA22 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF2[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl2[group], hbr = Kr2[group];
      const rl = idxL2[group], rr = idxR2[group];
      const sl = shiftsL2[group], sr = shiftsR2[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl3(al + f3(group, bl, cl, dl) + BUF2[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl3(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl3(ar + f3(rGroup, br, cr, dr) + BUF2[rr[i2]] + hbr, sr[i2]) + er | 0;
        ar = er, er = dr, dr = rotl3(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF2.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd1603 = /* @__PURE__ */ wrapConstructor3(() => new RIPEMD1602());

// ../../../../../node_modules/ethers/lib.esm/crypto/ripemd160.js
var locked10 = false;
var _ripemd1602 = function(data) {
  return ripemd1603(data);
};
var __ripemd1602 = _ripemd1602;
function ripemd1604(_data) {
  const data = getBytes2(_data, "data");
  return hexlify2(__ripemd1602(data));
}
ripemd1604._ = _ripemd1602;
ripemd1604.lock = function() {
  locked10 = true;
};
ripemd1604.register = function(func) {
  if (locked10) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd1602 = func;
};
Object.freeze(ripemd1604);

// ../../../../../node_modules/ethers/lib.esm/crypto/pbkdf2.js
var locked11 = false;
var _pbkdf22 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync2(password, salt, iterations, keylen, algo);
};
var __pbkdf22 = _pbkdf22;
function pbkdf24(_password, _salt, iterations, keylen, algo) {
  const password = getBytes2(_password, "password");
  const salt = getBytes2(_salt, "salt");
  return hexlify2(__pbkdf22(password, salt, iterations, keylen, algo));
}
pbkdf24._ = _pbkdf22;
pbkdf24.lock = function() {
  locked11 = true;
};
pbkdf24.register = function(func) {
  if (locked11) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf22 = func;
};
Object.freeze(pbkdf24);

// ../../../../../node_modules/ethers/lib.esm/crypto/random.js
var locked12 = false;
var _randomBytes2 = function(length) {
  return new Uint8Array(randomBytes5(length));
};
var __randomBytes2 = _randomBytes2;
function randomBytes6(length) {
  return __randomBytes2(length);
}
randomBytes6._ = _randomBytes2;
randomBytes6.lock = function() {
  locked12 = true;
};
randomBytes6.register = function(func) {
  if (locked12) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes2 = func;
};
Object.freeze(randomBytes6);

// ../../../../../node_modules/ethers/node_modules/@noble/hashes/esm/scrypt.js
var rotl4 = (a2, b4) => a2 << b4 | a2 >>> 32 - b4;
function XorAndSalsa2(prev, pi, input2, ii, out, oi) {
  let y00 = prev[pi++] ^ input2[ii++], y01 = prev[pi++] ^ input2[ii++];
  let y02 = prev[pi++] ^ input2[ii++], y03 = prev[pi++] ^ input2[ii++];
  let y04 = prev[pi++] ^ input2[ii++], y05 = prev[pi++] ^ input2[ii++];
  let y06 = prev[pi++] ^ input2[ii++], y07 = prev[pi++] ^ input2[ii++];
  let y08 = prev[pi++] ^ input2[ii++], y09 = prev[pi++] ^ input2[ii++];
  let y10 = prev[pi++] ^ input2[ii++], y11 = prev[pi++] ^ input2[ii++];
  let y12 = prev[pi++] ^ input2[ii++], y13 = prev[pi++] ^ input2[ii++];
  let y14 = prev[pi++] ^ input2[ii++], y15 = prev[pi++] ^ input2[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i2 = 0; i2 < 8; i2 += 2) {
    x04 ^= rotl4(x00 + x12 | 0, 7);
    x08 ^= rotl4(x04 + x00 | 0, 9);
    x12 ^= rotl4(x08 + x04 | 0, 13);
    x00 ^= rotl4(x12 + x08 | 0, 18);
    x09 ^= rotl4(x05 + x01 | 0, 7);
    x13 ^= rotl4(x09 + x05 | 0, 9);
    x01 ^= rotl4(x13 + x09 | 0, 13);
    x05 ^= rotl4(x01 + x13 | 0, 18);
    x14 ^= rotl4(x10 + x06 | 0, 7);
    x02 ^= rotl4(x14 + x10 | 0, 9);
    x06 ^= rotl4(x02 + x14 | 0, 13);
    x10 ^= rotl4(x06 + x02 | 0, 18);
    x03 ^= rotl4(x15 + x11 | 0, 7);
    x07 ^= rotl4(x03 + x15 | 0, 9);
    x11 ^= rotl4(x07 + x03 | 0, 13);
    x15 ^= rotl4(x11 + x07 | 0, 18);
    x01 ^= rotl4(x00 + x03 | 0, 7);
    x02 ^= rotl4(x01 + x00 | 0, 9);
    x03 ^= rotl4(x02 + x01 | 0, 13);
    x00 ^= rotl4(x03 + x02 | 0, 18);
    x06 ^= rotl4(x05 + x04 | 0, 7);
    x07 ^= rotl4(x06 + x05 | 0, 9);
    x04 ^= rotl4(x07 + x06 | 0, 13);
    x05 ^= rotl4(x04 + x07 | 0, 18);
    x11 ^= rotl4(x10 + x09 | 0, 7);
    x08 ^= rotl4(x11 + x10 | 0, 9);
    x09 ^= rotl4(x08 + x11 | 0, 13);
    x10 ^= rotl4(x09 + x08 | 0, 18);
    x12 ^= rotl4(x15 + x14 | 0, 7);
    x13 ^= rotl4(x12 + x15 | 0, 9);
    x14 ^= rotl4(x13 + x12 | 0, 13);
    x15 ^= rotl4(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix2(input2, ii, out, oi, r3) {
  let head = oi + 0;
  let tail = oi + 16 * r3;
  for (let i2 = 0; i2 < 16; i2++)
    out[tail + i2] = input2[ii + (2 * r3 - 1) * 16 + i2];
  for (let i2 = 0; i2 < r3; i2++, head += 16, ii += 16) {
    XorAndSalsa2(out, tail, input2, ii, out, head);
    if (i2 > 0)
      tail += 16;
    XorAndSalsa2(out, head, input2, ii += 16, out, tail);
  }
}
function scryptInit2(password, salt, _opts) {
  const opts = checkOpts2({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N5, r: r3, p: p3, dkLen, asyncTick, maxmem, onProgress } = opts;
  number2(N5);
  number2(r3);
  number2(p3);
  number2(dkLen);
  number2(asyncTick);
  number2(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r3;
  const blockSize32 = blockSize / 4;
  if (N5 <= 1 || (N5 & N5 - 1) !== 0 || N5 >= 2 ** (blockSize / 8) || N5 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p3 < 0 || p3 > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N5 + p3);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf23(sha2563, password, salt, { c: 1, dkLen: blockSize * p3 });
  const B32 = u322(B);
  const V = u322(new Uint8Array(blockSize * N5));
  const tmp = u322(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N5 * p3;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N5, r: r3, p: p3, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput2(password, dkLen, B, V, tmp) {
  const res = pbkdf23(sha2563, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt3(password, salt, opts) {
  const { N: N5, r: r3, p: p3, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit2(password, salt, opts);
  for (let pi = 0; pi < p3; pi++) {
    const Pi3 = blockSize32 * pi;
    for (let i2 = 0; i2 < blockSize32; i2++)
      V[i2] = B32[Pi3 + i2];
    for (let i2 = 0, pos = 0; i2 < N5 - 1; i2++) {
      BlockMix2(V, pos, V, pos += blockSize32, r3);
      blockMixCb();
    }
    BlockMix2(V, (N5 - 1) * blockSize32, B32, Pi3, r3);
    blockMixCb();
    for (let i2 = 0; i2 < N5; i2++) {
      const j = B32[Pi3 + blockSize32 - 16] % N5;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi3 + k] ^ V[j * blockSize32 + k];
      BlockMix2(tmp, 0, B32, Pi3, r3);
      blockMixCb();
    }
  }
  return scryptOutput2(password, dkLen, B, V, tmp);
}
async function scryptAsync2(password, salt, opts) {
  const { N: N5, r: r3, p: p3, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit2(password, salt, opts);
  for (let pi = 0; pi < p3; pi++) {
    const Pi3 = blockSize32 * pi;
    for (let i2 = 0; i2 < blockSize32; i2++)
      V[i2] = B32[Pi3 + i2];
    let pos = 0;
    await asyncLoop2(N5 - 1, asyncTick, () => {
      BlockMix2(V, pos, V, pos += blockSize32, r3);
      blockMixCb();
    });
    BlockMix2(V, (N5 - 1) * blockSize32, B32, Pi3, r3);
    blockMixCb();
    await asyncLoop2(N5, asyncTick, () => {
      const j = B32[Pi3 + blockSize32 - 16] % N5;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi3 + k] ^ V[j * blockSize32 + k];
      BlockMix2(tmp, 0, B32, Pi3, r3);
      blockMixCb();
    });
  }
  return scryptOutput2(password, dkLen, B, V, tmp);
}

// ../../../../../node_modules/ethers/lib.esm/crypto/scrypt.js
var lockedSync2 = false;
var lockedAsync2 = false;
var _scryptAsync2 = async function(passwd, salt, N5, r3, p3, dkLen, onProgress) {
  return await scryptAsync2(passwd, salt, { N: N5, r: r3, p: p3, dkLen, onProgress });
};
var _scryptSync2 = function(passwd, salt, N5, r3, p3, dkLen) {
  return scrypt3(passwd, salt, { N: N5, r: r3, p: p3, dkLen });
};
var __scryptAsync2 = _scryptAsync2;
var __scryptSync2 = _scryptSync2;
async function scrypt4(_passwd, _salt, N5, r3, p3, dkLen, progress) {
  const passwd = getBytes2(_passwd, "passwd");
  const salt = getBytes2(_salt, "salt");
  return hexlify2(await __scryptAsync2(passwd, salt, N5, r3, p3, dkLen, progress));
}
scrypt4._ = _scryptAsync2;
scrypt4.lock = function() {
  lockedAsync2 = true;
};
scrypt4.register = function(func) {
  if (lockedAsync2) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync2 = func;
};
Object.freeze(scrypt4);
function scryptSync2(_passwd, _salt, N5, r3, p3, dkLen) {
  const passwd = getBytes2(_passwd, "passwd");
  const salt = getBytes2(_salt, "salt");
  return hexlify2(__scryptSync2(passwd, salt, N5, r3, p3, dkLen));
}
scryptSync2._ = _scryptSync2;
scryptSync2.lock = function() {
  lockedSync2 = true;
};
scryptSync2.register = function(func) {
  if (lockedSync2) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync2 = func;
};
Object.freeze(scryptSync2);

// ../../../../../node_modules/ethers/lib.esm/crypto/sha2.js
var _sha2562 = function(data) {
  return createHash2("sha256").update(data).digest();
};
var _sha5122 = function(data) {
  return createHash2("sha512").update(data).digest();
};
var __sha2562 = _sha2562;
var __sha5122 = _sha5122;
var locked2562 = false;
var locked5122 = false;
function sha2564(_data) {
  const data = getBytes2(_data, "data");
  return hexlify2(__sha2562(data));
}
sha2564._ = _sha2562;
sha2564.lock = function() {
  locked2562 = true;
};
sha2564.register = function(func) {
  if (locked2562) {
    throw new Error("sha256 is locked");
  }
  __sha2562 = func;
};
Object.freeze(sha2564);
function sha5124(_data) {
  const data = getBytes2(_data, "data");
  return hexlify2(__sha5122(data));
}
sha5124._ = _sha5122;
sha5124.lock = function() {
  locked5122 = true;
};
sha5124.register = function(func) {
  if (locked5122) {
    throw new Error("sha512 is locked");
  }
  __sha5122 = func;
};
Object.freeze(sha2564);

// ../../../../../node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  bitGet: () => bitGet2,
  bitLen: () => bitLen2,
  bitMask: () => bitMask2,
  bitSet: () => bitSet2,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE2,
  bytesToNumberLE: () => bytesToNumberLE2,
  concatBytes: () => concatBytes4,
  createHmacDrbg: () => createHmacDrbg2,
  ensureBytes: () => ensureBytes2,
  equalBytes: () => equalBytes2,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber2,
  numberToBytesBE: () => numberToBytesBE2,
  numberToBytesLE: () => numberToBytesLE2,
  numberToHexUnpadded: () => numberToHexUnpadded2,
  numberToVarBytesBE: () => numberToVarBytesBE2,
  utf8ToBytes: () => utf8ToBytes5,
  validateObject: () => validateObject4
});
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n7 = BigInt(2);
var u8a4 = (a2) => a2 instanceof Uint8Array;
var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes4) {
  if (!u8a4(bytes4))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    hex += hexes2[bytes4[i2]];
  }
  return hex;
}
function numberToHexUnpadded2(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumberBE2(bytes4) {
  return hexToNumber2(bytesToHex2(bytes4));
}
function bytesToNumberLE2(bytes4) {
  if (!u8a4(bytes4))
    throw new Error("Uint8Array expected");
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes4).reverse()));
}
function numberToBytesBE2(n5, len) {
  return hexToBytes2(n5.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n5, len) {
  return numberToBytesBE2(n5, len).reverse();
}
function numberToVarBytesBE2(n5) {
  return hexToBytes2(numberToHexUnpadded2(n5));
}
function ensureBytes2(title2, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e3) {
      throw new Error(`${title2} must be valid hex string, got "${hex}". Cause: ${e3}`);
    }
  } else if (u8a4(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title2} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title2} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes4(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a4(a2))
      throw new Error("Uint8Array expected");
    r3.set(a2, pad2);
    pad2 += a2.length;
  });
  return r3;
}
function equalBytes2(b1, b22) {
  if (b1.length !== b22.length)
    return false;
  for (let i2 = 0; i2 < b1.length; i2++)
    if (b1[i2] !== b22[i2])
      return false;
  return true;
}
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen2(n5) {
  let len;
  for (len = 0; n5 > _0n8; n5 >>= _1n8, len += 1)
    ;
  return len;
}
function bitGet2(n5, pos) {
  return n5 >> BigInt(pos) & _1n8;
}
var bitSet2 = (n5, pos, value) => {
  return n5 | (value ? _1n8 : _0n8) << BigInt(pos);
};
var bitMask2 = (n5) => (_2n7 << BigInt(n5 - 1)) - _1n8;
var u8n2 = (data) => new Uint8Array(data);
var u8fr2 = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i2 = 0;
  const reset = () => {
    v2.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h2 = (...b4) => hmacFn(k, v2, ...b4);
  const reseed = (seed = u8n2()) => {
    k = h2(u8fr2([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr2([1]), seed);
    v2 = h2();
  };
  const gen3 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl = v2.slice();
      out.push(sl);
      len += v2.length;
    }
    return concatBytes4(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen3())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns2 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object3) => object3.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject4(object3, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns2[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object3[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object3)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object3;
}

// ../../../../../node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n8 = BigInt(2);
var _3n3 = BigInt(3);
var _4n3 = BigInt(4);
var _5n2 = BigInt(5);
var _8n2 = BigInt(8);
var _9n2 = BigInt(9);
var _16n2 = BigInt(16);
function mod2(a2, b4) {
  const result2 = a2 % b4;
  return result2 >= _0n9 ? result2 : b4 + result2;
}
function pow3(num, power, modulo) {
  if (modulo <= _0n9 || power < _0n9)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n9)
    return _0n9;
  let res = _1n9;
  while (power > _0n9) {
    if (power & _1n9)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n9;
  }
  return res;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n9) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number3, modulo) {
  if (number3 === _0n9 || modulo <= _0n9) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a2 = mod2(number3, modulo);
  let b4 = modulo;
  let x = _0n9, y2 = _1n9, u2 = _1n9, v2 = _0n9;
  while (a2 !== _0n9) {
    const q = b4 / a2;
    const r3 = b4 % a2;
    const m2 = x - u2 * q;
    const n5 = y2 - v2 * q;
    b4 = a2, a2 = r3, x = u2, y2 = v2, u2 = m2, v2 = n5;
  }
  const gcd = b4;
  if (gcd !== _1n9)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function tonelliShanks2(P2) {
  const legendreC = (P2 - _1n9) / _2n8;
  let Q, S3, Z;
  for (Q = P2 - _1n9, S3 = 0; Q % _2n8 === _0n9; Q /= _2n8, S3++)
    ;
  for (Z = _2n8; Z < P2 && pow3(Z, legendreC, P2) !== P2 - _1n9; Z++)
    ;
  if (S3 === 1) {
    const p1div4 = (P2 + _1n9) / _4n3;
    return function tonelliFast(Fp3, n5) {
      const root = Fp3.pow(n5, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n9) / _2n8;
  return function tonelliSlow(Fp3, n5) {
    if (Fp3.pow(n5, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r3 = S3;
    let g2 = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n5, Q1div2);
    let b4 = Fp3.pow(n5, Q);
    while (!Fp3.eql(b4, Fp3.ONE)) {
      if (Fp3.eql(b4, Fp3.ZERO))
        return Fp3.ZERO;
      let m2 = 1;
      for (let t2 = Fp3.sqr(b4); m2 < r3; m2++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g2, _1n9 << BigInt(r3 - m2 - 1));
      g2 = Fp3.sqr(ge);
      x = Fp3.mul(x, ge);
      b4 = Fp3.mul(b4, g2);
      r3 = m2;
    }
    return x;
  };
}
function FpSqrt2(P2) {
  if (P2 % _4n3 === _3n3) {
    const p1div4 = (P2 + _1n9) / _4n3;
    return function sqrt3mod4(Fp3, n5) {
      const root = Fp3.pow(n5, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n2 === _5n2) {
    const c1 = (P2 - _5n2) / _8n2;
    return function sqrt5mod8(Fp3, n5) {
      const n22 = Fp3.mul(n5, _2n8);
      const v2 = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n5, v2);
      const i2 = Fp3.mul(Fp3.mul(nv, _2n8), v2);
      const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _16n2 === _9n2) {
  }
  return tonelliShanks2(P2);
}
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS2.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject4(field, opts);
}
function FpPow2(f4, num, power) {
  if (power < _0n9)
    throw new Error("Expected power > 0");
  if (power === _0n9)
    return f4.ONE;
  if (power === _1n9)
    return num;
  let p3 = f4.ONE;
  let d = num;
  while (power > _0n9) {
    if (power & _1n9)
      p3 = f4.mul(p3, d);
    d = f4.sqr(d);
    power >>= _1n9;
  }
  return p3;
}
function FpInvertBatch2(f4, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f4.is0(num))
      return acc;
    tmp[i2] = acc;
    return f4.mul(acc, num);
  }, f4.ONE);
  const inverted = f4.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f4.is0(num))
      return acc;
    tmp[i2] = f4.mul(acc, tmp[i2]);
    return f4.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength2(n5, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLen3, isLE3 = false, redef = {}) {
  if (ORDER <= _0n9)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt2(ORDER);
  const f4 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n9,
    ONE: _1n9,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n9 <= num && num < ORDER;
    },
    is0: (num) => num === _0n9,
    isOdd: (num) => (num & _1n9) === _1n9,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow2(f4, num, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert2(num, ORDER),
    sqrt: redef.sqrt || ((n5) => sqrtP(f4, n5)),
    invertBatch: (lst) => FpInvertBatch2(f4, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b4, c2) => c2 ? b4 : a2,
    toBytes: (num) => isLE3 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
    fromBytes: (bytes4) => {
      if (bytes4.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes4.length}`);
      return isLE3 ? bytesToNumberLE2(bytes4) : bytesToNumberBE2(bytes4);
    }
  });
  return Object.freeze(f4);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length = getFieldBytesLength2(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField2(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE2(key) : bytesToNumberLE2(key);
  const reduced = mod2(num, fieldOrder - _1n9) + _1n9;
  return isLE3 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// ../../../../../node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
function wNAF2(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n5) {
      let p3 = c2.ZERO;
      let d = elm;
      while (n5 > _0n10) {
        if (n5 & _1n10)
          p3 = p3.add(d);
        d = d.double();
        n5 >>= _1n10;
      }
      return p3;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p3 = elm;
      let base2 = p3;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p3;
        points.push(base2);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base2 = base2.add(p3);
          points.push(base2);
        }
        p3 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n5) {
      const { windows, windowSize } = opts(W);
      let p3 = c2.ZERO;
      let f4 = c2.BASE;
      const mask3 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n5 & mask3);
        n5 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n5 += _1n10;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f4 = f4.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p3 = p3.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p3, f: f4 };
    },
    wNAFCached(P2, precomputesMap, n5, transform) {
      const W = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W);
        if (W !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W, comp, n5);
    }
  };
}
function validateBasic2(curve) {
  validateField2(curve.Fp);
  validateObject4(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength2(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// ../../../../../node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts2(curve) {
  const opts = validateBasic2(curve);
  validateObject4(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a2 } = opts;
  if (endo) {
    if (!Fp3.eql(a2, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n2, hexToBytes: h2b2 } = utils_exports2;
var DER2 = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER2;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n2(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER2;
    const data = typeof hex === "string" ? h2b2(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r3, l: sBytes } = DER2._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER2._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r: r3, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h2(sig.s));
    const r3 = slice(h2(sig.r));
    const shl = s.length / 2;
    const rhl = r3.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r3}02${sl}${s}`;
  }
};
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n9 = BigInt(2);
var _3n4 = BigInt(3);
var _4n4 = BigInt(4);
function weierstrassPoints2(opts) {
  const CURVE = validatePointOpts2(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes4(Uint8Array.from([4]), Fp3.toBytes(a2.x), Fp3.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes4) => {
    const tail = bytes4.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y: y2 };
  });
  function weierstrassEquation(x) {
    const { a: a2, b: b4 } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a2)), b4);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n11 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n5 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes2("private key", key, nByteLength));
    } catch (error2) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod2(num, n5);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p3) {
      const { x, y: y2 } = p3 || {};
      if (!p3 || !Fp3.isValid(x) || !Fp3.isValid(y2))
        throw new Error("invalid affine point");
      if (p3 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp3.eql(i2, Fp3.ZERO);
      if (is0(x) && is0(y2))
        return Point3.ZERO;
      return new Point3(x, y2, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p3) => p3.pz));
      return points.map((p3, i2) => p3.toAffine(toInv[i2])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point3.fromAffine(fromBytes(ensureBytes2("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: y2 } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y2);
      const right = weierstrassEquation(x);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U13 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U23 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U13 && U23;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b4 } = CURVE;
      const b32 = Fp3.mul(b4, _3n4);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a2, Z3);
      Y3 = Fp3.mul(b32, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b32, Z3);
      t2 = Fp3.mul(a2, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a2, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a2 = CURVE.a;
      const b32 = Fp3.mul(CURVE.b, _3n4);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a2, t4);
      X3 = Fp3.mul(b32, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.mul(b32, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n5) {
      return wnaf.wNAFCached(this, pointPrecomputes, n5, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p3) => p3.pz));
        return comp.map((p3, i2) => p3.toAffine(toInv[i2])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n5) {
      const I = Point3.ZERO;
      if (n5 === _0n11)
        return I;
      assertGE(n5);
      if (n5 === _1n11)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n5);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n5);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n11 || k2 > _0n11) {
        if (k1 & _1n11)
          k1p = k1p.add(d);
        if (k2 & _1n11)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n11;
        k2 >>= _1n11;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n5 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n5);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p3, f: f4 } = this.wNAF(n5);
        point = p3;
        fake = f4;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a2, b4) {
      const G = Point3.BASE;
      const mul = (P2, a3) => a3 === _0n11 || a3 === _1n11 || !P2.equals(G) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul(this, a2).add(mul(Q, b4));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y2, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y2, iz);
      const zz = Fp3.mul(z, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n11)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n11)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes5(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF2(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts2(curve) {
  const opts = validateBasic2(curve);
  validateObject4(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass2(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n11 < num && num < Fp3.ORDER;
  }
  function modN(a2) {
    return mod2(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert2(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints2({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a2 = point.toAffine();
      const x = Fp3.toBytes(a2.x);
      const cat = concatBytes4;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a2.y));
      }
    },
    fromBytes(bytes4) {
      const len = bytes4.length;
      const head = bytes4[0];
      const tail = bytes4.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE2(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y3 = Fp3.sqrt(y2);
        const isYOdd = (y3 & _1n11) === _1n11;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp3.neg(y3);
        return { x, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE2(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n11;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b4, from, to) => bytesToNumberBE2(b4.slice(from, to));
  class Signature3 {
    constructor(r3, s, recovery) {
      this.r = r3;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes2("compactSignature", hex, l2 * 2);
      return new Signature3(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r3, s } = DER2.toSig(ensureBytes2("DER", hex));
      return new Signature3(r3, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature3(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r3, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE.n : r3;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature3(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength2(CURVE.n);
      return mapHashToField2(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b4 = Point3.fromHex(publicB);
    return b4.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes4) {
    const num = bytesToNumberBE2(bytes4);
    const delta = bytes4.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes4) {
    return modN(bits2int(bytes4));
  };
  const ORDER_MASK = bitMask2(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n11 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE2(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes7 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e3 = ent === true ? randomBytes7(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e3));
    }
    const seed = concatBytes4(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r3 = modN(q.x);
      if (r3 === _0n11)
        return;
      const s = modN(ik * modN(m2 + r3 * d));
      if (s === _0n11)
        return;
      let recovery = (q.x === r3 ? 0 : 2) | Number(q.y & _1n11);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature3(r3, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg2(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature3.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
          _sig = Signature3.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r4, s: s2 } = sg;
        _sig = new Signature3(r4, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point3.fromHex(publicKey);
    } catch (error2) {
      if (error2.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r3, s } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h2 * is);
    const u2 = modN(r3 * is);
    const R = Point3.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v2 = modN(R.x);
    return v2 === r3;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature: Signature3,
    utils
  };
}

// ../../../../../node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash2(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac2(hash3, key, concatBytes3(...msgs)),
    randomBytes: randomBytes4
  };
}
function createCurve2(curveDef, defHash) {
  const create = (hash3) => weierstrass2({ ...curveDef, ...getHash2(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// ../../../../../node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P2 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n12 = BigInt(1);
var _2n10 = BigInt(2);
var divNearest2 = (a2, b4) => (a2 + b4 / _2n10) / b4;
function sqrtMod2(y2) {
  const P2 = secp256k1P2;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y2 * y2 * y2 % P2;
  const b32 = b22 * b22 * y2 % P2;
  const b6 = pow22(b32, _3n5, P2) * b32 % P2;
  const b9 = pow22(b6, _3n5, P2) * b32 % P2;
  const b11 = pow22(b9, _2n10, P2) * b22 % P2;
  const b222 = pow22(b11, _11n, P2) * b11 % P2;
  const b44 = pow22(b222, _22n, P2) * b222 % P2;
  const b88 = pow22(b44, _44n, P2) * b44 % P2;
  const b176 = pow22(b88, _88n, P2) * b88 % P2;
  const b220 = pow22(b176, _44n, P2) * b44 % P2;
  const b223 = pow22(b220, _3n5, P2) * b32 % P2;
  const t1 = pow22(b223, _23n, P2) * b222 % P2;
  const t2 = pow22(t1, _6n, P2) * b22 % P2;
  const root = pow22(t2, _2n10, P2);
  if (!Fp2.eql(Fp2.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field2(secp256k1P2, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k12 = createCurve2({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp2,
  n: secp256k1N2,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n5 = secp256k1N2;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n12 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b22 * k, n5);
      const c2 = divNearest2(-b1 * k, n5);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n5);
      let k2 = mod2(-c1 * b1 - c2 * b22, n5);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n5 - k1;
      if (k2neg)
        k2 = n5 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2563);
var _0n12 = BigInt(0);
var Point2 = secp256k12.ProjectivePoint;

// ../../../../../node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress2 = "0x0000000000000000000000000000000000000000";

// ../../../../../node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash2 = "0x0000000000000000000000000000000000000000000000000000000000000000";

// ../../../../../node_modules/ethers/lib.esm/constants/numbers.js
var N3 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther2 = BigInt("1000000000000000000");
var MaxUint2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2562 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt2562 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// ../../../../../node_modules/ethers/lib.esm/constants/strings.js
var EtherSymbol2 = "\u039E";
var MessagePrefix2 = "Ethereum Signed Message:\n";

// ../../../../../node_modules/ethers/lib.esm/crypto/signature.js
var BN_015 = BigInt(0);
var BN_19 = BigInt(1);
var BN_25 = BigInt(2);
var BN_273 = BigInt(27);
var BN_283 = BigInt(28);
var BN_353 = BigInt(35);
var _guard9 = {};
function toUint2562(value) {
  return zeroPadValue2(toBeArray2(value), 32);
}
var Signature2 = class _Signature {
  #r;
  #s;
  #v;
  #networkV;
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument2(dataLength2(value) === 32, "invalid r", "value", value);
    this.#r = hexlify2(value);
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return this.#s;
  }
  set s(_value) {
    assertArgument2(dataLength2(_value) === 32, "invalid s", "value", _value);
    const value = hexlify2(_value);
    assertArgument2(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    this.#s = value;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return this.#v;
  }
  set v(value) {
    const v2 = getNumber2(value, "value");
    assertArgument2(v2 === 27 || v2 === 28, "invalid v", "v", value);
    this.#v = v2;
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return this.#networkV;
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v2 = this.networkV;
    if (v2 == null) {
      return null;
    }
    return _Signature.getChainId(v2);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes2(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify2(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat3([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat3([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  @private
   */
  constructor(guard, r3, s, v2) {
    assertPrivate2(guard, _guard9, "Signature");
    this.#r = r3;
    this.#s = s;
    this.#v = v2;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard9, this.r, this.s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v2) {
    const bv = getBigInt2(v2, "v");
    if (bv == BN_273 || bv == BN_283) {
      return BN_015;
    }
    assertArgument2(bv >= BN_353, "invalid EIP-155 v", "v", v2);
    return (bv - BN_353) / BN_25;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v2) {
    return getBigInt2(chainId) * BN_25 + BigInt(35 + v2 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v2) {
    const bv = getBigInt2(v2);
    if (bv === BN_015 || bv === BN_273) {
      return 27;
    }
    if (bv === BN_19 || bv === BN_283) {
      return 28;
    }
    assertArgument2(bv >= BN_353, "invalid v", "v", v2);
    return bv & BN_19 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument2(check, message, "signature", sig);
    }
    ;
    if (sig == null) {
      return new _Signature(_guard9, ZeroHash2, ZeroHash2, 27);
    }
    if (typeof sig === "string") {
      const bytes4 = getBytes2(sig, "signature");
      if (bytes4.length === 64) {
        const r4 = hexlify2(bytes4.slice(0, 32));
        const s2 = bytes4.slice(32, 64);
        const v3 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _Signature(_guard9, r4, hexlify2(s2), v3);
      }
      if (bytes4.length === 65) {
        const r4 = hexlify2(bytes4.slice(0, 32));
        const s2 = bytes4.slice(32, 64);
        assertError((s2[0] & 128) === 0, "non-canonical s");
        const v3 = _Signature.getNormalizedV(bytes4[64]);
        return new _Signature(_guard9, r4, hexlify2(s2), v3);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r3 = toUint2562(_r);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint2562(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString2(yParityAndS, 32), "invalid yParityAndS");
        const bytes4 = getBytes2(yParityAndS);
        bytes4[0] &= 127;
        return hexlify2(bytes4);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes2(s)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v2 } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v3 = getBigInt2(_v);
        return {
          networkV: v3 >= BN_353 ? v3 : void 0,
          v: _Signature.getNormalizedV(v3)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString2(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes2(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber2(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result2 = new _Signature(_guard9, r3, s, v2);
    if (networkV) {
      result2.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber2(sig.yParity, "sig.yParity") === result2.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result2.yParityAndS, "yParityAndS mismatch");
    return result2;
  }
};

// ../../../../../node_modules/ethers/lib.esm/crypto/signing-key.js
var SigningKey2 = class _SigningKey {
  #privateKey;
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    assertArgument2(dataLength2(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify2(privateKey);
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return this.#privateKey;
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(this.#privateKey);
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(this.#privateKey, true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument2(dataLength2(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k12.sign(getBytesCopy2(digest), getBytesCopy2(this.#privateKey), {
      lowS: true
    });
    return Signature2.from({
      r: toBeHex2(sig.r, 32),
      s: toBeHex2(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify2(secp256k12.getSharedSecret(getBytesCopy2(this.#privateKey), getBytes2(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes4 = getBytes2(key, "key");
    if (bytes4.length === 32) {
      const pubKey = secp256k12.getPublicKey(bytes4, !!compressed);
      return hexlify2(pubKey);
    }
    if (bytes4.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes4, 1);
      bytes4 = pub;
    }
    const point = secp256k12.ProjectivePoint.fromHex(bytes4);
    return hexlify2(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument2(dataLength2(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature2.from(signature);
    let secpSig = secp256k12.Signature.fromCompact(getBytesCopy2(concat3([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy2(digest));
    assertArgument2(pubKey != null, "invalid signature for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k12.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k12.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};

// ../../../../../node_modules/ethers/lib.esm/crypto/index.js
function lock2() {
  computeHmac2.lock();
  keccak2562.lock();
  pbkdf24.lock();
  randomBytes6.lock();
  ripemd1604.lock();
  scrypt4.lock();
  scryptSync2.lock();
  sha2564.lock();
  sha5124.lock();
  randomBytes6.lock();
}

// ../../../../../node_modules/ethers/lib.esm/address/address.js
var BN_016 = BigInt(0);
var BN_362 = BigInt(36);
function getChecksumAddress2(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = getBytes2(keccak2562(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var ibanLookup2 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup2[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup2[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits2 = 15;
function ibanChecksum2(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup2[c2];
  }).join("");
  while (expanded.length >= safeDigits2) {
    let block = expanded.substring(0, safeDigits2);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum3 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum3.length < 2) {
    checksum3 = "0" + checksum3;
  }
  return checksum3;
}
var Base362 = function() {
  ;
  const result2 = {};
  for (let i2 = 0; i2 < 36; i2++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i2];
    result2[key] = BigInt(i2);
  }
  return result2;
}();
function fromBase362(value) {
  value = value.toLowerCase();
  let result2 = BN_016;
  for (let i2 = 0; i2 < value.length; i2++) {
    result2 = result2 * BN_362 + Base362[value[i2]];
  }
  return result2;
}
function getAddress2(address) {
  assertArgument2(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result2 = getChecksumAddress2(address);
    assertArgument2(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result2 === address, "bad address checksum", "address", address);
    return result2;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument2(address.substring(2, 4) === ibanChecksum2(address), "bad icap checksum", "address", address);
    let result2 = fromBase362(address.substring(4)).toString(16);
    while (result2.length < 40) {
      result2 = "0" + result2;
    }
    return getChecksumAddress2("0x" + result2);
  }
  assertArgument2(false, "invalid address", "address", address);
}
function getIcapAddress2(address) {
  let base36 = BigInt(getAddress2(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum2("XE00" + base36) + base36;
}

// ../../../../../node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress2(tx) {
  const from = getAddress2(tx.from);
  const nonce = getBigInt2(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress2(dataSlice2(keccak2562(encodeRlp2([from, nonceHex])), 12));
}
function getCreate2Address2(_from2, _salt, _initCodeHash) {
  const from = getAddress2(_from2);
  const salt = getBytes2(_salt, "salt");
  const initCodeHash = getBytes2(_initCodeHash, "initCodeHash");
  assertArgument2(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument2(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress2(dataSlice2(keccak2562(concat3(["0xff", from, salt, initCodeHash])), 12));
}

// ../../../../../node_modules/ethers/lib.esm/address/checks.js
function isAddressable2(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress2(value) {
  try {
    getAddress2(value);
    return true;
  } catch (error2) {
  }
  return false;
}
async function checkAddress2(target, promise) {
  const result2 = await promise;
  if (result2 == null || result2 === "0x0000000000000000000000000000000000000000") {
    assert5(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument2(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress2(result2);
}
function resolveAddress2(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress2(target);
    }
    assert5(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress2(target, resolver.resolveName(target));
  } else if (isAddressable2(target)) {
    return checkAddress2(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress2(target, target);
  }
  assertArgument2(false, "unsupported addressable value", "target", target);
}

// ../../../../../node_modules/ethers/lib.esm/abi/typed.js
var _gaurd2 = {};
function n4(value, width) {
  let signed3 = false;
  if (width < 0) {
    signed3 = true;
    width *= -1;
  }
  return new Typed2(_gaurd2, `${signed3 ? "" : "u"}int${width}`, value, { signed: signed3, width });
}
function b3(value, size) {
  return new Typed2(_gaurd2, `bytes${size ? size : ""}`, value, { size });
}
var _typedSymbol2 = Symbol.for("_ethers_typed");
var Typed2 = class _Typed {
  /**
   *  The type, as a Solidity-compatible type.
   */
  type;
  /**
   *  The actual value.
   */
  value;
  #options;
  /**
   *  @_ignore:
   */
  _typedSymbol;
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate2(_gaurd2, gaurd, "Typed");
    defineProperties2(this, { _typedSymbol: _typedSymbol2, type, value });
    this.#options = options;
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v2) => v2.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd2, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v2) {
    return n4(v2, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v2) {
    return n4(v2, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v2) {
    return n4(v2, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v2) {
    return n4(v2, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v2) {
    return n4(v2, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v2) {
    return n4(v2, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v2) {
    return n4(v2, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v2) {
    return n4(v2, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v2) {
    return n4(v2, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v2) {
    return n4(v2, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v2) {
    return n4(v2, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v2) {
    return n4(v2, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v2) {
    return n4(v2, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v2) {
    return n4(v2, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v2) {
    return n4(v2, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v2) {
    return n4(v2, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v2) {
    return n4(v2, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v2) {
    return n4(v2, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v2) {
    return n4(v2, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v2) {
    return n4(v2, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v2) {
    return n4(v2, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v2) {
    return n4(v2, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v2) {
    return n4(v2, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v2) {
    return n4(v2, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v2) {
    return n4(v2, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v2) {
    return n4(v2, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v2) {
    return n4(v2, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v2) {
    return n4(v2, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v2) {
    return n4(v2, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v2) {
    return n4(v2, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v2) {
    return n4(v2, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v2) {
    return n4(v2, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v2) {
    return n4(v2, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v2) {
    return n4(v2, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v2) {
    return n4(v2, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v2) {
    return n4(v2, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v2) {
    return n4(v2, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v2) {
    return n4(v2, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v2) {
    return n4(v2, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v2) {
    return n4(v2, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v2) {
    return n4(v2, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v2) {
    return n4(v2, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v2) {
    return n4(v2, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v2) {
    return n4(v2, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v2) {
    return n4(v2, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v2) {
    return n4(v2, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v2) {
    return n4(v2, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v2) {
    return n4(v2, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v2) {
    return n4(v2, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v2) {
    return n4(v2, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v2) {
    return n4(v2, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v2) {
    return n4(v2, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v2) {
    return n4(v2, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v2) {
    return n4(v2, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v2) {
    return n4(v2, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v2) {
    return n4(v2, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v2) {
    return n4(v2, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v2) {
    return n4(v2, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v2) {
    return n4(v2, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v2) {
    return n4(v2, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v2) {
    return n4(v2, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v2) {
    return n4(v2, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v2) {
    return n4(v2, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v2) {
    return n4(v2, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v2) {
    return n4(v2, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v2) {
    return n4(v2, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v2) {
    return b3(v2, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v2) {
    return b3(v2, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v2) {
    return b3(v2, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v2) {
    return b3(v2, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v2) {
    return b3(v2, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v2) {
    return b3(v2, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v2) {
    return b3(v2, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v2) {
    return b3(v2, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v2) {
    return b3(v2, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v2) {
    return b3(v2, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v2) {
    return b3(v2, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v2) {
    return b3(v2, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v2) {
    return b3(v2, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v2) {
    return b3(v2, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v2) {
    return b3(v2, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v2) {
    return b3(v2, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v2) {
    return b3(v2, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v2) {
    return b3(v2, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v2) {
    return b3(v2, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v2) {
    return b3(v2, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v2) {
    return b3(v2, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v2) {
    return b3(v2, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v2) {
    return b3(v2, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v2) {
    return b3(v2, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v2) {
    return b3(v2, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v2) {
    return b3(v2, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v2) {
    return b3(v2, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v2) {
    return b3(v2, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v2) {
    return b3(v2, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v2) {
    return b3(v2, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v2) {
    return b3(v2, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v2) {
    return b3(v2, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v2) {
    return new _Typed(_gaurd2, "address", v2);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v2) {
    return new _Typed(_gaurd2, "bool", !!v2);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v2) {
    return new _Typed(_gaurd2, "bytes", v2);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v2) {
    return new _Typed(_gaurd2, "string", v2);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v2, dynamic) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd2, "array", v2, dynamic);
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v2, name) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd2, "tuple", v2, name);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v2) {
    return new _Typed(_gaurd2, "overrides", Object.assign({}, v2));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol2;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/address.js
var AddressCoder2 = class extends Coder2 {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed2.dereference(_value, "string");
    try {
      value = getAddress2(value);
    } catch (error2) {
      return this._throwError(error2.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress2(toBeHex2(reader.readValue(), 20));
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/anonymous.js
var AnonymousCoder2 = class extends Coder2 {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/array.js
function pack2(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert5(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert5(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument2(false, "invalid tuple value", "tuple", values);
  }
  assertArgument2(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer2();
  let dynamicWriter = new Writer2();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack2(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error2) {
        if (isError4(error2, "BUFFER_OVERRUN")) {
          throw error2;
        }
        value = error2;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error2) {
        if (isError4(error2, "BUFFER_OVERRUN")) {
          throw error2;
        }
        value = error2;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result3.fromItems(values, keys);
}
var ArrayCoder2 = class extends Coder2 {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties2(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result2 = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      result2.push(defaultChild);
    }
    return result2;
  }
  encode(writer, _value) {
    const value = Typed2.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount2(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      coders.push(this.coder);
    }
    return pack2(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert5(count * WordSize2 <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize2, length: reader.dataLength });
    }
    let coders = [];
    for (let i2 = 0; i2 < count; i2++) {
      coders.push(new AnonymousCoder2(this.coder));
    }
    return unpack2(reader, coders);
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/boolean.js
var BooleanCoder2 = class extends Coder2 {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed2.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/bytes.js
var DynamicBytesCoder2 = class extends Coder2 {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy2(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
};
var BytesCoder2 = class extends DynamicBytesCoder2 {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify2(super.decode(reader));
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
var FixedBytesCoder2 = class extends Coder2 {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties2(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data = getBytesCopy2(Typed2.dereference(_value, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify2(reader.readBytes(this.size));
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/null.js
var Empty3 = new Uint8Array([]);
var NullCoder2 = class extends Coder2 {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty3);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/number.js
var BN_017 = BigInt(0);
var BN_110 = BigInt(1);
var BN_MAX_UINT2563 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var NumberCoder2 = class extends Coder2 {
  size;
  signed;
  constructor(size, signed3, localName) {
    const name = (signed3 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties2(this, { size, signed: signed3 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt2(Typed2.dereference(_value, this.type));
    let maxUintValue = mask2(BN_MAX_UINT2563, WordSize2 * 8);
    if (this.signed) {
      let bounds = mask2(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_110)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos2(value, 8 * WordSize2);
    } else if (value < BN_017 || value > mask2(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask2(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos2(value, this.size * 8);
    }
    return value;
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/string.js
var StringCoder2 = class extends DynamicBytesCoder2 {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes2(Typed2.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String2(super.decode(reader));
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/coders/tuple.js
var TupleCoder2 = class extends Coder2 {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties2(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed2.dereference(_value, "tuple");
    return pack2(writer, this.coders, value);
  }
  decode(reader) {
    return unpack2(reader, this.coders);
  }
};

// ../../../../../node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify2(addr, storageKeys) {
  return {
    address: getAddress2(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument2(isHexString2(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify2(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument2(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify2(set[0], set[1]);
      }
      assertArgument2(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify2(set.address, set.storageKeys);
    });
  }
  assertArgument2(value != null && typeof value === "object", "invalid access list", "value", value);
  const result2 = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify2(addr, Object.keys(storageKeys).sort());
  });
  result2.sort((a2, b4) => a2.address.localeCompare(b4.address));
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/transaction/authorization.js
function authorizationify(auth) {
  return {
    address: getAddress2(auth.address),
    nonce: getBigInt2(auth.nonce != null ? auth.nonce : 0),
    chainId: getBigInt2(auth.chainId != null ? auth.chainId : 0),
    signature: Signature2.from(auth.signature)
  };
}

// ../../../../../node_modules/ethers/lib.esm/transaction/address.js
function computeAddress2(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey2.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress2(keccak2562("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress2(digest, signature) {
  return computeAddress2(SigningKey2.recoverPublicKey(digest, signature));
}

// ../../../../../node_modules/ethers/lib.esm/transaction/transaction.js
var BN_018 = BigInt(0);
var BN_26 = BigInt(2);
var BN_274 = BigInt(27);
var BN_284 = BigInt(28);
var BN_354 = BigInt(35);
var BN_MAX_UINT2 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE2 = 4096 * 32;
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob2) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes2(kzg.blobToKzgCommitment(hexlify2(blob2)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes2(kzg.blobToKzgCommitment(blob2));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes2(kzg.blobToKZGCommitment(hexlify2(blob2)));
    }
    assertArgument2(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob2, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes2(kzg.computeBlobProof(hexlify2(blob2), hexlify2(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob2, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes2(kzg.computeBlobKZGProof(hexlify2(blob2), hexlify2(commitment)));
    }
    assertArgument2(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash2(version4, hash3) {
  let versioned = version4.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha2564(hash3).substring(4);
  return "0x" + versioned;
}
function handleAddress2(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress2(value);
}
function handleAccessList2(value, param) {
  try {
    return accessListify2(value);
  } catch (error2) {
    assertArgument2(false, error2.message, param, value);
  }
}
function handleAuthorizationList(value, param) {
  try {
    if (!Array.isArray(value)) {
      throw new Error("authorizationList: invalid array");
    }
    const result2 = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      const auth = value[i2];
      if (!Array.isArray(auth)) {
        throw new Error(`authorization[${i2}]: invalid array`);
      }
      if (auth.length !== 6) {
        throw new Error(`authorization[${i2}]: wrong length`);
      }
      if (!auth[1]) {
        throw new Error(`authorization[${i2}]: null address`);
      }
      result2.push({
        address: handleAddress2(auth[1]),
        nonce: handleUint2(auth[2], "nonce"),
        chainId: handleUint2(auth[0], "chainId"),
        signature: Signature2.from({
          yParity: handleNumber2(auth[3], "yParity"),
          r: zeroPadValue2(auth[4], 32),
          s: zeroPadValue2(auth[5], 32)
        })
      });
    }
    return result2;
  } catch (error2) {
    assertArgument2(false, error2.message, param, value);
  }
}
function handleNumber2(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber2(_value, param);
}
function handleUint2(_value, param) {
  if (_value === "0x") {
    return BN_018;
  }
  const value = getBigInt2(_value, param);
  assertArgument2(value <= BN_MAX_UINT2, "value exceeds uint size", param, value);
  return value;
}
function formatNumber3(_value, name) {
  const value = getBigInt2(_value, "value");
  const result2 = toBeArray2(value);
  assertArgument2(result2.length <= 32, `value too large`, `tx.${name}`, value);
  return result2;
}
function formatAccessList2(value) {
  return accessListify2(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
  return value.map((a2) => {
    return [
      formatNumber3(a2.chainId, "chainId"),
      a2.address,
      formatNumber3(a2.nonce, "nonce"),
      formatNumber3(a2.signature.yParity, "yParity"),
      a2.signature.r,
      a2.signature.s
    ];
  });
}
function formatHashes2(value, param) {
  assertArgument2(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i2 = 0; i2 < value.length; i2++) {
    assertArgument2(isHexString2(value[i2], 32), "invalid ${ param } hash", `value[${i2}]`, value[i2]);
  }
  return value;
}
function _parseLegacy2(data) {
  const fields = decodeRlp2(data);
  assertArgument2(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber2(fields[0], "nonce"),
    gasPrice: handleUint2(fields[1], "gasPrice"),
    gasLimit: handleUint2(fields[2], "gasLimit"),
    to: handleAddress2(fields[3]),
    value: handleUint2(fields[4], "value"),
    data: hexlify2(fields[5]),
    chainId: BN_018
  };
  if (fields.length === 6) {
    return tx;
  }
  const v2 = handleUint2(fields[6], "v");
  const r3 = handleUint2(fields[7], "r");
  const s = handleUint2(fields[8], "s");
  if (r3 === BN_018 && s === BN_018) {
    tx.chainId = v2;
  } else {
    let chainId = (v2 - BN_354) / BN_26;
    if (chainId < BN_018) {
      chainId = BN_018;
    }
    tx.chainId = chainId;
    assertArgument2(chainId !== BN_018 || (v2 === BN_274 || v2 === BN_284), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature2.from({
      r: zeroPadValue2(fields[7], 32),
      s: zeroPadValue2(fields[8], 32),
      v: v2
    });
  }
  return tx;
}
function _serializeLegacy2(tx, sig) {
  const fields = [
    formatNumber3(tx.nonce, "nonce"),
    formatNumber3(tx.gasPrice || 0, "gasPrice"),
    formatNumber3(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber3(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_018;
  if (tx.chainId != BN_018) {
    chainId = getBigInt2(tx.chainId, "tx.chainId");
    assertArgument2(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_018) {
      fields.push(toBeArray2(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp2(fields);
  }
  let v2 = BigInt(27 + sig.yParity);
  if (chainId !== BN_018) {
    v2 = Signature2.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v2) {
    assertArgument2(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray2(v2));
  fields.push(toBeArray2(sig.r));
  fields.push(toBeArray2(sig.s));
  return encodeRlp2(fields);
}
function _parseEipSignature2(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber2(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error2) {
    assertArgument2(false, "invalid yParity", "yParity", fields[0]);
  }
  const r3 = zeroPadValue2(fields[1], 32);
  const s = zeroPadValue2(fields[2], 32);
  const signature = Signature2.from({ r: r3, s, yParity });
  tx.signature = signature;
}
function _parseEip15592(data) {
  const fields = decodeRlp2(getBytes2(data).slice(1));
  assertArgument2(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify2(data));
  const tx = {
    type: 2,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint2(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint2(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint2(fields[4], "gasLimit"),
    to: handleAddress2(fields[5]),
    value: handleUint2(fields[6], "value"),
    data: hexlify2(fields[7]),
    accessList: handleAccessList2(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature2(tx, fields.slice(9));
  return tx;
}
function _serializeEip15592(tx, sig) {
  const fields = [
    formatNumber3(tx.chainId, "chainId"),
    formatNumber3(tx.nonce, "nonce"),
    formatNumber3(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber3(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber3(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber3(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber3(sig.yParity, "yParity"));
    fields.push(toBeArray2(sig.r));
    fields.push(toBeArray2(sig.s));
  }
  return concat3(["0x02", encodeRlp2(fields)]);
}
function _parseEip29302(data) {
  const fields = decodeRlp2(getBytes2(data).slice(1));
  assertArgument2(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify2(data));
  const tx = {
    type: 1,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    gasPrice: handleUint2(fields[2], "gasPrice"),
    gasLimit: handleUint2(fields[3], "gasLimit"),
    to: handleAddress2(fields[4]),
    value: handleUint2(fields[5], "value"),
    data: hexlify2(fields[6]),
    accessList: handleAccessList2(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature2(tx, fields.slice(8));
  return tx;
}
function _serializeEip29302(tx, sig) {
  const fields = [
    formatNumber3(tx.chainId, "chainId"),
    formatNumber3(tx.nonce, "nonce"),
    formatNumber3(tx.gasPrice || 0, "gasPrice"),
    formatNumber3(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber3(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber3(sig.yParity, "recoveryParam"));
    fields.push(toBeArray2(sig.r));
    fields.push(toBeArray2(sig.s));
  }
  return concat3(["0x01", encodeRlp2(fields)]);
}
function _parseEip48442(data) {
  let fields = decodeRlp2(getBytes2(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument2(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument2(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument2(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument2(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument2(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i2 = 0; i2 < fields[1].length; i2++) {
      blobs.push({
        data: fBlobs[i2],
        commitment: fCommits[i2],
        proof: fProofs[i2]
      });
    }
    fields = fields[0];
  }
  assertArgument2(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify2(data));
  const tx = {
    type: 3,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint2(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint2(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint2(fields[4], "gasLimit"),
    to: handleAddress2(fields[5]),
    value: handleUint2(fields[6], "value"),
    data: hexlify2(fields[7]),
    accessList: handleAccessList2(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint2(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument2(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument2(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i2 = 0; i2 < tx.blobVersionedHashes.length; i2++) {
    assertArgument2(isHexString2(tx.blobVersionedHashes[i2], 32), `invalid blobVersionedHash at index ${i2}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature2(tx, fields.slice(11));
  return tx;
}
function _serializeEip48442(tx, sig, blobs) {
  const fields = [
    formatNumber3(tx.chainId, "chainId"),
    formatNumber3(tx.nonce, "nonce"),
    formatNumber3(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber3(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber3(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress2,
    formatNumber3(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || []),
    formatNumber3(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes2(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber3(sig.yParity, "yParity"));
    fields.push(toBeArray2(sig.r));
    fields.push(toBeArray2(sig.s));
    if (blobs) {
      return concat3([
        "0x03",
        encodeRlp2([
          fields,
          blobs.map((b4) => b4.data),
          blobs.map((b4) => b4.commitment),
          blobs.map((b4) => b4.proof)
        ])
      ]);
    }
  }
  return concat3(["0x03", encodeRlp2(fields)]);
}
function _parseEip7702(data) {
  const fields = decodeRlp2(getBytes2(data).slice(1));
  assertArgument2(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify2(data));
  const tx = {
    type: 4,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint2(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint2(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint2(fields[4], "gasLimit"),
    to: handleAddress2(fields[5]),
    value: handleUint2(fields[6], "value"),
    data: hexlify2(fields[7]),
    accessList: handleAccessList2(fields[8], "accessList"),
    authorizationList: handleAuthorizationList(fields[9], "authorizationList")
  };
  if (fields.length === 10) {
    return tx;
  }
  _parseEipSignature2(tx, fields.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields = [
    formatNumber3(tx.chainId, "chainId"),
    formatNumber3(tx.nonce, "nonce"),
    formatNumber3(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber3(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber3(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber3(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields.push(formatNumber3(sig.yParity, "yParity"));
    fields.push(toBeArray2(sig.r));
    fields.push(toBeArray2(sig.s));
  }
  return concat3(["0x04", encodeRlp2(fields)]);
}
var Transaction2 = class _Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  #auths;
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        this.#type = 4;
        break;
      default:
        assertArgument2(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress2;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress2(value);
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber2(value, "value");
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt2(value);
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_018;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt2(value, "gasPrice");
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_018;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt2(value, "maxPriorityFeePerGas");
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_018;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt2(value, "maxFeePerGas");
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify2(value);
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt2(value, "value");
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt2(value);
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature2.from(value);
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify2(value);
  }
  get authorizationList() {
    const value = this.#auths || null;
    if (value == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value;
  }
  set authorizationList(auths) {
    this.#auths = auths == null ? null : auths.map((a2) => authorizationify(a2));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_018;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt2(value, "maxFeePerBlobGas");
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument2(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i2 = 0; i2 < value.length; i2++) {
        assertArgument2(isHexString2(value[i2], 32), "invalid blobVersionedHash", `value[${i2}]`, value[i2]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b4) => Object.assign({}, b4));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i2 = 0; i2 < _blobs.length; i2++) {
      const blob2 = _blobs[i2];
      if (isBytesLike2(blob2)) {
        assert5(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes2(blob2);
        assertArgument2(data.length <= BLOB_SIZE2, "blob is too large", `blobs[${i2}]`, blob2);
        if (data.length !== BLOB_SIZE2) {
          const padded = new Uint8Array(BLOB_SIZE2);
          padded.set(data);
          data = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data);
        const proof = hexlify2(this.#kzg.computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify2(data),
          commitment: hexlify2(commit),
          proof
        });
        versionedHashes.push(getVersionedHash2(1, commit));
      } else {
        const commit = hexlify2(blob2.commitment);
        blobs.push({
          data: hexlify2(blob2.data),
          commitment: commit,
          proof: hexlify2(blob2.proof)
        });
        versionedHashes.push(getVersionedHash2(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    if (kzg == null) {
      this.#kzg = null;
    } else {
      this.#kzg = getKzgLibrary(kzg);
    }
  }
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_018;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_018;
    this.#chainId = BN_018;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#kzg = null;
    this.#blobs = null;
    this.#auths = null;
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak2562(this.#getSerialized(true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak2562(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress2(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey2.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed3, sidecar) {
    assert5(!signed3 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed3 ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy2(this, sig);
      case 1:
        return _serializeEip29302(this, sig);
      case 2:
        return _serializeEip15592(this, sig);
      case 3:
        return _serializeEip48442(this, sig, sidecar ? this.blobs : null);
      case 4:
        return _serializeEip7702(this, sig);
    }
    assert5(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return this.#getSerialized(true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert5(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert5(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert5(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types.push(4);
      } else if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v2) => {
      if (v2 == null) {
        return null;
      }
      return v2.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes2(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy2(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip29302(payload));
        case 2:
          return _Transaction.from(_parseEip15592(payload));
        case 3:
          return _Transaction.from(_parseEip48442(payload));
        case 4:
          return _Transaction.from(_parseEip7702(payload));
      }
      assert5(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result2 = new _Transaction();
    if (tx.type != null) {
      result2.type = tx.type;
    }
    if (tx.to != null) {
      result2.to = tx.to;
    }
    if (tx.nonce != null) {
      result2.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result2.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result2.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result2.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result2.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result2.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result2.data = tx.data;
    }
    if (tx.value != null) {
      result2.value = tx.value;
    }
    if (tx.chainId != null) {
      result2.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result2.signature = Signature2.from(tx.signature);
    }
    if (tx.accessList != null) {
      result2.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result2.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result2.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result2.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result2.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument2(result2.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument2(result2.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument2(result2.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument2(result2.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result2;
  }
};

// ../../../../../node_modules/ethers/lib.esm/hash/authorization.js
function hashAuthorization(auth) {
  assertArgument2(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
  return keccak2562(concat3([
    "0x05",
    encodeRlp2([
      auth.chainId != null ? toBeArray2(auth.chainId) : "0x",
      getAddress2(auth.address),
      auth.nonce != null ? toBeArray2(auth.nonce) : "0x"
    ])
  ]));
}
function verifyAuthorization(auth, sig) {
  return recoverAddress2(hashAuthorization(auth), sig);
}

// ../../../../../node_modules/ethers/lib.esm/hash/id.js
function id2(value) {
  return keccak2562(toUtf8Bytes2(value));
}

// ../../../../../node_modules/@adraffy/ens-normalize/dist/index.mjs
var COMPRESSED$12 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED2 = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX2 = 4;
function decode_arithmetic2(bytes4) {
  let pos = 0;
  function u16() {
    return bytes4[pos++] << 8 | bytes4[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes4[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N5 = 31;
  const FULL = 2 ** N5;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N5; i2++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a2 = low + Math.floor(range * acc[start] / total);
    let b4 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a2 ^ b4) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b4 = b4 << 1 & MASK | 1;
    }
    while (a2 & ~b4 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b4 = (b4 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b4 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes4[pos_payload++] << 16 | bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
      case 2:
        return offset + 256 + (bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
      case 1:
        return offset + bytes4[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload2(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload2(s) {
  return read_payload2(decode_arithmetic2(unsafe_atob2(s)));
}
function unsafe_atob2(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i2) => lookup[c2.charCodeAt(0)] = i2);
  let n5 = s.length;
  let ret = new Uint8Array(6 * n5 >> 3);
  for (let i2 = 0, pos = 0, width = 0, carry = 0; i2 < n5; i2++) {
    carry = carry << 6 | lookup[s.charCodeAt(i2)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed2(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
function read_deltas2(n5, next) {
  let v2 = Array(n5);
  for (let i2 = 0, x = 0; i2 < n5; i2++) v2[i2] = x += signed2(next());
  return v2;
}
function read_sorted2(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n5 = next();
    if (!n5) break;
    prev += x;
    for (let i2 = 0; i2 < n5; i2++) {
      ret.push(prev + i2);
    }
    prev += n5 + 1;
  }
  return ret;
}
function read_sorted_arrays2(next) {
  return read_array_while2(() => {
    let v2 = read_sorted2(next);
    if (v2.length) return v2;
  });
}
function read_mapped2(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table2(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table2(w, next));
  }
  return ret.flat();
}
function read_array_while2(next) {
  let v2 = [];
  while (true) {
    let x = next(v2.length);
    if (!x) break;
    v2.push(x);
  }
  return v2;
}
function read_transposed2(n5, w, next) {
  let m2 = Array(n5).fill().map(() => []);
  for (let i2 = 0; i2 < w; i2++) {
    read_deltas2(n5, next).forEach((x, j) => m2[j].push(x));
  }
  return m2;
}
function read_linear_table2(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while2(next);
  let m2 = read_transposed2(vN.length, 1 + w, next);
  return m2.flatMap((v2, i2) => {
    let [x, ...ys] = v2;
    return Array(vN[i2]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y2) => y2 + j_dy)];
    });
  });
}
function read_replacement_table2(w, next) {
  let n5 = 1 + next();
  let m2 = read_transposed2(n5, 1 + w, next);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_trie2(next) {
  let ret = [];
  let sorted = read_sorted2(next);
  expand(decode9([]), []);
  return ret;
  function decode9(Q) {
    let S3 = next();
    let B = read_array_while2(() => {
      let cps = read_sorted2(next).map((i2) => sorted[i2]);
      if (cps.length) return decode9(cps);
    });
    return { S: S3, B, Q };
  }
  function expand({ S: S3, B }, cps, saved) {
    if (S3 & 4 && saved === cps[cps.length - 1]) return;
    if (S3 & 2) saved = cps[cps.length - 1];
    if (S3 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp3 of br.Q) {
        expand(br, [...cps, cp3], saved);
      }
    }
  }
}
function hex_cp2(cp3) {
  return cp3.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp2(cp3) {
  return `{${hex_cp2(cp3)}}`;
}
function explode_cp2(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp3 = s.codePointAt(pos);
    pos += cp3 < 65536 ? 1 : 2;
    cps.push(cp3);
  }
  return cps;
}
function str_from_cps2(cps) {
  const chunk2 = 4096;
  let len = cps.length;
  if (len < chunk2) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i2 = 0; i2 < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i2, i2 += chunk2)));
  }
  return buf.join("");
}
function compare_arrays2(a2, b4) {
  let n5 = a2.length;
  let c2 = n5 - b4.length;
  for (let i2 = 0; c2 == 0 && i2 < n5; i2++) c2 = a2[i2] - b4[i2];
  return c2;
}
var COMPRESSED2 = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S02 = 44032;
var L02 = 4352;
var V02 = 4449;
var T02 = 4519;
var L_COUNT2 = 19;
var V_COUNT2 = 21;
var T_COUNT2 = 28;
var N_COUNT2 = V_COUNT2 * T_COUNT2;
var S_COUNT2 = L_COUNT2 * N_COUNT2;
var S12 = S02 + S_COUNT2;
var L12 = L02 + L_COUNT2;
var V12 = V02 + V_COUNT2;
var T13 = T02 + T_COUNT2;
function unpack_cc2(packed) {
  return packed >> 24 & 255;
}
function unpack_cp2(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK2;
var EXCLUSIONS2;
var DECOMP2;
var RECOMP2;
function init$12() {
  let r3 = read_compressed_payload2(COMPRESSED2);
  SHIFTED_RANK2 = new Map(read_sorted_arrays2(r3).flatMap((v2, i2) => v2.map((x) => [x, i2 + 1 << 24])));
  EXCLUSIONS2 = new Set(read_sorted2(r3));
  DECOMP2 = /* @__PURE__ */ new Map();
  RECOMP2 = /* @__PURE__ */ new Map();
  for (let [cp3, cps] of read_mapped2(r3)) {
    if (!EXCLUSIONS2.has(cp3) && cps.length == 2) {
      let [a2, b4] = cps;
      let bucket = RECOMP2.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP2.set(a2, bucket);
      }
      bucket.set(b4, cp3);
    }
    DECOMP2.set(cp3, cps.reverse());
  }
}
function is_hangul2(cp3) {
  return cp3 >= S02 && cp3 < S12;
}
function compose_pair2(a2, b4) {
  if (a2 >= L02 && a2 < L12 && b4 >= V02 && b4 < V12) {
    return S02 + (a2 - L02) * N_COUNT2 + (b4 - V02) * T_COUNT2;
  } else if (is_hangul2(a2) && b4 > T02 && b4 < T13 && (a2 - S02) % T_COUNT2 == 0) {
    return a2 + (b4 - T02);
  } else {
    let recomp = RECOMP2.get(a2);
    if (recomp) {
      recomp = recomp.get(b4);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed2(cps) {
  if (!SHIFTED_RANK2) init$12();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add3(cp3) {
    let cc = SHIFTED_RANK2.get(cp3);
    if (cc) {
      check_order = true;
      cp3 |= cc;
    }
    ret.push(cp3);
  }
  for (let cp3 of cps) {
    while (true) {
      if (cp3 < 128) {
        ret.push(cp3);
      } else if (is_hangul2(cp3)) {
        let s_index = cp3 - S02;
        let l_index = s_index / N_COUNT2 | 0;
        let v_index = s_index % N_COUNT2 / T_COUNT2 | 0;
        let t_index = s_index % T_COUNT2;
        add3(L02 + l_index);
        add3(V02 + v_index);
        if (t_index > 0) add3(T02 + t_index);
      } else {
        let mapped = DECOMP2.get(cp3);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add3(cp3);
        }
      }
      if (!buf.length) break;
      cp3 = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc2(ret[0]);
    for (let i2 = 1; i2 < ret.length; i2++) {
      let cc = unpack_cc2(ret[i2]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i2 - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc2(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc2(ret[i2]);
    }
  }
  return ret;
}
function composed_from_decomposed2(v2) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v2) {
    let cc = unpack_cc2(packed);
    let cp3 = unpack_cp2(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp3;
      } else {
        ret.push(cp3);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp3;
      } else {
        stack.push(cp3);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair2(prev_cp, cp3);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp3;
      } else {
        stack.push(cp3);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd2(cps) {
  return decomposed2(cps).map(unpack_cp2);
}
function nfc2(cps) {
  return composed_from_decomposed2(decomposed2(cps));
}
var HYPHEN2 = 45;
var STOP_CH2 = ".";
var FE0F2 = 65039;
var UNIQUE_PH2 = 1;
var Array_from2 = (x) => Array.from(x);
function group_has_cp2(g2, cp3) {
  return g2.P.has(cp3) || g2.Q.has(cp3);
}
var Emoji2 = class extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
};
var MAPPED2;
var IGNORED2;
var CM2;
var NSM2;
var ESCAPE2;
var NFC_CHECK2;
var GROUPS2;
var WHOLE_VALID2;
var WHOLE_MAP2;
var VALID2;
var EMOJI_LIST2;
var EMOJI_ROOT2;
function init4() {
  if (MAPPED2) return;
  let r3 = read_compressed_payload2(COMPRESSED$12);
  const read_sorted_array = () => read_sorted2(r3);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v2) => v2.forEach((x) => set.add(x));
  MAPPED2 = new Map(read_mapped2(r3));
  IGNORED2 = read_sorted_set();
  CM2 = read_sorted_array();
  NSM2 = new Set(read_sorted_array().map((i2) => CM2[i2]));
  CM2 = new Set(CM2);
  ESCAPE2 = read_sorted_set();
  NFC_CHECK2 = read_sorted_set();
  let chunks = read_sorted_arrays2(r3);
  let unrestricted = r3();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i2) => set_add_many(set, chunks[i2]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS2 = read_array_while2((i2) => {
    let N5 = read_array_while2(r3).map((x) => x + 96);
    if (N5.length) {
      let R = i2 >= unrestricted;
      N5[0] -= 32;
      N5 = str_from_cps2(N5);
      if (R) N5 = `Restricted[${N5}]`;
      let P2 = read_chunked();
      let Q = read_chunked();
      let M = !r3();
      return { N: N5, P: P2, Q, M, R };
    }
  });
  WHOLE_VALID2 = read_sorted_set();
  WHOLE_MAP2 = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from2(WHOLE_VALID2)).sort((a2, b4) => a2 - b4);
  wholes.forEach((cp3, i2) => {
    let d = r3();
    let w = wholes[i2] = d ? wholes[i2 - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp3);
    if (!WHOLE_VALID2.has(cp3)) {
      WHOLE_MAP2.set(cp3, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP2.values())) {
    let recs = [];
    for (let cp3 of V) {
      let gs = GROUPS2.filter((g2) => group_has_cp2(g2, cp3));
      let rec = recs.find(({ G }) => gs.some((g2) => G.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp3);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from2(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g2) => !G.has(g2)));
      for (let cp3 of V2) {
        M.set(cp3, complement);
      }
    }
  }
  VALID2 = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp3) => VALID2.has(cp3) ? multi.add(cp3) : VALID2.add(cp3);
  for (let g2 of GROUPS2) {
    for (let cp3 of g2.P) add_to_union(cp3);
    for (let cp3 of g2.Q) add_to_union(cp3);
  }
  for (let cp3 of VALID2) {
    if (!WHOLE_MAP2.has(cp3) && !multi.has(cp3)) {
      WHOLE_MAP2.set(cp3, UNIQUE_PH2);
    }
  }
  set_add_many(VALID2, nfd2(VALID2));
  EMOJI_LIST2 = read_trie2(r3).map((v2) => Emoji2.from(v2)).sort(compare_arrays2);
  EMOJI_ROOT2 = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST2) {
    let prev = [EMOJI_ROOT2];
    for (let cp3 of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp3);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp3, child);
        }
        return child;
      });
      if (cp3 === FE0F2) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp2(cp3) {
  return (should_escape2(cp3) ? "" : `${bidi_qq2(safe_str_from_cps2([cp3]))} `) + quote_cp2(cp3);
}
function bidi_qq2(s) {
  return `"${s}"\u200E`;
}
function check_label_extension2(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN2 && cps[3] == HYPHEN2) {
    throw new Error(`invalid label extension: "${str_from_cps2(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore2(cps) {
  const UNDERSCORE = 95;
  for (let i2 = cps.lastIndexOf(UNDERSCORE); i2 > 0; ) {
    if (cps[--i2] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced2(cps) {
  let cp3 = cps[0];
  let prev = FENCED2.get(cp3);
  if (prev) throw error_placement2(`leading ${prev}`);
  let n5 = cps.length;
  let last = -1;
  for (let i2 = 1; i2 < n5; i2++) {
    cp3 = cps[i2];
    let match = FENCED2.get(cp3);
    if (match) {
      if (last == i2) throw error_placement2(`${prev} + ${match}`);
      last = i2 + 1;
      prev = match;
    }
  }
  if (last == n5) throw error_placement2(`trailing ${prev}`);
}
function safe_str_from_cps2(cps, max = Infinity, quoter = quote_cp2) {
  let buf = [];
  if (is_combining_mark2(cps[0])) buf.push("\u25CC");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n5 = cps.length;
  for (let i2 = 0; i2 < n5; i2++) {
    let cp3 = cps[i2];
    if (should_escape2(cp3)) {
      buf.push(str_from_cps2(cps.slice(prev, i2)));
      buf.push(quoter(cp3));
      prev = i2 + 1;
    }
  }
  buf.push(str_from_cps2(cps.slice(prev, n5)));
  return buf.join("");
}
function is_combining_mark2(cp3) {
  init4();
  return CM2.has(cp3);
}
function should_escape2(cp3) {
  init4();
  return ESCAPE2.has(cp3);
}
function ens_normalize2(name) {
  return flatten2(split4(name, nfc2, filter_fe0f2));
}
function split4(name, nf, ef) {
  if (!name) return [];
  init4();
  let offset = 0;
  return name.split(STOP_CH2).map((label) => {
    let input2 = explode_cp2(label);
    let info = {
      input: input2,
      offset
      // codepoint, not substring!
    };
    offset += input2.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str2(input2, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore2(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp3) => cp3 < 128)) {
        check_label_extension2(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM2.has(norm[0])) throw error_placement2("leading combining mark");
          for (let i2 = 1; i2 < token_count; i2++) {
            let cps = tokens[i2];
            if (!cps.is_emoji && CM2.has(cps[0])) {
              throw error_placement2(`emoji + combining mark: "${str_from_cps2(tokens[i2 - 1])} + ${safe_str_from_cps2([cps[0]])}"`);
            }
          }
          check_fenced2(norm);
          let unique = Array_from2(new Set(chars));
          let [g2] = determine_group2(unique);
          check_group2(g2, chars);
          check_whole2(g2, unique);
          type = g2.N;
        }
      }
      info.type = type;
    } catch (err3) {
      info.error = err3;
    }
    return info;
  });
}
function check_whole2(group, unique) {
  let maker;
  let shared = [];
  for (let cp3 of unique) {
    let whole = WHOLE_MAP2.get(cp3);
    if (whole === UNIQUE_PH2) return;
    if (whole) {
      let set = whole.M.get(cp3);
      maker = maker ? maker.filter((g2) => set.has(g2)) : Array_from2(set);
      if (!maker.length) return;
    } else {
      shared.push(cp3);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp3) => group_has_cp2(g2, cp3))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
function determine_group2(unique) {
  let groups = GROUPS2;
  for (let cp3 of unique) {
    let gs = groups.filter((g2) => group_has_cp2(g2, cp3));
    if (!gs.length) {
      if (!GROUPS2.some((g2) => group_has_cp2(g2, cp3))) {
        throw error_disallowed2(cp3);
      } else {
        throw error_group_member2(groups[0], cp3);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten2(split5) {
  return split5.map(({ input: input2, error: error2, output: output3 }) => {
    if (error2) {
      let msg = error2.message;
      throw new Error(split5.length == 1 ? msg : `Invalid label ${bidi_qq2(safe_str_from_cps2(input2, 63))}: ${msg}`);
    }
    return str_from_cps2(output3);
  }).join(STOP_CH2);
}
function error_disallowed2(cp3) {
  return new Error(`disallowed character: ${quoted_cp2(cp3)}`);
}
function error_group_member2(g2, cp3) {
  let quoted = quoted_cp2(cp3);
  let gg = GROUPS2.find((g3) => g3.P.has(cp3));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
function error_placement2(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group2(g2, cps) {
  for (let cp3 of cps) {
    if (!group_has_cp2(g2, cp3)) {
      throw error_group_member2(g2, cp3);
    }
  }
  if (g2.M) {
    let decomposed3 = nfd2(cps);
    for (let i2 = 1, e3 = decomposed3.length; i2 < e3; i2++) {
      if (NSM2.has(decomposed3[i2])) {
        let j = i2 + 1;
        for (let cp3; j < e3 && NSM2.has(cp3 = decomposed3[j]); j++) {
          for (let k = i2; k < j; k++) {
            if (decomposed3[k] == cp3) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp2(cp3)}`);
            }
          }
        }
        if (j - i2 > NSM_MAX2) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq2(safe_str_from_cps2(decomposed3.slice(i2 - 1, j)))} (${j - i2}/${NSM_MAX2})`);
        }
        i2 = j;
      }
    }
  }
}
function tokens_from_str2(input2, nf, ef) {
  let ret = [];
  let chars = [];
  input2 = input2.slice().reverse();
  while (input2.length) {
    let emoji = consume_emoji_reversed2(input2);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp3 = input2.pop();
      if (VALID2.has(cp3)) {
        chars.push(cp3);
      } else {
        let cps = MAPPED2.get(cp3);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED2.has(cp3)) {
          throw error_disallowed2(cp3);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f2(cps) {
  return cps.filter((cp3) => cp3 != FE0F2);
}
function consume_emoji_reversed2(cps, eaten) {
  let node = EMOJI_ROOT2;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten) eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// ../../../../../node_modules/ethers/lib.esm/hash/namehash.js
var Zeros4 = new Uint8Array(32);
Zeros4.fill(0);
function checkComponent2(comp) {
  assertArgument2(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit2(name) {
  const bytes4 = toUtf8Bytes2(ensNormalize2(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    const d = bytes4[i2];
    if (d === 46) {
      comps.push(checkComponent2(bytes4.slice(last, i2)));
      last = i2 + 1;
    }
  }
  assertArgument2(last < bytes4.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent2(bytes4.slice(last)));
  return comps;
}
function ensNormalize2(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize2(name);
  } catch (error2) {
    assertArgument2(false, `invalid ENS name (${error2.message})`, "name", name);
  }
}
function isValidName2(name) {
  try {
    return ensNameSplit2(name).length !== 0;
  } catch (error2) {
  }
  return false;
}
function namehash2(name) {
  assertArgument2(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument2(name.length, `invalid ENS name (empty label)`, "name", name);
  let result2 = Zeros4;
  const comps = ensNameSplit2(name);
  while (comps.length) {
    result2 = keccak2562(concat3([result2, keccak2562(comps.pop())]));
  }
  return hexlify2(result2);
}
function dnsEncode2(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument2(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify2(concat3(ensNameSplit2(name).map((comp) => {
    assertArgument2(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes4 = new Uint8Array(comp.length + 1);
    bytes4.set(comp, 1);
    bytes4[0] = bytes4.length - 1;
    return bytes4;
  }))) + "00";
}

// ../../../../../node_modules/ethers/lib.esm/hash/message.js
function hashMessage2(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes2(message);
  }
  return keccak2562(concat3([
    toUtf8Bytes2(MessagePrefix2),
    toUtf8Bytes2(String(message.length)),
    message
  ]));
}
function verifyMessage2(message, sig) {
  const digest = hashMessage2(message);
  return recoverAddress2(digest, sig);
}

// ../../../../../node_modules/ethers/lib.esm/hash/solidity.js
var regexBytes2 = new RegExp("^bytes([0-9]+)$");
var regexNumber2 = new RegExp("^(u?int)([0-9]*)$");
var regexArray2 = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack2(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return getBytes2(zeroPadValue2(value, 32));
      }
      return getBytes2(getAddress2(value));
    case "string":
      return toUtf8Bytes2(value);
    case "bytes":
      return getBytes2(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray2) {
        return getBytes2(zeroPadValue2(value, 32));
      }
      return getBytes2(value);
  }
  let match = type.match(regexNumber2);
  if (match) {
    let signed3 = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument2((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray2) {
      size = 256;
    }
    if (signed3) {
      value = toTwos2(value, size);
    }
    return getBytes2(zeroPadValue2(toBeArray2(value), size / 8));
  }
  match = type.match(regexBytes2);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument2(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument2(dataLength2(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray2) {
      return getBytes2(zeroPadBytes2(value, 32));
    }
    return value;
  }
  match = type.match(regexArray2);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument2(count === value.length, `invalid array length for ${type}`, "value", value);
    const result2 = [];
    value.forEach(function(value2) {
      result2.push(_pack2(baseType, value2, true));
    });
    return getBytes2(concat3(result2));
  }
  assertArgument2(false, "invalid type", "type", type);
}
function solidityPacked2(types, values) {
  assertArgument2(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack2(type, values[index]));
  });
  return hexlify2(concat3(tight));
}
function solidityPackedKeccak2562(types, values) {
  return keccak2562(solidityPacked2(types, values));
}
function solidityPackedSha2562(types, values) {
  return sha2564(solidityPacked2(types, values));
}

// ../../../../../node_modules/ethers/lib.esm/hash/typed-data.js
var padding2 = new Uint8Array(32);
padding2.fill(0);
var BN__12 = BigInt(-1);
var BN_019 = BigInt(0);
var BN_111 = BigInt(1);
var BN_MAX_UINT2564 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight2(value) {
  const bytes4 = getBytes2(value);
  const padOffset = bytes4.length % 32;
  if (padOffset) {
    return concat3([bytes4, padding2.slice(padOffset)]);
  }
  return hexlify2(bytes4);
}
var hexTrue2 = toBeHex2(BN_111, 32);
var hexFalse2 = toBeHex2(BN_019, 32);
var domainFieldTypes2 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames2 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString2(key) {
  return function(value) {
    assertArgument2(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks2 = {
  name: checkString2("name"),
  version: checkString2("version"),
  chainId: function(_value) {
    const value = getBigInt2(_value, "domain.chainId");
    assertArgument2(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity2(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress2(value).toLowerCase();
    } catch (error2) {
    }
    assertArgument2(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes4 = getBytes2(value, "domain.salt");
    assertArgument2(bytes4.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify2(bytes4);
  }
};
function getBaseEncoder2(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed3 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument2(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask2(BN_MAX_UINT2564, signed3 ? width - 1 : width);
      const boundsLower = signed3 ? (boundsUpper + BN_111) * BN__12 : BN_019;
      return function(_value) {
        const value = getBigInt2(_value, "value");
        assertArgument2(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex2(signed3 ? toTwos2(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument2(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes4 = getBytes2(value);
        assertArgument2(bytes4.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight2(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue2(getAddress2(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse2 : hexTrue2;
      };
    case "bytes":
      return function(value) {
        return keccak2562(value);
      };
    case "string":
      return function(value) {
        return id2(value);
      };
  }
  return null;
}
function encodeType2(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray2(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
var TypedDataEncoder2 = class _TypedDataEncoder {
  /**
   *  The primary type for the structured [[types]].
   *
   *  This is derived automatically from the [[types]], since no
   *  recursion is possible, once the DAG for the types is consturcted
   *  internally, the primary type must be the only remaining type with
   *  no parent nodes.
   */
  primaryType;
  #types;
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types) {
    this.#fullTypes = /* @__PURE__ */ new Map();
    this.#encoderCache = /* @__PURE__ */ new Map();
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types).forEach((type) => {
      types[type] = _types[type].map(({ name, type: type2 }) => {
        let { base: base2, index } = splitArray2(type2);
        if (base2 === "int" && !_types["int"]) {
          base2 = "int256";
        }
        if (base2 === "uint" && !_types["uint"]) {
          base2 = "uint256";
        }
        return { name, type: base2 + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument2(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray2(field.type).base;
        assertArgument2(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder2(baseType);
        if (encoder) {
          continue;
        }
        assertArgument2(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n5) => parents.get(n5).length === 0);
    assertArgument2(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument2(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", _types);
    defineProperties2(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument2(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType2(name, types[name]) + st.map((t2) => encodeType2(t2, types[t2])).join(""));
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray2(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument2(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result2 = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result2 = result2.map(keccak2562);
        }
        return keccak2562(concat3(result2));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id2(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result2 = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak2562(result2);
          }
          return result2;
        });
        values.unshift(encodedType);
        return concat3(values);
      };
    }
    assertArgument2(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result2 = this.#fullTypes.get(name);
    assertArgument2(result2, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result2;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak2562(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray2(type).array;
    if (array) {
      assertArgument2(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v2) => this._visit(array.prefix, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument2(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain3) {
    const domainFields = [];
    for (const name in domain3) {
      if (domain3[name] == null) {
        continue;
      }
      const type = domainFieldTypes2[name];
      assertArgument2(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain3);
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b4) => {
      return domainFieldNames2.indexOf(a2.name) - domainFieldNames2.indexOf(b4.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain3);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain3, types, value) {
    return concat3([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain3),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain3, types, value) {
    return keccak2562(_TypedDataEncoder.encode(domain3, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain3, types, value, resolveName) {
    domain3 = Object.assign({}, domain3);
    for (const key in domain3) {
      if (domain3[key] == null) {
        delete domain3[key];
      }
    }
    const ensCache = {};
    if (domain3.verifyingContract && !isHexString2(domain3.verifyingContract, 20)) {
      ensCache[domain3.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString2(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain3.verifyingContract && ensCache[domain3.verifyingContract]) {
      domain3.verifyingContract = ensCache[domain3.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain: domain3, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain3, types, value) {
    _TypedDataEncoder.hashDomain(domain3);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames2.forEach((name) => {
      const value2 = domain3[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks2[name](value2);
      domainTypes.push({ name, type: domainFieldTypes2[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument2(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify2(getBytes2(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt2(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument2(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument2(false, "unsupported type", "type", type);
      })
    };
  }
};
function verifyTypedData2(domain3, types, value, signature) {
  return recoverAddress2(TypedDataEncoder2.hash(domain3, types, value), signature);
}

// ../../../../../node_modules/ethers/lib.esm/abi/fragments.js
function setify2(items) {
  const result2 = /* @__PURE__ */ new Set();
  items.forEach((k) => result2.add(k));
  return Object.freeze(result2);
}
var _kwVisibDeploy2 = "external public payable override";
var KwVisibDeploy2 = setify2(_kwVisibDeploy2.split(" "));
var _kwVisib2 = "constant external internal payable private public pure view override";
var KwVisib2 = setify2(_kwVisib2.split(" "));
var _kwTypes2 = "constructor error event fallback function receive struct";
var KwTypes2 = setify2(_kwTypes2.split(" "));
var _kwModifiers2 = "calldata memory storage payable indexed";
var KwModifiers2 = setify2(_kwModifiers2.split(" "));
var _kwOther2 = "tuple returns";
var _keywords2 = [_kwTypes2, _kwModifiers2, _kwOther2, _kwVisib2].join(" ");
var Keywords2 = setify2(_keywords2.split(" "));
var SimpleTokens2 = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix2 = new RegExp("^(\\s*)");
var regexNumberPrefix2 = new RegExp("^([0-9]+)");
var regexIdPrefix2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType2 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var TokenString2 = class _TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new _TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new _TokenString(this.#tokens.slice(from, to).map((t2) => {
      return Object.freeze(Object.assign({}, t2, {
        match: t2.match - from,
        linkBack: t2.linkBack - from,
        linkNext: t2.linkNext - from
      }));
    }));
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result2 = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result2;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result2 = [];
    while (this.#offset < top.match - 1) {
      const link3 = this.peek().linkNext;
      result2.push(this.#subTokenString(this.#offset + 1, link3));
      this.#offset = link3;
    }
    this.#offset = top.match + 1;
    return result2;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result2 = this.peek();
    this.#offset++;
    return result2;
  }
  toString() {
    const tokens = [];
    for (let i2 = this.#offset; i2 < this.#tokens.length; i2++) {
      const token = this.#tokens[i2];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
function lex2(text3) {
  const tokens = [];
  const throwError3 = (message) => {
    const token = offset < text3.length ? JSON.stringify(text3[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text3.length) {
    let cur = text3.substring(offset);
    let match = cur.match(regexWhitespacePrefix2);
    if (match) {
      offset += match[1].length;
      cur = text3.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens2[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError3("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber2(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix2);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords2.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType2)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix2);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString2(tokens.map((t2) => Object.freeze(t2)));
}
function allowSingle2(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName2(type, tokens) {
  if (tokens.peekKeyword(KwTypes2)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords2(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability2(tokens) {
  let modifiers = consumeKeywords2(tokens, KwVisib2);
  allowSingle2(modifiers, setify2("constant payable nonpayable".split(" ")));
  allowSingle2(modifiers, setify2("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams2(tokens, allowIndexed) {
  return tokens.popParams().map((t2) => ParamType2.from(t2, allowIndexed));
}
function consumeGas2(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt2(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi2(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
var regexArrayType2 = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType2(type) {
  const match = type.match(regexType2);
  assertArgument2(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument2(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument2(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard10 = {};
var internal3 = Symbol.for("_ethers_internal");
var ParamTypeInternal2 = "_ParamTypeInternal";
var ErrorFragmentInternal2 = "_ErrorInternal";
var EventFragmentInternal2 = "_EventInternal";
var ConstructorFragmentInternal2 = "_ConstructorInternal";
var FallbackFragmentInternal2 = "_FallbackInternal";
var FunctionFragmentInternal2 = "_FunctionInternal";
var StructFragmentInternal2 = "_StructInternal";
var ParamType2 = class _ParamType {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */
  name;
  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */
  type;
  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */
  baseType;
  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */
  indexed;
  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */
  components;
  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */
  arrayLength;
  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */
  arrayChildren;
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate2(guard, _guard10, "ParamType");
    Object.defineProperty(this, internal3, { value: ParamTypeInternal2 });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties2(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result4 = JSON.parse(this.arrayChildren.format("json"));
        result4.name = name;
        result4.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result4);
      }
      const result3 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result3.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result3.components = this.components.map((c2) => JSON.parse(c2.format(format3)));
      }
      return JSON.stringify(result3);
    }
    let result2 = "";
    if (this.isArray()) {
      result2 += this.arrayChildren.format(format3);
      result2 += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result2 += "(" + this.components.map((comp) => comp.format(format3)).join(format3 === "full" ? ", " : ",") + ")";
      } else {
        result2 += this.type;
      }
    }
    if (format3 !== "sighash") {
      if (this.indexed === true) {
        result2 += " indexed";
      }
      if (format3 === "full" && this.name) {
        result2 += " " + this.name;
      }
    }
    return result2;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process3) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2) => _this.arrayChildren.walk(v2, process3));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2, i2) => _this.components[i2].walk(v2, process3));
    }
    return process3(this.type, value);
  }
  #walkAsync(promises2, value, process3, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result3 = value.slice();
      result3.forEach((value2, index) => {
        childType.#walkAsync(promises2, value2, process3, (value3) => {
          result3[index] = value3;
        });
      });
      setValue(result3);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result3;
      if (Array.isArray(value)) {
        result3 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result3 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result3.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result3.forEach((value2, index) => {
        components[index].#walkAsync(promises2, value2, process3, (value3) => {
          result3[index] = value3;
        });
      });
      setValue(result3);
      return;
    }
    const result2 = process3(this.type, value);
    if (result2.then) {
      promises2.push(async function() {
        setValue(await result2);
      }());
    } else {
      setValue(result2);
    }
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process3) {
    const promises2 = [];
    const result2 = [value];
    this.#walkAsync(promises2, value, process3, (value2) => {
      result2[0] = value2;
    });
    if (promises2.length) {
      await Promise.all(promises2);
    }
    return result2[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex2(obj), allowIndexed);
      } catch (error2) {
        assertArgument2(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords2(obj, setify2(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t2) => _ParamType.from(t2));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType2(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard10, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords2(obj, KwModifiers2);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard10, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument2(!name || typeof name === "string" && name.match(regexId2), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument2(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType2);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard10, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard10, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType2(obj.type);
    return new _ParamType(_guard10, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal3] === ParamTypeInternal2;
  }
};
var Fragment2 = class _Fragment {
  /**
   *  The type of the fragment.
   */
  type;
  /**
   *  The inputs for the fragment.
   */
  inputs;
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    assertPrivate2(guard, _guard10, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties2(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        _Fragment.from(JSON.parse(obj));
      } catch (e3) {
      }
      return _Fragment.from(lex2(obj));
    }
    if (obj instanceof TokenString2) {
      const type = obj.peekKeyword(KwTypes2);
      switch (type) {
        case "constructor":
          return ConstructorFragment2.from(obj);
        case "error":
          return ErrorFragment2.from(obj);
        case "event":
          return EventFragment2.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment2.from(obj);
        case "function":
          return FunctionFragment2.from(obj);
        case "struct":
          return StructFragment2.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment2.from(obj);
        case "error":
          return ErrorFragment2.from(obj);
        case "event":
          return EventFragment2.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment2.from(obj);
        case "function":
          return FunctionFragment2.from(obj);
        case "struct":
          return StructFragment2.from(obj);
      }
      assert5(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument2(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment2.isFragment(value);
  }
};
var NamedFragment2 = class extends Fragment2 {
  /**
   *  The name of the fragment.
   */
  name;
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument2(typeof name === "string" && name.match(regexId2), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties2(this, { name });
  }
};
function joinParams2(format3, params) {
  return "(" + params.map((p3) => p3.format(format3)).join(format3 === "full" ? ", " : ",") + ")";
}
var ErrorFragment2 = class _ErrorFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal3, { value: ErrorFragmentInternal2 });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id2(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format3)))
      });
    }
    const result2 = [];
    if (format3 !== "sighash") {
      result2.push("error");
    }
    result2.push(this.name + joinParams2(format3, this.inputs));
    return result2.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ErrorFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("error", obj);
      const inputs = consumeParams2(obj);
      consumeEoi2(obj);
      return new _ErrorFragment(_guard10, name, inputs);
    }
    return new _ErrorFragment(_guard10, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === ErrorFragmentInternal2;
  }
};
var EventFragment2 = class _EventFragment extends NamedFragment2 {
  /**
   *  Whether this event is anonymous.
   */
  anonymous;
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal3, { value: EventFragmentInternal2 });
    defineProperties2(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id2(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i2) => JSON.parse(i2.format(format3)))
      });
    }
    const result2 = [];
    if (format3 !== "sighash") {
      result2.push("event");
    }
    result2.push(this.name + joinParams2(format3, this.inputs));
    if (format3 !== "sighash" && this.anonymous) {
      result2.push("anonymous");
    }
    return result2.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p3) => ParamType2.from(p3));
    const fragment = new _EventFragment(_guard10, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (_EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _EventFragment.from(lex2(obj));
      } catch (error2) {
        assertArgument2(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("event", obj);
      const inputs = consumeParams2(obj, true);
      const anonymous = !!consumeKeywords2(obj, setify2(["anonymous"])).has("anonymous");
      consumeEoi2(obj);
      return new _EventFragment(_guard10, name, inputs, anonymous);
    }
    return new _EventFragment(_guard10, obj.name, obj.inputs ? obj.inputs.map((p3) => ParamType2.from(p3, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === EventFragmentInternal2;
  }
};
var ConstructorFragment2 = class _ConstructorFragment extends Fragment2 {
  /**
   *  Whether the constructor can receive an endowment.
   */
  payable;
  /**
   *  The recommended gas limit for deployment or ``null``.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal3, { value: ConstructorFragmentInternal2 });
    defineProperties2(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format3) {
    assert5(format3 != null && format3 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format3 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i2) => JSON.parse(i2.format(format3)))
      });
    }
    const result2 = [`constructor${joinParams2(format3, this.inputs)}`];
    if (this.payable) {
      result2.push("payable");
    }
    if (this.gas != null) {
      result2.push(`@${this.gas.toString()}`);
    }
    return result2.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ConstructorFragment.from(lex2(obj));
      } catch (error2) {
        assertArgument2(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      consumeKeywords2(obj, setify2(["constructor"]));
      const inputs = consumeParams2(obj);
      const payable = !!consumeKeywords2(obj, KwVisibDeploy2).has("payable");
      const gas = consumeGas2(obj);
      consumeEoi2(obj);
      return new _ConstructorFragment(_guard10, "constructor", inputs, payable, gas);
    }
    return new _ConstructorFragment(_guard10, "constructor", obj.inputs ? obj.inputs.map(ParamType2.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === ConstructorFragmentInternal2;
  }
};
var FallbackFragment2 = class _FallbackFragment extends Fragment2 {
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal3, { value: FallbackFragmentInternal2 });
    defineProperties2(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format3) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format3 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FallbackFragment.from(lex2(obj));
      } catch (error2) {
        assertArgument2(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify2(["fallback", "receive"]));
      assertArgument2(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify2(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams2(obj);
        assertArgument2(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords2(obj, setify2(["payable"]));
        consumeEoi2(obj);
        return new _FallbackFragment(_guard10, [], true);
      }
      let inputs = consumeParams2(obj);
      if (inputs.length) {
        assertArgument2(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i2) => i2.format("minimal")).join(", "));
      } else {
        inputs = [ParamType2.from("bytes")];
      }
      const mutability = consumeMutability2(obj);
      assertArgument2(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords2(obj, setify2(["returns"])).has("returns")) {
        const outputs = consumeParams2(obj);
        assertArgument2(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i2) => i2.format("minimal")).join(", "));
      }
      consumeEoi2(obj);
      return new _FallbackFragment(_guard10, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new _FallbackFragment(_guard10, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType2.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new _FallbackFragment(_guard10, inputs, payable);
    }
    assertArgument2(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === FallbackFragmentInternal2;
  }
};
var FunctionFragment2 = class _FunctionFragment extends NamedFragment2 {
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */
  constant;
  /**
   *  The returned types for the result of calling this function.
   */
  outputs;
  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */
  stateMutability;
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  /**
   *  The recommended gas limit to send when calling this function.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal3, { value: FunctionFragmentInternal2 });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties2(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id2(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format3) {
    if (format3 == null) {
      format3 = "sighash";
    }
    if (format3 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i2) => JSON.parse(i2.format(format3))),
        outputs: this.outputs.map((o3) => JSON.parse(o3.format(format3)))
      });
    }
    const result2 = [];
    if (format3 !== "sighash") {
      result2.push("function");
    }
    result2.push(this.name + joinParams2(format3, this.inputs));
    if (format3 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result2.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result2.push("returns");
        result2.push(joinParams2(format3, this.outputs));
      }
      if (this.gas != null) {
        result2.push(`@${this.gas.toString()}`);
      }
    }
    return result2.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p3) => ParamType2.from(p3));
    const fragment = new _FunctionFragment(_guard10, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FunctionFragment.from(lex2(obj));
      } catch (error2) {
        assertArgument2(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("function", obj);
      const inputs = consumeParams2(obj);
      const mutability = consumeMutability2(obj);
      let outputs = [];
      if (consumeKeywords2(obj, setify2(["returns"])).has("returns")) {
        outputs = consumeParams2(obj);
      }
      const gas = consumeGas2(obj);
      consumeEoi2(obj);
      return new _FunctionFragment(_guard10, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new _FunctionFragment(_guard10, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType2.from) : [], obj.outputs ? obj.outputs.map(ParamType2.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === FunctionFragmentInternal2;
  }
};
var StructFragment2 = class _StructFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal3, { value: StructFragmentInternal2 });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return _StructFragment.from(lex2(obj));
      } catch (error2) {
        assertArgument2(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("struct", obj);
      const inputs = consumeParams2(obj);
      consumeEoi2(obj);
      return new _StructFragment(_guard10, name, inputs);
    }
    return new _StructFragment(_guard10, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === StructFragmentInternal2;
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/abi-coder.js
var PanicReasons3 = /* @__PURE__ */ new Map();
PanicReasons3.set(0, "GENERIC_PANIC");
PanicReasons3.set(1, "ASSERT_FALSE");
PanicReasons3.set(17, "OVERFLOW");
PanicReasons3.set(18, "DIVIDE_BY_ZERO");
PanicReasons3.set(33, "ENUM_RANGE_ERROR");
PanicReasons3.set(34, "BAD_STORAGE_DATA");
PanicReasons3.set(49, "STACK_UNDERFLOW");
PanicReasons3.set(50, "ARRAY_RANGE_ERROR");
PanicReasons3.set(65, "OUT_OF_MEMORY");
PanicReasons3.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes2 = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber2 = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder2 = null;
var defaultMaxInflation2 = 1024;
function getBuiltinCallException2(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes4 = getBytes2(data);
    data = hexlify2(data);
    if (bytes4.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes4.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify2(bytes4.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes4.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error2) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify2(bytes4.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes4.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons3.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error2) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress2(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress2(tx.from);
  }
  return makeError2(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
var AbiCoder2 = class _AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder2(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder2(param.components.map((c2) => this.#getCoder(c2)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder2(param.name);
      case "bool":
        return new BooleanCoder2(param.name);
      case "string":
        return new StringCoder2(param.name);
      case "bytes":
        return new BytesCoder2(param.name);
      case "":
        return new NullCoder2(param.name);
    }
    let match = param.type.match(paramTypeNumber2);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument2(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder2(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes2);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument2(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder2(size, param.name);
    }
    assertArgument2(false, "invalid type", "type", param.type);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => this.#getCoder(ParamType2.from(type)));
    const coder = new TupleCoder2(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount2(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => this.#getCoder(ParamType2.from(type)));
    const coder = new TupleCoder2(coders, "_");
    const writer = new Writer2();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => this.#getCoder(ParamType2.from(type)));
    const coder = new TupleCoder2(coders, "_");
    return coder.decode(new Reader2(data, loose, defaultMaxInflation2));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument2(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation2 = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder2 == null) {
      defaultCoder2 = new _AbiCoder();
    }
    return defaultCoder2;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException2(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};

// ../../../../../node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String2(text3) {
  const bytes4 = toUtf8Bytes2(text3);
  if (bytes4.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes2(bytes4, 32);
}
function decodeBytes32String2(_bytes) {
  const data = getBytes2(_bytes, "bytes");
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String2(data.slice(0, length));
}

// ../../../../../node_modules/ethers/lib.esm/abi/interface.js
var LogDescription2 = class {
  /**
   *  The matching fragment for the ``topic0``.
   */
  fragment;
  /**
   *  The name of the Event.
   */
  name;
  /**
   *  The full Event signature.
   */
  signature;
  /**
   *  The topic hash for the Event.
   */
  topic;
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  args;
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args2) {
    const name = fragment.name, signature = fragment.format();
    defineProperties2(this, {
      fragment,
      name,
      signature,
      topic,
      args: args2
    });
  }
};
var TransactionDescription2 = class {
  /**
   *  The matching fragment from the transaction ``data``.
   */
  fragment;
  /**
   *  The name of the Function from the transaction ``data``.
   */
  name;
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  args;
  /**
   *  The full Function signature from the transaction ``data``.
   */
  signature;
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  selector;
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  value;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args2, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties2(this, {
      fragment,
      name,
      args: args2,
      signature,
      selector,
      value
    });
  }
};
var ErrorDescription2 = class {
  /**
   *  The matching fragment.
   */
  fragment;
  /**
   *  The name of the Error.
   */
  name;
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  args;
  /**
   *  The full Error signature.
   */
  signature;
  /**
   *  The selector for the Error.
   */
  selector;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args2) {
    const name = fragment.name, signature = fragment.format();
    defineProperties2(this, {
      fragment,
      name,
      args: args2,
      signature,
      selector
    });
  }
};
var Indexed2 = class {
  /**
   *  The ``keccak256`` of the value logged.
   */
  hash;
  /**
   *  @_ignore:
   */
  _isIndexed;
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  /**
   *  @_ignore:
   */
  constructor(hash3) {
    defineProperties2(this, { hash: hash3, _isIndexed: true });
  }
};
var PanicReasons4 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors2 = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons4[code.toString()]) {
        reason = PanicReasons4[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
var Interface2 = class _Interface {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */
  fragments;
  /**
   *  The Contract constructor.
   */
  deploy;
  /**
   *  The Fallback method, if any.
   */
  fallback;
  /**
   *  If receiving ether is supported.
   */
  receive;
  #errors;
  #events;
  #functions;
  //    #structs: Map<string, StructFragment>;
  #abiCoder;
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    this.#functions = /* @__PURE__ */ new Map();
    this.#errors = /* @__PURE__ */ new Map();
    this.#events = /* @__PURE__ */ new Map();
    const frags = [];
    for (const a2 of abi) {
      try {
        frags.push(Fragment2.from(a2));
      } catch (error2) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error2.message);
      }
    }
    defineProperties2(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties2(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument2(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties2(this, {
        deploy: ConstructorFragment2.from("constructor()")
      });
    }
    defineProperties2(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format3 = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f4) => f4.format(format3));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f4) => f4.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder2.defaultAbiCoder();
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  #getFunction(key, values, forceUnique) {
    if (isHexString2(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed2.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          const inputs = matching[i2].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i2, 1);
          }
        }
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          const inputs = matching[i2].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed2.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i2, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i2, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument2(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result2 = this.#functions.get(FunctionFragment2.from(key).format());
    if (result2) {
      return result2;
    }
    return null;
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument2(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names3 = Array.from(this.#functions.keys());
    names3.sort((a2, b4) => a2.localeCompare(b4));
    for (let i2 = 0; i2 < names3.length; i2++) {
      const name = names3[i2];
      callback(this.#functions.get(name), i2);
    }
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  #getEvent(key, values, forceUnique) {
    if (isHexString2(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          if (matching[i2].inputs.length < values.length) {
            matching.splice(i2, 1);
          }
        }
        for (let i2 = matching.length - 1; i2 >= 0; i2--) {
          const inputs = matching[i2].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed2.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i2, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument2(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result2 = this.#events.get(EventFragment2.from(key).format());
    if (result2) {
      return result2;
    }
    return null;
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument2(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names3 = Array.from(this.#events.keys());
    names3.sort((a2, b4) => a2.localeCompare(b4));
    for (let i2 = 0; i2 < names3.length; i2++) {
      const name = names3[i2];
      callback(this.#events.get(name), i2);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString2(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors2[selector]) {
        return ErrorFragment2.from(BuiltinErrors2[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment2.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment2.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument2(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment2.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment2.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment2.from("error Panic(uint256)");
    }
    const result2 = this.#errors.get(key);
    if (result2) {
      return result2;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names3 = Array.from(this.#errors.keys());
    names3.sort((a2, b4) => a2.localeCompare(b4));
    for (let i2 = 0; i2 < names3.length; i2++) {
      const name = names3[i2];
      callback(this.#errors.get(name), i2);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return this.#abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f4 = this.getError(fragment);
      assertArgument2(f4, "unknown error", "fragment", fragment);
      fragment = f4;
    }
    assertArgument2(dataSlice2(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice2(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getError(fragment);
      assertArgument2(f4, "unknown error", "fragment", fragment);
      fragment = f4;
    }
    return concat3([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument2(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    assertArgument2(dataSlice2(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice2(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument2(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    return concat3([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument2(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    let message = "invalid length for result data";
    const bytes4 = getBytesCopy2(data);
    if (bytes4.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes4);
      } catch (error2) {
        message = "could not decode result data";
      }
    }
    assert5(false, message, "BAD_DATA", {
      value: hexlify2(bytes4),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data = getBytes2(_data, "data");
    const error2 = AbiCoder2.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error2.message.startsWith(customPrefix)) {
      const selector = hexlify2(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args2 = this.#abiCoder.decode(ef.inputs, data.slice(4));
          error2.revert = {
            name: ef.name,
            signature: ef.format(),
            args: args2
          };
          error2.reason = error2.revert.signature;
          error2.message = `execution reverted: ${error2.reason}`;
        } catch (e3) {
          error2.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error2.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error2;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument2(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    return hexlify2(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument2(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    assert5(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id2(value);
      } else if (param.type === "bytes") {
        return keccak2562(hexlify2(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex2(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes2(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue2(hexlify2(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument2(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument2(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument2(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument2(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id2(value));
        } else if (param.type === "bytes") {
          topics.push(keccak2562(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument2(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument2(isHexString2(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType2.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat3(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed2(null);
        } else if (dynamic[index]) {
          value = new Indexed2(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error2) {
            value = error2;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error2) {
          value = error2;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result3.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes2(tx.data, "tx.data");
    const value = getBigInt2(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify2(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args2 = this.#abiCoder.decode(fragment.inputs, data.slice(4));
    return new TransactionDescription2(fragment, fragment.selector, args2, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log3) {
    const fragment = this.getEvent(log3.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription2(fragment, fragment.topicHash, this.decodeEventLog(fragment, log3.data, log3.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify2(data);
    const fragment = this.getError(dataSlice2(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args2 = this.#abiCoder.decode(fragment.inputs, dataSlice2(hexData, 4));
    return new ErrorDescription2(fragment, fragment.selector, args2);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider.js
var BN_020 = BigInt(0);
function getValue4(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson2(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
var FeeData2 = class {
  /**
   *  The gas price for legacy networks.
   */
  gasPrice;
  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxFeePerGas;
  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxPriorityFeePerGas;
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties2(this, {
      gasPrice: getValue4(gasPrice),
      maxFeePerGas: getValue4(maxFeePerGas),
      maxPriorityFeePerGas: getValue4(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson2(gasPrice),
      maxFeePerGas: toJson2(maxFeePerGas),
      maxPriorityFeePerGas: toJson2(maxPriorityFeePerGas)
    };
  }
};
function copyRequest2(req) {
  const result2 = {};
  if (req.to) {
    result2.to = req.to;
  }
  if (req.from) {
    result2.from = req.from;
  }
  if (req.data) {
    result2.data = hexlify2(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result2[key] = getBigInt2(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result2[key] = getNumber2(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result2.accessList = accessListify2(req.accessList);
  }
  if (req.authorizationList) {
    result2.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result2.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result2.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result2.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result2.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result2.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result2.blobs = req.blobs.map((b4) => {
      if (isBytesLike2(b4)) {
        return hexlify2(b4);
      }
      return Object.assign({}, b4);
    });
  }
  return result2;
}
var Block2 = class {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */
  number;
  /**
   *  The block hash.
   *
   *  This hash includes all properties, so can be safely used to identify
   *  an exact set of block properties.
   */
  hash;
  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */
  timestamp;
  /**
   *  The block hash of the parent block.
   */
  parentHash;
  /**
   *  The hash tree root of the parent beacon block for the given
   *  execution block. See [[link-eip-4788]].
   */
  parentBeaconBlockRoot;
  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */
  nonce;
  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */
  difficulty;
  /**
   *  The total gas limit for this block.
   */
  gasLimit;
  /**
   *  The total gas used in this block.
   */
  gasUsed;
  /**
   *  The root hash for the global state after applying changes
   *  in this block.
   */
  stateRoot;
  /**
   *  The hash of the transaction receipts trie.
   */
  receiptsRoot;
  /**
   *  The total amount of blob gas consumed by the transactions
   *  within the block. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The running total of blob gas consumed in excess of the
   *  target, prior to the block. See [[link-eip-4844]].
   */
  excessBlobGas;
  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */
  miner;
  /**
   *  The latest RANDAO mix of the post beacon state of
   *  the previous block.
   */
  prevRandao;
  /**
   *  Any extra data the validator wished to include.
   */
  extraData;
  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */
  baseFeePerGas;
  #transactions;
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse2(tx, provider);
      }
      return tx;
    });
    defineProperties2(this, {
      provider,
      hash: getValue4(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue4(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue4(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert5(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash3, miner, prevRandao, nonce, number: number3, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp: timestamp2, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson2(baseFeePerGas),
      difficulty: toJson2(difficulty),
      extraData,
      gasLimit: toJson2(gasLimit),
      gasUsed: toJson2(gasUsed),
      blobGasUsed: toJson2(this.blobGasUsed),
      excessBlobGas: toJson2(this.excessBlobGas),
      hash: hash3,
      miner,
      prevRandao,
      nonce,
      number: number3,
      parentHash,
      timestamp: timestamp2,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return this.#transactions.length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash3 = indexOrHash.toLowerCase();
      for (const v2 of this.#transactions) {
        if (typeof v2 === "string") {
          if (v2 !== hash3) {
            continue;
          }
          tx = v2;
          break;
        } else {
          if (v2.hash !== hash3) {
            continue;
          }
          tx = v2;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument2(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter2(this);
  }
};
var Log2 = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The transaction hash of the transaction this log occurred in. Use the
   *  [[Log-getTransaction]] to get the [[TransactionResponse]].
   */
  transactionHash;
  /**
   *  The block hash of the block this log occurred in. Use the
   *  [[Log-getBlock]] to get the [[Block]].
   */
  blockHash;
  /**
   *  The block number of the block this log occurred in. It is preferred
   *  to use the [[Block-hash]] when fetching the related [[Block]],
   *  since in the case of an orphaned block, the block at that height may
   *  have changed.
   */
  blockNumber;
  /**
   *  If the **Log** represents a block that was removed due to an orphaned
   *  block, this will be true.
   *
   *  This can only happen within an orphan event listener.
   */
  removed;
  /**
   *  The address of the contract that emitted this log.
   */
  address;
  /**
   *  The data included in this log when it was emitted.
   */
  data;
  /**
   *  The indexed topics included in this log when it was emitted.
   *
   *  All topics are included in the bloom filters, so they can be
   *  efficiently filtered using the [[Provider-getLogs]] method.
   */
  topics;
  /**
   *  The index within the block this log occurred at. This is generally
   *  not useful to developers, but can be used with the various roots
   *  to proof inclusion within a block.
   */
  index;
  /**
   *  The index within the transaction of this log.
   */
  transactionIndex;
  /**
   *  @_ignore:
   */
  constructor(log3, provider) {
    this.provider = provider;
    const topics = Object.freeze(log3.topics.slice());
    defineProperties2(this, {
      transactionHash: log3.transactionHash,
      blockHash: log3.blockHash,
      blockNumber: log3.blockNumber,
      removed: log3.removed,
      address: log3.address,
      data: log3.data,
      topics,
      index: log3.index,
      transactionIndex: log3.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert5(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert5(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert5(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter2(this);
  }
};
var TransactionReceipt2 = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The address the transaction was sent to.
   */
  to;
  /**
   *  The sender of the transaction.
   */
  from;
  /**
   *  The address of the contract if the transaction was directly
   *  responsible for deploying one.
   *
   *  This is non-null **only** if the ``to`` is empty and the ``data``
   *  was successfully executed as initcode.
   */
  contractAddress;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The index of this transaction within the block transactions.
   */
  index;
  /**
   *  The block hash of the [[Block]] this transaction was included in.
   */
  blockHash;
  /**
   *  The block number of the [[Block]] this transaction was included in.
   */
  blockNumber;
  /**
   *  The bloom filter bytes that represent all logs that occurred within
   *  this transaction. This is generally not useful for most developers,
   *  but can be used to validate the included logs.
   */
  logsBloom;
  /**
   *  The actual amount of gas used by this transaction.
   *
   *  When creating a transaction, the amount of gas that will be used can
   *  only be approximated, but the sender must pay the gas fee for the
   *  entire gas limit. After the transaction, the difference is refunded.
   */
  gasUsed;
  /**
   *  The gas used for BLObs. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The amount of gas used by all transactions within the block for this
   *  and all transactions with a lower ``index``.
   *
   *  This is generally not useful for developers but can be used to
   *  validate certain aspects of execution.
   */
  cumulativeGasUsed;
  /**
   *  The actual gas price used during execution.
   *
   *  Due to the complexity of [[link-eip-1559]] this value can only
   *  be caluclated after the transaction has been mined, snce the base
   *  fee is protocol-enforced.
   */
  gasPrice;
  /**
   *  The price paid per BLOB in gas. See [[link-eip-4844]].
   */
  blobGasPrice;
  /**
   *  The [[link-eip-2718]] transaction type.
   */
  type;
  //readonly byzantium!: boolean;
  /**
   *  The status of this transaction, indicating success (i.e. ``1``) or
   *  a revert (i.e. ``0``).
   *
   *  This is available in post-byzantium blocks, but some backends may
   *  backfill this value.
   */
  status;
  /**
   *  The root hash of this transaction.
   *
   *  This is no present and was only included in pre-byzantium blocks, but
   *  could be used to validate certain parts of the receipt.
   */
  root;
  #logs;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log3) => {
      return new Log2(log3, provider);
    }));
    let gasPrice = BN_020;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties2(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return this.#logs;
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash3,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson2(this.cumulativeGasUsed),
      from,
      gasPrice: toJson2(this.gasPrice),
      blobGasUsed: toJson2(this.blobGasUsed),
      blobGasPrice: toJson2(this.blobGasPrice),
      gasUsed: toJson2(this.gasUsed),
      hash: hash3,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter2(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert5(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter2(this, other);
  }
};
var TransactionResponse2 = class _TransactionResponse {
  /**
   *  The provider this is connected to, which will influence how its
   *  methods will resolve its async inspection methods.
   */
  provider;
  /**
   *  The block number of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockNumber;
  /**
   *  The blockHash of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockHash;
  /**
   *  The index within the block that this transaction resides at.
   */
  index;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The [[link-eip-2718]] transaction envelope type. This is
   *  ``0`` for legacy transactions types.
   */
  type;
  /**
   *  The receiver of this transaction.
   *
   *  If ``null``, then the transaction is an initcode transaction.
   *  This means the result of executing the [[data]] will be deployed
   *  as a new contract on chain (assuming it does not revert) and the
   *  address may be computed using [[getCreateAddress]].
   */
  to;
  /**
   *  The sender of this transaction. It is implicitly computed
   *  from the transaction pre-image hash (as the digest) and the
   *  [[signature]] using ecrecover.
   */
  from;
  /**
   *  The nonce, which is used to prevent replay attacks and offer
   *  a method to ensure transactions from a given sender are explicitly
   *  ordered.
   *
   *  When sending a transaction, this must be equal to the number of
   *  transactions ever sent by [[from]].
   */
  nonce;
  /**
   *  The maximum units of gas this transaction can consume. If execution
   *  exceeds this, the entries transaction is reverted and the sender
   *  is charged for the full amount, despite not state changes being made.
   */
  gasLimit;
  /**
   *  The gas price can have various values, depending on the network.
   *
   *  In modern networks, for transactions that are included this is
   *  the //effective gas price// (the fee per gas that was actually
   *  charged), while for transactions that have not been included yet
   *  is the [[maxFeePerGas]].
   *
   *  For legacy transactions, or transactions on legacy networks, this
   *  is the fee that will be charged per unit of gas the transaction
   *  consumes.
   */
  gasPrice;
  /**
   *  The maximum priority fee (per unit of gas) to allow a
   *  validator to charge the sender. This is inclusive of the
   *  [[maxFeeFeePerGas]].
   */
  maxPriorityFeePerGas;
  /**
   *  The maximum fee (per unit of gas) to allow this transaction
   *  to charge the sender.
   */
  maxFeePerGas;
  /**
   *  The [[link-eip-4844]] max fee per BLOb gas.
   */
  maxFeePerBlobGas;
  /**
   *  The data.
   */
  data;
  /**
   *  The value, in wei. Use [[formatEther]] to format this value
   *  as ether.
   */
  value;
  /**
   *  The chain ID.
   */
  chainId;
  /**
   *  The signature.
   */
  signature;
  /**
   *  The [[link-eip-2930]] access list for transaction types that
   *  support it, otherwise ``null``.
   */
  accessList;
  /**
   *  The [[link-eip-4844]] BLOb versioned hashes.
   */
  blobVersionedHashes;
  /**
   *  The [[link-eip-7702]] authorizations (if any).
   */
  authorizationList;
  #startBlock;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    this.#startBlock = -1;
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash3, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson2(this.chainId),
      data,
      from,
      gasLimit: toJson2(this.gasLimit),
      gasPrice: toJson2(this.gasPrice),
      hash: hash3,
      maxFeePerGas: toJson2(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson2(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson2(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson2(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties2({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties2({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash3 of block) {
          if (hash3 === this.hash) {
            return;
          }
        }
        for (let i2 = 0; i2 < block.length; i2++) {
          const tx = await block.getTransaction(i2);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_020) {
              reason = "cancelled";
            }
            assert5(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert5(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve3, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError2("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve3(checkReceipt(receipt2));
          } catch (error2) {
            reject(error2);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error2) {
            if (isError4(error2, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error2);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert5(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter2(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert5(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert5(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter2(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument2(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
};
function createOrphanedBlockFilter2(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter2(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter2(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter2(log3) {
  return { orphan: "drop-log", log: {
    transactionHash: log3.transactionHash,
    blockHash: log3.blockHash,
    blockNumber: log3.blockNumber,
    address: log3.address,
    data: log3.data,
    topics: Object.freeze(log3.topics.slice()),
    index: log3.index
  } };
}

// ../../../../../node_modules/ethers/lib.esm/contract/wrappers.js
var EventLog2 = class extends Log2 {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The matching event.
   */
  fragment;
  /**
   *  The parsed arguments passed to the event by ``emit``.
   */
  args;
  /**
   * @_ignore:
   */
  constructor(log3, iface, fragment) {
    super(log3, log3.provider);
    const args2 = iface.decodeEventLog(fragment, log3.data, log3.topics);
    defineProperties2(this, { args: args2, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};
var UndecodedEventLog2 = class extends Log2 {
  /**
   *  The error encounted when trying to decode the log.
   */
  error;
  /**
   * @_ignore:
   */
  constructor(log3, error2) {
    super(log3, log3.provider);
    defineProperties2(this, { error: error2 });
  }
};
var ContractTransactionReceipt2 = class extends TransactionReceipt2 {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log3) => {
      const fragment = log3.topics.length ? this.#iface.getEvent(log3.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog2(log3, this.#iface, fragment);
        } catch (error2) {
          return new UndecodedEventLog2(log3, error2);
        }
      }
      return log3;
    });
  }
};
var ContractTransactionResponse2 = class extends TransactionResponse2 {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt2(this.#iface, this.provider, receipt);
  }
};
var ContractUnknownEventPayload2 = class extends EventPayload2 {
  /**
   *  The log with no matching events.
   */
  log;
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log3) {
    super(contract, listener, filter);
    defineProperties2(this, { log: log3 });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
};
var ContractEventPayload2 = class extends ContractUnknownEventPayload2 {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog2(_log, contract.interface, fragment));
    const args2 = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties2(this, { args: args2, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};

// ../../../../../node_modules/ethers/lib.esm/contract/contract.js
var BN_021 = BigInt(0);
function canCall2(value) {
  return value && typeof value.call === "function";
}
function canEstimate2(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve2(value) {
  return value && typeof value.resolveName === "function";
}
function canSend2(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver2(value) {
  if (value != null) {
    if (canResolve2(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
var PreparedTopicFilter2 = class {
  #filter;
  fragment;
  constructor(contract, fragment, args2) {
    defineProperties2(this, { fragment });
    if (fragment.inputs.length < args2.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner2(contract.runner, "resolveName");
    const resolver = canResolve2(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args2[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args2[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v2) => resolveAddress2(v2, resolver)));
            }
            return resolveAddress2(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
};
function getRunner2(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider2(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides2(arg, allowed) {
  const _overrides = Typed2.dereference(arg, "overrides");
  assertArgument2(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest2(_overrides);
  assertArgument2(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument2(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs2(_runner, inputs, args2) {
  const runner = getRunner2(_runner, "resolveName");
  const resolver = canResolve2(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args2[index], (type, value) => {
      value = Typed2.dereference(value, type);
      if (type === "address") {
        return resolveAddress2(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback2(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides2(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress2(tx.from, getResolver2(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt2(tx.value || BN_021, "overrides.value") === BN_021;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument2(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument2(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument2(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument2(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner2(contract.runner, "call");
    assert5(canCall2(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error2) {
      if (isCallException2(error2) && error2.data) {
        throw contract.interface.makeError(error2.data, tx);
      }
      throw error2;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert5(canSend2(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider2(contract.runner);
    return new ContractTransactionResponse2(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner2(contract.runner, "estimateGas");
    assert5(canEstimate2(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties2(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod2(contract, key) {
  const getFragment = function(...args2) {
    const fragment = contract.interface.getFunction(key, args2);
    assert5(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args: args2 }
    });
    return fragment;
  };
  const populateTransaction = async function(...args2) {
    const fragment = getFragment(...args2);
    let overrides = {};
    if (fragment.inputs.length + 1 === args2.length) {
      overrides = await copyOverrides2(args2.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress2(overrides.from, getResolver2(contract.runner));
      }
    }
    if (fragment.inputs.length !== args2.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs2(contract.runner, fragment.inputs, args2);
    return Object.assign({}, overrides, await resolveProperties2({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args2) {
    const result2 = await staticCallResult(...args2);
    if (result2.length === 1) {
      return result2[0];
    }
    return result2;
  };
  const send = async function(...args2) {
    const runner = contract.runner;
    assert5(canSend2(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args2));
    const provider = getProvider2(contract.runner);
    return new ContractTransactionResponse2(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args2) {
    const runner = getRunner2(contract.runner, "estimateGas");
    assert5(canEstimate2(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args2));
  };
  const staticCallResult = async function(...args2) {
    const runner = getRunner2(contract.runner, "call");
    assert5(canCall2(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args2);
    let result2 = "0x";
    try {
      result2 = await runner.call(tx);
    } catch (error2) {
      if (isCallException2(error2) && error2.data) {
        throw contract.interface.makeError(error2.data, tx);
      }
      throw error2;
    }
    const fragment = getFragment(...args2);
    return contract.interface.decodeFunctionResult(fragment, result2);
  };
  const method = async (...args2) => {
    const fragment = getFragment(...args2);
    if (fragment.constant) {
      return await staticCall(...args2);
    }
    return await send(...args2);
  };
  defineProperties2(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert5(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent2(contract, key) {
  const getFragment = function(...args2) {
    const fragment = contract.interface.getEvent(key, args2);
    assert5(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args: args2 }
    });
    return fragment;
  };
  const method = function(...args2) {
    return new PreparedTopicFilter2(contract, getFragment(...args2), args2);
  };
  defineProperties2(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert5(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
var internal4 = Symbol.for("_ethersInternal_contract");
var internalValues2 = /* @__PURE__ */ new WeakMap();
function setInternal2(contract, values) {
  internalValues2.set(contract[internal4], values);
}
function getInternal2(contract) {
  return internalValues2.get(contract[internal4]);
}
function isDeferred2(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo2(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString2(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument2(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e3) => {
      if (e3 == null) {
        return null;
      }
      if (Array.isArray(e3)) {
        return e3.map(topicHashify);
      }
      return topicHashify(e3);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString2(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument2(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred2(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument2(false, "unknown event name", "event", event);
  }
  topics = topics.map((t2) => {
    if (t2 == null) {
      return null;
    }
    if (Array.isArray(t2)) {
      const items = Array.from(new Set(t2.map((t3) => t3.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t2.toLowerCase();
  });
  const tag = topics.map((t2) => {
    if (t2 == null) {
      return "null";
    }
    if (Array.isArray(t2)) {
      return t2.join("|");
    }
    return t2;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub2(contract, event) {
  const { subs } = getInternal2(contract);
  return subs.get((await getSubInfo2(contract, event)).tag) || null;
}
async function getSub2(contract, operation, event) {
  const provider = getProvider2(contract.runner);
  assert5(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo2(contract, event);
  const { addr, subs } = getInternal2(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log3) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log3.topics[0]);
        } catch (error2) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args2 = fragment ? contract.interface.decodeEventLog(fragment, log3.data, log3.topics) : [];
        emit4(contract, event, args2, (listener2) => {
          return new ContractEventPayload2(contract, listener2, event, _foundFragment, log3);
        });
      } else {
        emit4(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload2(contract, listener2, event, log3);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
var lastEmit2 = Promise.resolve();
async function _emit2(contract, event, args2, payloadFunc) {
  await lastEmit2;
  const sub = await hasSub2(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once: once4 }) => {
    const passArgs = Array.from(args2);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once4 ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error2) {
    }
    return !once4;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal2(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit4(contract, event, args2, payloadFunc) {
  try {
    await lastEmit2;
  } catch (error2) {
  }
  const resultPromise = _emit2(contract, event, args2, payloadFunc);
  lastEmit2 = resultPromise;
  return await resultPromise;
}
var passProperties4 = ["then"];
var BaseContract2 = class _BaseContract {
  /**
   *  The target to connect to.
   *
   *  This can be an address, ENS name or any [[Addressable]], such as
   *  another contract. To get the resovled address, use the ``getAddress``
   *  method.
   */
  target;
  /**
   *  The contract Interface.
   */
  interface;
  /**
   *  The connected runner. This is generally a [[Provider]] or a
   *  [[Signer]], which dictates what operations are supported.
   *
   *  For example, a **Contract** connected to a [[Provider]] may
   *  only execute read-only operations.
   */
  runner;
  /**
   *  All the Events available on this contract.
   */
  filters;
  /**
   *  @_ignore:
   */
  [internal4];
  /**
   *  The fallback or receive function if any.
   */
  fallback;
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    assertArgument2(typeof target === "string" || isAddressable2(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface2.from(abi);
    defineProperties2(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal4, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider2(runner);
      deployTx = new ContractTransactionResponse2(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString2(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner2(runner, "resolveName");
        if (!canResolve2(resolver)) {
          throw makeError2("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError2("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal2(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal2(this).addr = addr2;
        return addr2;
      });
    }
    setInternal2(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties4.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error2) {
          if (!isError4(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
            throw error2;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties4.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties2(this, { filters });
    defineProperties2(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback2(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties4.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error2) {
          if (!isError4(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
            throw error2;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties4.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal2(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider2(this.runner);
    assert5(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider2(this.runner);
    assert5(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve3, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve3(this);
          }
          provider.once("block", checkCode);
        } catch (error2) {
          reject(error2);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal2(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod2(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent2(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash3) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal2(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo2(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider2(this.runner);
    assert5(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log3) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log3.topics[0]);
        } catch (error2) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog2(log3, this.interface, foundFragment);
        } catch (error2) {
          return new UndecodedEventLog2(log3, error2);
        }
      }
      return new Log2(log3, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub2(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub2(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args2) {
    return await emit4(this, event, args2, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub2(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal2(this);
    let total = 0;
    for (const { listeners: listeners3 } of subs.values()) {
      total += listeners3.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub2(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal2(this);
    let result2 = [];
    for (const { listeners: listeners3 } of subs.values()) {
      result2 = result2.concat(listeners3.map(({ listener }) => listener));
    }
    return result2;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub2(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal2(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub2(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal2(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal2(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
function _ContractBase2() {
  return BaseContract2;
}
var Contract2 = class extends _ContractBase2() {
};

// ../../../../../node_modules/ethers/lib.esm/contract/factory.js
var ContractFactory2 = class _ContractFactory {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The Contract deployment bytecode. Often called the initcode.
   */
  bytecode;
  /**
   *  The ContractRunner to deploy the Contract as.
   */
  runner;
  /**
   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
   *  optionally connected to %%runner%%.
   *
   *  The %%bytecode%% may be the ``bytecode`` property within the
   *  standard Solidity JSON output.
   */
  constructor(abi, bytecode, runner) {
    const iface = Interface2.from(abi);
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify2(getBytes2(bytecode));
    } else {
      if (typeof bytecode === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify2(getBytes2(bytecode));
    }
    defineProperties2(this, {
      bytecode,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract2(target, this.interface, this.runner);
  }
  /**
   *  Resolves to the transaction to deploy the contract, passing %%args%%
   *  into the constructor.
   */
  async getDeployTransaction(...args2) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args2.length) {
      overrides = await copyOverrides2(args2.pop());
    }
    if (fragment.inputs.length !== args2.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs2(this.runner, fragment.inputs, args2);
    const data = concat3([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data });
  }
  /**
   *  Resolves to the Contract deployed by passing %%args%% into the
   *  constructor.
   *
   *  This will resolve to the Contract before it has been deployed to the
   *  network, so the [[BaseContract-waitForDeployment]] should be used before
   *  sending any transactions to it.
   */
  async deploy(...args2) {
    const tx = await this.getDeployTransaction(...args2);
    assert5(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx);
    const address = getCreateAddress2(sentTx);
    return new BaseContract2(address, this.interface, this.runner, sentTx);
  }
  /**
   *  Return a new **ContractFactory** with the same ABI and bytecode,
   *  but connected to %%runner%%.
   */
  connect(runner) {
    return new _ContractFactory(this.interface, this.bytecode, runner);
  }
  /**
   *  Create a new **ContractFactory** from the standard Solidity JSON output.
   */
  static fromSolidity(output3, runner) {
    assertArgument2(output3 != null, "bad compiler output", "output", output3);
    if (typeof output3 === "string") {
      output3 = JSON.parse(output3);
    }
    const abi = output3.abi;
    let bytecode = "";
    if (output3.bytecode) {
      bytecode = output3.bytecode;
    } else if (output3.evm && output3.evm.bytecode) {
      bytecode = output3.evm.bytecode;
    }
    return new this(abi, bytecode, runner);
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink2(link3) {
  if (link3.match(/^ipfs:\/\/ipfs\//i)) {
    link3 = link3.substring(12);
  } else if (link3.match(/^ipfs:\/\//i)) {
    link3 = link3.substring(7);
  } else {
    assertArgument2(false, "unsupported IPFS format", "link", link3);
  }
  return `https://gateway.ipfs.io/ipfs/${link3}`;
}
var MulticoinProviderPlugin2 = class {
  /**
   *  The name.
   */
  name;
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    defineProperties2(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
};
var matcherIpfs2 = new RegExp("^(ipfs)://(.*)$", "i");
var matchers2 = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs2,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var EnsResolver2 = class _EnsResolver {
  /**
   *  The connected provider.
   */
  provider;
  /**
   *  The address of the resolver.
   */
  address;
  /**
   *  The name this resolver was resolved against.
   */
  name;
  // For EIP-2544 names, the ancestor that provided the resolver
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties2(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract2(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error2) {
          if (isError4(error2, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error2;
        }
      })();
    }
    return await this.#supports2544;
  }
  async #fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash2(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert5(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode2(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result2 = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result2)[0];
      }
      return result2;
    } catch (error2) {
      if (!isError4(error2, "CALL_EXCEPTION")) {
        throw error2;
      }
    }
    return null;
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result2 = await this.#fetch("addr(bytes32)");
        if (result2 == null || result2 === ZeroAddress2) {
          return null;
        }
        return result2;
      } catch (error2) {
        if (isError4(error2, "CALL_EXCEPTION")) {
          return null;
        }
        throw error2;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString2(data2, 20)) {
        return getAddress2(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin2)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert5(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await this.#fetch("text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await this.#fetch("contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase582("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert5(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i2 = 0; i2 < matchers2.length; i2++) {
        const match = avatar.match(matchers2[i2]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url2 = getIpfsLink2(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url2 });
            return { linkage, url: url2 };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract2(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex2(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink2(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest2(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error2) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error3) {
                const bytes4 = response.body;
                if (bytes4) {
                  linkage.push({ type: "!metadata", value: hexlify2(bytes4) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs2);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink2(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error2) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert5(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async #getResolver(provider, name) {
    const ensAddr = await _EnsResolver.getEnsAddress(provider);
    try {
      const contract = new Contract2(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract.resolver(namehash2(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress2) {
        return null;
      }
      return addr;
    } catch (error2) {
      throw error2;
    }
    return null;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await _EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/format.js
var BN_022 = BigInt(0);
function allowNull2(format3, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format3(value);
  };
}
function arrayOf2(format3, allowNull3) {
  return (array) => {
    if (allowNull3 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i2) => format3(i2));
  };
}
function object2(format3, altNames) {
  return (value) => {
    const result2 = {};
    for (const key in format3) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format3[key](value[srcKey]);
        if (nv !== void 0) {
          result2[key] = nv;
        }
      } catch (error2) {
        const message = error2 instanceof Error ? error2.message : "not-an-error";
        assert5(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result2;
  };
}
function formatBoolean2(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument2(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData2(value) {
  assertArgument2(isHexString2(value, true), "invalid data", "value", value);
  return value;
}
function formatHash2(value) {
  assertArgument2(isHexString2(value, 32), "invalid hash", "value", value);
  return value;
}
var _formatLog2 = object2({
  address: getAddress2,
  blockHash: formatHash2,
  blockNumber: getNumber2,
  data: formatData2,
  index: getNumber2,
  removed: allowNull2(formatBoolean2, false),
  topics: arrayOf2(formatHash2),
  transactionHash: formatHash2,
  transactionIndex: getNumber2
}, {
  index: ["logIndex"]
});
function formatLog2(value) {
  return _formatLog2(value);
}
var _formatBlock2 = object2({
  hash: allowNull2(formatHash2),
  parentHash: formatHash2,
  parentBeaconBlockRoot: allowNull2(formatHash2, null),
  number: getNumber2,
  timestamp: getNumber2,
  nonce: allowNull2(formatData2),
  difficulty: getBigInt2,
  gasLimit: getBigInt2,
  gasUsed: getBigInt2,
  stateRoot: allowNull2(formatHash2, null),
  receiptsRoot: allowNull2(formatHash2, null),
  blobGasUsed: allowNull2(getBigInt2, null),
  excessBlobGas: allowNull2(getBigInt2, null),
  miner: allowNull2(getAddress2),
  prevRandao: allowNull2(formatHash2, null),
  extraData: formatData2,
  baseFeePerGas: allowNull2(getBigInt2)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock2(value) {
  const result2 = _formatBlock2(value);
  result2.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse2(tx);
  });
  return result2;
}
var _formatReceiptLog2 = object2({
  transactionIndex: getNumber2,
  blockNumber: getNumber2,
  transactionHash: formatHash2,
  address: getAddress2,
  topics: arrayOf2(formatHash2),
  data: formatData2,
  index: getNumber2,
  blockHash: formatHash2
}, {
  index: ["logIndex"]
});
function formatReceiptLog2(value) {
  return _formatReceiptLog2(value);
}
var _formatTransactionReceipt2 = object2({
  to: allowNull2(getAddress2, null),
  from: allowNull2(getAddress2, null),
  contractAddress: allowNull2(getAddress2, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber2,
  root: allowNull2(hexlify2),
  gasUsed: getBigInt2,
  blobGasUsed: allowNull2(getBigInt2, null),
  logsBloom: allowNull2(formatData2),
  blockHash: formatHash2,
  hash: formatHash2,
  logs: arrayOf2(formatReceiptLog2),
  blockNumber: getNumber2,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt2,
  effectiveGasPrice: allowNull2(getBigInt2),
  blobGasPrice: allowNull2(getBigInt2, null),
  status: allowNull2(getNumber2),
  type: allowNull2(getNumber2, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt2(value) {
  return _formatTransactionReceipt2(value);
}
function formatTransactionResponse2(value) {
  if (value.to && getBigInt2(value.to) === BN_022) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result2 = object2({
    hash: formatHash2,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull2(getNumber2, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber2(value2);
    },
    accessList: allowNull2(accessListify2, null),
    blobVersionedHashes: allowNull2(arrayOf2(formatHash2, true), null),
    authorizationList: allowNull2(arrayOf2((v2) => {
      return {
        address: getAddress2(v2.address),
        chainId: getBigInt2(v2.chainId),
        nonce: getBigInt2(v2.nonce),
        signature: Signature2.from(v2.signature ? v2.signature : v2)
      };
    }, false), null),
    blockHash: allowNull2(formatHash2, null),
    blockNumber: allowNull2(getNumber2, null),
    transactionIndex: allowNull2(getNumber2, null),
    from: getAddress2,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull2(getBigInt2),
    maxPriorityFeePerGas: allowNull2(getBigInt2),
    maxFeePerGas: allowNull2(getBigInt2),
    maxFeePerBlobGas: allowNull2(getBigInt2, null),
    gasLimit: getBigInt2,
    to: allowNull2(getAddress2, null),
    value: getBigInt2,
    nonce: getNumber2,
    data: formatData2,
    creates: allowNull2(getAddress2, null),
    chainId: allowNull2(getBigInt2, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result2.to == null && result2.creates == null) {
    result2.creates = getCreateAddress2(result2);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result2.accessList = [];
  }
  if (value.signature) {
    result2.signature = Signature2.from(value.signature);
  } else {
    result2.signature = Signature2.from(value);
  }
  if (result2.chainId == null) {
    const chainId = result2.signature.legacyChainId;
    if (chainId != null) {
      result2.chainId = chainId;
    }
  }
  if (result2.blockHash && getBigInt2(result2.blockHash) === BN_022) {
    result2.blockHash = null;
  }
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress2 = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
var NetworkPlugin2 = class _NetworkPlugin {
  /**
   *  The name of the plugin.
   *
   *  It is recommended to use reverse-domain-notation, which permits
   *  unique names with a known authority as well as hierarchal entries.
   */
  name;
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    defineProperties2(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new _NetworkPlugin(this.name);
  }
};
var GasCostPlugin2 = class _GasCostPlugin extends NetworkPlugin2 {
  /**
   *  The block number to treat these values as valid from.
   *
   *  This allows a hardfork to have updated values included as well as
   *  mulutiple hardforks to be supported.
   */
  effectiveBlock;
  /**
   *  The transactions base fee.
   */
  txBase;
  /**
   *  The fee for creating a new account.
   */
  txCreate;
  /**
   *  The fee per zero-byte in the data.
   */
  txDataZero;
  /**
   *  The fee per non-zero-byte in the data.
   */
  txDataNonzero;
  /**
   *  The fee per storage key in the [[link-eip-2930]] access list.
   */
  txAccessListStorageKey;
  /**
   *  The fee per address in the [[link-eip-2930]] access list.
   */
  txAccessListAddress;
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument2(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties2(this, props);
  }
  clone() {
    return new _GasCostPlugin(this.effectiveBlock, this);
  }
};
var EnsPlugin2 = class _EnsPlugin extends NetworkPlugin2 {
  /**
   *  The ENS Registrty Contract address.
   */
  address;
  /**
   *  The chain ID that the ENS contract lives on.
   */
  targetNetwork;
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties2(this, {
      address: address || EnsAddress2,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new _EnsPlugin(this.address, this.targetNetwork);
  }
};
var FeeDataNetworkPlugin2 = class _FeeDataNetworkPlugin extends NetworkPlugin2 {
  #feeDataFunc;
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new _FeeDataNetworkPlugin(this.#feeDataFunc);
  }
};
var FetchUrlFeeDataNetworkPlugin2 = class extends NetworkPlugin2 {
  #url;
  #processFunc;
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return this.#url;
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return this.#processFunc;
  }
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url2, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url2;
    this.#processFunc = processFunc;
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/network.js
var Networks2 = /* @__PURE__ */ new Map();
var Network2 = class _Network {
  #name;
  #chainId;
  #plugins;
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt2(chainId);
    this.#plugins = /* @__PURE__ */ new Map();
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt2(value, "chainId");
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt2(other);
      } catch (error2) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt2(other);
      } catch (error2) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt2(other.chainId);
        } catch (error2) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename2) {
    return this.plugins.filter((p3) => p3.name.split("#")[0] === basename2);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin2();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i2 = 2; i2 < tx.data.length; i2 += 2) {
        if (tx.data.substring(i2, i2 + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify2(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks2();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks2.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument2(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument2(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin2(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument2(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks2.get(nameOrChainId);
    if (existing) {
      assertArgument2(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks2.set(nameOrChainId, networkFunc);
  }
};
function parseUnits4(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin2(url2) {
  return new FetchUrlFeeDataNetworkPlugin2(url2, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits4(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits4(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error2) {
      assert5(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error: error2 });
    }
  });
}
var injected2 = false;
function injectCommonNetworks2() {
  if (injected2) {
    return;
  }
  injected2 = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network2(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin2(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin2());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network2.register(name, func);
    Network2.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network2.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin2("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin2("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}

// ../../../../../node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy4(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var PollingBlockSubscriber2 = class {
  #provider;
  #poller;
  #interval;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4e3;
    this.#blockNumber = -2;
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async #poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b4 = this.#blockNumber + 1; b4 <= blockNumber; b4++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b4);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error2) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};
var OnBlockSubscriber2 = class {
  #provider;
  #poll;
  #running;
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
};
var PollingBlockTagSubscriber2 = class extends OnBlockSubscriber2 {
  #tag;
  #lastBlock;
  constructor(provider, tag) {
    super(provider);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
};
var PollingOrphanSubscriber2 = class extends OnBlockSubscriber2 {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy4(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
};
var PollingTransactionSubscriber2 = class extends OnBlockSubscriber2 {
  #hash;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash3) {
    super(provider);
    this.#hash = hash3;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
};
var PollingEventSubscriber2 = class {
  #provider;
  #filter;
  #poller;
  #running;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy4(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async #poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy4(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log3 of logs) {
      this.#provider.emit(this.#filter, log3);
      this.#blockNumber = log3.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/abstract-provider.js
var BN_29 = BigInt(2);
var MAX_CCIP_REDIRECTS2 = 10;
function isPromise4(value) {
  return value && typeof value.then === "function";
}
function getTag2(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v2) => {
    if (v2 == null) {
      return "null";
    }
    if (typeof v2 === "bigint") {
      return `bigint:${v2.toString()}`;
    }
    if (typeof v2 === "string") {
      return v2.toLowerCase();
    }
    if (typeof v2 === "object" && !Array.isArray(v2)) {
      const keys = Object.keys(v2);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v2[key];
        return accum;
      }, {});
    }
    return v2;
  });
}
var UnmanagedSubscriber2 = class {
  /**
   *  The name fof the event.
   */
  name;
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    defineProperties2(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
};
function copy5(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify2(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription2(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString2(_event, 32)) {
    const hash3 = _event.toLowerCase();
    return { type: "transaction", tag: getTag2("tx", { hash: hash3 }), hash: hash3 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag2("orphan", event), filter: copy5(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t2) => {
        if (t2 == null) {
          return null;
        }
        if (Array.isArray(t2)) {
          return concisify2(t2.map((t3) => t3.toLowerCase()));
        }
        return t2.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises2 = [];
      const addAddress = (addr) => {
        if (isHexString2(addr)) {
          addresses.push(addr);
        } else {
          promises2.push((async () => {
            addresses.push(await resolveAddress2(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises2.length) {
        await Promise.all(promises2);
      }
      filter.address = concisify2(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag2("event", filter), type: "event" };
  }
  assertArgument2(false, "unknown ProviderEvent", "event", _event);
}
function getTime5() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var defaultOptions3 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var AbstractProvider2 = class {
  #subs;
  #plugins;
  // null=unpaused, true=paused+dropWhilePaused, false=paused
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  // The most recent block number if running an event or -1 if no "block" event
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions3, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network2.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#plugins = /* @__PURE__ */ new Map();
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = /* @__PURE__ */ new Map();
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  // Shares multiple identical requests made during the same 250ms
  async #perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag2(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i2 = 0; i2 < urls.length; i2++) {
      const url2 = urls[i2];
      const href = url2.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest2(href);
      if (url2.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i2, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error2) {
        errorMessages.push(error2.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error: error2 } });
        continue;
      }
      try {
        const result2 = resp.bodyJson;
        if (result2.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result: result2 });
          return result2.data;
        }
        if (result2.message) {
          errorMessage = result2.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: result2 });
      } catch (error2) {
      }
      assert5(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url: url2, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert5(false, `error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block2(formatBlock2(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log2(formatLog2(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt2(formatTransactionReceipt2(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse2(formatTransactionResponse2(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert5(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert5(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber2(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress2(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString2(blockTag)) {
      if (isHexString2(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity2(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber2(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity2(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity2(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b4) => toQuantity2(b4 + blockTag));
    }
    assertArgument2(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t2) => {
      if (t2 == null) {
        return null;
      }
      if (Array.isArray(t2)) {
        return concisify2(t2.map((t3) => t3.toLowerCase()));
      }
      return t2.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve3 = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result2) => {
        return resolve3(result2[0], result2[1], result2[2]);
      });
    }
    return resolve3(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request) {
    const request = copyRequest2(_request);
    const promises2 = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress2(request[key], this);
      if (isPromise4(addr)) {
        promises2.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise4(blockTag)) {
        promises2.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises2.length) {
      return async function() {
        await Promise.all(promises2);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error2) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error2;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert5(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties2({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt2(value, "%response");
          } catch (error2) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt2(value, "%response");
          } catch (error2) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_29 + maxPriorityFeePerGas;
      }
      return new FeeData2(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest2(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData2(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise4(tx)) {
      tx = await tx;
    }
    return getBigInt2(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async #call(tx, blockTag, attempt) {
    assert5(attempt < MAX_CCIP_REDIRECTS2, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest2(tx);
    try {
      return hexlify2(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error2) {
      if (!this.disableCcipRead && isCallException2(error2) && error2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice2(error2.data, 0, 4) === "0x556f1830") {
        const data = error2.data;
        const txSender = await resolveAddress2(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup2(dataSlice2(error2.data, 4));
        } catch (error3) {
          assert5(false, error3.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data }
          });
        }
        assert5(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert5(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error2.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat3([ccipArgs.selector, encodeBytes2([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result2 = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result: result2 });
          return result2;
        } catch (error3) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error3 });
          throw error3;
        }
      }
      throw error2;
    }
  }
  async #checkNetwork(promise) {
    const { value } = await resolveProperties2({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties2({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  // Account
  async #getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt2(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber2(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify2(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt2(_position, "position");
    return hexlify2(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash3, network } = await resolveProperties2({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction2.from(signedTx);
    if (tx.hash !== hash3) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async #getBlock(block, includeTransactions) {
    if (isHexString2(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash3) {
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash3 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash3) {
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash3 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash3 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash3) {
    const { result: result2 } = await resolveProperties2({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash3 })
    });
    if (result2 == null) {
      return null;
    }
    return hexlify2(result2);
  }
  // Bloom-filter Queries
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise4(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p3) => this._wrapLog(p3, network));
  }
  // ENS
  _getProvider(chainId) {
    assert5(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver2.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress2(address);
    const node = namehash2(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver2.getEnsAddress(this);
      const ensContract = new Contract2(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress2) {
        return null;
      }
      const resolverContract = new Contract2(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error2) {
      if (isError4(error2, "BAD_DATA") && error2.value === "0x") {
        return null;
      }
      if (isError4(error2, "CALL_EXCEPTION")) {
        return null;
      }
      throw error2;
    }
    return null;
  }
  async waitForTransaction(hash3, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash3);
    }
    return new Promise(async (resolve3, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash3);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve3(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error2) {
          console.log("EEE", error2);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError2("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert5(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime5() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of this.#subs.values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber2(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber2(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber2(this, sub.type);
      case "event":
        return new PollingEventSubscriber2(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber2(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber2(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of this.#subs.values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async #hasSub(event, emitArgs) {
    let sub = await getSubscription2(event, this);
    if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub = await getSubscription2({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub.tag) || null;
  }
  async #getSub(event) {
    const subscription = await getSubscription2(event, this);
    const tag = subscription.tag;
    let sub = this.#subs.get(tag);
    if (!sub) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = /* @__PURE__ */ new WeakMap();
      const nameMap = /* @__PURE__ */ new Map();
      sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub);
    }
    return sub;
  }
  async on(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args2) {
    const sub = await this.#hasSub(event, args2);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    ;
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once: once4 }) => {
      const payload = new EventPayload2(this, once4 ? null : listener, event);
      try {
        listener.call(this, ...args2, payload);
      } catch (error2) {
      }
      return !once4;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners: listeners3 } of this.#subs.values()) {
      total += listeners3.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result2 = [];
    for (const { listeners: listeners3 } of this.#subs.values()) {
      result2 = result2.concat(listeners3.map(({ listener }) => listener));
    }
    return result2;
  }
  async off(event, listener) {
    const sub = await this.#hasSub(event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert5(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime5() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime5();
      setTimeout(timer.func, timeout);
    }
  }
};
function _parseString2(result2, start) {
  try {
    const bytes4 = _parseBytes2(result2, start);
    if (bytes4) {
      return toUtf8String2(bytes4);
    }
  } catch (error2) {
  }
  return null;
}
function _parseBytes2(result2, start) {
  if (result2 === "0x") {
    return null;
  }
  try {
    const offset = getNumber2(dataSlice2(result2, start, start + 32));
    const length = getNumber2(dataSlice2(result2, offset, offset + 32));
    return dataSlice2(result2, offset + 32, offset + 32 + length);
  } catch (error2) {
  }
  return null;
}
function numPad2(value) {
  const result2 = toBeArray2(value);
  if (result2.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result2, 32 - result2.length);
  return padded;
}
function bytesPad2(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result2 = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result2.set(value);
  return result2;
}
var empty3 = new Uint8Array([]);
function encodeBytes2(datas) {
  const result2 = [];
  let byteCount = 0;
  for (let i2 = 0; i2 < datas.length; i2++) {
    result2.push(empty3);
    byteCount += 32;
  }
  for (let i2 = 0; i2 < datas.length; i2++) {
    const data = getBytes2(datas[i2]);
    result2[i2] = numPad2(byteCount);
    result2.push(numPad2(data.length));
    result2.push(bytesPad2(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat3(result2);
}
var zeros2 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup2(data) {
  const result2 = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert5(dataLength2(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice2(data, 0, 32);
  assert5(dataSlice2(sender, 0, 12) === dataSlice2(zeros2, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result2.sender = dataSlice2(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber2(dataSlice2(data, 32, 64));
    const urlsLength = getNumber2(dataSlice2(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice2(data, urlsOffset + 32);
    for (let u2 = 0; u2 < urlsLength; u2++) {
      const url2 = _parseString2(urlsData, u2 * 32);
      if (url2 == null) {
        throw new Error("abort");
      }
      urls.push(url2);
    }
    result2.urls = urls;
  } catch (error2) {
    assert5(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes2(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result2.calldata = calldata;
  } catch (error2) {
    assert5(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert5(dataSlice2(data, 100, 128) === dataSlice2(zeros2, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result2.selector = dataSlice2(data, 96, 100);
  try {
    const extraData = _parseBytes2(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result2.extraData = extraData;
  } catch (error2) {
    assert5(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result2.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result2[k]);
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider2(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert5(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate2(signer, tx) {
  let pop = copyRequest2(tx);
  if (pop.to != null) {
    pop.to = resolveAddress2(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress2(from, signer)
    ]).then(([address, from2]) => {
      assertArgument2(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties2(pop);
}
var AbstractSigner2 = class {
  /**
   *  The provider this signer is connected to.
   */
  provider;
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    defineProperties2(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider2(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate2(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider2(this, "populateTransaction");
    const pop = await populate2(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt2(pop.chainId);
      assertArgument2(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument2(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument2(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert5(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert5(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert5(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties2(pop);
  }
  async populateAuthorization(_auth) {
    const auth = Object.assign({}, _auth);
    if (auth.chainId == null) {
      auth.chainId = (await checkProvider2(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth.nonce == null) {
      auth.nonce = await this.getNonce();
    }
    return auth;
  }
  async estimateGas(tx) {
    return checkProvider2(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider2(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider2(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider2(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction2.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
  // @TODO: in v7 move this to be abstract
  authorize(authorization) {
    assert5(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
};
var VoidSigner2 = class _VoidSigner extends AbstractSigner2 {
  /**
   *  The signer address.
   */
  address;
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    defineProperties2(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
  #throwUnsupported(suffix, operation) {
    assert5(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain3, types, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/community.js
var shown2 = /* @__PURE__ */ new Set();
function showThrottleMessage2(service) {
  if (shown2.has(service)) {
    return;
  }
  shown2.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}

// ../../../../../node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy6(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var FilterIdSubscriber2 = class {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result2) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async #poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error2) {
        if (!isError4(error2, "UNSUPPORTED_OPERATION") || error2.operation !== "eth_newFilter") {
          throw error2;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result2 = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result2);
    } catch (error2) {
      console.log("@TODO", error2);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
};
var FilterIdEventSubscriber2 = class extends FilterIdSubscriber2 {
  #event;
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    this.#event = copy6(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber2(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result2 of results) {
      provider.emit(this.#event, provider._wrapLog(result2, provider._network));
    }
  }
};
var FilterIdPendingSubscriber2 = class extends FilterIdSubscriber2 {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result2 of results) {
      provider.emit("pending", result2);
    }
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var Primitive2 = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy2(value) {
  if (value == null || Primitive2.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy2);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall5(duration) {
  return new Promise((resolve3) => {
    setTimeout(resolve3, duration);
  });
}
function getLowerCase2(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable2(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions4 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var JsonRpcSigner2 = class extends AbstractSigner2 {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress2(address);
    defineProperties2(this, { address });
  }
  connect(provider) {
    assert5(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy2(_tx);
    const promises2 = [];
    if (tx.from) {
      const _from2 = tx.from;
      promises2.push((async () => {
        const from = await resolveAddress2(_from2, this.provider);
        assertArgument2(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises2.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises2.push((async () => {
        tx.to = await resolveAddress2(_to, this.provider);
      })());
    }
    if (promises2.length) {
      await Promise.all(promises2);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash3 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve3, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash3);
          if (tx2 != null) {
            resolve3(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error2) {
          if (isError4(error2, "CANCELLED") || isError4(error2, "BAD_DATA") || isError4(error2, "NETWORK_ERROR") || isError4(error2, "UNSUPPORTED_OPERATION")) {
            if (error2.info == null) {
              error2.info = {};
            }
            error2.info.sendTransactionHash = hash3;
            reject(error2);
            return;
          }
          if (isError4(error2, "INVALID_ARGUMENT")) {
            invalids++;
            if (error2.info == null) {
              error2.info = {};
            }
            error2.info.sendTransactionHash = hash3;
            if (invalids > 10) {
              reject(error2);
              return;
            }
          }
          this.provider.emit("error", makeError2("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: error2 }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy2(_tx);
    if (tx.from) {
      const from = await resolveAddress2(tx.from, this.provider);
      assertArgument2(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes2(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify2(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain3, types, _value) {
    const value = deepCopy2(_value);
    const populated = await TypedDataEncoder2.resolveNames(domain3, types, value, async (value2) => {
      const address = await resolveAddress2(value2);
      assertArgument2(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder2.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes2(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify2(message)
    ]);
  }
};
var JsonRpcApiProvider2 = class extends AbstractProvider2 {
  #options;
  // The next ID to use for the JSON-RPC ID field
  #nextId;
  // Payloads are queued and triggered in batches using the drainTimer
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes4 = JSON.stringify(batch.map((p3) => p3.payload));
          if (bytes4.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p3) => p3.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result2 = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result: result2 });
            for (const { resolve: resolve3, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError2("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result2.filter((r3) => r3.id === payload2.id)[0];
              if (resp == null) {
                const error2 = makeError2("missing response for request", "BAD_DATA", {
                  value: result2,
                  info: { payload: payload2 }
                });
                this.emit("error", error2);
                reject(error2);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve3(resp.result);
            }
          } catch (error2) {
            this.emit("debug", { action: "receiveRpcError", error: error2 });
            for (const { reject } of batch) {
              reject(error2);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions4, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve3 = null;
      const promise = new Promise((_resolve) => {
        resolve3 = _resolve;
      });
      this.#notReady = { promise, resolve: resolve3 };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument2(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network2.from(network);
      }
    } else if (staticNetwork) {
      assertArgument2(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return this.#options[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert5(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt2(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result2 = Network2.from(getBigInt2(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result2;
        } catch (error2) {
          this.#pendingDetectNetwork = null;
          throw error2;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result2;
      try {
        result2 = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error2) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error: error2 });
        throw error2;
      }
      this.emit("debug", { action: "receiveRpcResult", result: result2 });
      if ("result" in result2) {
        return Network2.from(getBigInt2(result2.result));
      }
      throw this.getRpcError(payload, result2);
    })();
    return await this.#pendingDetectNetwork;
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error2) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError2("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: error2 } }));
          await stall5(1e3);
        }
      }
      this.#scheduleDrain();
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber2(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber2(this, sub.filter);
      }
      return new FilterIdEventSubscriber2(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber2("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return this.#notReady == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result2 = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result2[dstKey] = toQuantity2(getBigInt2(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result2[key] = hexlify2(tx[key]);
    });
    if (tx.accessList) {
      result2["accessList"] = accessListify2(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result2["blobVersionedHashes"] = tx.blobVersionedHashes.map((h2) => h2.toLowerCase());
    }
    if (tx.authorizationList) {
      result2["authorizationList"] = tx.authorizationList.map((_a) => {
        const a2 = authorizationify(_a);
        return {
          address: a2.address,
          nonce: toQuantity2(a2.nonce),
          chainId: toQuantity2(a2.chainId),
          yParity: toQuantity2(a2.signature.yParity),
          r: a2.signature.r,
          s: a2.signature.s
        };
      });
    }
    return result2;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase2(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase2(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase2(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase2(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase2);
          } else {
            req.filter.address = getLowerCase2(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error: error2 } = _error;
    if (method === "eth_estimateGas" && error2.message) {
      const msg = error2.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError2("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error: error2 }
        });
      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
        return makeError2("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error: error2 }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result2 = spelunkData2(error2);
      const e3 = AbiCoder2.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result2 ? result2.data : null);
      e3.info = { error: error2, payload };
      return e3;
    }
    const message = JSON.stringify(spelunkMessage2(error2));
    if (typeof error2.message === "string" && error2.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError2(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error: error2 }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError2("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error: error2 }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError2("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error: error2 } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError2("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error: error2 } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError2("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error: error2 } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error2 && error2.details && error2.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError2("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error: error2, payload }
      });
    }
    return makeError2("could not coalesce error", "UNKNOWN_ERROR", { error: error2, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError2("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id3 = this.#nextId++;
    const promise = new Promise((resolve3, reject) => {
      this.#payloads.push({
        resolve: resolve3,
        reject,
        payload: { method, params, id: id3, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner2(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties2({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress2(address);
    for (const account of accounts) {
      if (getAddress2(account) === address) {
        return new JsonRpcSigner2(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner2(this, a2));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError2("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
};
var JsonRpcApiPollingProvider2 = class extends JsonRpcApiProvider2 {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions4.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable2(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub) => {
      if (isPollable2(sub)) {
        sub.pollingInterval = this.#pollingInterval;
      }
    });
  }
};
var JsonRpcProvider2 = class extends JsonRpcApiPollingProvider2 {
  #connect;
  constructor(url2, network, options) {
    if (url2 == null) {
      url2 = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url2 === "string") {
      this.#connect = new FetchRequest2(url2);
    } else {
      this.#connect = url2.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
};
function spelunkData2(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString2(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result2 = spelunkData2(value[key]);
      if (result2) {
        return result2;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData2(JSON.parse(value));
    } catch (error2) {
    }
  }
  return null;
}
function _spelunkMessage2(value, result2) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result2.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage2(value[key], result2);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage2(JSON.parse(value), result2);
    } catch (error2) {
    }
  }
}
function spelunkMessage2(value) {
  const result2 = [];
  _spelunkMessage2(value, result2);
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/providers/provider-ankr.js
var defaultApiKey3 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost7(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var AnkrProvider2 = class _AnkrProvider extends JsonRpcProvider2 {
  /**
   *  The API key for the Ankr connection.
   */
  apiKey;
  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey3;
    }
    const options = { polling: true, staticNetwork: network };
    const request = _AnkrProvider.getRequest(network, apiKey);
    super(request, network, options);
    defineProperties2(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AnkrProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%apiKey%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey3;
    }
    const request = new FetchRequest2(`https://${getHost7(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey3) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error2) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error2 && error2.error && error2.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error2.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error2);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey3;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-alchemy.js
var defaultApiKey4 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost8(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var AlchemyProvider2 = class _AlchemyProvider extends JsonRpcProvider2 {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey4;
    }
    const request = _AlchemyProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties2(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AlchemyProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties2({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data;
      let error2 = false;
      try {
        data = trace[0].result.output;
        error2 = trace[0].error === "Reverted";
      } catch (error3) {
      }
      if (data) {
        assert5(!error2, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
          // @TODO
        });
        return data;
      }
      assert5(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey4;
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey4;
    }
    const request = new FetchRequest2(`https://${getHost8(network.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey4) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("alchemy");
        return true;
      };
    }
    return request;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-chainstack.js
function getApiKey2(name) {
  switch (name) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
function getHost9(name) {
  switch (name) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var ChainstackProvider2 = class _ChainstackProvider extends JsonRpcProvider2 {
  /**
   *  The API key for the Chainstack connection.
   */
  apiKey;
  /**
   *  Creates a new **ChainstackProvider**.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (apiKey == null) {
      apiKey = getApiKey2(network.name);
    }
    const request = _ChainstackProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties2(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _ChainstackProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === getApiKey2(this._network.name);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%apiKey%% and %%projectSecret%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = getApiKey2(network.name);
    }
    const request = new FetchRequest2(`https://${getHost9(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === getApiKey2(network.name)) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("ChainstackProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-cloudflare.js
var CloudflareProvider2 = class extends JsonRpcProvider2 {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    assertArgument2(network.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network, { staticNetwork: network });
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-etherscan.js
var THROTTLE2 = 2e3;
function isPromise5(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId2 = "org.ethers.plugins.provider.Etherscan";
var EtherscanPlugin2 = class _EtherscanPlugin extends NetworkPlugin2 {
  /**
   *  The Etherscan API base URL.
   */
  baseUrl;
  /**
   *  Creates a new **EtherscanProvider** which will use
   *  %%baseUrl%%.
   */
  constructor(baseUrl) {
    super(EtherscanPluginId2);
    defineProperties2(this, { baseUrl });
  }
  clone() {
    return new _EtherscanPlugin(this.baseUrl);
  }
};
var skipKeys2 = ["enableCcipRead"];
var nextId2 = 1;
var EtherscanProvider2 = class extends AbstractProvider2 {
  /**
   *  The connected network.
   */
  network;
  /**
   *  The API key or null if using the community provided bandwidth.
   */
  apiKey;
  #plugin;
  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network = Network2.from(_network);
    this.#plugin = network.getPlugin(EtherscanPluginId2);
    defineProperties2(this, { apiKey, network });
    this.getBaseUrl();
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "base":
        return "https://api.basescan.org";
      case "base-sepolia":
        return "https://api-sepolia.basescan.org";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-amoy":
        return "https://api-amoy.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    assertArgument2(false, "unsupported network", "network", this.network);
  }
  /**
   *  Returns the URL for the %%module%% and %%params%%.
   */
  getUrl(module, params) {
    const query3 = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.getBaseUrl()}/api?module=${module}${query3}${apiKey}`;
  }
  /**
   *  Returns the URL for using POST requests.
   */
  getPostUrl() {
    return `${this.getBaseUrl()}/api`;
  }
  /**
   *  Returns the parameters for using POST requests.
   */
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the result of calling %%module%% with %%params%%.
   *
   *  If %%post%%, the request is made as a POST request.
   */
  async fetch(module, params, post) {
    const id3 = nextId2++;
    const url2 = post ? this.getPostUrl() : this.getUrl(module, params);
    const payload = post ? this.getPostData(module, params) : null;
    this.emit("debug", { action: "sendRequest", id: id3, url: url2, payload });
    const request = new FetchRequest2(url2);
    request.setThrottleParams({ slotInterval: 1e3 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage2("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result3 = response2.hasBody() ? JSON.parse(toUtf8String2(response2.body)) : {};
      const throttle = (typeof result3.result === "string" ? result3.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module === "proxy") {
        if (result3 && result3.status == 0 && result3.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result3 });
          response2.throwThrottleError(result3.result, THROTTLE2);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result3.result });
          response2.throwThrottleError(result3.result, THROTTLE2);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error2) {
      this.emit("debug", { action: "receiveError", id: id3, error: error2, reason: "assertOk" });
      assert5(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
      assert5(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result2 = JSON.parse(toUtf8String2(response.body));
    if (module === "proxy") {
      if (result2.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id3, result: result2, reason: "invalid JSON-RPC" });
        assert5(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result: result2 } });
      }
      if (result2.error) {
        this.emit("debug", { action: "receiveError", id: id3, result: result2, reason: "JSON-RPC error" });
        assert5(false, "error response", "SERVER_ERROR", { request, response, info: { result: result2 } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result: result2 });
      return result2.result;
    } else {
      if (result2.status == 0 && (result2.message === "No records found" || result2.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id3, result: result2 });
        return result2.result;
      }
      if (result2.status != 1 || typeof result2.message === "string" && !result2.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id3, result: result2 });
        assert5(false, "error response", "SERVER_ERROR", { request, response, info: { result: result2 } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result: result2 });
      return result2.result;
    }
  }
  /**
   *  Returns %%transaction%% normalized for the Etherscan API.
   */
  _getTransactionPostData(transaction) {
    const result2 = {};
    for (let key in transaction) {
      if (skipKeys2.indexOf(key) >= 0) {
        continue;
      }
      if (transaction[key] == null) {
        continue;
      }
      let value = transaction[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if (key === "blockTag" && value === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity2(value);
      } else if (key === "accessList") {
        value = "[" + accessListify2(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else if (key === "blobVersionedHashes") {
        if (value.length === 0) {
          continue;
        }
        assert5(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
          operation: "_getTransactionPostData",
          info: { transaction }
        });
      } else {
        value = hexlify2(value);
      }
      result2[key] = value;
    }
    return result2;
  }
  /**
   *  Throws the normalized Etherscan error.
   */
  _checkError(req, error2, transaction) {
    let message = "";
    if (isError4(error2, "SERVER_ERROR")) {
      try {
        message = error2.info.result.error.message;
      } catch (e3) {
      }
      if (!message) {
        try {
          message = error2.info.message;
        } catch (e3) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert5(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data = "";
        try {
          data = error2.info.result.error.data;
        } catch (error3) {
        }
        const e3 = AbiCoder2.getBuiltinCallException(req.method, req.transaction, data);
        e3.info = { request: req, error: error2 };
        throw e3;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction2 = Transaction2.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert5(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction2
          });
        }
        if (message.match(/insufficient funds/)) {
          assert5(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction2
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert5(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction2
          });
        }
      }
    }
    throw error2;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      /* Working with Etherscan to get this added:
      try {
          const test = await this.fetch("proxy", {
              action: "eth_maxPriorityFeePerGas"
          });
          console.log(test);
          return test;
      } catch (e) {
          console.log("DEBUG", e);
          throw e;
      }
      */
      /* This might be safe; but due to rounding neither myself
         or Etherscan are necessarily comfortable with this. :)
      try {
          const result = await this.fetch("gastracker", { action: "gasoracle" });
          console.log(result);
          const gasPrice = parseUnits(result.SafeGasPrice, "gwei");
          const baseFee = parseUnits(result.suggestBaseFee, "gwei");
          const priorityFee = gasPrice - baseFee;
          if (priorityFee < 0) { throw new Error("negative priority fee; defer to abstract provider default"); }
          return priorityFee;
      } catch (error) {
          console.log("DEBUG", error);
          throw error;
      }
      */
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error2) => {
          return this._checkError(req, error2, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert5(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error2) {
          return this._checkError(req, error2, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error2) {
          return this._checkError(req, error2, req.transaction);
        }
      }
      /*
                  case "getLogs": {
                      // Needs to complain if more than one address is passed in
                      const args: Record<string, any> = { action: "getLogs" }
      
                      if (params.filter.fromBlock) {
                          args.fromBlock = checkLogTag(params.filter.fromBlock);
                      }
      
                      if (params.filter.toBlock) {
                          args.toBlock = checkLogTag(params.filter.toBlock);
                      }
      
                      if (params.filter.address) {
                          args.address = params.filter.address;
                      }
      
                      // @TODO: We can handle slightly more complicated logs using the logs API
                      if (params.filter.topics && params.filter.topics.length > 0) {
                          if (params.filter.topics.length > 1) {
                              logger.throwError("unsupported topic count", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                          }
                          if (params.filter.topics.length === 1) {
                              const topic0 = params.filter.topics[0];
                              if (typeof(topic0) !== "string" || topic0.length !== 66) {
                                  logger.throwError("unsupported topic format", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                              }
                              args.topic0 = topic0;
                          }
                      }
      
                      const logs: Array<any> = await this.fetch("logs", args);
      
                      // Cache txHash => blockHash
                      let blocks: { [tag: string]: string } = {};
      
                      // Add any missing blockHash to the logs
                      for (let i = 0; i < logs.length; i++) {
                          const log = logs[i];
                          if (log.blockHash != null) { continue; }
                          if (blocks[log.blockNumber] == null) {
                              const block = await this.getBlock(log.blockNumber);
                              if (block) {
                                  blocks[log.blockNumber] = block.hash;
                              }
                          }
      
                          log.blockHash = blocks[log.blockNumber];
                      }
      
                      return logs;
                  }
      */
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the current price of ether.
   *
   *  This returns ``0`` on any network other than ``mainnet``.
   */
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  /**
   *  Resolves to a [Contract]] for %%address%%, using the
   *  Etherscan API to retreive the Contract ABI.
   */
  async getContract(_address) {
    let address = this._getAddress(_address);
    if (isPromise5(address)) {
      address = await address;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address
      });
      const abi = JSON.parse(resp);
      return new Contract2(address, abi, this);
    } catch (error2) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/ws-browser.js
function getGlobal4() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var _WebSocket2 = getGlobal4().WebSocket;

// ../../../../../node_modules/ethers/lib.esm/providers/provider-socket.js
var SocketSubscriber2 = class {
  #provider;
  #filter;
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = JSON.stringify(filter);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      ;
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      if (this.#provider.destroyed) {
        return;
      }
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(dropWhilePaused) {
    assert5(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  /**
   *  @_ignore:
   */
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(provider, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
};
var SocketBlockSubscriber2 = class extends SocketSubscriber2 {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newHeads"]);
  }
  async _emit(provider, message) {
    provider.emit("block", parseInt(message.number));
  }
};
var SocketPendingSubscriber2 = class extends SocketSubscriber2 {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newPendingTransactions"]);
  }
  async _emit(provider, message) {
    provider.emit("pending", message);
  }
};
var SocketEventSubscriber2 = class extends SocketSubscriber2 {
  #logFilter;
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  /**
   *  @_ignore:
   */
  constructor(provider, filter) {
    super(provider, ["logs", filter]);
    this.#logFilter = JSON.stringify(filter);
  }
  async _emit(provider, message) {
    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
  }
};
var SocketProvider2 = class extends JsonRpcApiProvider2 {
  #callbacks;
  // Maps each filterId to its subscriber
  #subs;
  // If any events come in before a subscriber has finished
  // registering, queue them
  #pending;
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(network, _options) {
    const options = Object.assign({}, _options != null ? _options : {});
    assertArgument2(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network, options);
    this.#callbacks = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#pending = /* @__PURE__ */ new Map();
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "close":
        return new UnmanagedSubscriber2("close");
      case "block":
        return new SocketBlockSubscriber2(this);
      case "pending":
        return new SocketPendingSubscriber2(this);
      case "event":
        return new SocketEventSubscriber2(this, sub.filter);
      case "orphan":
        if (sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber2("drop-log");
        }
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument2(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve3, reject) => {
      this.#callbacks.set(payload.id, { payload, resolve: resolve3, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(message) {
    const result2 = JSON.parse(message);
    if (result2 && typeof result2 === "object" && "id" in result2) {
      const callback = this.#callbacks.get(result2.id);
      if (callback == null) {
        this.emit("error", makeError2("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result: result2
        }));
        return;
      }
      this.#callbacks.delete(result2.id);
      callback.resolve(result2);
    } else if (result2 && result2.method === "eth_subscription") {
      const filterId = result2.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result2.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result2.params.result);
      }
    } else {
      this.emit("error", makeError2("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result: result2
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-websocket.js
var WebSocketProvider2 = class extends SocketProvider2 {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url2, network, options) {
    super(network, options);
    if (typeof url2 === "string") {
      this.#connect = () => {
        return new _WebSocket2(url2);
      };
      this.#websocket = this.#connect();
    } else if (typeof url2 === "function") {
      this.#connect = url2;
      this.#websocket = url2();
    } else {
      this.#connect = null;
      this.#websocket = url2;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error2) {
        console.log("failed to start WebsocketProvider", error2);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-infura.js
var defaultProjectId2 = "84842078b09946638c03157f83405213";
function getHost10(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
    // @TODO: Remove this typo in the future!
    case "base-goerli":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bsc-mainnet.infura.io";
    case "bnbt":
      return "bsc-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var InfuraWebSocketProvider2 = class extends WebSocketProvider2 {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(network, projectId) {
    const provider = new InfuraProvider2(network, projectId);
    const req = provider._getConnection();
    assert5(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url2 = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url2, provider._network);
    defineProperties2(this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId2;
  }
};
var InfuraProvider2 = class _InfuraProvider extends JsonRpcProvider2 {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId2;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = _InfuraProvider.getRequest(network, projectId, projectSecret);
    super(request, network, { staticNetwork: network });
    defineProperties2(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new _InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId2;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(network, projectId) {
    return new InfuraWebSocketProvider2(network, projectId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(network, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId2;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest2(`https://${getHost10(network.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("InfuraProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-quicknode.js
var defaultToken2 = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost11(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var QuickNodeProvider2 = class _QuickNodeProvider extends JsonRpcProvider2 {
  /**
   *  The API token.
   */
  token;
  /**
   *  Creates a new **QuickNodeProvider**.
   */
  constructor(_network, token) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (token == null) {
      token = defaultToken2;
    }
    const request = _QuickNodeProvider.getRequest(network, token);
    super(request, network, { staticNetwork: network });
    defineProperties2(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new _QuickNodeProvider(chainId, this.token);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken2;
  }
  /**
   *  Returns a new request prepared for %%network%% and the
   *  %%token%%.
   */
  static getRequest(network, token) {
    if (token == null) {
      token = defaultToken2;
    }
    const request = new FetchRequest2(`https://${getHost11(network.name)}/${token}`);
    request.allowGzip = true;
    if (token === defaultToken2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("QuickNodeProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-fallback.js
var BN_112 = BigInt("1");
var BN_210 = BigInt("2");
function shuffle2(array) {
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j];
    array[j] = tmp;
  }
}
function stall6(duration) {
  return new Promise((resolve3) => {
    setTimeout(resolve3, duration);
  });
}
function getTime6() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stringify5(value) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
}
var defaultConfig2 = { stallTimeout: 400, priority: 1, weight: 1 };
var defaultState2 = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};
async function waitForSync2(config2, blockNumber) {
  while (config2.blockNumber < 0 || config2.blockNumber < blockNumber) {
    if (!config2._updateNumber) {
      config2._updateNumber = (async () => {
        try {
          const blockNumber2 = await config2.provider.getBlockNumber();
          if (blockNumber2 > config2.blockNumber) {
            config2.blockNumber = blockNumber2;
          }
        } catch (error2) {
          config2.blockNumber = -2;
          config2._lastFatalError = error2;
          config2._lastFatalErrorTimestamp = getTime6();
        }
        config2._updateNumber = null;
      })();
    }
    await config2._updateNumber;
    config2.outOfSync++;
    if (config2._lastFatalError) {
      break;
    }
  }
}
function _normalize2(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize2).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize2(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize2(value[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult2(method, value) {
  if ("error" in value) {
    const error2 = value.error;
    let tag;
    if (isError4(error2, "CALL_EXCEPTION")) {
      tag = _normalize2(Object.assign({}, error2, {
        shortMessage: void 0,
        reason: void 0,
        info: void 0
      }));
    } else {
      tag = _normalize2(error2);
    }
    return { tag, value: error2 };
  }
  const result2 = value.result;
  return { tag: _normalize2(result2), value: result2 };
}
function checkQuorum2(quorum, results) {
  const tally = /* @__PURE__ */ new Map();
  for (const { value, tag, weight } of results) {
    const t2 = tally.get(tag) || { value, weight: 0 };
    t2.weight += weight;
    tally.set(tag, t2);
  }
  let best = null;
  for (const r3 of tally.values()) {
    if (r3.weight >= quorum && (!best || r3.weight > best.weight)) {
      best = r3;
    }
  }
  if (best) {
    return best.value;
  }
  return void 0;
}
function getMedian2(quorum, results) {
  let resultWeight = 0;
  const errorMap2 = /* @__PURE__ */ new Map();
  let bestError = null;
  const values = [];
  for (const { value, tag, weight } of results) {
    if (value instanceof Error) {
      const e3 = errorMap2.get(tag) || { value, weight: 0 };
      e3.weight += weight;
      errorMap2.set(tag, e3);
      if (bestError == null || e3.weight > bestError.weight) {
        bestError = e3;
      }
    } else {
      values.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return void 0;
  }
  values.sort((a2, b4) => a2 < b4 ? -1 : b4 > a2 ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_112) / BN_210;
}
function getAnyResult2(quorum, results) {
  const result2 = checkQuorum2(quorum, results);
  if (result2 !== void 0) {
    return result2;
  }
  for (const r3 of results) {
    if (r3.value) {
      return r3.value;
    }
  }
  return void 0;
}
function getFuzzyMode2(quorum, results) {
  if (quorum === 1) {
    return getNumber2(getMedian2(quorum, results), "%internal");
  }
  const tally = /* @__PURE__ */ new Map();
  const add3 = (result2, weight) => {
    const t2 = tally.get(result2) || { result: result2, weight: 0 };
    t2.weight += weight;
    tally.set(result2, t2);
  };
  for (const { weight, value } of results) {
    const r3 = getNumber2(value);
    add3(r3 - 1, weight);
    add3(r3, weight);
    add3(r3 + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = void 0;
  for (const { weight, result: result2 } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result2 > bestResult)) {
      bestWeight = weight;
      bestResult = result2;
    }
  }
  return bestResult;
}
var FallbackProvider2 = class extends AbstractProvider2 {
  /**
   *  The number of backends that must agree on a value before it is
   *  accpeted.
   */
  quorum;
  /**
   *  @_ignore:
   */
  eventQuorum;
  /**
   *  @_ignore:
   */
  eventWorkers;
  #configs;
  #height;
  #initialSyncPromise;
  /**
   *  Creates a new **FallbackProvider** with %%providers%% connected to
   *  %%network%%.
   *
   *  If a [[Provider]] is included in %%providers%%, defaults are used
   *  for the configuration.
   */
  constructor(providers, network, options) {
    super(network, options);
    this.#configs = providers.map((p3) => {
      if (p3 instanceof AbstractProvider2) {
        return Object.assign({ provider: p3 }, defaultConfig2, defaultState2);
      } else {
        return Object.assign({}, defaultConfig2, p3, defaultState2);
      }
    });
    this.#height = -2;
    this.#initialSyncPromise = null;
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(this.#configs.reduce((accum, config2) => {
        accum += config2.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument2(this.quorum <= this.#configs.reduce((a2, c2) => a2 + c2.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
  }
  get providerConfigs() {
    return this.#configs.map((c2) => {
      const result2 = Object.assign({}, c2);
      for (const key in result2) {
        if (key[0] === "_") {
          delete result2[key];
        }
      }
      return result2;
    });
  }
  async _detectNetwork() {
    return Network2.from(getBigInt2(await this._perform({ method: "chainId" })));
  }
  // @TODO: Add support to select providers to be the event subscriber
  //_getSubscriber(sub: Subscription): Subscriber {
  //    throw new Error("@TODO");
  //}
  /**
   *  Transforms a %%req%% into the correct method call on %%provider%%.
   */
  async _translatePerform(provider, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider.getNetwork()).chainId;
      case "estimateGas":
        return await provider.estimateGas(req.transaction);
      case "getBalance":
        return await provider.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider.getBlock(block, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider.getBlockNumber();
      case "getCode":
        return await provider.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider.getFeeData()).gasPrice;
      case "getPriorityFee":
        return (await provider.getFeeData()).maxPriorityFeePerGas;
      case "getLogs":
        return await provider.getLogs(req.filter);
      case "getStorage":
        return await provider.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider.getTransactionResult(req.hash);
    }
  }
  // Grab the next (random) config that is not already part of
  // the running set
  #getNextConfig(running) {
    const configs = Array.from(running).map((r3) => r3.config);
    const allConfigs = this.#configs.slice();
    shuffle2(allConfigs);
    allConfigs.sort((a2, b4) => a2.priority - b4.priority);
    for (const config2 of allConfigs) {
      if (config2._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config2) === -1) {
        return config2;
      }
    }
    return null;
  }
  // Adds a new runner (if available) to running.
  #addRunner(running, req) {
    const config2 = this.#getNextConfig(running);
    if (config2 == null) {
      return null;
    }
    const runner = {
      config: config2,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    const now = getTime6();
    runner.perform = (async () => {
      try {
        config2.requests++;
        const result2 = await this._translatePerform(config2.provider, req);
        runner.result = { result: result2 };
      } catch (error2) {
        config2.errorResponses++;
        runner.result = { error: error2 };
      }
      const dt = getTime6() - now;
      config2._totalTime += dt;
      config2.rollingDuration = 0.95 * config2.rollingDuration + 0.05 * dt;
      runner.perform = null;
    })();
    runner.staller = (async () => {
      await stall6(config2.stallTimeout);
      runner.staller = null;
    })();
    running.add(runner);
    return runner;
  }
  // Initializes the blockNumber and network for each runner and
  // blocks until initialized
  async #initialSync() {
    let initialSync = this.#initialSyncPromise;
    if (!initialSync) {
      const promises2 = [];
      this.#configs.forEach((config2) => {
        promises2.push((async () => {
          await waitForSync2(config2, 0);
          if (!config2._lastFatalError) {
            config2._network = await config2.provider.getNetwork();
          }
        })());
      });
      this.#initialSyncPromise = initialSync = (async () => {
        await Promise.all(promises2);
        let chainId = null;
        for (const config2 of this.#configs) {
          if (config2._lastFatalError) {
            continue;
          }
          const network = config2._network;
          if (chainId == null) {
            chainId = network.chainId;
          } else if (network.chainId !== chainId) {
            assert5(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
              operation: "new FallbackProvider"
            });
          }
        }
      })();
    }
    await initialSync;
  }
  async #checkQuorum(running, req) {
    const results = [];
    for (const runner of running) {
      if (runner.result != null) {
        const { tag, value } = normalizeResult2(req.method, runner.result);
        results.push({ tag, value, weight: runner.config.weight });
      }
    }
    if (results.reduce((a2, r3) => a2 + r3.weight, 0) < this.quorum) {
      return void 0;
    }
    switch (req.method) {
      case "getBlockNumber": {
        if (this.#height === -2) {
          this.#height = Math.ceil(getNumber2(getMedian2(this.quorum, this.#configs.filter((c2) => !c2._lastFatalError).map((c2) => ({
            value: c2.blockNumber,
            tag: getNumber2(c2.blockNumber).toString(),
            weight: c2.weight
          })))));
        }
        const mode = getFuzzyMode2(this.quorum, results);
        if (mode === void 0) {
          return void 0;
        }
        if (mode > this.#height) {
          this.#height = mode;
        }
        return this.#height;
      }
      case "getGasPrice":
      case "getPriorityFee":
      case "estimateGas":
        return getMedian2(this.quorum, results);
      case "getBlock":
        if ("blockTag" in req && req.blockTag === "pending") {
          return getAnyResult2(this.quorum, results);
        }
        return checkQuorum2(this.quorum, results);
      case "call":
      case "chainId":
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorage":
      case "getTransaction":
      case "getTransactionReceipt":
      case "getLogs":
        return checkQuorum2(this.quorum, results);
      case "broadcastTransaction":
        return getAnyResult2(this.quorum, results);
    }
    assert5(false, "unsupported method", "UNSUPPORTED_OPERATION", {
      operation: `_perform(${stringify5(req.method)})`
    });
  }
  async #waitForQuorum(running, req) {
    if (running.size === 0) {
      throw new Error("no runners?!");
    }
    const interesting = [];
    let newRunners = 0;
    for (const runner of running) {
      if (runner.perform) {
        interesting.push(runner.perform);
      }
      if (runner.staller) {
        interesting.push(runner.staller);
        continue;
      }
      if (runner.didBump) {
        continue;
      }
      runner.didBump = true;
      newRunners++;
    }
    const value = await this.#checkQuorum(running, req);
    if (value !== void 0) {
      if (value instanceof Error) {
        throw value;
      }
      return value;
    }
    for (let i2 = 0; i2 < newRunners; i2++) {
      this.#addRunner(running, req);
    }
    assert5(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
      request: "%sub-requests",
      info: { request: req, results: Array.from(running).map((r3) => stringify5(r3.result)) }
    });
    await Promise.race(interesting);
    return await this.#waitForQuorum(running, req);
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results = this.#configs.map((c2) => null);
      const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {
        try {
          const result4 = await provider._perform(req);
          results[index] = Object.assign(normalizeResult2(req.method, { result: result4 }), { weight });
        } catch (error2) {
          results[index] = Object.assign(normalizeResult2(req.method, { error: error2 }), { weight });
        }
      });
      while (true) {
        const done = results.filter((r3) => r3 != null);
        for (const { value } of done) {
          if (!(value instanceof Error)) {
            return value;
          }
        }
        const result4 = checkQuorum2(this.quorum, results.filter((r3) => r3 != null));
        if (isError4(result4, "INSUFFICIENT_FUNDS")) {
          throw result4;
        }
        const waiting = broadcasts.filter((b4, i2) => results[i2] == null);
        if (waiting.length === 0) {
          break;
        }
        await Promise.race(waiting);
      }
      const result3 = getAnyResult2(this.quorum, results);
      assert5(result3 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results.map(stringify5) }
      });
      if (result3 instanceof Error) {
        throw result3;
      }
      return result3;
    }
    await this.#initialSync();
    const running = /* @__PURE__ */ new Set();
    let inflightQuorum = 0;
    while (true) {
      const runner = this.#addRunner(running, req);
      if (runner == null) {
        break;
      }
      inflightQuorum += runner.config.weight;
      if (inflightQuorum >= this.quorum) {
        break;
      }
    }
    const result2 = await this.#waitForQuorum(running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result2;
  }
  async destroy() {
    for (const { provider } of this.#configs) {
      provider.destroy();
    }
    super.destroy();
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/default-provider.js
function isWebSocketLike2(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
var Testnets2 = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
function getDefaultProvider2(network, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name) => {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network === "string" && network.match(/^https?:/)) {
    return new JsonRpcProvider2(network);
  }
  if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike2(network)) {
    return new WebSocketProvider2(network);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network2.from(network);
  } catch (error2) {
  }
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider2("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new JsonRpcProvider2("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider2(network, options.alchemy));
    } catch (error2) {
    }
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider2(network, options.ankr));
    } catch (error2) {
    }
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new ChainstackProvider2(network, options.chainstack));
    } catch (error2) {
    }
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider2(network));
    } catch (error2) {
    }
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider2(network, options.etherscan));
    } catch (error2) {
    }
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = void 0;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider2(network, projectId, projectSecret));
    } catch (error2) {
    }
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider2(network, token));
    } catch (error2) {
    }
  }
  assert5(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets2.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider2(providers, void 0, { quorum });
}

// ../../../../../node_modules/ethers/lib.esm/providers/signer-noncemanager.js
var NonceManager2 = class _NonceManager extends AbstractSigner2 {
  /**
   *  The Signer being managed.
   */
  signer;
  #noncePromise;
  #delta;
  /**
   *  Creates a new **NonceManager** to manage %%signer%%.
   */
  constructor(signer) {
    super(signer.provider);
    defineProperties2(this, { signer });
    this.#noncePromise = null;
    this.#delta = 0;
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider) {
    return new _NonceManager(this.signer.connect(provider));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (this.#noncePromise == null) {
        this.#noncePromise = super.getNonce("pending");
      }
      const delta = this.#delta;
      return await this.#noncePromise + delta;
    }
    return super.getNonce(blockTag);
  }
  /**
   *  Manually increment the nonce. This may be useful when managng
   *  offline transactions.
   */
  increment() {
    this.#delta++;
  }
  /**
   *  Resets the nonce, causing the **NonceManager** to reload the current
   *  nonce from the blockchain on the next transaction.
   */
  reset() {
    this.#delta = 0;
    this.#noncePromise = null;
  }
  async sendTransaction(tx) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx = await this.signer.populateTransaction(tx);
    tx.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx);
  }
  signTransaction(tx) {
    return this.signer.signTransaction(tx);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain3, types, value) {
    return this.signer.signTypedData(domain3, types, value);
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-browser.js
var BrowserProvider2 = class _BrowserProvider extends JsonRpcApiPollingProvider2 {
  #request;
  #providerInfo;
  /**
   *  Connect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network, _options) {
    const options = Object.assign({}, _options != null ? _options : {}, { batchMaxCount: 1 });
    assertArgument2(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    this.#providerInfo = null;
    if (_options && _options.providerInfo) {
      this.#providerInfo = _options.providerInfo;
    }
    this.#request = async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result2 = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result: result2 });
        return result2;
      } catch (e3) {
        const error2 = new Error(e3.message);
        error2.code = e3.code;
        error2.data = e3.data;
        error2.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error: error2 });
        throw error2;
      }
    };
  }
  get providerInfo() {
    return this.#providerInfo;
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument2(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result2 = await this.#request(payload.method, payload.params || []);
      return [{ id: payload.id, result: result2 }];
    } catch (e3) {
      return [{
        id: payload.id,
        error: { code: e3.code, data: e3.data, message: e3.message }
      }];
    }
  }
  getRpcError(payload, error2) {
    error2 = JSON.parse(JSON.stringify(error2));
    switch (error2.error.code || -1) {
      case 4001:
        error2.error.message = `ethers-user-denied: ${error2.error.message}`;
        break;
      case 4200:
        error2.error.message = `ethers-unsupported: ${error2.error.message}`;
        break;
    }
    return super.getRpcError(payload, error2);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await this.#request("eth_requestAccounts", []);
      } catch (error2) {
        const payload = error2.payload;
        throw this.getRpcError(payload, { id: payload.id, error: error2 });
      }
    }
    return await super.getSigner(address);
  }
  /**
   *  Discover and connect to a Provider in the Browser using the
   *  [[link-eip-6963]] discovery mechanism. If no providers are
   *  present, ``null`` is resolved.
   */
  static async discover(options) {
    if (options == null) {
      options = {};
    }
    if (options.provider) {
      return new _BrowserProvider(options.provider);
    }
    const context = options.window ? options.window : typeof window !== "undefined" ? window : null;
    if (context == null) {
      return null;
    }
    const anyProvider = options.anyProvider;
    if (anyProvider && context.ethereum) {
      return new _BrowserProvider(context.ethereum);
    }
    if (!("addEventListener" in context && "dispatchEvent" in context && "removeEventListener" in context)) {
      return null;
    }
    const timeout = options.timeout ? options.timeout : 300;
    if (timeout === 0) {
      return null;
    }
    return await new Promise((resolve3, reject) => {
      let found = [];
      const addProvider = (event) => {
        found.push(event.detail);
        if (anyProvider) {
          finalize();
        }
      };
      const finalize = () => {
        clearTimeout(timer);
        if (found.length) {
          if (options && options.filter) {
            const filtered = options.filter(found.map((i2) => Object.assign({}, i2.info)));
            if (filtered == null) {
              resolve3(null);
            } else if (filtered instanceof _BrowserProvider) {
              resolve3(filtered);
            } else {
              let match = null;
              if (filtered.uuid) {
                const matches = found.filter((f4) => filtered.uuid === f4.info.uuid);
                match = matches[0];
              }
              if (match) {
                const { provider, info } = match;
                resolve3(new _BrowserProvider(provider, void 0, {
                  providerInfo: info
                }));
              } else {
                reject(makeError2("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                  value: filtered
                }));
              }
            }
          } else {
            const { provider, info } = found[0];
            resolve3(new _BrowserProvider(provider, void 0, {
              providerInfo: info
            }));
          }
        } else {
          resolve3(null);
        }
        context.removeEventListener("eip6963:announceProvider", addProvider);
      };
      const timer = setTimeout(() => {
        finalize();
      }, timeout);
      context.addEventListener("eip6963:announceProvider", addProvider);
      context.dispatchEvent(new Event("eip6963:requestProvider"));
    });
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-blockscout.js
function getUrl2(name) {
  switch (name) {
    case "mainnet":
      return "https://eth.blockscout.com/api/eth-rpc";
    case "sepolia":
      return "https://eth-sepolia.blockscout.com/api/eth-rpc";
    case "holesky":
      return "https://eth-holesky.blockscout.com/api/eth-rpc";
    case "classic":
      return "https://etc.blockscout.com/api/eth-rpc";
    case "arbitrum":
      return "https://arbitrum.blockscout.com/api/eth-rpc";
    case "base":
      return "https://base.blockscout.com/api/eth-rpc";
    case "base-sepolia":
      return "https://base-sepolia.blockscout.com/api/eth-rpc";
    case "matic":
      return "https://polygon.blockscout.com/api/eth-rpc";
    case "optimism":
      return "https://optimism.blockscout.com/api/eth-rpc";
    case "optimism-sepolia":
      return "https://optimism-sepolia.blockscout.com/api/eth-rpc";
    case "xdai":
      return "https://gnosis.blockscout.com/api/eth-rpc";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var BlockscoutProvider = class _BlockscoutProvider extends JsonRpcProvider2 {
  /**
   *  The API key.
   */
  apiKey;
  /**
   *  Creates a new **BlockscoutProvider**.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (apiKey == null) {
      apiKey = null;
    }
    const request = _BlockscoutProvider.getRequest(network);
    super(request, network, { staticNetwork: network });
    defineProperties2(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _BlockscoutProvider(chainId, this.apiKey);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === null;
  }
  getRpcRequest(req) {
    const resp = super.getRpcRequest(req);
    if (resp && resp.method === "eth_estimateGas" && resp.args.length == 1) {
      resp.args = resp.args.slice();
      resp.args.push("latest");
    }
    return resp;
  }
  getRpcError(payload, _error) {
    const error2 = _error ? _error.error : null;
    if (error2 && error2.code === -32015 && !isHexString2(error2.data || "", true)) {
      const panicCodes = {
        "assert(false)": "01",
        "arithmetic underflow or overflow": "11",
        "division or modulo by zero": "12",
        "out-of-bounds array access; popping on an empty array": "31",
        "out-of-bounds access of an array or bytesN": "32"
      };
      let panicCode = "";
      if (error2.message === "VM execution error.") {
        panicCode = panicCodes[error2.data] || "";
      } else if (panicCodes[error2.message || ""]) {
        panicCode = panicCodes[error2.message || ""];
      }
      if (panicCode) {
        error2.message += ` (reverted: ${error2.data})`;
        error2.data = "0x4e487b7100000000000000000000000000000000000000000000000000000000000000" + panicCode;
      }
    } else if (error2 && error2.code === -32e3) {
      if (error2.message === "wrong transaction nonce") {
        error2.message += " (nonce too low)";
      }
    }
    return super.getRpcError(payload, _error);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%apiKey%%.
   */
  static getRequest(network) {
    const request = new FetchRequest2(getUrl2(network.name));
    request.allowGzip = true;
    return request;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-pocket.js
var defaultApplicationId2 = "62e1ad51b37b8e00394bda3b";
function getHost12(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument2(false, "unsupported network", "network", name);
}
var PocketProvider2 = class _PocketProvider extends JsonRpcProvider2 {
  /**
   *  The Application ID for the Pocket connection.
   */
  applicationId;
  /**
   *  The Application Secret for making authenticated requests
   *  to the Pocket connection.
   */
  applicationSecret;
  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId2;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network };
    const request = _PocketProvider.getRequest(network, applicationId, applicationSecret);
    super(request, network, options);
    defineProperties2(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new _PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error2) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%applicationId%%.
   */
  static getRequest(network, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId2;
    }
    const request = new FetchRequest2(`https://${getHost12(network.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId2;
  }
};

// ../../../../../node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js
var IpcSocketProvider2 = void 0;

// ../../../../../node_modules/ethers/lib.esm/wallet/base-wallet.js
var BaseWallet2 = class _BaseWallet extends AbstractSigner2 {
  /**
   *  The wallet address.
   */
  address;
  #signingKey;
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    assertArgument2(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address = computeAddress2(this.signingKey.publicKey);
    defineProperties2(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return this.#signingKey;
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _BaseWallet(this.#signingKey, provider);
  }
  async signTransaction(tx) {
    tx = copyRequest2(tx);
    const { to, from } = await resolveProperties2({
      to: tx.to ? resolveAddress2(tx.to, this) : void 0,
      from: tx.from ? resolveAddress2(tx.from, this) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument2(getAddress2(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction2.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage2(message)).serialized;
  }
  /**
   *  Returns the Authorization for %%auth%%.
   */
  authorizeSync(auth) {
    assertArgument2(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
    const signature = this.signingKey.sign(hashAuthorization(auth));
    return Object.assign({}, {
      address: getAddress2(auth.address),
      nonce: getBigInt2(auth.nonce || 0),
      chainId: getBigInt2(auth.chainId || 0)
    }, { signature });
  }
  /**
   *  Resolves to the Authorization for %%auth%%.
   */
  async authorize(auth) {
    auth = Object.assign({}, auth, {
      address: await resolveAddress2(auth.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth));
  }
  async signTypedData(domain3, types, value) {
    const populated = await TypedDataEncoder2.resolveNames(domain3, types, value, async (name) => {
      assert5(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert5(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder2.hash(populated.domain, types, populated.value)).serialized;
  }
};

// ../../../../../node_modules/ethers/lib.esm/wordlists/decode-owl.js
var subsChrs2 = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word2 = /^[a-z]*$/i;
function unfold2(words3, sep2) {
  let initial = 97;
  return words3.reduce((accum, word) => {
    if (word === sep2) {
      initial++;
    } else if (word.match(Word2)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode7(data, subs) {
  for (let i2 = subsChrs2.length - 1; i2 >= 0; i2--) {
    data = data.split(subsChrs2[i2]).join(subs.substring(2 * i2, 2 * i2 + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i2 = parseInt(semi); i2 >= 0; i2--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold2(unfold2(clumps, ";"), ":");
}
function decodeOwl2(data) {
  assertArgument2(data[0] === "0", "unsupported auwl data", "data", data);
  return decode7(data.substring(1 + 2 * subsChrs2.length), data.substring(1, 1 + 2 * subsChrs2.length));
}

// ../../../../../node_modules/ethers/lib.esm/wordlists/wordlist.js
var Wordlist2 = class {
  locale;
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    defineProperties2(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words3) {
    return words3.join(" ");
  }
};

// ../../../../../node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
var WordlistOwl2 = class extends Wordlist2 {
  #data;
  #checksum;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum3) {
    super(locale);
    this.#data = data;
    this.#checksum = checksum3;
    this.#words = null;
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return this.#data;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl2(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words3 = this._decodeWords();
      const checksum3 = id2(words3.join("\n") + "\n");
      if (checksum3 !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words3;
    }
    return this.#words;
  }
  getWord(index) {
    const words3 = this.#loadWords();
    assertArgument2(index >= 0 && index < words3.length, `invalid word index: ${index}`, "index", index);
    return words3[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
};

// ../../../../../node_modules/ethers/lib.esm/wordlists/lang-en.js
var words2 = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum2 = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist2 = null;
var LangEn2 = class _LangEn extends WordlistOwl2 {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words2, checksum2);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist2 == null) {
      wordlist2 = new _LangEn();
    }
    return wordlist2;
  }
};

// ../../../../../node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask2(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask2(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy2(mnemonic, wordlist3) {
  assertNormalize2("NFKD");
  if (wordlist3 == null) {
    wordlist3 = LangEn2.wordlist();
  }
  const words3 = wordlist3.split(mnemonic);
  assertArgument2(words3.length % 3 === 0 && words3.length >= 12 && words3.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words3.length / 8));
  let offset = 0;
  for (let i2 = 0; i2 < words3.length; i2++) {
    let index = wordlist3.getWordIndex(words3[i2].normalize("NFKD"));
    assertArgument2(index >= 0, `invalid mnemonic word at index ${i2}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words3.length / 3;
  const checksumBits = words3.length / 3;
  const checksumMask = getUpperMask2(checksumBits);
  const checksum3 = getBytes2(sha2564(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument2(checksum3 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify2(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic2(entropy, wordlist3) {
  assertArgument2(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist3 == null) {
    wordlist3 = LangEn2.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask2(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum3 = parseInt(sha2564(entropy).substring(2, 4), 16) & getUpperMask2(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum3 >> 8 - checksumBits;
  return wordlist3.join(indices.map((index) => wordlist3.getWord(index)));
}
var _guard11 = {};
var Mnemonic2 = class _Mnemonic {
  /**
   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
   *
   *  Use the [[wordlist]] ``split`` method to get the individual words.
   */
  phrase;
  /**
   *  The password used for this mnemonic. If no password is used this
   *  is the empty string (i.e. ``""``) as per the specification.
   */
  password;
  /**
   *  The wordlist for this mnemonic.
   */
  wordlist;
  /**
   *  The underlying entropy which the mnemonic encodes.
   */
  entropy;
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn2.wordlist();
    }
    assertPrivate2(guard, _guard11, "Mnemonic");
    defineProperties2(this, { phrase, password, wordlist: wordlist3, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes2("mnemonic" + this.password, "NFKD");
    return pbkdf24(toUtf8Bytes2(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist3) {
    const entropy = mnemonicToEntropy2(phrase, wordlist3);
    phrase = entropyToMnemonic2(getBytes2(entropy), wordlist3);
    return new _Mnemonic(_guard11, entropy, phrase, password, wordlist3);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist3) {
    const entropy = getBytes2(_entropy, "entropy");
    const phrase = entropyToMnemonic2(entropy, wordlist3);
    return new _Mnemonic(_guard11, hexlify2(entropy), phrase, password, wordlist3);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist3) {
    const entropy = getBytes2(_entropy, "entropy");
    return entropyToMnemonic2(entropy, wordlist3);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist3) {
    return mnemonicToEntropy2(phrase, wordlist3);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist3) {
    try {
      mnemonicToEntropy2(phrase, wordlist3);
      return true;
    } catch (error2) {
    }
    return false;
  }
};

// ../../../../../node_modules/aes-js/lib.esm/aes.js
var __classPrivateFieldGet5 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
};
var _AES_key2;
var _AES_Kd2;
var _AES_Ke2;
var numberOfRounds2 = { 16: 10, 24: 12, 32: 14 };
var rcon2 = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T14 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T42 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T52 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T62 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T72 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T82 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U12 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U32 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U42 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt322(bytes4) {
  const result2 = [];
  for (let i2 = 0; i2 < bytes4.length; i2 += 4) {
    result2.push(bytes4[i2] << 24 | bytes4[i2 + 1] << 16 | bytes4[i2 + 2] << 8 | bytes4[i2 + 3]);
  }
  return result2;
}
var AES2 = class _AES {
  get key() {
    return __classPrivateFieldGet5(this, _AES_key2, "f").slice();
  }
  constructor(key) {
    _AES_key2.set(this, void 0);
    _AES_Kd2.set(this, void 0);
    _AES_Ke2.set(this, void 0);
    if (!(this instanceof _AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet4(this, _AES_key2, new Uint8Array(key), "f");
    const rounds = numberOfRounds2[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet4(this, _AES_Ke2, [], "f");
    __classPrivateFieldSet4(this, _AES_Kd2, [], "f");
    for (let i2 = 0; i2 <= rounds; i2++) {
      __classPrivateFieldGet5(this, _AES_Ke2, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet5(this, _AES_Kd2, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt322(this.key);
    let index;
    for (let i2 = 0; i2 < KC; i2++) {
      index = i2 >> 2;
      __classPrivateFieldGet5(this, _AES_Ke2, "f")[index][i2 % 4] = tk[i2];
      __classPrivateFieldGet5(this, _AES_Kd2, "f")[rounds - index][i2 % 4] = tk[i2];
    }
    let rconpointer = 0;
    let t2 = KC, tt;
    while (t2 < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon2[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i3 = 1; i3 < KC; i3++) {
          tk[i3] ^= tk[i3 - 1];
        }
      } else {
        for (let i3 = 1; i3 < KC / 2; i3++) {
          tk[i3] ^= tk[i3 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
        for (let i3 = KC / 2 + 1; i3 < KC; i3++) {
          tk[i3] ^= tk[i3 - 1];
        }
      }
      let i2 = 0, r3, c2;
      while (i2 < KC && t2 < roundKeyCount) {
        r3 = t2 >> 2;
        c2 = t2 % 4;
        __classPrivateFieldGet5(this, _AES_Ke2, "f")[r3][c2] = tk[i2];
        __classPrivateFieldGet5(this, _AES_Kd2, "f")[rounds - r3][c2] = tk[i2++];
        t2++;
      }
    }
    for (let r3 = 1; r3 < rounds; r3++) {
      for (let c2 = 0; c2 < 4; c2++) {
        tt = __classPrivateFieldGet5(this, _AES_Kd2, "f")[r3][c2];
        __classPrivateFieldGet5(this, _AES_Kd2, "f")[r3][c2] = U12[tt >> 24 & 255] ^ U22[tt >> 16 & 255] ^ U32[tt >> 8 & 255] ^ U42[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet5(this, _AES_Ke2, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t2 = convertToInt322(plaintext);
    for (let i2 = 0; i2 < 4; i2++) {
      t2[i2] ^= __classPrivateFieldGet5(this, _AES_Ke2, "f")[0][i2];
    }
    for (let r3 = 1; r3 < rounds; r3++) {
      for (let i2 = 0; i2 < 4; i2++) {
        a2[i2] = T14[t2[i2] >> 24 & 255] ^ T22[t2[(i2 + 1) % 4] >> 16 & 255] ^ T32[t2[(i2 + 2) % 4] >> 8 & 255] ^ T42[t2[(i2 + 3) % 4] & 255] ^ __classPrivateFieldGet5(this, _AES_Ke2, "f")[r3][i2];
      }
      t2 = a2.slice();
    }
    const result2 = new Uint8Array(16);
    let tt = 0;
    for (let i2 = 0; i2 < 4; i2++) {
      tt = __classPrivateFieldGet5(this, _AES_Ke2, "f")[rounds][i2];
      result2[4 * i2] = (S2[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
      result2[4 * i2 + 1] = (S2[t2[(i2 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result2[4 * i2 + 2] = (S2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result2[4 * i2 + 3] = (S2[t2[(i2 + 3) % 4] & 255] ^ tt) & 255;
    }
    return result2;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet5(this, _AES_Kd2, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t2 = convertToInt322(ciphertext);
    for (let i2 = 0; i2 < 4; i2++) {
      t2[i2] ^= __classPrivateFieldGet5(this, _AES_Kd2, "f")[0][i2];
    }
    for (let r3 = 1; r3 < rounds; r3++) {
      for (let i2 = 0; i2 < 4; i2++) {
        a2[i2] = T52[t2[i2] >> 24 & 255] ^ T62[t2[(i2 + 3) % 4] >> 16 & 255] ^ T72[t2[(i2 + 2) % 4] >> 8 & 255] ^ T82[t2[(i2 + 1) % 4] & 255] ^ __classPrivateFieldGet5(this, _AES_Kd2, "f")[r3][i2];
      }
      t2 = a2.slice();
    }
    const result2 = new Uint8Array(16);
    let tt = 0;
    for (let i2 = 0; i2 < 4; i2++) {
      tt = __classPrivateFieldGet5(this, _AES_Kd2, "f")[rounds][i2];
      result2[4 * i2] = (Si2[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
      result2[4 * i2 + 1] = (Si2[t2[(i2 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result2[4 * i2 + 2] = (Si2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result2[4 * i2 + 3] = (Si2[t2[(i2 + 1) % 4] & 255] ^ tt) & 255;
    }
    return result2;
  }
};
_AES_key2 = /* @__PURE__ */ new WeakMap(), _AES_Kd2 = /* @__PURE__ */ new WeakMap(), _AES_Ke2 = /* @__PURE__ */ new WeakMap();

// ../../../../../node_modules/aes-js/lib.esm/mode.js
var ModeOfOperation2 = class {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES2(key) },
      name: { enumerable: true, value: name }
    });
  }
};

// ../../../../../node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet5 = function(receiver, state, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CBC_iv2;
var _CBC_lastBlock2;
var CBC2 = class _CBC extends ModeOfOperation2 {
  constructor(key, iv) {
    super("ECC", key, _CBC);
    _CBC_iv2.set(this, void 0);
    _CBC_lastBlock2.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet5(this, _CBC_iv2, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet5(this, _CBC_iv2, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet5(this, _CBC_lastBlock2, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet6(this, _CBC_iv2, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i2 = 0; i2 < plaintext.length; i2 += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet6(this, _CBC_lastBlock2, "f")[j] ^= plaintext[i2 + j];
      }
      __classPrivateFieldSet5(this, _CBC_lastBlock2, this.aes.encrypt(__classPrivateFieldGet6(this, _CBC_lastBlock2, "f")), "f");
      ciphertext.set(__classPrivateFieldGet6(this, _CBC_lastBlock2, "f"), i2);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i2 = 0; i2 < ciphertext.length; i2 += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i2, i2 + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i2 + j] = block[j] ^ __classPrivateFieldGet6(this, _CBC_lastBlock2, "f")[j];
        __classPrivateFieldGet6(this, _CBC_lastBlock2, "f")[j] = ciphertext[i2 + j];
      }
    }
    return plaintext;
  }
};
_CBC_iv2 = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock2 = /* @__PURE__ */ new WeakMap();

// ../../../../../node_modules/aes-js/lib.esm/mode-cfb.js
var __classPrivateFieldGet7 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CFB_instances2;
var _CFB_iv2;
var _CFB_shiftRegister2;
var _CFB_shift3;
_CFB_iv2 = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister2 = /* @__PURE__ */ new WeakMap(), _CFB_instances2 = /* @__PURE__ */ new WeakSet(), _CFB_shift3 = function _CFB_shift4(data) {
  const segmentSize = this.segmentSize / 8;
  __classPrivateFieldGet7(this, _CFB_shiftRegister2, "f").set(__classPrivateFieldGet7(this, _CFB_shiftRegister2, "f").subarray(segmentSize));
  __classPrivateFieldGet7(this, _CFB_shiftRegister2, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
};

// ../../../../../node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet6 = function(receiver, state, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet8 = function(receiver, state, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CTR_remaining2;
var _CTR_remainingIndex2;
var _CTR_counter2;
var CTR2 = class _CTR extends ModeOfOperation2 {
  constructor(key, initialValue) {
    super("CTR", key, _CTR);
    _CTR_remaining2.set(this, void 0);
    _CTR_remainingIndex2.set(this, void 0);
    _CTR_counter2.set(this, void 0);
    __classPrivateFieldSet6(this, _CTR_counter2, new Uint8Array(16), "f");
    __classPrivateFieldGet8(this, _CTR_counter2, "f").fill(0);
    __classPrivateFieldSet6(this, _CTR_remaining2, __classPrivateFieldGet8(this, _CTR_counter2, "f"), "f");
    __classPrivateFieldSet6(this, _CTR_remainingIndex2, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet8(this, _CTR_counter2, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet8(this, _CTR_counter2, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet8(this, _CTR_counter2, "f").set(value);
  }
  increment() {
    for (let i2 = 15; i2 >= 0; i2--) {
      if (__classPrivateFieldGet8(this, _CTR_counter2, "f")[i2] === 255) {
        __classPrivateFieldGet8(this, _CTR_counter2, "f")[i2] = 0;
      } else {
        __classPrivateFieldGet8(this, _CTR_counter2, "f")[i2]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i2 = 0; i2 < crypttext.length; i2++) {
      if (__classPrivateFieldGet8(this, _CTR_remainingIndex2, "f") === 16) {
        __classPrivateFieldSet6(this, _CTR_remaining2, this.aes.encrypt(__classPrivateFieldGet8(this, _CTR_counter2, "f")), "f");
        __classPrivateFieldSet6(this, _CTR_remainingIndex2, 0, "f");
        this.increment();
      }
      crypttext[i2] ^= __classPrivateFieldGet8(this, _CTR_remaining2, "f")[__classPrivateFieldSet6(this, _CTR_remainingIndex2, (_b = __classPrivateFieldGet8(this, _CTR_remainingIndex2, "f"), _a = _b++, _b), "f"), _a];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
};
_CTR_remaining2 = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex2 = /* @__PURE__ */ new WeakMap(), _CTR_counter2 = /* @__PURE__ */ new WeakMap();

// ../../../../../node_modules/aes-js/lib.esm/mode-ofb.js
var _OFB_iv2;
var _OFB_lastPrecipher2;
var _OFB_lastPrecipherIndex2;
_OFB_iv2 = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher2 = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex2 = /* @__PURE__ */ new WeakMap();

// ../../../../../node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip2(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i2 = 0; i2 < padder; i2++) {
    if (data[length + i2] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}

// ../../../../../node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify2(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy2(hexString);
}
function zpad3(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword2(password) {
  if (typeof password === "string") {
    return toUtf8Bytes2(password, "NFKC");
  }
  return getBytesCopy2(password);
}
function spelunk2(object3, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument2(match != null, "invalid path", "path", _path);
  const path2 = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object3;
  for (const comp of path2.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument2(!reqd || cur != null, "missing required value", "path", path2);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify2(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument2(false, `wrong type found for ${type} `, "path", path2);
  }
  return cur;
}

// ../../../../../node_modules/ethers/lib.esm/wallet/json-keystore.js
var defaultPath3 = "m/44'/60'/0'/0/0";
function isKeystoreJson2(json) {
  try {
    const data = JSON.parse(json);
    const version4 = data.version != null ? parseInt(data.version) : 0;
    if (version4 === 3) {
      return true;
    }
  } catch (error2) {
  }
  return false;
}
function decrypt2(data, key, ciphertext) {
  const cipher = spelunk2(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk2(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR2(key, iv);
    return hexlify2(aesCtr.decrypt(ciphertext));
  }
  assert5(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount2(data, _key) {
  const key = getBytes2(_key);
  const ciphertext = spelunk2(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify2(keccak2562(concat3([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument2(computedMAC === spelunk2(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt2(data, key.slice(0, 16), ciphertext);
  const address = computeAddress2(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument2(getAddress2(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account = { address, privateKey };
  const version4 = spelunk2(data, "x-ethers.version:string");
  if (version4 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk2(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk2(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR2(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk2(data, "x-ethers.path:string") || defaultPath3,
      locale: spelunk2(data, "x-ethers.locale:string") || "en",
      entropy: hexlify2(getBytes2(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams2(data) {
  const kdf = spelunk2(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk2(data, "crypto.kdfparams.salt:data!");
      const N5 = spelunk2(data, "crypto.kdfparams.n:int!");
      const r3 = spelunk2(data, "crypto.kdfparams.r:int!");
      const p3 = spelunk2(data, "crypto.kdfparams.p:int!");
      assertArgument2(N5 > 0 && (N5 & N5 - 1) === 0, "invalid kdf.N", "kdf.N", N5);
      assertArgument2(r3 > 0 && p3 > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk2(data, "crypto.kdfparams.dklen:int!");
      assertArgument2(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N5, r: r3, p: p3, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk2(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk2(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument2(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk2(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk2(data, "crypto.kdfparams.dklen:int!");
      assertArgument2(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument2(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync2(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword2(_password);
  const params = getDecryptKdfParams2(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf24(password, salt2, count, dkLen2, algorithm);
    return getAccount2(data, key2);
  }
  assert5(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N5, r: r3, p: p3, dkLen } = params;
  const key = scryptSync2(password, salt, N5, r3, p3, dkLen);
  return getAccount2(data, key);
}
function stall7(duration) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3();
    }, duration);
  });
}
async function decryptKeystoreJson2(json, _password, progress) {
  const data = JSON.parse(json);
  const password = getPassword2(_password);
  const params = getDecryptKdfParams2(data);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall7(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf24(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall7(0);
    }
    return getAccount2(data, key2);
  }
  assert5(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N5, r: r3, p: p3, dkLen } = params;
  const key = await scrypt4(password, salt, N5, r3, p3, dkLen, progress);
  return getAccount2(data, key);
}
function getEncryptKdfParams2(options) {
  const salt = options.salt != null ? getBytes2(options.salt, "options.salt") : randomBytes6(32);
  let N5 = 1 << 17, r3 = 8, p3 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N5 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r3 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p3 = options.scrypt.p;
    }
  }
  assertArgument2(typeof N5 === "number" && N5 > 0 && Number.isSafeInteger(N5) && (BigInt(N5) & BigInt(N5 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N5);
  assertArgument2(typeof r3 === "number" && r3 > 0 && Number.isSafeInteger(r3), "invalid scrypt r parameter", "options.r", r3);
  assertArgument2(typeof p3 === "number" && p3 > 0 && Number.isSafeInteger(p3), "invalid scrypt p parameter", "options.p", p3);
  return { name: "scrypt", dkLen: 32, salt, N: N5, r: r3, p: p3 };
}
function _encryptKeystore2(key, kdf, account, options) {
  const privateKey = getBytes2(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes2(options.iv, "options.iv") : randomBytes6(16);
  assertArgument2(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes2(options.uuid, "options.uuid") : randomBytes6(16);
  assertArgument2(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR2(derivedKey, iv);
  const ciphertext = getBytes2(aesCtr.encrypt(privateKey));
  const mac = keccak2562(concat3([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV42(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify2(iv).substring(2)
      },
      ciphertext: hexlify2(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify2(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version3}`;
    const path2 = account.mnemonic.path || defaultPath3;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes2(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes6(16);
    const mnemonicAesCtr = new CTR2(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes2(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp2 = now.getUTCFullYear() + "-" + zpad3(now.getUTCMonth() + 1, 2) + "-" + zpad3(now.getUTCDate(), 2) + "T" + zpad3(now.getUTCHours(), 2) + "-" + zpad3(now.getUTCMinutes(), 2) + "-" + zpad3(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp2 + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path: path2,
      locale,
      mnemonicCounter: hexlify2(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify2(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync2(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword2(password);
  const kdf = getEncryptKdfParams2(options);
  const key = scryptSync2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore2(getBytes2(key), kdf, account, options);
}
async function encryptKeystoreJson2(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword2(password);
  const kdf = getEncryptKdfParams2(options);
  const key = await scrypt4(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore2(getBytes2(key), kdf, account, options);
}

// ../../../../../node_modules/ethers/lib.esm/wallet/hdwallet.js
var defaultPath4 = "m/44'/60'/0'/0/0";
var MasterSecret2 = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit2 = 2147483648;
var N4 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles4 = "0123456789abcdef";
function zpad4(value, length) {
  let result2 = "";
  while (value) {
    result2 = Nibbles4[value % 16] + result2;
    value = Math.trunc(value / 16);
  }
  while (result2.length < length * 2) {
    result2 = "0" + result2;
  }
  return "0x" + result2;
}
function encodeBase58Check2(_value) {
  const value = getBytes2(_value);
  const check = dataSlice2(sha2564(sha2564(value)), 0, 4);
  const bytes4 = concat3([value, check]);
  return encodeBase582(bytes4);
}
var _guard12 = {};
function ser_I2(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit2) {
    assert5(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes2(privateKey), 1);
  } else {
    data.set(getBytes2(publicKey));
  }
  for (let i2 = 24; i2 >= 0; i2 -= 8) {
    data[33 + (i2 >> 3)] = index >> 24 - i2 & 255;
  }
  const I = getBytes2(computeHmac2("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath2(node, path2) {
  const components = path2.split("/");
  assertArgument2(components.length > 0, "invalid path", "path", path2);
  if (components[0] === "m") {
    assertArgument2(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path2);
    components.shift();
  }
  let result2 = node;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument2(index < HardenedBit2, "invalid path index", `path[${i2}]`, component);
      result2 = result2.deriveChild(HardenedBit2 + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument2(index < HardenedBit2, "invalid path index", `path[${i2}]`, component);
      result2 = result2.deriveChild(index);
    } else {
      assertArgument2(false, "invalid path component", `path[${i2}]`, component);
    }
  }
  return result2;
}
var HDNodeWallet2 = class _HDNodeWallet extends BaseWallet2 {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent fingerprint.
   */
  parentFingerprint;
  /**
   *  The mnemonic used to create this HD Node, if available.
   *
   *  Sources such as extended keys do not encode the mnemonic, in
   *  which case this will be ``null``.
   */
  mnemonic;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provide full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  encode it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path2, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    assertPrivate2(guard, _guard12, "HDNodeWallet");
    defineProperties2(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice2(ripemd1604(sha2564(this.publicKey)), 0, 4);
    defineProperties2(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path: path2,
      index,
      depth
    });
    defineProperties2(this, { mnemonic });
  }
  connect(provider) {
    return new _HDNodeWallet(_guard12, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m2 = this.mnemonic;
    if (this.path && m2 && m2.wordlist.locale === "en" && m2.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m2.entropy
      };
    }
    return account;
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson2(this.#account(), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync2(this.#account(), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert5(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check2(concat3([
      "0x0488ADE4",
      zpad4(this.depth, 1),
      this.parentFingerprint,
      zpad4(this.index, 4),
      this.chainCode,
      concat3(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet2(_guard12, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber2(_index, "index");
    assertArgument2(index <= 4294967295, "invalid index", "index", index);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index & ~HardenedBit2);
      if (index & HardenedBit2) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I2(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey2(toBeHex2((toBigInt3(IL) + BigInt(this.privateKey)) % N4, 32));
    return new _HDNodeWallet(_guard12, ki, this.fingerprint, hexlify2(IR), path2, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path2) {
    return derivePath2(this, path2);
  }
  static #fromSeed(_seed, mnemonic) {
    assertArgument2(isBytesLike2(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes2(_seed, "seed");
    assertArgument2(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes2(computeHmac2("sha512", MasterSecret2, seed));
    const signingKey = new SigningKey2(hexlify2(I.slice(0, 32)));
    return new _HDNodeWallet(_guard12, signingKey, "0x00000000", hexlify2(I.slice(32)), "m", 0, 0, mnemonic, null);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes4 = toBeArray2(decodeBase582(extendedKey));
    assertArgument2(bytes4.length === 82 || encodeBase58Check2(bytes4.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes4[4];
    const parentFingerprint = hexlify2(bytes4.slice(5, 9));
    const index = parseInt(hexlify2(bytes4.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify2(bytes4.slice(13, 45));
    const key = bytes4.slice(45, 78);
    switch (hexlify2(bytes4.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify2(key);
        return new HDNodeVoidWallet2(_guard12, computeAddress2(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard12, new SigningKey2(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument2(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path2, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath4;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn2.wordlist();
    }
    const mnemonic = Mnemonic2.fromEntropy(randomBytes6(16), password, wordlist3);
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path2) {
    if (!path2) {
      path2 = defaultPath4;
    }
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path2, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath4;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn2.wordlist();
    }
    const mnemonic = Mnemonic2.fromPhrase(phrase, password, wordlist3);
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    return _HDNodeWallet.#fromSeed(seed, null);
  }
};
var HDNodeVoidWallet2 = class _HDNodeVoidWallet extends VoidSigner2 {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent node fingerprint.
   */
  parentFingerprint;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path2, index, depth, provider) {
    super(address, provider);
    assertPrivate2(guard, _guard12, "HDNodeVoidWallet");
    defineProperties2(this, { publicKey });
    const fingerprint = dataSlice2(ripemd1604(sha2564(publicKey)), 0, 4);
    defineProperties2(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path: path2,
      index,
      depth
    });
  }
  connect(provider) {
    return new _HDNodeVoidWallet(_guard12, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert5(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check2(concat3([
      "0x0488B21E",
      zpad4(this.depth, 1),
      this.parentFingerprint,
      zpad4(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber2(_index, "index");
    assertArgument2(index <= 4294967295, "invalid index", "index", index);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index & ~HardenedBit2);
      if (index & HardenedBit2) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I2(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey2.addPoints(IL, this.publicKey, true);
    const address = computeAddress2(Ki);
    return new _HDNodeVoidWallet(_guard12, address, Ki, this.fingerprint, hexlify2(IR), path2, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path2) {
    return derivePath2(this, path2);
  }
};
function getAccountPath2(_index) {
  const index = getNumber2(_index, "index");
  assertArgument2(index >= 0 && index < HardenedBit2, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath2(_index) {
  const index = getNumber2(_index, "index");
  assertArgument2(index >= 0 && index < HardenedBit2, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}

// ../../../../../node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson2(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error2) {
  }
  return false;
}
function decryptCrowdsaleJson2(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword2(_password);
  const address = getAddress2(spelunk2(data, "ethaddr:string!"));
  const encseed = looseArrayify2(spelunk2(data, "encseed:string!"));
  assertArgument2(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes2(pbkdf24(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC2(key, iv);
  const seed = pkcs7Strip2(getBytes2(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i2 = 0; i2 < seed.length; i2++) {
    seedHex += String.fromCharCode(seed[i2]);
  }
  return { address, privateKey: id2(seedHex) };
}

// ../../../../../node_modules/ethers/lib.esm/wallet/wallet.js
function stall8(duration) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3();
    }, duration);
  });
}
var Wallet2 = class _Wallet extends BaseWallet2 {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey2(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new _Wallet(this.signingKey, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson2(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync2(account, password);
  }
  static #fromAccount(account) {
    assertArgument2(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic = Mnemonic2.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet2.fromMnemonic(mnemonic, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new _Wallet(account.privateKey);
    assertArgument2(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    let account = null;
    if (isKeystoreJson2(json)) {
      account = await decryptKeystoreJson2(json, password, progress);
    } else if (isCrowdsaleJson2(json)) {
      if (progress) {
        progress(0);
        await stall8(0);
      }
      account = decryptCrowdsaleJson2(json, password);
      if (progress) {
        progress(1);
        await stall8(0);
      }
    }
    return _Wallet.#fromAccount(account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    let account = null;
    if (isKeystoreJson2(json)) {
      account = decryptKeystoreJsonSync2(json, password);
    } else if (isCrowdsaleJson2(json)) {
      account = decryptCrowdsaleJson2(json, password);
    } else {
      assertArgument2(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return _Wallet.#fromAccount(account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider) {
    const wallet = HDNodeWallet2.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet2.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
};

// ../../../../../node_modules/ethers/lib.esm/wordlists/bit-reader.js
var Base642 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
function decodeBits2(width, data) {
  const maxValue3 = (1 << width) - 1;
  const result2 = [];
  let accum = 0, bits = 0, flood = 0;
  for (let i2 = 0; i2 < data.length; i2++) {
    accum = accum << 6 | Base642.indexOf(data[i2]);
    bits += 6;
    while (bits >= width) {
      const value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      if (value === 0) {
        flood += maxValue3;
      } else {
        result2.push(value + flood);
        flood = 0;
      }
    }
  }
  return result2;
}

// ../../../../../node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA2(data, accents) {
  let words3 = decodeOwl2(data).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument2(match !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits2(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words3 = words3.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words3.split(",");
}

// ../../../../../node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
var WordlistOwlA2 = class extends WordlistOwl2 {
  #accent;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
   *  and %%accent%% data and validated against the %%checksum%%.
   */
  constructor(locale, data, accent, checksum3) {
    super(locale, data, checksum3);
    this.#accent = accent;
  }
  /**
   *  The OWLA-encoded accent data.
   */
  get _accent() {
    return this.#accent;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwlA2(this._data, this._accent);
  }
};

// ../../../../../node_modules/ethers/lib.esm/wordlists/wordlists-browser.js
var wordlists2 = {
  en: LangEn2.wordlist()
};

// node_modules/azle/src/stable/lib/canister_methods/index.ts
function decoratorArgumentsHandler(canisterMethodMode, param1, param2, param3) {
  const decoratorIsOverloadedWithoutParams = isDecoratorOverloadedWithoutParams(param1, param2);
  if (decoratorIsOverloadedWithoutParams === true) {
    const originalMethod = param1;
    const context = param2;
    return decoratorImplementation(
      canisterMethodMode,
      originalMethod,
      context
    );
  } else {
    const paramIdlTypes = canisterMethodMode === "query" || canisterMethodMode === "update" || canisterMethodMode === "init" || canisterMethodMode === "postUpgrade" ? param1 : void 0;
    const returnIdlType = canisterMethodMode === "query" || canisterMethodMode === "update" ? param2 : void 0;
    const options = canisterMethodMode === "inspectMessage" ? param1 : canisterMethodMode === "init" || canisterMethodMode === "postUpgrade" ? param2 : param3;
    return (originalMethod, context) => {
      return decoratorImplementation(
        canisterMethodMode,
        originalMethod,
        context,
        paramIdlTypes,
        returnIdlType,
        options
      );
    };
  }
}
function decoratorImplementation(canisterMethodMode, originalMethod, context, paramIdlTypes, returnIdlType, options) {
  context.addInitializer(function() {
    let defaultCanisterClassMeta = {
      callbacks: {},
      canisterMethodIdlParamTypes: {},
      canisterMethodsIndex: 0,
      initAndPostUpgradeIdlTypes: [],
      methodMeta: {
        queries: [],
        updates: []
      }
    };
    let canisterClassMeta = this.constructor._azleCanisterClassMeta ?? defaultCanisterClassMeta;
    const name = context.name;
    const index = canisterClassMeta.canisterMethodsIndex++;
    const indexString = index.toString();
    if (canisterMethodMode === "query") {
      throwIfMethodAlreadyDefined(
        `@query ${name}`,
        canisterClassMeta.methodMeta.queries?.find(
          (queryMethod) => queryMethod.name === name
        ) !== void 0
      );
      canisterClassMeta.methodMeta.queries?.push({
        name,
        index,
        composite: options?.composite ?? false,
        hidden: options?.hidden ?? false
      });
      canisterClassMeta.canisterMethodIdlParamTypes[name] = idl_exports.Func(
        paramIdlTypes ?? [],
        returnIdlType === void 0 ? [] : [returnIdlType],
        ["query"]
      );
    }
    if (canisterMethodMode === "update") {
      throwIfMethodAlreadyDefined(
        `@update ${name}`,
        canisterClassMeta.methodMeta.updates?.find(
          (updateMethod) => updateMethod.name === name
        ) !== void 0
      );
      canisterClassMeta.methodMeta.updates?.push({
        name,
        index,
        hidden: options?.hidden ?? false
      });
      canisterClassMeta.canisterMethodIdlParamTypes[name] = idl_exports.Func(
        paramIdlTypes ?? [],
        returnIdlType === void 0 ? [] : [returnIdlType]
      );
    }
    if (canisterMethodMode === "init") {
      throwIfMethodAlreadyDefined(
        "@init",
        canisterClassMeta.methodMeta.init !== void 0
      );
      canisterClassMeta.methodMeta.init = {
        name,
        index
      };
      const postUpgradeDefined = canisterClassMeta.methodMeta.post_upgrade !== void 0;
      if (postUpgradeDefined === true) {
        verifyInitAndPostUpgradeHaveTheSameParams(
          paramIdlTypes ?? [],
          canisterClassMeta.initAndPostUpgradeIdlTypes
        );
      } else {
        canisterClassMeta.initAndPostUpgradeIdlTypes = paramIdlTypes ?? [];
      }
    }
    if (canisterMethodMode === "postUpgrade") {
      throwIfMethodAlreadyDefined(
        "@postUpgrade",
        canisterClassMeta.methodMeta.post_upgrade !== void 0
      );
      canisterClassMeta.methodMeta.post_upgrade = {
        name,
        index
      };
      const initDefined = canisterClassMeta.methodMeta.init !== void 0;
      if (initDefined === true) {
        verifyInitAndPostUpgradeHaveTheSameParams(
          paramIdlTypes ?? [],
          canisterClassMeta.initAndPostUpgradeIdlTypes
        );
      } else {
        canisterClassMeta.initAndPostUpgradeIdlTypes = paramIdlTypes ?? [];
      }
    }
    if (canisterMethodMode === "preUpgrade") {
      throwIfMethodAlreadyDefined(
        "@preUpgrade",
        canisterClassMeta.methodMeta.pre_upgrade !== void 0
      );
      canisterClassMeta.methodMeta.pre_upgrade = {
        name,
        index
      };
    }
    if (canisterMethodMode === "inspectMessage") {
      throwIfMethodAlreadyDefined(
        "@inspectMessage",
        canisterClassMeta.methodMeta.inspect_message !== void 0
      );
      canisterClassMeta.methodMeta.inspect_message = {
        name,
        index
      };
    }
    if (canisterMethodMode === "heartbeat") {
      throwIfMethodAlreadyDefined(
        "@heartbeat",
        canisterClassMeta.methodMeta.heartbeat !== void 0
      );
      canisterClassMeta.methodMeta.heartbeat = {
        name,
        index
      };
    }
    if (canisterMethodMode === "onLowWasmMemory") {
      throwIfMethodAlreadyDefined(
        "@onLowWasmMemory",
        canisterClassMeta.methodMeta.on_low_wasm_memory !== void 0
      );
      canisterClassMeta.methodMeta.on_low_wasm_memory = {
        name,
        index
      };
    }
    canisterClassMeta.callbacks[indexString] = async () => {
      try {
        await executeAndReplyWithCandidSerde(
          canisterMethodMode,
          originalMethod.bind(this),
          paramIdlTypes ?? [],
          returnIdlType,
          options?.manual ?? false,
          canisterClassMeta.canisterMethodIdlParamTypes
        );
      } catch (error2) {
        handleUncaughtError(error2);
      }
    };
  });
}
function isDecoratorOverloadedWithoutParams(param1, param2) {
  return typeof param1 === "function" && param2 !== void 0 && "kind" in param2 && param2.kind === "method" && param2.metadata !== void 0 && param2.name !== void 0;
}
function verifyInitAndPostUpgradeHaveTheSameParams(a2, b4) {
  const aSignature = idlToString(idl_exports.Func(a2, []));
  const bSignature = idlToString(idl_exports.Func(b4, []));
  if (aSignature !== bSignature) {
    throw new Error(
      `'@init' and '@postUpgrade' methods must have the same parameters.
Found:
${aSignature}
${bSignature}`
    );
  }
}
function throwIfMethodAlreadyDefined(methodName, isDefined) {
  if (isDefined === true) {
    throw new Error(
      `'${methodName}' method can only have one definition in the canister`
    );
  }
}

// node_modules/azle/src/stable/lib/canister_methods/query.ts
function query2(param1, param2, param3) {
  return decoratorArgumentsHandler("query", param1, param2, param3);
}

// node_modules/azle/src/stable/lib/canister_methods/update.ts
function update2(param1, param2, param3) {
  return decoratorArgumentsHandler("update", param1, param2, param3);
}

// ../../../../../node_modules/@dfinity/principal/lib/esm/utils/base32.js
var alphabet2 = "abcdefghijklmnopqrstuvwxyz234567";
var lookupTable2 = /* @__PURE__ */ Object.create(null);
for (let i2 = 0; i2 < alphabet2.length; i2++) {
  lookupTable2[alphabet2[i2]] = i2;
}
lookupTable2["0"] = lookupTable2.o;
lookupTable2["1"] = lookupTable2.i;
function encode6(input2) {
  let skip = 0;
  let bits = 0;
  let output3 = "";
  function encodeByte(byte) {
    if (skip < 0) {
      bits |= byte >> -skip;
    } else {
      bits = byte << skip & 248;
    }
    if (skip > 3) {
      skip -= 8;
      return 1;
    }
    if (skip < 4) {
      output3 += alphabet2[bits >> 3];
      skip += 5;
    }
    return 0;
  }
  for (let i2 = 0; i2 < input2.length; ) {
    i2 += encodeByte(input2[i2]);
  }
  return output3 + (skip < 0 ? alphabet2[bits >> 3] : "");
}
function decode8(input2) {
  let skip = 0;
  let byte = 0;
  const output3 = new Uint8Array(input2.length * 4 / 3 | 0);
  let o3 = 0;
  function decodeChar(char) {
    let val = lookupTable2[char.toLowerCase()];
    if (val === void 0) {
      throw new Error(`Invalid character: ${JSON.stringify(char)}`);
    }
    val <<= 3;
    byte |= val >>> skip;
    skip += 5;
    if (skip >= 8) {
      output3[o3++] = byte;
      skip -= 8;
      if (skip > 0) {
        byte = val << 5 - skip & 255;
      } else {
        byte = 0;
      }
    }
  }
  for (const c2 of input2) {
    decodeChar(c2);
  }
  return output3.slice(0, o3);
}

// ../../../../../node_modules/@dfinity/principal/lib/esm/utils/getCrc.js
var lookUpTable2 = new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
function getCrc322(buf) {
  const b4 = new Uint8Array(buf);
  let crc = -1;
  for (let i2 = 0; i2 < b4.length; i2++) {
    const byte = b4[i2];
    const t2 = (byte ^ crc) & 255;
    crc = lookUpTable2[t2] ^ crc >>> 8;
  }
  return (crc ^ -1) >>> 0;
}

// ../../../../../node_modules/@noble/hashes/esm/utils.js
function isBytes2(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes2(b4, ...lengths) {
  if (!isBytes2(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes2(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView4(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr4(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function utf8ToBytes6(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes4(data) {
  if (typeof data === "string")
    data = utf8ToBytes6(data);
  abytes2(data);
  return data;
}
var Hash4 = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// ../../../../../node_modules/@noble/hashes/esm/_md.js
function setBigUint644(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE3 ? 4 : 0;
  const l2 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE3);
  view.setUint32(byteOffset + l2, wl, isLE3);
}
function Chi4(a2, b4, c2) {
  return a2 & b4 ^ ~a2 & c2;
}
function Maj4(a2, b4, c2) {
  return a2 & b4 ^ a2 & c2 ^ b4 & c2;
}
var HashMD2 = class extends Hash4 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView4(this.buffer);
  }
  update(data) {
    aexists2(this);
    data = toBytes4(data);
    abytes2(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView4(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView4(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished: finished2, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished2;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV2 = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = /* @__PURE__ */ Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);

// ../../../../../node_modules/@noble/hashes/esm/sha2.js
var SHA256_K4 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W4 = /* @__PURE__ */ new Uint32Array(64);
var SHA2564 = class extends HashMD2 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV2[0] | 0;
    this.B = SHA256_IV2[1] | 0;
    this.C = SHA256_IV2[2] | 0;
    this.D = SHA256_IV2[3] | 0;
    this.E = SHA256_IV2[4] | 0;
    this.F = SHA256_IV2[5] | 0;
    this.G = SHA256_IV2[6] | 0;
    this.H = SHA256_IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F: F2, G, H } = this;
    return [A, B, C, D, E, F2, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F2, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W4[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W4[i2 - 15];
      const W2 = SHA256_W4[i2 - 2];
      const s0 = rotr4(W15, 7) ^ rotr4(W15, 18) ^ W15 >>> 3;
      const s1 = rotr4(W2, 17) ^ rotr4(W2, 19) ^ W2 >>> 10;
      SHA256_W4[i2] = s1 + SHA256_W4[i2 - 7] + s0 + SHA256_W4[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F: F2, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr4(E, 6) ^ rotr4(E, 11) ^ rotr4(E, 25);
      const T15 = H + sigma1 + Chi4(E, F2, G) + SHA256_K4[i2] + SHA256_W4[i2] | 0;
      const sigma0 = rotr4(A, 2) ^ rotr4(A, 13) ^ rotr4(A, 22);
      const T23 = sigma0 + Maj4(A, B, C) | 0;
      H = G;
      G = F2;
      F2 = E;
      E = D + T15 | 0;
      D = C;
      C = B;
      B = A;
      A = T15 + T23 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F2, G, H);
  }
  roundClean() {
    clean(SHA256_W4);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA2242 = class extends SHA2564 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var sha2243 = /* @__PURE__ */ createHasher(() => new SHA2242());

// ../../../../../node_modules/@noble/hashes/esm/sha256.js
var sha2244 = sha2243;

// ../../../../../node_modules/@dfinity/principal/lib/esm/utils/sha224.js
function sha2245(data) {
  return sha2244.create().update(new Uint8Array(data)).digest();
}

// ../../../../../node_modules/@dfinity/principal/lib/esm/index.js
var JSON_KEY_PRINCIPAL2 = "__principal__";
var SELF_AUTHENTICATING_SUFFIX2 = 2;
var ANONYMOUS_SUFFIX2 = 4;
var MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR2 = "aaaaa-aa";
var fromHexString2 = (hexString) => {
  var _a;
  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map((byte) => parseInt(byte, 16)));
};
var toHexString2 = (bytes4) => bytes4.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
var Principal5 = class _Principal {
  constructor(_arr) {
    this._arr = _arr;
    this._isPrincipal = true;
  }
  static anonymous() {
    return new this(new Uint8Array([ANONYMOUS_SUFFIX2]));
  }
  /**
   * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`
   * @returns {Principal} principal of the management canister
   */
  static managementCanister() {
    return this.fromText(MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR2);
  }
  static selfAuthenticating(publicKey) {
    const sha = sha2245(publicKey);
    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX2]));
  }
  static from(other) {
    if (typeof other === "string") {
      return _Principal.fromText(other);
    } else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {
      return new _Principal(other);
    } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
      return new _Principal(other._arr);
    }
    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
  }
  static fromHex(hex) {
    return new this(fromHexString2(hex));
  }
  static fromText(text3) {
    let maybePrincipal = text3;
    if (text3.includes(JSON_KEY_PRINCIPAL2)) {
      const obj = JSON.parse(text3);
      if (JSON_KEY_PRINCIPAL2 in obj) {
        maybePrincipal = obj[JSON_KEY_PRINCIPAL2];
      }
    }
    const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, "");
    let arr = decode8(canisterIdNoDash);
    arr = arr.slice(4, arr.length);
    const principal = new this(arr);
    if (principal.toText() !== maybePrincipal) {
      throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${maybePrincipal}" may not be a valid Principal ID).`);
    }
    return principal;
  }
  static fromUint8Array(arr) {
    return new this(arr);
  }
  isAnonymous() {
    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX2;
  }
  toUint8Array() {
    return this._arr;
  }
  toHex() {
    return toHexString2(this._arr).toUpperCase();
  }
  toText() {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, getCrc322(this._arr));
    const checksum3 = new Uint8Array(checksumArrayBuf);
    const bytes4 = Uint8Array.from(this._arr);
    const array = new Uint8Array([...checksum3, ...bytes4]);
    const result2 = encode6(array);
    const matches = result2.match(/.{1,5}/g);
    if (!matches) {
      throw new Error();
    }
    return matches.join("-");
  }
  toString() {
    return this.toText();
  }
  /**
   * Serializes to JSON
   * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string
   */
  toJSON() {
    return { [JSON_KEY_PRINCIPAL2]: this.toText() };
  }
  /**
   * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification
   * @param {Principal} other - a {@link Principal} to compare
   * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than
   */
  compareTo(other) {
    for (let i2 = 0; i2 < Math.min(this._arr.length, other._arr.length); i2++) {
      if (this._arr[i2] < other._arr[i2])
        return "lt";
      else if (this._arr[i2] > other._arr[i2])
        return "gt";
    }
    if (this._arr.length < other._arr.length)
      return "lt";
    if (this._arr.length > other._arr.length)
      return "gt";
    return "eq";
  }
  /**
   * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method
   * @param other a {@link Principal} to compare
   * @returns {boolean} boolean
   */
  ltEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "lt" || cmp == "eq";
  }
  /**
   * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method
   * @param other a {@link Principal} to compare
   * @returns {boolean} boolean
   */
  gtEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "gt" || cmp == "eq";
  }
};

// src/callee.ts
var callee_exports = {};
__export(callee_exports, {
  default: () => callee_default
});
var _echoUpdate_dec, _echo_dec, _init;
_echo_dec = [query2([idl_exports.Text], idl_exports.Text)], _echoUpdate_dec = [update2([idl_exports.Text], idl_exports.Text)];
var callee_default = class {
  constructor() {
    __runInitializers(_init, 5, this);
  }
  echo(message) {
    return message;
  }
  echoUpdate(message) {
    return message;
  }
};
_init = __decoratorStart(null);
__decorateElement(_init, 1, "echo", _echo_dec, callee_default);
__decorateElement(_init, 1, "echoUpdate", _echoUpdate_dec, callee_default);
__decoratorMetadata(_init, callee_default);

// <stdin>
ethers_exports2.FetchRequest.registerGetUrl(ethersGetUrl);
if (isClassSyntaxExport(callee_exports)) {
  let getCanisterClassMeta = function() {
    const defaultExportNotDefined = callee_default === void 0 || callee_default === null;
    const defaultExportNotAnArrayOrClass = Array.isArray(callee_default) === false && isClass(callee_default) === false;
    const defaultExportAnArrayWithNonClasses = Array.isArray(callee_default) === true && callee_default.every((canisterClass) => isClass(canisterClass) === true) === false;
    if (defaultExportNotDefined === true || defaultExportNotAnArrayOrClass === true || defaultExportAnArrayWithNonClasses === true) {
      throw new Error("A class or an array of classes must be the default export from src/callee.ts");
    }
    const canisterClasses = Array.isArray(callee_default) ? callee_default : [callee_default];
    let canisterClassMeta2 = {
      callbacks: {},
      canisterMethodIdlParamTypes: {},
      canisterMethodsIndex: 0,
      initAndPostUpgradeIdlTypes: [],
      methodMeta: {
        queries: [],
        updates: []
      }
    };
    canisterClasses.forEach((canisterClass) => {
      canisterClass._azleCanisterClassMeta = canisterClassMeta2;
      new canisterClass();
    });
    return canisterClassMeta2;
  }, isClass = function(value) {
    return value !== void 0 && value !== null && typeof value === "function" && value.toString().startsWith("class");
  }, isMethodVisible = function(methodName, methodMeta) {
    const { queries = [], updates = [] } = methodMeta;
    const allMethods = [...queries, ...updates];
    const method = allMethods.find((m2) => m2.name === methodName);
    return method?.hidden === false;
  };
  const canisterClassMeta = getCanisterClassMeta();
  globalThis._azleDispatch({
    type: "SET_AZLE_CANISTER_CLASS_META",
    payload: canisterClassMeta,
    location: {
      filepath: "azle/src/stable/build/commands/build/javascript.ts",
      functionName: "handleClassApiCanister"
    }
  });
  const visibleMethodIdlParamTypes = Object.fromEntries(
    Object.entries(canisterClassMeta.canisterMethodIdlParamTypes).filter(([methodName]) => isMethodVisible(methodName, canisterClassMeta.methodMeta))
  );
  const canisterIdlType = idl_exports.Service(visibleMethodIdlParamTypes);
  const candid = idlToString(canisterIdlType, {
    ...getDefaultVisitorData(),
    isFirstService: true,
    initAndPostUpgradeParamIdlTypes: canisterClassMeta.initAndPostUpgradeIdlTypes
  });
  globalThis._azleGetCandidAndMethodMeta = () => {
    return JSON.stringify({
      candid,
      methodMeta: canisterClassMeta.methodMeta
    });
  };
} else {
  setTimeout(() => {
    const canister = callee_default !== void 0 ? callee_default() : Server2(() => globalThis._azleNodeServer)();
    if (globalThis.process !== void 0 && globalThis.process.env.AZLE_RECORD_BENCHMARKS === "true") {
      const methodMeta = canister.methodMeta;
      globalThis._azleCanisterMethodNames = Object.entries(methodMeta).reduce((acc, [key, value]) => {
        if (value === void 0) {
          return acc;
        }
        if (key === "queries" || key === "updates") {
          const queriesOrUpdates = value.reduce((innerAcc, method) => {
            const indexString = method.index.toString();
            return { ...innerAcc, [indexString]: method.name };
          }, {});
          return { ...acc, ...queriesOrUpdates };
        } else {
          const indexString = value.index.toString();
          return { ...acc, [indexString]: value.name };
        }
      }, {});
    }
    const candid = idlToString(canister.getIdlType([]), {
      ...getDefaultVisitorData(),
      isFirstService: true,
      initAndPostUpgradeParamIdlTypes: canister.getInitAndPostUpgradeParamIdlTypes()
    });
    globalThis._azleCallbacks = canister.callbacks;
    globalThis._azleGetCandidAndMethodMeta = () => {
      return JSON.stringify({
        candid,
        methodMeta: canister.methodMeta
      });
    };
  });
}
function isClassSyntaxExport(canister) {
  const isNothing = canister === void 0 || canister.default === void 0;
  const isFunctionalSyntaxExport = canister?.default?.isCanister === true || canister?.default?.isRecursive === true;
  return !isNothing && !isFunctionalSyntaxExport;
}
export {
  Principal5 as Principal
};
/*! Bundled license information:

wasmedge_quickjs/modules/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

aes-js/lib.esm/aes.js:
aes-js/lib.esm/aes.js:
  (*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. *)
*/
