# TODO the next great simplification might be deploying multiple examples to one dfx replica instance: https://forum.dfinity.org/t/use-the-same-local-replica-for-multiple-projects/11900
# TODO this might allow us to avoid spinning up so many jobs in the matrix

# This GitHub Action flow works as follows:
# The tests are currently simple example-based integration tests.
# Each directory in the examples directory represents an example project and is intended to have tests that ensure the canisters contained in that example function properly.
# These tests are currently written in TypeScript and are intended to be run in a Node.js environment.
# This GitHub Action takes care of deploying to npm and GitHub.
# Tests can either run against the current code of Azle found in the repository, or the code deployed by the GitHub Action to npm.
# Feature branch pull requests (pull requests without release-- in the base branch name) will run all tests against the code found in the repository.
# Release branch pull requests (pull requests with release-- in the base branch name) will run all tests against the code found in the repository and the code deployed by the GitHub Action to npm.
# Pushes to main will run all tests against the code in the repository if the latest commit was not a merge of a release branch, and will run tests against the code in the repository and the code deployed by the GitHub Action to npm otherwise.
# The basic-integration-tests matrix spins up one job per combination of example directory and code source (repo or npm).
# The check-basic-integration-tests-success job is designed to ensure that all jobs spun up from the matrix in the basic-integration-tests have succeeded

name: Azle Tests
on:
    push:
        branches:
            - main
    pull_request: # Runs on pull requests to any branch
jobs:
    see-vars:
        name: See vars
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v4
            - run: |
                  echo "CI: $CI"
                  echo "ACTION: $GITHUB_ACTION"
                  echo "ACTION_PATH: $GITHUB_ACTION_PATH"
                  echo "ACTION_REPOSITORY: $GITHUB_ACTION_REPOSITORY"
                  echo "ACTIONS: $GITHUB_ACTIONS"
                  echo "ACTOR: $GITHUB_ACTOR"
                  echo "ACTOR_ID: $GITHUB_ACTOR_ID"
                  echo "API_URL: $GITHUB_API_URL"
                  echo "BASE_REF: $GITHUB_BASE_REF"
                  echo "ENV: $GITHUB_ENV"
                  echo "EVENT_NAME: $GITHUB_EVENT_NAME"
                  echo "EVENT_PATH: $GITHUB_EVENT_PATH"
                  echo "GRAPHQL_URL: $GITHUB_GRAPHQL_URL"
                  echo "HEAD_REF: $GITHUB_HEAD_REF"
                  echo "JOB: $GITHUB_JOB"
                  echo "OUTPUT: $GITHUB_OUTPUT"
                  echo "PATH: $GITHUB_PATH"
                  echo "REF: $GITHUB_REF"
                  echo "REF_NAME: $GITHUB_REF_NAME"
                  echo "REF_PROTECTED: $GITHUB_REF_PROTECTED"
                  echo "REF_TYPE: $GITHUB_REF_TYPE"
                  echo "REPOSITORY: $GITHUB_REPOSITORY"
                  echo "REPSOITORY ID: $GITHUB_REPOSITORY_ID"
                  echo "REPOSITORY_OWNER: $GITHUB_REPOSITORY_OWNER"
                  echo "REPSOSITRY_OWNDER_ID: $GITHUB_REPOSITORY_OWNER_ID"
                  echo "RETENTION_DAYS: $GITHUB_RETENTION_DAYS"
                  echo "RUN_ATTEMPT: $GITHUB_RUN_ATTEMPT"
                  echo "RUN_ID: $GITHUB_RUN_ID"
                  echo "RUN_NUMBER: $GITHUB_RUN_NUMBER"
                  echo "SERVER_URL: $GITHUB_SERVER_URL"
                  echo "SHA: $GITHUB_SHA"
                  echo "STEP_SUMMARY: $GITHUB_STEP_SUMMARY"
                  echo "TRIGGERING_ACTOR: $GITHUB_TRIGGERING_ACTOR"
                  echo "WORKFLOW: $GITHUB_WORKFLOW"
                  echo "WORKFLOW_REF: $GITHUB_WORKFLOW_REF"
                  echo "WORKFLOW_SHA: $GITHUB_WORKFLOW_SHA"
                  echo "WORKSPACE: $GITHUB_WORKSPACE"
                  echo "ARCH: $RUNNER_ARCH"
                  echo "DEBUG: $RUNNER_DEBUG"
                  echo "ENVIRONMENT: $RUNNER_ENVIRONMENT"
                  echo "NAME: $RUNNER_NAME"
                  echo "OS: $RUNNER_OS"
                  echo "TEMP: $RUNNER_TEMP"
                  echo "TOOL_CACHE: $RUNNER_TOOL_CACHE"

                  # Show the repository's remote URL
                  echo "Repository URL:"
                  git remote get-url origin

                  # Show the current branch name
                  echo -e "\nCurrent Branch:"
                  git branch --show-current

                  # Show the latest commit hash and message
                  echo -e "\nLatest Commit:"
                  git log -1 --pretty=format:"%h - %s"

                  # Show the date and author of the latest commit
                  echo -e "\nCommit Details:"
                  git log -1 --pretty=format:"Author: %an, Date: %ad"

                  # Show the last few commits
                  echo -e "\nLast 20 Commits:"
                  git log --oneline --graph -n 20

                  # Show the repository's status
                  echo -e "\nRepository Status:"
                  git status -s

                  # Show unpushed commits (if any)
                  echo -e "\nUnpushed Commits:"
                  git log @{u}..HEAD --oneline || echo "No unpushed commits"

                  # Show stashes (if any)
                  echo -e "\nGit Stashes:"
                  git stash list || echo "No stashes"

                  echo -e "\nDone!"
    release-candidate-deploy:
        runs-on: ubuntu-latest
        env:
            GPG_SIGNING_KEY: ${{ secrets.GPG_SIGNING_KEY }} # All commits must be verified
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        outputs:
            # These outputs are used to pass information along to the next job
            should_run_tests: ${{ steps.should_run_tests.outputs.should_run_tests }} # We only want the next job to run the tests once we have finished deploying to npm and GitHub
            example_directories: ${{ steps.example_directories.outputs.example_directories }}
        steps:
            - uses: actions/checkout@v4
              # if: contains(github.head_ref, 'release--')
              with:
                  ref: ${{ contains(github.head_ref, 'release--') && github.event.pull_request.head.ref || github.ref }} # This is necessary for this job to be able to commit and push to the origin remote properly
                  token: ${{ secrets.LASTMJS_GITHUB_TOKEN || github.token }} # A personal GitHub token is setup as a secret so that committing and pushing to GitHub from the Action will trigger another workflow
            - uses: actions/setup-node@v4
              with:
                  node-version: 20
                  registry-url: https://registry.npmjs.org
              env:
                  NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
            - if: contains(github.head_ref, 'release--')
              name: Install dfx
              run: |
                  DFXVM_INIT_YES=true DFX_VERSION=0.22.0 sh -ci "$(curl -fsSL https://sdk.dfinity.org/install.sh)"
                  echo "$HOME/.local/share/dfx/bin" >> $GITHUB_PATH
            # TODO we should use some Action-specific bot account
            - if: contains(github.head_ref, 'release--')
              run: git config --global user.name 'Jordan Last'
            - if: contains(github.head_ref, 'release--')
              run: git config --global user.email 'jordan.michael.last@gmail.com'
            - if: contains(github.head_ref, 'release--')
              run: git config --global commit.gpgsign true
            - if: contains(github.head_ref, 'release--')
              run: echo -n "$GPG_SIGNING_KEY" | base64 --decode | gpg --import
            - if: contains(github.head_ref, 'release--')
              run: git config --global user.signingkey C8B77BCBE16CD2B94B43F9C8757397B82D4ED7B0
            - id: example_directories
              # TODO to improve this further we might be able to create an environment variable that grabs the example directories with a glob
              # TODO we want to be able to easily include and exclude examples though
              # TODO we have a number of flaky tests and we have moved them to the top of the list here so we can keep a better eye on them until we have resolved their flakyness
              run: |
                  EXAMPLE_DIRECTORIES=$(cat << END
                  [
                    "examples/hello_world"
                  ]
                  END
                  )
                  EXAMPLE_DIRECTORIES="${EXAMPLE_DIRECTORIES//'%'/'%25'}"
                  EXAMPLE_DIRECTORIES="${EXAMPLE_DIRECTORIES//$'\n'/'%0A'}"
                  EXAMPLE_DIRECTORIES="${EXAMPLE_DIRECTORIES//$'\r'/'%0D'}"
                  echo "::set-output name=example_directories::$EXAMPLE_DIRECTORIES"
            - id: should_run_tests
              run: |
                  BRANCH_NAME="${{ github.head_ref }}"
                  RELEASE_VERSION="${BRANCH_NAME:9}"
                  COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s")
                  if [[ "${{ contains(github.head_ref, 'release--') }}" == "true" && "$COMMIT_MESSAGE" != "azle-bot automated release $RELEASE_VERSION" ]]
                  then
                    ./publish-github-action.sh $RELEASE_VERSION ${{ toJSON(steps.example_directories.outputs.example_directories) }}
                  else
                    echo "::set-output name=should_run_tests::true"
                  fi
            - id: double_check
              name: Double Check
              run: |
                  BRANCH_NAME="${{ github.head_ref }}"
                  RELEASE_VERSION="${BRANCH_NAME:9}"
                  COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s")
                  echo "This is the good stuff"
                  echo $BRANCH_NAME
                  echo $RELEASE_VERSION
                  echo $COMMIT_MESSAGE
                  if [[ "${{ contains(github.head_ref, 'release--') }}" == "true" && "$COMMIT_MESSAGE" != "azle-bot automated release $RELEASE_VERSION" ]]
                  then
                    echo "We have decided not to release and do the other thing with the automatic publish instead."
                  else
                    echo "We have decided to run the tests"
                  fi
    basic-integration-tests:
        needs: release-candidate-deploy
        runs-on: ${{ matrix.os }}
        env:
            ETHEREUM_URL: ${{ secrets.ETHEREUM_URL }}
            AZLE_IDENTITY_STORAGE_MODE: 'plaintext'
            AZLE_END_TO_END_TEST_LINK_AZLE: ${{ matrix.azle_source == 'repo' }}
            AZLE_TEST_RUN_ON_RELEASE: ${{ contains(github.head_ref, 'release--') }}
        strategy:
            fail-fast: false # We want to see which example tests succeed and which ones fail, we don't want one example test to cancel the rest
            matrix:
                # os: [macos-latest]
                os: [ubuntu-latest]
                include_npm:
                    # Only include npm in the matrix if you've pushed to main and the last commit was a merge of a release branch, or the base branch of the pull request is a release branch
                    - ${{ (github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, 'Merge pull request') && contains(github.event.head_commit.message, 'demergent-labs/release--')) || contains(github.head_ref, 'release--') }}
                azle_source:
                    - npm
                    - repo
                exclude:
                    - include_npm: false
                      azle_source: npm
                    - include_npm: true
                      azle_source: repo
                # If should_run_tests is false, we still want the steps of this job to execute so that check-basic-integration-tests-success will run. We do this by creating an array with one dummy element
                example_directories: ${{ needs.release-candidate-deploy.outputs.should_run_tests == 'true' && fromJSON(needs.release-candidate-deploy.outputs.example_directories) || fromJSON('["dummy"]') }}
        steps:
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              uses: actions/checkout@v4
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              uses: actions/setup-node@v4
              with:
                  node-version: 20
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              name: Install dfx
              run: |
                  DFXVM_INIT_YES=true DFX_VERSION=0.22.0 sh -ci "$(curl -fsSL https://sdk.dfinity.org/install.sh)"
                  echo "$HOME/.local/share/dfx/bin" >> $GITHUB_PATH
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests && matrix.os == 'macos-latest' }}
              shell: bash -l {0}
              # The DNS server stuff is because of this: https://github.com/actions/runner-images/issues/6383
              run: |
                  sudo networksetup -setdnsservers Ethernet 9.9.9.9
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              shell: bash -l {0} # TODO figure out why this is here and comment about it
              run: npm install
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests && matrix.azle_source == 'repo' }}
              shell: bash -l {0}
              run: npm link
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              shell: bash -l {0}
              run: npm run lint
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              shell: bash -l {0}
              working-directory: ${{ matrix.example_directories }}
              run: npm install
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests && matrix.azle_source == 'repo' }}
              shell: bash -l {0}
              working-directory: ${{ matrix.example_directories }}
              run: npm link azle
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests }}
              working-directory: ${{ matrix.example_directories }}
              run: dfx start --clean --background --host 127.0.0.1:8000
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests && !contains(github.head_ref, 'release--') && !(github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, 'Merge pull request') && contains(github.event.head_commit.message, 'demergent-labs/release--')) }}
              shell: bash -l {0}
              working-directory: ${{ matrix.example_directories }}
              run: AZLE_PROPTEST_NUM_RUNS=5 AZLE_PROPTEST_VERBOSE=true npm test
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests && contains(github.head_ref, 'release--') && !(github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, 'Merge pull request') && contains(github.event.head_commit.message, 'demergent-labs/release--')) }}
              shell: bash -l {0}
              working-directory: ${{ matrix.example_directories }}
              run: AZLE_PROPTEST_NUM_RUNS=10 AZLE_PROPTEST_VERBOSE=true npm test
            - if: ${{ needs.release-candidate-deploy.outputs.should_run_tests && (github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, 'Merge pull request') && contains(github.event.head_commit.message, 'demergent-labs/release--')) }}
              shell: bash -l {0}
              working-directory: ${{ matrix.example_directories }}
              run: AZLE_PROPTEST_NUM_RUNS=100 AZLE_PROPTEST_VERBOSE=true npm test

    check-basic-integration-tests-success:
        needs: basic-integration-tests
        runs-on: ubuntu-latest
        if: success()
        steps:
            - run: exit 0

    check-basic-integration-tests-failure:
        needs: basic-integration-tests
        runs-on: ubuntu-latest
        if: failure()
        steps:
            - run: exit 1
