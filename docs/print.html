<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Azle Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="the_azle_book.html"><strong aria-hidden="true">1.</strong> The Azle Book (Beta)</a></li><li class="chapter-item expanded "><a href="candid_rpc_or_http_server.html"><strong aria-hidden="true">2.</strong> Candid RPC or HTTP Server</a></li><li class="chapter-item expanded "><a href="candid_rpc.html"><strong aria-hidden="true">3.</strong> Candid RPC</a></li><li class="chapter-item expanded "><a href="http_server.html"><strong aria-hidden="true">4.</strong> HTTP Server (Experimental)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="get_started.html"><strong aria-hidden="true">4.1.</strong> Get Started</a></li><li class="chapter-item expanded "><a href="rest_based_examples.html"><strong aria-hidden="true">4.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="deployment.html"><strong aria-hidden="true">4.3.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="project_structure.html"><strong aria-hidden="true">4.4.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="servers.html"><strong aria-hidden="true">4.5.</strong> Servers</a></li><li class="chapter-item expanded "><a href="assets.html"><strong aria-hidden="true">4.6.</strong> Assets</a></li><li class="chapter-item expanded "><a href="authentication.html"><strong aria-hidden="true">4.7.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="fetch.html"><strong aria-hidden="true">4.8.</strong> fetch</a></li><li class="chapter-item expanded "><a href="npm.html"><strong aria-hidden="true">4.9.</strong> npm</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">4.10.</strong> Tokens</a></li><li class="chapter-item expanded "><a href="bitcoin.html"><strong aria-hidden="true">4.11.</strong> Bitcoin</a></li><li class="chapter-item expanded "><a href="ethereum.html"><strong aria-hidden="true">4.12.</strong> Ethereum</a></li><li class="chapter-item expanded "><a href="databases.html"><strong aria-hidden="true">4.13.</strong> Databases</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.</strong> Cycles</div></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">4.15.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">4.16.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="reference_http/reference.html"><strong aria-hidden="true">4.17.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference_http/autoreload.html"><strong aria-hidden="true">4.17.1.</strong> Autoreload</a></li><li class="chapter-item expanded "><a href="reference_http/environment_variables.html"><strong aria-hidden="true">4.17.2.</strong> Environment Variables</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="candid_based_documentation.html"><strong aria-hidden="true">5.</strong> Old Candid-based Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="azle.html"><strong aria-hidden="true">5.1.</strong> Azle (Beta)</a></li><li class="chapter-item expanded "><a href="internet_computer_overview.html"><strong aria-hidden="true">5.2.</strong> Internet Computer Overview</a></li><li class="chapter-item expanded "><a href="canisters_overview.html"><strong aria-hidden="true">5.3.</strong> Canisters Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">5.4.</strong> Installation</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">5.5.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="deployment_candid_based.html"><strong aria-hidden="true">5.6.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">5.7.</strong> Examples</a></li><li class="chapter-item expanded "><a href="query_methods.html"><strong aria-hidden="true">5.8.</strong> Query Methods</a></li><li class="chapter-item expanded "><a href="update_methods.html"><strong aria-hidden="true">5.9.</strong> Update Methods</a></li><li class="chapter-item expanded "><a href="candid.html"><strong aria-hidden="true">5.10.</strong> Candid</a></li><li class="chapter-item expanded "><a href="stable_structures.html"><strong aria-hidden="true">5.11.</strong> Stable Structures</a></li><li class="chapter-item expanded "><a href="cross_canister.html"><strong aria-hidden="true">5.12.</strong> Cross-canister</a></li><li class="chapter-item expanded "><a href="http.html"><strong aria-hidden="true">5.13.</strong> HTTP</a></li><li class="chapter-item expanded "><a href="management_canister.html"><strong aria-hidden="true">5.14.</strong> Management Canister</a></li><li class="chapter-item expanded "><a href="canister_lifecycle.html"><strong aria-hidden="true">5.15.</strong> Canister Lifecycle</a></li><li class="chapter-item expanded "><a href="timers.html"><strong aria-hidden="true">5.16.</strong> Timers</a></li><li class="chapter-item expanded "><a href="cycles.html"><strong aria-hidden="true">5.17.</strong> Cycles</a></li><li class="chapter-item expanded "><a href="caveats.html"><strong aria-hidden="true">5.18.</strong> Caveats</a></li><li class="chapter-item expanded "><a href="reference/reference.html"><strong aria-hidden="true">5.19.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/bitcoin.html"><strong aria-hidden="true">5.19.1.</strong> Bitcoin</a></li><li class="chapter-item expanded "><a href="reference/call_apis/call_apis.html"><strong aria-hidden="true">5.19.2.</strong> Call APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/call_apis/accept_message.html"><strong aria-hidden="true">5.19.2.1.</strong> accept message</a></li><li class="chapter-item expanded "><a href="reference/call_apis/arg_data_raw.html"><strong aria-hidden="true">5.19.2.2.</strong> arg data raw</a></li><li class="chapter-item expanded "><a href="reference/call_apis/call.html"><strong aria-hidden="true">5.19.2.3.</strong> call</a></li><li class="chapter-item expanded "><a href="reference/call_apis/call_raw.html"><strong aria-hidden="true">5.19.2.4.</strong> call raw</a></li><li class="chapter-item expanded "><a href="reference/call_apis/call_raw128.html"><strong aria-hidden="true">5.19.2.5.</strong> call raw 128</a></li><li class="chapter-item expanded "><a href="reference/call_apis/call_with_payment.html"><strong aria-hidden="true">5.19.2.6.</strong> call with payment</a></li><li class="chapter-item expanded "><a href="reference/call_apis/call_with_payment128.html"><strong aria-hidden="true">5.19.2.7.</strong> call with payment 128</a></li><li class="chapter-item expanded "><a href="reference/call_apis/caller.html"><strong aria-hidden="true">5.19.2.8.</strong> caller</a></li><li class="chapter-item expanded "><a href="reference/call_apis/method_name.html"><strong aria-hidden="true">5.19.2.9.</strong> method name</a></li><li class="chapter-item expanded "><a href="reference/call_apis/msg_cycles_accept.html"><strong aria-hidden="true">5.19.2.10.</strong> msg cycles accept</a></li><li class="chapter-item expanded "><a href="reference/call_apis/msg_cycles_accept128.html"><strong aria-hidden="true">5.19.2.11.</strong> msg cycles accept 128</a></li><li class="chapter-item expanded "><a href="reference/call_apis/msg_cycles_available.html"><strong aria-hidden="true">5.19.2.12.</strong> msg cycles available</a></li><li class="chapter-item expanded "><a href="reference/call_apis/msg_cycles_available128.html"><strong aria-hidden="true">5.19.2.13.</strong> msg cycles available 128</a></li><li class="chapter-item expanded "><a href="reference/call_apis/msg_cycles_refunded.html"><strong aria-hidden="true">5.19.2.14.</strong> msg cycles refunded</a></li><li class="chapter-item expanded "><a href="reference/call_apis/msg_cycles_refunded128.html"><strong aria-hidden="true">5.19.2.15.</strong> msg cycles refunded 128</a></li><li class="chapter-item expanded "><a href="reference/call_apis/notify.html"><strong aria-hidden="true">5.19.2.16.</strong> notify</a></li><li class="chapter-item expanded "><a href="reference/call_apis/notify_raw.html"><strong aria-hidden="true">5.19.2.17.</strong> notify raw</a></li><li class="chapter-item expanded "><a href="reference/call_apis/notify_with_payment_128.html"><strong aria-hidden="true">5.19.2.18.</strong> notify with payment 128</a></li><li class="chapter-item expanded "><a href="reference/call_apis/reject.html"><strong aria-hidden="true">5.19.2.19.</strong> reject</a></li><li class="chapter-item expanded "><a href="reference/call_apis/reject_code.html"><strong aria-hidden="true">5.19.2.20.</strong> reject code</a></li><li class="chapter-item expanded "><a href="reference/call_apis/reject_message.html"><strong aria-hidden="true">5.19.2.21.</strong> reject message</a></li><li class="chapter-item expanded "><a href="reference/call_apis/reply.html"><strong aria-hidden="true">5.19.2.22.</strong> reply</a></li><li class="chapter-item expanded "><a href="reference/call_apis/reply_raw.html"><strong aria-hidden="true">5.19.2.23.</strong> reply raw</a></li></ol></li><li class="chapter-item expanded "><a href="reference/candid/candid.html"><strong aria-hidden="true">5.19.3.</strong> Candid</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/candid/blob.html"><strong aria-hidden="true">5.19.3.1.</strong> blob</a></li><li class="chapter-item expanded "><a href="reference/candid/bool.html"><strong aria-hidden="true">5.19.3.2.</strong> bool</a></li><li class="chapter-item expanded "><a href="reference/candid/empty.html"><strong aria-hidden="true">5.19.3.3.</strong> empty</a></li><li class="chapter-item expanded "><a href="reference/candid/float32.html"><strong aria-hidden="true">5.19.3.4.</strong> float32</a></li><li class="chapter-item expanded "><a href="reference/candid/float64.html"><strong aria-hidden="true">5.19.3.5.</strong> float64</a></li><li class="chapter-item expanded "><a href="reference/candid/func.html"><strong aria-hidden="true">5.19.3.6.</strong> func</a></li><li class="chapter-item expanded "><a href="reference/candid/int.html"><strong aria-hidden="true">5.19.3.7.</strong> int</a></li><li class="chapter-item expanded "><a href="reference/candid/int8.html"><strong aria-hidden="true">5.19.3.8.</strong> int8</a></li><li class="chapter-item expanded "><a href="reference/candid/int16.html"><strong aria-hidden="true">5.19.3.9.</strong> int16</a></li><li class="chapter-item expanded "><a href="reference/candid/int32.html"><strong aria-hidden="true">5.19.3.10.</strong> int32</a></li><li class="chapter-item expanded "><a href="reference/candid/int64.html"><strong aria-hidden="true">5.19.3.11.</strong> int64</a></li><li class="chapter-item expanded "><a href="reference/candid/nat.html"><strong aria-hidden="true">5.19.3.12.</strong> nat</a></li><li class="chapter-item expanded "><a href="reference/candid/nat8.html"><strong aria-hidden="true">5.19.3.13.</strong> nat8</a></li><li class="chapter-item expanded "><a href="reference/candid/nat16.html"><strong aria-hidden="true">5.19.3.14.</strong> nat16</a></li><li class="chapter-item expanded "><a href="reference/candid/nat32.html"><strong aria-hidden="true">5.19.3.15.</strong> nat32</a></li><li class="chapter-item expanded "><a href="reference/candid/nat64.html"><strong aria-hidden="true">5.19.3.16.</strong> nat64</a></li><li class="chapter-item expanded "><a href="reference/candid/null.html"><strong aria-hidden="true">5.19.3.17.</strong> null</a></li><li class="chapter-item expanded "><a href="reference/candid/opt.html"><strong aria-hidden="true">5.19.3.18.</strong> opt</a></li><li class="chapter-item expanded "><a href="reference/candid/principal.html"><strong aria-hidden="true">5.19.3.19.</strong> principal</a></li><li class="chapter-item expanded "><a href="reference/candid/record.html"><strong aria-hidden="true">5.19.3.20.</strong> record</a></li><li class="chapter-item expanded "><a href="reference/candid/reserved.html"><strong aria-hidden="true">5.19.3.21.</strong> reserved</a></li><li class="chapter-item expanded "><a href="reference/candid/service.html"><strong aria-hidden="true">5.19.3.22.</strong> service</a></li><li class="chapter-item expanded "><a href="reference/candid/text.html"><strong aria-hidden="true">5.19.3.23.</strong> text</a></li><li class="chapter-item expanded "><a href="reference/candid/variant.html"><strong aria-hidden="true">5.19.3.24.</strong> variant</a></li><li class="chapter-item expanded "><a href="reference/candid/vec.html"><strong aria-hidden="true">5.19.3.25.</strong> vec</a></li></ol></li><li class="chapter-item expanded "><a href="reference/canister_apis/canister_apis.html"><strong aria-hidden="true">5.19.4.</strong> Canister APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/canister_apis/candid_decode.html"><strong aria-hidden="true">5.19.4.1.</strong> candid decode</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/candid_encode.html"><strong aria-hidden="true">5.19.4.2.</strong> candid encode</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/canister_balance.html"><strong aria-hidden="true">5.19.4.3.</strong> canister balance</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/canister_balance128.html"><strong aria-hidden="true">5.19.4.4.</strong> canister balance 128</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/canister_version.html"><strong aria-hidden="true">5.19.4.5.</strong> canister version</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/canister_id.html"><strong aria-hidden="true">5.19.4.6.</strong> canister id</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/data_certificate.html"><strong aria-hidden="true">5.19.4.7.</strong> data certificate</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/instruction_counter.html"><strong aria-hidden="true">5.19.4.8.</strong> instruction counter</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/is_controller.html"><strong aria-hidden="true">5.19.4.9.</strong> is controller</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/performance_counter.html"><strong aria-hidden="true">5.19.4.10.</strong> performance counter</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/print.html"><strong aria-hidden="true">5.19.4.11.</strong> print</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/set_certified_data.html"><strong aria-hidden="true">5.19.4.12.</strong> set certified data</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/time.html"><strong aria-hidden="true">5.19.4.13.</strong> time</a></li><li class="chapter-item expanded "><a href="reference/canister_apis/trap.html"><strong aria-hidden="true">5.19.4.14.</strong> trap</a></li></ol></li><li class="chapter-item expanded "><a href="reference/canister_methods/canister_methods.html"><strong aria-hidden="true">5.19.5.</strong> Canister Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/canister_methods/heartbeat.html"><strong aria-hidden="true">5.19.5.1.</strong> heartbeat</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/http_request.html"><strong aria-hidden="true">5.19.5.2.</strong> http_request</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/http_request_update.html"><strong aria-hidden="true">5.19.5.3.</strong> http_request_update</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/init.html"><strong aria-hidden="true">5.19.5.4.</strong> init</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/inspect_message.html"><strong aria-hidden="true">5.19.5.5.</strong> inspect message</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/post_upgrade.html"><strong aria-hidden="true">5.19.5.6.</strong> post upgrade</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/pre_upgrade.html"><strong aria-hidden="true">5.19.5.7.</strong> pre upgrade</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/query.html"><strong aria-hidden="true">5.19.5.8.</strong> query</a></li><li class="chapter-item expanded "><a href="reference/canister_methods/update.html"><strong aria-hidden="true">5.19.5.9.</strong> update</a></li></ol></li><li class="chapter-item expanded "><a href="reference/environment_variables.html"><strong aria-hidden="true">5.19.6.</strong> Environment Variables</a></li><li class="chapter-item expanded "><a href="reference/management_canister/management_canister.html"><strong aria-hidden="true">5.19.7.</strong> Management Canister</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/management_canister/bitcoin_get_balance.html"><strong aria-hidden="true">5.19.7.1.</strong> bitcoin_get_balance</a></li><li class="chapter-item expanded "><a href="reference/management_canister/bitcoin_get_current_fee_percentiles.html"><strong aria-hidden="true">5.19.7.2.</strong> bitcoin_get_current_fee_percentiles</a></li><li class="chapter-item expanded "><a href="reference/management_canister/bitcoin_get_utxos.html"><strong aria-hidden="true">5.19.7.3.</strong> bitcoin_get_utxos</a></li><li class="chapter-item expanded "><a href="reference/management_canister/bitcoin_send_transaction.html"><strong aria-hidden="true">5.19.7.4.</strong> bitcoin_send_transaction</a></li><li class="chapter-item expanded "><a href="reference/management_canister/canister_status.html"><strong aria-hidden="true">5.19.7.5.</strong> canister_status</a></li><li class="chapter-item expanded "><a href="reference/management_canister/create_canister.html"><strong aria-hidden="true">5.19.7.6.</strong> create_canister</a></li><li class="chapter-item expanded "><a href="reference/management_canister/delete_canister.html"><strong aria-hidden="true">5.19.7.7.</strong> delete_canister</a></li><li class="chapter-item expanded "><a href="reference/management_canister/deposit_cycles.html"><strong aria-hidden="true">5.19.7.8.</strong> deposit_cycles</a></li><li class="chapter-item expanded "><a href="reference/management_canister/ecdsa_public_key.html"><strong aria-hidden="true">5.19.7.9.</strong> ecdsa_public_key</a></li><li class="chapter-item expanded "><a href="reference/management_canister/http_request.html"><strong aria-hidden="true">5.19.7.10.</strong> http_request</a></li><li class="chapter-item expanded "><a href="reference/management_canister/install_code.html"><strong aria-hidden="true">5.19.7.11.</strong> install_code</a></li><li class="chapter-item expanded "><a href="reference/management_canister/provisional_create_canister_with_cycles.html"><strong aria-hidden="true">5.19.7.12.</strong> provisional_create_canister_with_cycles</a></li><li class="chapter-item expanded "><a href="reference/management_canister/provisional_top_up_canister.html"><strong aria-hidden="true">5.19.7.13.</strong> provisional_top_up_canister</a></li><li class="chapter-item expanded "><a href="reference/management_canister/raw_rand.html"><strong aria-hidden="true">5.19.7.14.</strong> raw_rand</a></li><li class="chapter-item expanded "><a href="reference/management_canister/sign_with_ecdsa.html"><strong aria-hidden="true">5.19.7.15.</strong> sign_with_ecdsa</a></li><li class="chapter-item expanded "><a href="reference/management_canister/start_canister.html"><strong aria-hidden="true">5.19.7.16.</strong> start_canister</a></li><li class="chapter-item expanded "><a href="reference/management_canister/stop_canister.html"><strong aria-hidden="true">5.19.7.17.</strong> stop_canister</a></li><li class="chapter-item expanded "><a href="reference/management_canister/uninstall_code.html"><strong aria-hidden="true">5.19.7.18.</strong> uninstall_code</a></li><li class="chapter-item expanded "><a href="reference/management_canister/update_settings.html"><strong aria-hidden="true">5.19.7.19.</strong> update_settings</a></li></ol></li><li class="chapter-item expanded "><a href="reference/plugins.html"><strong aria-hidden="true">5.19.8.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="reference/stable_memory/stable_memory.html"><strong aria-hidden="true">5.19.9.</strong> Stable Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/stable_memory/stable_structures.html"><strong aria-hidden="true">5.19.9.1.</strong> stable structures</a></li></ol></li><li class="chapter-item expanded "><a href="reference/timers/timers.html"><strong aria-hidden="true">5.19.10.</strong> Timers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/timers/clear_timer.html"><strong aria-hidden="true">5.19.10.1.</strong> clear timer</a></li><li class="chapter-item expanded "><a href="reference/timers/set_timer.html"><strong aria-hidden="true">5.19.10.2.</strong> set timer</a></li><li class="chapter-item expanded "><a href="reference/timers/set_timer_interval.html"><strong aria-hidden="true">5.19.10.3.</strong> set timer interval</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Azle Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-azle-book-beta"><a class="header" href="#the-azle-book-beta">The Azle Book (Beta)</a></h1>
<div style="display: flex; justify-content: center">
    <img src="logo.svg" alt="The Azle Logo" height="250px" />
</div>
<p>Welcome to The Azle Book! This is a guide for building secure decentralized/replicated servers in TypeScript or JavaScript on <a href="https://internetcomputer.org/">ICP</a>. The current replication factor is <a href="https://dashboard.internetcomputer.org/subnets">13-40 times</a>.</p>
<p>Please remember that Azle stable mode is continuously subjected to <a href="https://github.com/demergent-labs/azle/actions">intense scrutiny and testing</a>, however it does not yet have multiple independent security reviews/audits.</p>
<p>The Azle Book is subject to the following license and Azle's <a href="https://github.com/demergent-labs/azle/blob/main/LICENSE_EXTENSION.md">License Extension</a>:</p>
<pre><code>MIT License

Copyright (c) 2025 AZLE token holders (nlhft-2iaaa-aaaae-qaaua-cai)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-rpc-or-http-server"><a class="header" href="#candid-rpc-or-http-server">Candid RPC or HTTP Server</a></h1>
<p>Azle applications (<a href="https://internetcomputer.org/docs/current/concepts/canisters-code">canisters</a>) can be developed using two main methodologies: <a href="./candid_rpc.html">Candid RPC</a> and <a href="./http_server.html">HTTP Server</a>.</p>
<p>Candid RPC embraces ICP's <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/candid/">Candid language</a>, exposing canister methods directly to Candid-speaking clients, and using Candid for serialization and deserialization purposes.</p>
<p>HTTP Server embraces traditional web server techniques, allowing you to write HTTP servers using popular libraries such as <a href="https://expressjs.com/">Express</a>, and using <a href="https://www.json.org/json-en.html">JSON</a> for simple serialization and deserialization purposes.</p>
<p>Candid RPC is heading towards 1.0 and production-readiness in 2025.</p>
<p>HTTP Server will remain experimental for an unknown length of time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-rpc"><a class="header" href="#candid-rpc">Candid RPC</a></h1>
<p>This section documents the Candid RPC methodology for developing Azle applications. This methodology embraces ICP's Candid language, exposing canister methods directly to Candid-speaking clients, and using Candid for serialization and deserialization purposes.</p>
<p>Candid RPC is heading towards 1.0 and production-readiness in 2025.</p>
<ul>
<li><a href="candid_rpc.html#get-started">Get Started</a></li>
<li><a href="candid_rpc.html#examples">Examples</a></li>
<li><a href="candid_rpc.html#canister-class">Canister Class</a></li>
<li><a href="candid_rpc.html#dfinitycandid-idl">@dfinity/candid IDL</a></li>
<li><a href="candid_rpc.html#decorators">Decorators</a>
<ul>
<li><a href="candid_rpc.html#query">@query</a></li>
<li><a href="candid_rpc.html#update">@update</a></li>
<li><a href="candid_rpc.html#init">@init</a></li>
<li><a href="candid_rpc.html#postupgrade">@postUpgrade</a></li>
<li><a href="candid_rpc.html#preupgrade">@preUpgrade</a></li>
<li><a href="candid_rpc.html#inspectmessage">@inspectMessage</a></li>
<li><a href="candid_rpc.html#heartbeat">@heartbeat</a></li>
</ul>
</li>
<li><a href="candid_rpc.html#ic-api">IC API</a></li>
</ul>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>Azle helps you to build secure decentralized/replicated servers in TypeScript or JavaScript on <a href="https://internetcomputer.org/">ICP</a>. The current replication factor is <a href="https://dashboard.internetcomputer.org/subnets">13-40 times</a>.</p>
<p>Please remember that Azle stable mode is continuously subjected to <a href="https://github.com/demergent-labs/azle/actions">intense scrutiny and testing</a>, however it does not yet have multiple independent security reviews/audits.</p>
<p>Azle runs in stable mode by default.</p>
<p>This mode is intended for production use after Azle's 1.0 release. Its focus is on API and runtime stability, security, performance, TypeScript and JavaScript language support, the ICP APIs, and Candid remote procedure calls (RPC). There is minimal support for the Node.js standard library, npm ecosystem, and HTTP server functionality.</p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<blockquote>
<p>Windows is only supported through a Linux virtual environment of some kind, such as <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a></p>
</blockquote>
<p>You will need <a href="candid_rpc.html#nodejs-22">Node.js 22</a> and <a href="candid_rpc.html#dfx">dfx</a> to develop ICP applications with Azle:</p>
<h4 id="nodejs-22"><a class="header" href="#nodejs-22">Node.js 22</a></h4>
<p>It's recommended to use nvm to install Node.js 22:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>Restart your terminal and then run:</p>
<pre><code class="language-bash">nvm install 22
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">node --version
</code></pre>
<h4 id="dfx"><a class="header" href="#dfx">dfx</a></h4>
<p>Install the dfx command line tools for managing ICP applications:</p>
<pre><code class="language-bash">DFX_VERSION=0.24.3 sh -ci &quot;$(curl -fsSL https://internetcomputer.org/install.sh)&quot;
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">dfx --version
</code></pre>
<h3 id="deployment"><a class="header" href="#deployment">Deployment</a></h3>
<p>To create and deploy a simple sample application called <code>hello_world</code>:</p>
<pre><code class="language-bash"># create a new default project called hello_world
npx azle new hello_world
cd hello_world
</code></pre>
<pre><code class="language-bash"># install all npm dependencies including azle
npm install
</code></pre>
<pre><code class="language-bash"># start up a local ICP replica
dfx start --clean
</code></pre>
<p>In a separate terminal in the <code>hello_world</code> directory:</p>
<pre><code class="language-bash"># deploy your canister
dfx deploy
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Some of the best documentation for creating Candid RPC canisters is currently in <a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc">the examples directory</a>.</p>
<h2 id="canister-class"><a class="header" href="#canister-class">Canister Class</a></h2>
<p>Your canister's functionality must be encapsulated in a class exported using the default export:</p>
<pre><code class="language-typescript">import { IDL, query } from 'azle';

export default class {
    @query([], IDL.Text)
    hello(): string {
        return 'world!';
    }
}
</code></pre>
<p>You must use the <a href="candid_rpc.html#query">@query</a>, <a href="candid_rpc.html#update">@update</a>, <a href="candid_rpc.html#init">@init</a>, <a href="candid_rpc.html#postupgrade">@postUpgrade</a>, <a href="candid_rpc.html#preupgrade">@preUpgrade</a>, <a href="candid_rpc.html#inspectmessage">@inspectMessage</a>, and <a href="candid_rpc.html#heartbeat">@heartbeat</a> decorators to expose your canister's methods. Adding TypeScript types is optional.</p>
<h2 id="dfinitycandid-idl"><a class="header" href="#dfinitycandid-idl">@dfinity/candid IDL</a></h2>
<p>For each of your canister's methods, deserialization of incoming arguments and serialization of return values is handled with a combination of the <a href="candid_rpc.html#query">@query</a>, <a href="candid_rpc.html#update">@update</a>, <a href="candid_rpc.html#init">@init</a>, and <a href="candid_rpc.html#postupgrade">@postUpgrade</a> decorators and the <a href="https://agent-js.icp.xyz/candid/modules/IDL.html">IDL</a> object from the <a href="https://agent-js.icp.xyz/candid/index.html">@dfinity/candid</a> library.</p>
<p><code>IDL</code> is re-exported by Azle, and has properties that correspond to <a href="https://internetcomputer.org/docs/current/references/candid-ref">Candid's supported types</a>. You must use <code>IDL</code> to instruct the method decorators on how to deserialize arguments and serialize the return value. Here's an example of accessing the Candid types from <code>IDL</code>:</p>
<pre><code class="language-typescript">import { IDL } from 'azle';

IDL.Text;

IDL.Vec(IDL.Nat8); // Candid blob

IDL.Nat;
IDL.Nat64;
IDL.Nat32;
IDL.Nat16;
IDL.Nat8;

IDL.Int;
IDL.Int64;
IDL.Int32;
IDL.Int16;
IDL.Int8;

IDL.Float64;
IDL.Float32;

IDL.Bool;

IDL.Null;

IDL.Vec(IDL.Int);

IDL.Opt(IDL.Text);

IDL.Record({
    prop1: IDL.Text,
    prop2: IDL.Bool
});

IDL.Variant({
    Tag1: IDL.Null,
    Tag2: IDL.Nat
});

IDL.Func([], [], ['query']);

IDL.Service({
    myQueryMethod: IDL.Func([IDL.Text, IDL.Text], [IDL.Bool])
});

IDL.Principal;

IDL.Reserved;

IDL.Empty;
</code></pre>
<h2 id="decorators"><a class="header" href="#decorators">Decorators</a></h2>
<h3 id="query"><a class="header" href="#query">@query</a></h3>
<p>Exposes the decorated method as a read-only <code>canister_query</code> method.</p>
<p>The first parameter to this decorator accepts <code>IDL</code> Candid type objects that will deserialize incoming Candid arguments. The second parameter to this decorator accepts an <code>IDL</code> Candid type object that will serialize the outgoing return value to Candid.</p>
<h3 id="update"><a class="header" href="#update">@update</a></h3>
<p>Exposes the decorated method as a read-write <code>canister_update</code> method.</p>
<p>The first parameter to this decorator accepts <code>IDL</code> Candid type objects that will deserialize incoming Candid arguments. The second parameter to this decorator accepts an <code>IDL</code> Candid type object that will serialize the outgoing return value to Candid.</p>
<h3 id="init"><a class="header" href="#init">@init</a></h3>
<p>Exposes the decorated method as the <code>canister_init</code> method called only once during canister initialization.</p>
<p>The first parameter to this decorator accepts <code>IDL</code> Candid type objects that will deserialize incoming Candid arguments.</p>
<h3 id="postupgrade"><a class="header" href="#postupgrade">@postUpgrade</a></h3>
<p>Exposes the decorated method as the <code>canister_post_upgrade</code> method called during every canister upgrade.</p>
<p>The first parameter to this decorator accepts <code>IDL</code> Candid type objects that will deserialize incoming Candid arguments.</p>
<h3 id="preupgrade"><a class="header" href="#preupgrade">@preUpgrade</a></h3>
<p>Exposes the decorated method as the <code>canister_pre_upgrade</code> method called before every canister upgrade.</p>
<h3 id="inspectmessage"><a class="header" href="#inspectmessage">@inspectMessage</a></h3>
<p>Exposes the decorated method as the <code>canister_inspect_message</code> method called before every <code>update</code> call.</p>
<h3 id="heartbeat"><a class="header" href="#heartbeat">@heartbeat</a></h3>
<p>Exposes the decorated method as the <code>canister_heartbeat</code> method called on a regular interval (every second or so).</p>
<h2 id="ic-api"><a class="header" href="#ic-api">IC API</a></h2>
<p>The IC API is exposed as functions exported from <code>azle</code>. You can see the available functions in <a href="https://github.com/demergent-labs/azle/tree/main/src/lib/stable/ic_apis">the source code</a>.</p>
<p>Some of the best documentation for using the IC API is currently in <a href="https://github.com/demergent-labs/azle/tree/main/examples/stable">the examples directory</a>, especially the <a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/property/ic_api">ic_api property tests</a>.</p>
<p>Here's an example of getting the caller's principal using the <code>caller</code> function:</p>
<pre><code class="language-typescript">import { caller, IDL, update } from 'azle';

export default class {
    @update([], IDL.Bool)
    isUserAnonymous(): boolean {
        if (caller().toText() === '2vxsx-fae') {
            return true;
        } else {
            return false;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-experimental"><a class="header" href="#http-server-experimental">HTTP Server (Experimental)</a></h1>
<p>This section documents the HTTP Server methodology for developing Azle applications. This methodology embraces traditional web server techniques, allowing you to write HTTP servers using popular libraries such as Express, and using JSON for simple serialization and deserialization purposes.</p>
<p>HTTP Server functionality will remain experimental for an unknown length of time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-started-1"><a class="header" href="#get-started-1">Get Started</a></h1>
<ul>
<li><a href="get_started.html#installation">Installation</a></li>
<li><a href="get_started.html#deployment">Deployment</a></li>
</ul>
<p>Azle helps you to build secure decentralized/replicated servers in TypeScript or JavaScript on <a href="https://internetcomputer.org/">ICP</a>. The current replication factor is <a href="https://dashboard.internetcomputer.org/subnets">13-40 times</a>.</p>
<p>Please remember that the HTTP Server functionality is only accessible in Azle's experimental mode.</p>
<p>Azle runs in experimental mode through explicitly enabling a flag in <code>dfx.json</code> or certain CLI commands.</p>
<p>This mode is intended for developers who are willing to accept the risk of using an alpha or beta project. Its focus is on quickly enabling new features and functionality without requiring the time and other resources necessary to advance them to the stable mode. The Node.js standard libary, npm ecosystem, and HTTP server functionality are also major areas of focus.</p>
<blockquote>
<p>NOTE: Keep clearly in mind that the experimental mode fundamentally changes the Azle Wasm binary. It is not guaranteed to be secure or stable in API changes or runtime behavior. If you enable the experimental mode, even if you only use APIs from the stable mode, you are accepting a higher risk of bugs, errors, crashes, security exploits, breaking API changes, etc.</p>
</blockquote>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<blockquote>
<p>Windows is only supported through a Linux virtual environment of some kind, such as <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a></p>
</blockquote>
<p>You will need <a href="get_started.html#nodejs-22">Node.js 22</a> and <a href="get_started.html#dfx">dfx</a> to develop ICP applications with Azle:</p>
<h3 id="nodejs-22-1"><a class="header" href="#nodejs-22-1">Node.js 22</a></h3>
<p>It's recommended to use nvm to install Node.js 22:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>Restart your terminal and then run:</p>
<pre><code class="language-bash">nvm install 22
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">node --version
</code></pre>
<h3 id="dfx-1"><a class="header" href="#dfx-1">dfx</a></h3>
<p>Install the dfx command line tools for managing ICP applications:</p>
<pre><code class="language-bash">DFX_VERSION=0.24.3 sh -ci &quot;$(curl -fsSL https://internetcomputer.org/install.sh)&quot;
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">dfx --version
</code></pre>
<h2 id="deployment-1"><a class="header" href="#deployment-1">Deployment</a></h2>
<p>To create and deploy a simple sample application called <code>hello_world</code>:</p>
<pre><code class="language-bash"># create a new default project called hello_world
npx azle new hello_world --http-server --experimental
cd hello_world
</code></pre>
<pre><code class="language-bash"># install all npm dependencies including azle
npm install
</code></pre>
<pre><code class="language-bash"># start up a local ICP replica
dfx start --clean
</code></pre>
<p>In a separate terminal in the <code>hello_world</code> directory:</p>
<pre><code class="language-bash"># deploy your canister
dfx deploy
</code></pre>
<p>If you would like your canister to autoreload on file changes:</p>
<pre><code class="language-bash">AZLE_AUTORELOAD=true dfx deploy
</code></pre>
<p>View your frontend in a web browser at <code>http://[canisterId].raw.localhost:8000</code>.</p>
<p>To obtain your application's [canisterId]:</p>
<pre><code class="language-bash">dfx canister id backend
</code></pre>
<p>Communicate with your canister using any HTTP client library, for example using <code>curl</code>:</p>
<pre><code class="language-bash">curl http://[canisterId].raw.localhost:8000/db
curl -X POST -H &quot;Content-Type: application/json&quot; -d &quot;{ \&quot;hello\&quot;: \&quot;world\&quot; }&quot; http://[canisterId].raw.localhost:8000/db/update
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>There are many Azle examples in the <a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server">examples directory</a>. We recommend starting with the following:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/apollo_server">apollo_server</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/audio_and_video">audio_and_video</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/autoreload">autoreload</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers">ethers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers_base">ethers_base</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/express">express</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/fetch_ic">fetch_ic</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/file_protocol">file_protocol</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/fs">fs</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/hello_world_http_server">hello_world_http_server</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/http_outcall_fetch">http_outcall_fetch</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/hybrid_canister">hybrid_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/internet_identity">internet_identity</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/large_files">large_files</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite">sqlite</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/tfjs">tfjs</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/web_assembly">web_assembly</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment-2"><a class="header" href="#deployment-2">Deployment</a></h1>
<ul>
<li><a href="deployment.html#starting-the-local-replica">Starting the local replica</a></li>
<li><a href="deployment.html#deploying-to-the-local-replica">Deploying to the local replica</a></li>
<li><a href="deployment.html#interacting-with-your-canister">Interacting with your canister</a></li>
<li><a href="deployment.html#deploying-to-mainnet">Deploying to mainnet</a></li>
</ul>
<p>There are two main <a href="https://internetcomputer.org/">ICP</a> environments that you will generally interact with: <a href="deployment.html#deploying-to-the-local-replica">the local replica</a> and <a href="deployment.html#deploying-to-mainnet">mainnet</a>.</p>
<p>We recommend using the <code>dfx</code> command line tools to deploy to these environments. Please note that not all <code>dfx</code> commands are shown here. See <a href="https://internetcomputer.org/docs/current/references/cli-reference/dfx-parent">the dfx CLI reference</a> for more information.</p>
<h2 id="starting-the-local-replica"><a class="header" href="#starting-the-local-replica">Starting the local replica</a></h2>
<p>We recommend running your local replica in its own terminal and on a port of your choosing:</p>
<pre><code class="language-bash">dfx start --host 127.0.0.1:8000
</code></pre>
<p>Alternatively you can start the local replica as a background process:</p>
<pre><code class="language-bash">dfx start --background --host 127.0.0.1:8000
</code></pre>
<p>If you want to stop a local replica running in the background:</p>
<pre><code class="language-bash">dfx stop
</code></pre>
<p>If you ever see this kind of error after <code>dfx stop</code>:</p>
<pre><code class="language-bash">Error: Failed to kill all processes.  Remaining: 627221 626923 627260
</code></pre>
<p>Then try this:</p>
<pre><code class="language-bash">dfx killall
</code></pre>
<p>If your replica starts behaving strangely, we recommend starting the replica clean, which will clean the <code>dfx</code> state of your project:</p>
<pre><code class="language-bash">dfx start --clean --host 127.0.0.1:8000
</code></pre>
<h2 id="deploying-to-the-local-replica"><a class="header" href="#deploying-to-the-local-replica">Deploying to the local replica</a></h2>
<p>To deploy all canisters defined in your <code>dfx.json</code>:</p>
<pre><code class="language-bash">dfx deploy
</code></pre>
<p>If you would like your canister to autoreload on file changes:</p>
<pre><code class="language-bash">AZLE_AUTORELOAD=true dfx deploy
</code></pre>
<p>To deploy an individual canister:</p>
<pre><code class="language-bash">dfx deploy [canisterName]
</code></pre>
<h2 id="interacting-with-your-canister"><a class="header" href="#interacting-with-your-canister">Interacting with your canister</a></h2>
<p>You will generally interact with your canister through an HTTP client such as <code>curl</code>, <code>fetch</code>, or a web browser. The URL of your canister locally will look like this: <code>http://[canisterId].raw.localhost:[replicaPort]</code>. Azle will print your canister's URL in the terminal after a successful deploy.</p>
<pre><code class="language-bash"># You can obtain the canisterId like this
dfx canister id [canisterName]

# You can obtain the replicaPort like this
dfx info webserver-port

# An example of performing a GET request to a canister
curl http://a3shf-5eaaa-aaaaa-qaafa-cai.raw.localhost:8000

# An example of performing a POST request to a canister
curl -X POST -H &quot;Content-Type: application/json&quot; -d &quot;{ \&quot;hello\&quot;: \&quot;world\&quot; }&quot; http://a3shf-5eaaa-aaaaa-qaafa-cai.raw.localhost:8000
</code></pre>
<h2 id="deploying-to-mainnet"><a class="header" href="#deploying-to-mainnet">Deploying to mainnet</a></h2>
<p>Assuming you are <a href="https://internetcomputer.org/docs/current/developer-docs/getting-started/cycles/cycles-wallet">setup with a cycles wallet</a>, then you are ready to deploy to mainnet.</p>
<p>To deploy all canisters defined in your dfx.json:</p>
<pre><code class="language-bash">dfx deploy --network ic
</code></pre>
<p>To deploy an individual canister:</p>
<pre><code class="language-bash">dfx deploy --network ic [canisterName]
</code></pre>
<p>The URL of your canister on mainnet will look like this: <code>https://[canisterId].raw.icp0.io</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure-tldr"><a class="header" href="#project-structure-tldr">Project Structure TL;DR</a></h1>
<p>Your project is just a directory with a <code>dfx.json</code> file that points to your <code>.ts</code> or <code>.js</code> entrypoint.</p>
<p>Here's what your directory structure might look like:</p>
<pre><code>hello_world/
|
├── dfx.json
|
└── src/
    └── api.ts
</code></pre>
<p>For an HTTP Server canister this would be the simplest corresponding <code>dfx.json</code> file:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;
            }
        }
    }
}
</code></pre>
<p>For a Candid RPC canister this would be the simplest corresponding <code>dfx.json</code> file:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;
        }
    }
}
</code></pre>
<p>Once you have created this directory structure you can <a href="./deployment.html#deploying-to-mainnet">deploy to mainnet</a> or a <a href="./deployment.html#starting-the-local-replica">locally running replica</a> by running the <code>dfx deploy</code> command in the same directory as your <code>dfx.json</code> file.</p>
<h2 id="dfxjson"><a class="header" href="#dfxjson">dfx.json</a></h2>
<p>The <code>dfx.json</code> file is the main ICP-specific configuration file for your canisters. The following are various examples of <code>dfx.json</code> files.</p>
<h3 id="automatic-candid-file-generation"><a class="header" href="#automatic-candid-file-generation">Automatic Candid File Generation</a></h3>
<p>The command-line tools <code>dfx</code> require a Candid file to deploy your canister. Candid RPC canisters will automatically have their Candid files generated and stored in the <code>.azle</code> directory without any extra property in the <code>dfx.json</code> file. HTTP Server canisters must specify <code>&quot;candid_gen&quot;: &quot;http&quot;</code> for their Candid files to be generated automatically in the <code>.azle</code> directory:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;
            }
        }
    }
}
</code></pre>
<h3 id="custom-candid-file"><a class="header" href="#custom-candid-file">Custom Candid File</a></h3>
<p>If you would like to provide your own custom Candid file you can specify <code>&quot;candid&quot;: &quot;[path to your candid file]&quot;</code> and <code>&quot;candid_gen&quot;: &quot;custom&quot;</code>:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;candid&quot;: &quot;src/api.did&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;custom&quot;
            }
        }
    }
}
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>You can provide environment variables to Azle canisters by specifying their names in your <code>dfx.json</code> file and then accessing them through the <code>process.env</code> object in Azle.</p>
<p>You must provide the environment variables that you want included in the same process as your <code>dfx deploy</code> command.</p>
<p>Be aware that the environment variables that you specify in your <code>dfx.json</code> file will be included in plain text in your canister's Wasm binary.</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;,
                &quot;env&quot;: [&quot;MY_ENVIRONMENT_VARIABLE&quot;]
            }
        }
    }
}
</code></pre>
<h3 id="assets"><a class="header" href="#assets">Assets</a></h3>
<p>See <a href="./assets.html">the Assets chapter</a> for more information:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;,
                &quot;assets&quot;: [
                    [&quot;src/frontend/dist&quot;, &quot;dist&quot;],
                    [&quot;src/backend/media/audio.ogg&quot;, &quot;media/audio.ogg&quot;],
                    [&quot;src/backend/media/video.ogv&quot;, &quot;media/video.ogv&quot;]
                ]
            }
        }
    }
}
</code></pre>
<h3 id="build-assets"><a class="header" href="#build-assets">Build Assets</a></h3>
<p>See <a href="./assets.html">the Assets chapter</a> for more information:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;,
                &quot;assets&quot;: [
                    [&quot;src/frontend/dist&quot;, &quot;dist&quot;],
                    [&quot;src/backend/media/audio.ogg&quot;, &quot;media/audio.ogg&quot;],
                    [&quot;src/backend/media/video.ogv&quot;, &quot;media/video.ogv&quot;]
                ],
                &quot;build_assets&quot;: &quot;npm run build&quot;
            }
        }
    }
}
</code></pre>
<h3 id="esm-externals"><a class="header" href="#esm-externals">ESM Externals</a></h3>
<p>This will instruct Azle's TypeScript/JavaScript build process to ignore bundling the provided named packages.</p>
<p>Sometimes the build process is overly eager to include packages that won't actually be used at runtime. This can be a problem if those packages wouldn't even work at runtime due to limitations in ICP or Azle. It is thus useful to be able to exclude them:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;,
                &quot;esm_externals&quot;: [&quot;@nestjs/microservices&quot;, &quot;@nestjs/websockets&quot;]
            }
        }
    }
}
</code></pre>
<h3 id="esm-aliases"><a class="header" href="#esm-aliases">ESM Aliases</a></h3>
<p>This will instruct Azle's TypeScript/JavaScript build process to alias a package name to another pacakge name.</p>
<p>This can be useful if you need to polyfill certain packages that might not exist in Azle:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;api&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/api.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;,
                &quot;esm_aliases&quot;: {
                    &quot;crypto&quot;: &quot;crypto-browserify&quot;
                }
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servers-tldr"><a class="header" href="#servers-tldr">Servers TL;DR</a></h1>
<p>Just write Node.js servers like this:</p>
<pre><code class="language-typescript">import { createServer } from 'http';

const server = createServer((req, res) =&gt; {
    res.write('Hello World!');
    res.end();
});

server.listen();
</code></pre>
<p>or write Express servers like this:</p>
<pre><code class="language-typescript">import express, { Request } from 'express';

let db = {
    hello: ''
};

const app = express();

app.use(express.json());

app.get('/db', (req, res) =&gt; {
    res.json(db);
});

app.post('/db/update', (req: Request&lt;any, any, typeof db&gt;, res) =&gt; {
    db = req.body;

    res.json(db);
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<p>or NestJS servers like this:</p>
<pre><code class="language-typescript">import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';

import { AppModule } from './app.module';

async function bootstrap() {
    const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule);
    await app.listen(3000);
}

bootstrap();
</code></pre>
<h1 id="servers"><a class="header" href="#servers">Servers</a></h1>
<ul>
<li><a href="servers.html#nodejs-httpserver">Node.js http.server</a></li>
<li><a href="servers.html#express">Express</a></li>
<li><a href="servers.html#server">Server</a></li>
<li><a href="servers.html#limitations">Limitations</a></li>
</ul>
<p>Azle supports building HTTP servers on ICP using the <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a> class as the foundation. These servers can serve static files or act as API backends, or both.</p>
<p>Azle currently has good but not comprehensive support for <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a> and <a href="https://expressjs.com/">Express</a>. Support for other libraries like <a href="https://nestjs.com/">Nest</a> are works-in-progress.</p>
<p>Once <a href="./deployment.html">deployed</a> you can access your server at a URL like this locally <code>http://bkyz2-fmaaa-aaaaa-qaaaq-cai.raw.localhost:8000</code> or like this on mainnet <code>https://bkyz2-fmaaa-aaaaa-qaaaq-cai.raw.icp0.io</code>.</p>
<p>You can use any HTTP client to interact with your server, such as <code>curl</code>, <code>fetch</code>, or a web browser. See the <a href="./deployment.html#interacting-with-your-canister">Interacting with your canister section</a> of the <a href="./deployment.html">deployment chapter</a> for help in constructing your canister URL.</p>
<h2 id="nodejs-httpserver"><a class="header" href="#nodejs-httpserver">Node.js http.server</a></h2>
<p>Azle supports instances of <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a>. <code>listen()</code> must be called on the server instance for Azle to use it to handle HTTP requests. Azle does not respect a port being passed into <code>listen()</code>. The port is set by the ICP replica (e.g. <code>dfx start --host 127.0.0.1:8000</code>), not by Azle.</p>
<p>Here's an example of a very simple <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a>:</p>
<pre><code class="language-typescript">import { createServer } from 'http';

const server = createServer((req, res) =&gt; {
    res.write('Hello World!');
    res.end();
});

server.listen();
</code></pre>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<p><a href="https://expressjs.com/">Express</a> is one of the most popular backend JavaScript web frameworks, and it's the recommended way to get started building servers in Azle. Here's the main code from the <a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/hello_world_http_server">hello_world_http_server example</a>:</p>
<pre><code class="language-typescript">import express, { Request } from 'express';

let db = {
    hello: ''
};

const app = express();

app.use(express.json());

app.get('/db', (req, res) =&gt; {
    res.json(db);
});

app.post('/db/update', (req: Request&lt;any, any, typeof db&gt;, res) =&gt; {
    db = req.body;

    res.json(db);
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<h3 id="jsonstringify"><a class="header" href="#jsonstringify">jsonStringify</a></h3>
<p>When working with <code>res.json</code> you may run into errors because of attempting to send back JavaScript objects that are not strictly <code>JSON</code>. This can happen when trying to send back an object with a <code>BigInt</code> for example.</p>
<p>Azle has created a special function called <code>jsonStringify</code> that will serialize many ICP-specific data structures to <code>JSON</code> for you:</p>
<pre><code class="language-typescript">import { jsonStringify } from 'azle/experimental';
import express, { Request } from 'express';

let db = {
    bigInt: 0n
};

const app = express();

app.use(express.json());

app.get('/db', (req, res) =&gt; {
    res.send(jsonStringify(db));
});

app.post('/db/update', (req: Request&lt;any, any, typeof db&gt;, res) =&gt; {
    db = req.body;

    res.send(jsonStringify(db));
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>If you need to add <a href="./query_methods.html">canister methods</a> to your HTTP server, the <code>Server</code> function imported from <code>azle</code> allows you to do so.</p>
<p>Here's an example of a very simple HTTP server:</p>
<pre><code class="language-typescript">import { Server } from 'azle/experimental';
import express from 'express';

export default Server(() =&gt; {
    const app = express();

    app.get('/http-query', (_req, res) =&gt; {
        res.send('http-query-server');
    });

    app.post('/http-update', (_req, res) =&gt; {
        res.send('http-update-server');
    });

    return app.listen();
});
</code></pre>
<p>You can add canister methods like this:</p>
<pre><code class="language-typescript">import { query, Server, text, update } from 'azle/experimental';
import express from 'express';

export default Server(
    () =&gt; {
        const app = express();

        app.get('/http-query', (_req, res) =&gt; {
            res.send('http-query-server');
        });

        app.post('/http-update', (_req, res) =&gt; {
            res.send('http-update-server');
        });

        return app.listen();
    },
    {
        candidQuery: query([], text, () =&gt; {
            return 'candidQueryServer';
        }),
        candidUpdate: update([], text, () =&gt; {
            return 'candidUpdateServer';
        })
    }
);
</code></pre>
<p>The <code>default</code> export of your <code>main</code> module must be the result of calling <code>Server</code>, and the callback argument to <code>Server</code> must return a <a href="https://nodejs.org/api/http.html#class-httpserver">Node.js http.Server</a>. The <code>main</code> module is specified by the <code>main</code> property of your project's <a href="https://github.com/demergent-labs/azle/blob/main/examples/hello_world/dfx.json#L5">dfx.json file</a>. The <code>dfx.json</code> file must be at the root directory of your project.</p>
<p>The callback argument to <code>Server</code> can be asynchronous:</p>
<pre><code class="language-typescript">import { Server } from 'azle/experimental';
import { createServer } from 'http';

export default Server(async () =&gt; {
    const message = await asynchronousHelloWorld();

    return createServer((req, res) =&gt; {
        res.write(message);
        res.end();
    });
});

async function asynchronousHelloWorld() {
    // do some asynchronous task
    return 'Hello World Asynchronous!';
}
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>For a deeper understanding of possible limitations you may want to refer to <a href="https://internetcomputer.org/docs/current/references/http-gateway-protocol-spec">The HTTP Gateway Protocol Specification</a>.</p>
<ul>
<li>The top-level route <code>/api</code> is currently reserved by the replica locally</li>
<li>The <code>Transfer-Encoding</code> header is not supported</li>
<li><code>gzip</code> responses most likely do not work</li>
<li>HTTP requests are generally limited to ~2 MiB</li>
<li>HTTP responses are generally limited to ~3 MiB</li>
<li>You cannot set HTTP status codes in the 1xx range</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets-tldr"><a class="header" href="#assets-tldr">Assets TL;DR</a></h1>
<p>You can automatically copy static assets (essentially files and folders) into your canister's filesystem during deploy by using the <code>assets</code> and <code>build_assets</code> properties of the canister object in your project's <code>dfx.json</code> file.</p>
<p>Here's an example that copies the <code>src/frontend/dist</code> directory on the deploying machine into the <code>dist</code> directory of the canister, using the <code>assets</code> and <code>build_assets</code> properties:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;backend&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/backend/index.ts&quot;,
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;assets&quot;: [[&quot;src/frontend/dist&quot;, &quot;dist&quot;]],
                &quot;build_assets&quot;: &quot;npm run build&quot;
            }
        }
    }
}
</code></pre>
<p>The <code>assets</code> property is an array of tuples, where the first element of the tuple is the source directory on the deploying machine, and the second element of the tuple is the destination directory in the canister. Use <code>assets</code> for total assets up to ~2 GiB in size. We are working on increasing this limit further.</p>
<p>The <code>build_assets</code> property allows you to specify custom terminal commands that will run before Azle copies the assets into the canister. You can use <code>build_assets</code> to build your frontend code for example. In this case we are running <code>npm run build</code>, which refers to an npm script that we have specified in our <code>package.json</code> file.</p>
<p>Once you have loaded assets into your canister, they are accessible from that canister's filesystem. Here's an example of using the Express static middleware to serve a frontend from the canister's filesystem:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.use(express.static('/dist'));

app.listen();
</code></pre>
<p>Assuming the <code>/dist</code> directory in the canister has an appropriate <code>index.html</code> file, this canister would serve a frontend at its URL when loaded in a web browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-tldr"><a class="header" href="#authentication-tldr">Authentication TL;DR</a></h1>
<p>Azle canisters can import <code>caller</code> from <code>azle</code> and use it to get the <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#principal">principal (public-key linked identifier)</a> of the initiator of an HTTP request. HTTP requests are anonymous (principal <code>2vxsx-fae</code>) by default, but authentication with web browsers (and maybe Node.js) can be done using a JWT-like API from <code>azle/http_client</code>.</p>
<p>First you import <code>toJwt</code> from <code>azle/http_client</code>:</p>
<pre><code class="language-typescript">import { toJwt } from 'azle/http_client';
</code></pre>
<p>Then you use <code>fetch</code> and construct an <code>Authorization</code> header using an <a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a> <code>Identity</code>:</p>
<pre><code class="language-typescript">const response = await fetch(
    `http://bkyz2-fmaaa-aaaaa-qaaaq-cai.raw.localhost:8000/whoami`,
    {
        method: 'GET',
        headers: [['Authorization', toJwt(this.identity)]]
    }
);
</code></pre>
<p>Here's an example of the frontend of a simple web application using <code>azle/http_client</code> and <a href="https://internetcomputer.org/internet-identity">Internet Identity</a>:</p>
<pre><code class="language-typescript">import { Identity } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { toJwt } from 'azle/http_client';
import { html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';

@customElement('azle-app')
export class AzleApp extends LitElement {
    @property()
    identity: Identity | null = null;

    @property()
    whoami: string = '';

    connectedCallback() {
        super.connectedCallback();
        this.authenticate();
    }

    async authenticate() {
        const authClient = await AuthClient.create();
        const isAuthenticated = await authClient.isAuthenticated();

        if (isAuthenticated === true) {
            this.handleIsAuthenticated(authClient);
        } else {
            await this.handleIsNotAuthenticated(authClient);
        }
    }

    handleIsAuthenticated(authClient: AuthClient) {
        this.identity = authClient.getIdentity();
    }

    async handleIsNotAuthenticated(authClient: AuthClient) {
        await new Promise((resolve, reject) =&gt; {
            authClient.login({
                identityProvider: import.meta.env.VITE_IDENTITY_PROVIDER,
                onSuccess: resolve as () =&gt; void,
                onError: reject,
                windowOpenerFeatures: `width=500,height=500`
            });
        });

        this.identity = authClient.getIdentity();
    }

    async whoamiUnauthenticated() {
        const response = await fetch(
            `${import.meta.env.VITE_CANISTER_ORIGIN}/whoami`
        );
        const responseText = await response.text();

        this.whoami = responseText;
    }

    async whoamiAuthenticated() {
        const response = await fetch(
            `${import.meta.env.VITE_CANISTER_ORIGIN}/whoami`,
            {
                method: 'GET',
                headers: [['Authorization', toJwt(this.identity)]]
            }
        );
        const responseText = await response.text();

        this.whoami = responseText;
    }

    render() {
        return html`
            &lt;h1&gt;Internet Identity&lt;/h1&gt;

            &lt;h2&gt;
                Whoami principal:
                &lt;span id=&quot;whoamiPrincipal&quot;&gt;${this.whoami}&lt;/span&gt;
            &lt;/h2&gt;

            &lt;button
                id=&quot;whoamiUnauthenticated&quot;
                @click=${this.whoamiUnauthenticated}
            &gt;
                Whoami Unauthenticated
            &lt;/button&gt;
            &lt;button
                id=&quot;whoamiAuthenticated&quot;
                @click=${this.whoamiAuthenticated}
                .disabled=${this.identity === null}
            &gt;
                Whoami Authenticated
            &lt;/button&gt;
        `;
    }
}
</code></pre>
<p>Here's an example of the backend of that same simple web application:</p>
<pre><code class="language-typescript">import { caller } from 'azle';
import express from 'express';

const app = express();

app.get('/whoami', (req, res) =&gt; {
    res.send(caller().toString());
});

app.use(express.static('/dist'));

app.listen();
</code></pre>
<h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/fetch_ic">fetch_ic</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/internet_identity">internet_identity</a></li>
</ul>
<h2 id="under-the-hood"><a class="header" href="#under-the-hood">Under-the-hood</a></h2>
<p>Authentication of ICP calls is done through signatures on messages. <a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a> provides very nice abstractions for creating all of the required signatures in the correct formats when calling into canisters on ICP. Unfortunately this requires you to abandon traditional HTTP requests, as you must use the agent's APIs.</p>
<p>Azle attempts to enable you to perform traditional HTTP requests with traditional libraries. Currently Azle focuses on <code>fetch</code>. When importing <code>toJwt</code>, <code>azle/http_client</code> will overwrite the global <code>fetch</code> function and will intercept <code>fetch</code> requests that have <code>Authorization</code> headers with an <code>Identity</code> as a value.</p>
<p>Once intercepted, these requests are turned into <code>@dfinity/agent</code> requests that call <a href="https://internetcomputer.org/docs/current/references/http-gateway-protocol-spec">the http_request and http_request_update canister methods</a> directly, thus performing all of the required client-side authentication work.</p>
<p>We are working to push for ICP to more natively understand JWTs for authentication, without the need to intercept <code>fetch</code> requests and convert them into agent requests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fetch-tldr"><a class="header" href="#fetch-tldr">fetch TL;DR</a></h1>
<p>Azle canisters use a custom <code>fetch</code> implementation to perform cross-canister calls and to perform HTTPS outcalls.</p>
<p>Here's an example of performing a cross-canister call:</p>
<pre><code class="language-typescript">import { serialize } from 'azle/experimental';
import express from 'express';

const app = express();

app.use(express.json());

app.post('/cross-canister-call', async (req, res) =&gt; {
    const to: string = req.body.to;
    const amount: number = req.body.amount;

    const response = await fetch(`icp://dfdal-2uaaa-aaaaa-qaama-cai/transfer`, {
        body: serialize({
            candidPath: '/token.did',
            args: [to, amount]
        })
    });
    const responseJson = await response.json();

    res.json(responseJson);
});

app.listen();
</code></pre>
<p>Keep these important points in mind when performing a cross-canister call:</p>
<ul>
<li>Use the <code>icp://</code> protocol in the URL</li>
<li>The <code>canister id</code> of the canister that you are calling immediately follows <code>icp://</code> in the URL</li>
<li>The <code>canister method</code> that you are calling immediately follows the <code>canister id</code> in the URL</li>
<li>The <code>candidPath</code> property of the <code>body</code> is the path to the Candid file defining the method signatures of the canister that you are calling. You must obtain this file and copy it into your canister. See the <a href="./assets.html">Assets chapter</a> for info on copying files into your canister</li>
<li>The <code>args</code> property of the <code>body</code> is an array of the arguments that will be passed to the <code>canister method</code> that you are calling</li>
</ul>
<p>Here's an example of performing an HTTPS outcall:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.use(express.json());

app.post('/https-outcall', async (_req, res) =&gt; {
    const response = await fetch(`https://httpbin.org/headers`, {
        headers: {
            'X-Azle-Request-Key-0': 'X-Azle-Request-Value-0',
            'X-Azle-Request-Key-1': 'X-Azle-Request-Value-1',
            'X-Azle-Request-Key-2': 'X-Azle-Request-Value-2'
        }
    });
    const responseJson = await response.json();

    res.json(responseJson);
});

app.listen();
</code></pre>
<h1 id="fetch"><a class="header" href="#fetch">fetch</a></h1>
<p>Azle has custom <code>fetch</code> implementations for clients and canisters.</p>
<p>The client <code>fetch</code> is used for authentication, and you can learn more about it in the <a href="./authentication.html">Authentication chapter</a>.</p>
<p>Canister <code>fetch</code> is used to perform cross-canister calls and <a href="https://internetcomputer.org/https-outcalls">HTTPS outcalls</a>. There are three main types of calls made with canister <code>fetch</code>:</p>
<ol>
<li><a href="fetch.html#cross-canister-calls-to-a-candid-canister">Cross-canister calls to a candid canister</a></li>
<li><a href="fetch.html#cross-canister-calls-to-an-http-canister">Cross-canister calls to an HTTP canister</a></li>
<li><a href="fetch.html#https-outcalls">HTTPS outcalls</a></li>
</ol>
<h2 id="cross-canister-calls-to-a-candid-canister"><a class="header" href="#cross-canister-calls-to-a-candid-canister">Cross-canister calls to a candid canister</a></h2>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/async_await">async_await</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/canister">canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/ckbtc">ckbtc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/composite_queries">composite_queries</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/cross_canister_calls">cross_canister_calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/func_types">func_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/heartbeat">heartbeat</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/icrc">icrc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/ledger_canister">ledger_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/management_canister">management_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/motoko_examples/whoami">whoami</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/recursion">recursion</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/rejections">rejections</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/timers">timers</a></li>
</ul>
<h2 id="cross-canister-calls-to-an-http-canister"><a class="header" href="#cross-canister-calls-to-an-http-canister">Cross-canister calls to an HTTP canister</a></h2>
<p>We are working on better abstractions for these types of calls. For now you would just make a cross-canister call using <code>icp://</code> to the <code>http_request</code> and <code>http_request_update</code> methods of the canister that you are calling.</p>
<h2 id="https-outcalls"><a class="header" href="#https-outcalls">HTTPS outcalls</a></h2>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/http_server/http_outcall_fetch">http_outcall_fetch</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/tests/end_to_end/candid_rpc/functional_syntax/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<!-- // TODO explain that you can generally only do these in POST unless the method is a query method
// TODO we have to show the imports
// TODO explain the POST, PUT, PATCH etc

TODO explain the ic.setOutgoingHttpOptions

TODO split up the examples for each type of fetch

## Canister fetch cross-canister call to a candid canister

Most canisters on ICP are not HTTP canisters. We are pushing to change this situation, but for now this is how things are. Most canisters will thus only expose Candid canister methods.

So imagine a canister that exposes this Candid update method:

```
transfer: (text, text, nat64) -> (nat64);
```

```typescript
const response = await fetch(`icp://dfdal-2uaaa-aaaaa-qaama-cai/transfer`, {
    body: serialize({
        candidPath: '/src/canister2/index.did',
        args: [from, to, amount]
    })
});
const responseJson = await response.json();

return responseJson;
```

## Canister fetch cross-canister call to an HTTP canister

## Canister fetch HTTPS outcalls -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm-tldr"><a class="header" href="#npm-tldr">npm TL;DR</a></h1>
<p>If you want to know if an <a href="https://www.npmjs.com/">npm</a> package will work with Azle, just try out the package.</p>
<p>It's extremely difficult to know generally if a package will work unless it has been tried out and tested already. This is due to the complexity of understanding and implementing all required JavaScript, web, Node.js, and OS-level APIs required for an <code>npm</code> package to execute correctly.</p>
<p>To get an idea for which <code>npm</code> packages are currently supported, the <a href="./rest_based_examples.html">Azle examples</a> are full of example code with tests.</p>
<p>You can also look at the <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> documentation <a href="https://github.com/WasmEdge/WasmEdge/issues/1535">here</a> and <a href="https://wasmedge.org/docs/develop/javascript/nodejs">here</a>, as <code>wasmedge-quickjs</code> is our implementation for much of the Node.js stdlib.</p>
<h1 id="npm"><a class="header" href="#npm">npm</a></h1>
<p>Azle's goal is to support as many <a href="https://www.npmjs.com/">npm</a> packages as possible.</p>
<p>The current reality is that not all <code>npm</code> packages work well with Azle. It is also very difficult to determine which <code>npm</code> packages might work well.</p>
<p>For example, when asked about a specific package, we usually cannot say whether or not a given package &quot;works&quot;. To truly know if a package will work for your situation, the easiest thing to do is to install it, import it, and try it out.</p>
<p>If you do want to reason about whether or not a package is likely to work, consider the following:</p>
<ol>
<li>Which web or Node.js APIs does the package use?</li>
<li>Does the package depend on functionality that ICP supports?</li>
<li>Will the package stay within <a href="./limitations.html">these limitations</a>?</li>
</ol>
<p>For example, any kind of networking outside of HTTP is unlikely to work (without modification), because ICP has very limited support for non-ICP networking.</p>
<p>Also any kind of heavy computation is unlikely to work (without modification), because ICP has very limited instruction limits per call.</p>
<p>We use <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> as our implementation for much of the Node.js stdlib. To get a feel for which Node.js standard libraries Azle supports, see <a href="https://github.com/WasmEdge/WasmEdge/issues/1535">here</a> and <a href="https://wasmedge.org/docs/develop/javascript/nodejs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens-tldr"><a class="header" href="#tokens-tldr">Tokens TL;DR</a></h1>
<p><a href="https://internetcomputer.org/docs/current/concepts/canisters-code">Canisters</a> can either:</p>
<ol>
<li>Interact with tokens that already exist</li>
<li>Implement, extend, or proxy tokens</li>
</ol>
<p>Canisters can use cross-canister calls to interact with tokens implemented using <a href="https://github.com/dfinity/ICRC">ICRC</a> or other standards. They can also interact with non-ICP tokens through <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/encryption/t-ecdsa">threshold ECDSA</a>.</p>
<p>Canisters can implement tokens from scratch, or extend or proxy implementations already written.</p>
<p>Demergent Labs does not keep any token implementations up-to-date. Here are some old implementations for inspiration and learning:</p>
<ul>
<li><a href="https://github.com/demergent-labs/ICRC-1">ICRC-1</a></li>
<li><a href="https://github.com/lastmjs/extendable-token-azle">extendable-token-azle</a></li>
</ul>
<h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/basic_bitcoin">basic_bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcoinjs_lib">bitcoinjs-lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcore_lib">bitcore-lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/ckbtc">ckbtc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers">ethers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers_base">ethers_base</a></li>
<li><a href="https://github.com/lastmjs/extendable-token-azle">extendable-token-azle</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/icrc">icrc</a></li>
<li><a href="https://github.com/demergent-labs/ICRC-1">ICRC-1</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/ledger_canister">ledger_canister</a></li>
</ul>
<!-- -   ICRC transfer from frontend
-   ICRC transfer from backend
-   ckBTC/ckETH transfer from frontend
-   ckBTC/ckETH transfer from backend
-   BTC/ETH transfers from backend
-   Show get balance, total supply, etc as well
-   Basically show the basic needs of users, how to transfer tokens and look up balances

## Interacting with tokens

### ICP tokens

### Foreign blockchain tokens

## Implementing tokens

There are three ways to interact with tokens on ICP. You can interact with a token implemented in another canister with its own standard. You can interact with a token implemented in another canister using ICRC. You can interact with a token canister. You can initiate transfers in a token canister. Or you can implement your own token canister to augment underlying functionality.

You could also act as a proxy to another canister.

You could also interact with tokens on another blockchain like Bitcoin or Ethereum. You can also use ckTokens.

Interacting with:

Custom standard/non-standard ICP tokens
ICRC standard ICP tokens
ck foreign ICP tokens
Foreign tokens

Implementing:

Custom standard/non-standard ICP tokens
ICRC standard ICP tokens
ck foreign ICP tokens

So you can initiate transfers on a custom ICP token. You can initiate transfers on ICRC ICP tokens. You can initiate transfers, read balances, etc on ck tokens which are wrapped tokens on another blockchain. And you can interact with tokens on other blockchains with ECDSA now and soon EdDSA.

So there's interacting with a token that already exists. And then there's creating your own token. If you want to create your own token without changing its functionality, you can just deploy a canister that already exists. If you need to implement your own functionality, you would have to implement your own.

Let's have implementations of all ICRC standards in Azle with tests.

For the TL;DR let's just explain each of these categories and show some code snippets.

This could take a bit of work. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin"><a class="header" href="#bitcoin">Bitcoin</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/basic_bitcoin">basic_bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/bitcoin_psbt">bitcoin_psbt</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcoinjs_lib">bitcoinjs_lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/bitcore_lib">bitcore_lib</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/demo/ckbtc">ckbtc</a></li>
</ul>
<p>There are two main ways to interact with Bitcoin on ICP: through the <a href="bitcoin.html#management-canister">management canister</a> and through the <a href="bitcoin.html#ckbtc">ckBTC canister</a>.</p>
<h2 id="management-canister"><a class="header" href="#management-canister">management canister</a></h2>
<p>To sign Bitcoin transactions using <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/encryption/t-ecdsa">threshold ECDSA</a> and interact with the Bitcoin blockchain directly from ICP, make <a href="./fetch.html">cross-canister calls</a> to the following methods on the <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#ic-management-canister">management canister</a>: <code>ecdsa_public_key</code>, <code>sign_with_ecdsa</code>, <code>bitcoin_get_balance</code>, <code>bitcoin_get_balance_query</code>, <code>bitcoin_get_utxos</code>, <code>bitcoin_get_utxos_query</code>, <code>bitcoin_send_transaction</code>, <code>bitcoin_get_current_fee_percentiles</code>.</p>
<p>To construct your cross-canister calls to these methods, use <code>canister id</code> <code>aaaaa-aa</code> and the management canister's <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#ic-candid">Candid type information</a> to construct the arguments to send in the <code>body</code> of your <code>fetch</code> call.</p>
<p>Here's an example of doing a test cross-canister call to the <code>bitcoin_get_balance</code> method:</p>
<pre><code class="language-typescript">import { serialize } from 'azle/experimental';

// ...

const response = await fetch(`icp://aaaaa-aa/bitcoin_get_balance`, {
    body: serialize({
        args: [
            {
                'bc1q34aq5drpuwy3wgl9lhup9892qp6svr8ldzyy7c',
                min_confirmations: [],
                network: { regtest: null }
            }
        ],
        cycles: 100_000_000n
    })
});
const responseJson = await response.json();

// ...
</code></pre>
<h2 id="ckbtc"><a class="header" href="#ckbtc">ckBTC</a></h2>
<p><a href="https://internetcomputer.org/docs/current/developer-docs/multi-chain/bitcoin/ckbtc/overview">ckBTC</a> is an <a href="https://internetcomputer.org/docs/current/references/icrc1-standard">ICRC</a> canister that wraps underlying bitcoin controlled with threshold ECDSA.</p>
<p>ICRCs are a set of standards for ICP canisters that define the method signatures and corresponding types for those canisters.</p>
<p>You interact with the <code>ckBTC</code> canister by calling its methods. You can do this from the frontend with <a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a>, or from an Azle canister through <a href="./fetch.html">cross-canister calls</a>.</p>
<p>Here's an example of doing a test cross-canister call to the <code>ckBTC</code> <code>icrc1_balance_of</code> method:</p>
<pre><code class="language-typescript">import { ic, serialize } from 'azle/experimental';

// ...

const response = await fetch(
    `icp://mc6ru-gyaaa-aaaar-qaaaq-cai/icrc1_balance_of`,
    {
        body: serialize({
            candidPath: `/candid/icp/icrc.did`,
            args: [
                {
                    owner: ic.id(),
                    subaccount: [
                        padPrincipalWithZeros(ic.caller().toUint8Array())
                    ]
                }
            ]
        })
    }
);
const responseJson = await response.json();

// ...

function padPrincipalWithZeros(principalBlob: Uint8Array): Uint8Array {
    let newUin8Array = new Uint8Array(32);
    newUin8Array.set(principalBlob);
    return newUin8Array;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethereum"><a class="header" href="#ethereum">Ethereum</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable/test/end_to_end/candid_rpc/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers">ethers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ethers_base">ethers_base</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/ic_evm_rpc">ic_evm_rpc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databases"><a class="header" href="#databases">Databases</a></h1>
<p>The eventual goal for Azle is to support as many database solutions as possible. This is difficult for a number of reasons related to ICP's decentralized computing paradigm and Wasm environment.</p>
<p><a href="https://sqlite.org/">SQLite</a> is the current recommended approach to databases with Azle. We plan to provide Postgres support through <a href="https://github.com/electric-sql/pglite">pglite</a> next.</p>
<p>Azle has good support for SQLite through <a href="https://www.npmjs.com/package/sql.js">sql.js</a>. It also has good support for ORMs like <a href="https://orm.drizzle.team/">Drizzle</a> and <a href="https://typeorm.io/">TypeORM</a> using <code>sql.js</code>.</p>
<p>The following examples should be very useful as you get started using SQLite in Azle:</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite">sqlite</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite_drizzle">sqlite_drizzle</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/experimental/test/end_to_end/http_server/sqlite_typeorm">sqlite_typeorm</a></li>
</ul>
<h2 id="sqljs"><a class="header" href="#sqljs">sql.js</a></h2>
<p>SQLite in Azle works using an <a href="https://en.wikipedia.org/wiki/Asm.js">asm.js</a> build of SQLite from <code>sql.js</code> without modifications to the library. The database is stored entirely in memory on the heap, giving you ~2 GiB of space. Serialization across upgrades is possible using stable memory like this:</p>
<pre><code class="language-typescript">// src/index.its

import {
    init,
    postUpgrade,
    preUpgrade,
    Server,
    StableBTreeMap,
    stableJson
} from 'azle/experimental';
import { Database } from 'sql.js/dist/sql-asm.js';

import { initDb } from './db';
import { initServer } from './server';

export let db: Database;

let stableDbMap = StableBTreeMap&lt;'DATABASE', Uint8Array&gt;(0, stableJson, {
    toBytes: (data: Uint8Array) =&gt; data,
    fromBytes: (bytes: Uint8Array) =&gt; bytes
});

export default Server(initServer, {
    init: init([], async () =&gt; {
        db = await initDb();
    }),
    preUpgrade: preUpgrade(() =&gt; {
        stableDbMap.insert('DATABASE', db.export());
    }),
    postUpgrade: postUpgrade([], async () =&gt; {
        db = await initDb(stableDbMap.get('DATABASE').Some);
    })
});
</code></pre>
<pre><code class="language-typescript">// src/db/index.ts

import initSqlJs, {
    Database,
    QueryExecResult,
    SqlValue
} from 'sql.js/dist/sql-asm.js';

import { migrations } from './migrations';

export async function initDb(
    bytes: Uint8Array = Uint8Array.from([])
): Promise&lt;Database&gt; {
    const SQL = await initSqlJs({});

    let db = new SQL.Database(bytes);

    if (bytes.length === 0) {
        for (const migration of migrations) {
            db.run(migration);
        }
    }

    return db;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-tldr"><a class="header" href="#debugging-tldr">Debugging TL;DR</a></h1>
<p>If your terminal logs ever say <code>did not produce a response</code> or <code>response failed classification=Status code: 502 Bad Gateway</code>, it most likely means that your canister has thrown an error and halted execution for that call. Use <code>console.log</code> and <code>try/catch</code> liberally to track down problems and reveal error information. If your error logs do not have useful messages, use <code>try/catch</code> with a <code>console.log</code> of the catch error argument to reveal the underlying error message.</p>
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<ul>
<li><a href="debugging.html#consolelog-and-trycatch">console.log and try/catch</a></li>
<li><a href="debugging.html#canister-did-not-produce-a-response">Canister did not produce a response</a></li>
<li><a href="debugging.html#no-error-message">No error message</a></li>
<li><a href="debugging.html#final-compiled-and-bundled-javascript">Final Compiled and Bundled JavaScript</a></li>
</ul>
<p>Azle currently has less-than-elegant error reporting. We hope to improve this significantly in the future.</p>
<p>In the meantime, consider the following tips when trying to debug your application.</p>
<h2 id="consolelog-and-trycatch"><a class="header" href="#consolelog-and-trycatch">console.log and try/catch</a></h2>
<p>At the highest level, the most important tip is this: use <code>console.log</code> and <code>try/catch</code> liberally to track down problems and reveal error information.</p>
<h2 id="canister-did-not-produce-a-response"><a class="header" href="#canister-did-not-produce-a-response">Canister did not produce a response</a></h2>
<p>If you ever see an error that looks like this:</p>
<pre><code>Replica Error: reject code CanisterError, reject message IC0506: Canister bkyz2-fmaaa-aaaaa-qaaaq-cai did not produce a response, error code Some(&quot;IC0506&quot;)
</code></pre>
<p>or this:</p>
<pre><code>2024-04-17T15:01:39.194377Z  WARN icx_proxy_dev::proxy::agent: Replica Error
2024-04-17T15:01:39.194565Z ERROR tower_http::trace::on_failure: response failed classification=Status code: 502 Bad Gateway latency=61 ms
</code></pre>
<p>it most likely means that your canister has thrown an error and halted execution for that call. First check the replica's logs for any errors messages. If there are no useful error messages, use <a href="debugging.html#consolelog-and-trycatch">console.log and try/catch</a> liberally to track down the source of the error and to reveal more information about the error.</p>
<p>Don't be surprised if you need to <code>console.log</code> after each of your program's statements (including dependencies found in <code>node_modules</code>) to find out where the error is coming from. And don't be surprised if you need to use <code>try/catch</code> with a <code>console.log</code> of the catch error argument to reveal useful error messaging.</p>
<h2 id="no-error-message"><a class="header" href="#no-error-message">No error message</a></h2>
<p>You might find yourself in a situation where an error is reported without a useful message like this:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Error&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;pre&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (azle_main:110643)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (azle_main:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (azle_main:73452)&lt;br&gt; &amp;nbsp; &amp;nbsp;at dispatch (azle_main:73432)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (azle_main:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (azle_main:73655)&lt;br&gt; &amp;nbsp; &amp;nbsp;at process_params (azle_main:73692)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (azle_main:73660)&lt;br&gt; &amp;nbsp; &amp;nbsp;at expressInit (azle_main:73910)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (azle_main:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at trim_prefix (azle_main:73684)&lt;br&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (azle_main:73657)&lt;br&gt; &amp;nbsp; &amp;nbsp;at process_params (azle_main:73692)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (azle_main:73660)&lt;br&gt; &amp;nbsp; &amp;nbsp;at query3 (azle_main:73938)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (azle_main:73283)&lt;br&gt; &amp;nbsp; &amp;nbsp;at trim_prefix (azle_main:73684)&lt;br&gt; &amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (azle_main:73657)&lt;br&gt; &amp;nbsp; &amp;nbsp;at process_params (azle_main:73692)&lt;br&gt; &amp;nbsp; &amp;nbsp;at next (azle_main:73660)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (azle_main:73587)&lt;br&gt; &amp;nbsp; &amp;nbsp;at handle (azle_main:76233)&lt;br&gt; &amp;nbsp; &amp;nbsp;at app2 (azle_main:78091)&lt;br&gt; &amp;nbsp; &amp;nbsp;at call (native)&lt;br&gt; &amp;nbsp; &amp;nbsp;at emitTwo (azle_main:9782)&lt;br&gt; &amp;nbsp; &amp;nbsp;at emit2 (azle_main:10023)&lt;br&gt; &amp;nbsp; &amp;nbsp;at httpHandler (azle_main:87618)&lt;br&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>or like this:</p>
<pre><code>2024-04-17 14:35:30.433501980 UTC: [Canister bkyz2-fmaaa-aaaaa-qaaaq-cai] &quot;    at &lt;anonymous&gt; (azle_main:110643)\n    at handle (azle_main:73283)\n    at next (azle_main:73452)\n    at dispatch (azle_main:73432)\n    at handle (azle_main:73283)\n    at &lt;anonymous&gt; (azle_main:73655)\n    at process_params (azle_main:73692)\n    at next (azle_main:73660)\n    at expressInit (azle_main:73910)\n    at handle (azle_main:73283)\n    at trim_prefix (azle_main:73684)\n    at &lt;anonymous&gt; (azle_main:73657)\n    at process_params (azle_main:73692)\n    at next (azle_main:73660)\n    at query3 (azle_main:73938)\n    at handle (azle_main:73283)\n    at trim_prefix (azle_main:73684)\n    at &lt;anonymous&gt; (azle_main:73657)\n    at process_params (azle_main:73692)\n    at next (azle_main:73660)\n    at handle (azle_main:73587)\n    at handle (azle_main:76233)\n    at app2 (azle_main:78091)\n    at call (native)\n    at emitTwo (azle_main:9782)\n    at emit2 (azle_main:10023)\n    at httpHandler (azle_main:87618)\n&quot;
2024-04-17T14:35:31.983590Z ERROR tower_http::trace::on_failure: response failed classification=Status code: 500 Internal Server Error latency=101 ms
2024-04-17 14:36:34.652587412 UTC: [Canister bkyz2-fmaaa-aaaaa-qaaaq-cai] &quot;    at &lt;anonymous&gt; (azle_main:110643)\n    at handle (azle_main:73283)\n    at next (azle_main:73452)\n    at dispatch (azle_main:73432)\n    at handle (azle_main:73283)\n    at &lt;anonymous&gt; (azle_main:73655)\n    at process_params (azle_main:73692)\n    at next (azle_main:73660)\n    at expressInit (azle_main:73910)\n    at handle (azle_main:73283)\n    at trim_prefix (azle_main:73684)\n    at &lt;anonymous&gt; (azle_main:73657)\n    at process_params (azle_main:73692)\n    at next (azle_main:73660)\n    at query3 (azle_main:73938)\n    at handle (azle_main:73283)\n    at trim_prefix (azle_main:73684)\n    at &lt;anonymous&gt; (azle_main:73657)\n    at process_params (azle_main:73692)\n    at next (azle_main:73660)\n    at handle (azle_main:73587)\n    at handle (azle_main:76233)\n    at app2 (azle_main:78091)\n    at call (native)\n    at emitTwo (azle_main:9782)\n    at emit2 (azle_main:10023)\n    at httpHandler (azle_main:87618)\n&quot;
</code></pre>
<p>In these situations you might be able to use <code>try/catch</code> with a <code>console.log</code> of the catch error argument to reveal the underlying error message.</p>
<p>For example, this code without a <code>try/catch</code> will log errors without the message <code>This is the error text</code>:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.get('/hello-world', (_req, res) =&gt; {
    throw new Error('This is the error text');
    res.send('Hello World!');
});

app.listen();
</code></pre>
<p>You can get the message to print in the replica terminal like this:</p>
<pre><code class="language-typescript">import express from 'express';

const app = express();

app.get('/hello-world', (_req, res) =&gt; {
    try {
        throw new Error('This is the error text');
        res.send('Hello World!');
    } catch (error) {
        console.log(error);
    }
});

app.listen();
</code></pre>
<h2 id="final-compiled-and-bundled-javascript"><a class="header" href="#final-compiled-and-bundled-javascript">Final Compiled and Bundled JavaScript</a></h2>
<p>Azle compiles and bundles your TypeScript/JavaScript into a final JavaScript file to be included and executed inside of your canister. Inspecting this final JavaScript code may help you to debug your application.</p>
<p>When you see something like <code>(azle_main:110643)</code> in your error stack traces, it is a reference to the final compiled and bundled JavaScript file that is actually deployed with and executed by the canister. The right-hand side of <code>azle_main</code> e.g. <code>:110643</code> is the line number in that file.</p>
<p>You can find the file at <code>[project_name]/.azle/[canister_name]/canister/src/main.js</code>. If you have the <code>AZLE_AUTORELOAD</code> environment variable set to <code>true</code> then you should instead look at <code>[project_name]/.azle/[canister_name]/canister/src/main_reloaded.js</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-tldr"><a class="header" href="#limitations-tldr">Limitations TL;DR</a></h1>
<p>There are a number of limitations that you are likely to run into while you develop with Azle on ICP. These are generally the most limiting:</p>
<ul>
<li>5 billion instruction limit for query calls (HTTP GET requests) (~1 second of computation)</li>
<li>40 billion instruction limit for update calls (HTTP POST/etc requests) (~10 seconds of computation)</li>
<li>2 MiB request size limit</li>
<li>3 MiB response size limit</li>
<li>4 GiB heap limit</li>
<li>High request latency relative to traditional web applications (think seconds not milliseconds)</li>
<li>High costs relative to traditional web applications (think ~10x traditional web costs)</li>
<li>StableBTreeMap memory id <code>254</code> is reserved for the stable memory file system</li>
</ul>
<p>Read more <a href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/maintain/resource-limits">here</a> for in-depth information on current ICP limitations.</p>
<!-- # Limitations

Keep in mind that this is not an exhaustive collection of the limitations of Azle or [ICP](https://internetcomputer.org/).

Let's discuss some important limitations of Azle and ICP that you are likely to run into. This is chapter is currently a work-in-progress:

-   `/api` can't be used locally
-   instruction limit (5 billion)
-   Message size limit (2 MiB request, 3 MiB response)
-   heap limit (4 GiB)
-   http outcalls request and response size, latency, and expense
-   1_000 update calls per sec
-   30_000 query calls per sec
-   stable memory limit (96 GiB)
-   no chunked http responses
-   Wasm binary limits (~10 MiB code section, ~90 MiB data section) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="reference_http/./autoreload.html">Autoreload</a></li>
<li><a href="reference_http/./environment_variables.html">Environment Variables</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoreload"><a class="header" href="#autoreload">Autoreload</a></h1>
<p>You can turn on automatic reloading of your canister's final compiled JavaScript by using the <code>AZLE_AUTORELOAD</code> environment variable during deploy:</p>
<pre><code class="language-bash">AZLE_AUTORELOAD=true dfx deploy
</code></pre>
<p>The autoreload feature watches all <code>.ts</code> and <code>.js</code> files recursively in the directory with your <code>dfx.json</code> file (the root directory of your project), excluding files found in <code>.azle</code>, <code>.dfx</code>, and <code>node_modules</code>.</p>
<p>Autoreload only works properly if you do not change the methods of your canister. HTTP-based canisters will generally work well with autoreload as the query and update methods <code>http_request</code> and <code>http_request_update</code> will not need to change often. Candid-based canisters with explicit <code>query</code> and <code>update</code> methods may require manual deploys more often.</p>
<p>Autoreload will not reload assets uploaded through the <code>assets</code> property of your <code>dfx.json</code>.</p>
<p>Setting <code>AZLE_AUTORELOAD=true</code> will create a new <code>dfx</code> identity and set it as a controller of your canister. By default it will be called <code>_azle_file_uploader_identity</code>. This name can be changed with the <code>AZLE_UPLOADER_IDENTITY_NAME</code> environment variable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h1>
<ul>
<li><a href="reference_http/environment_variables.html#azle_autoreload">AZLE_AUTORELOAD</a></li>
<li><a href="reference_http/environment_variables.html#azle_identity_storage_mode">AZLE_IDENTITY_STORAGE_MODE</a></li>
<li><a href="reference_http/environment_variables.html#azle_instruction_count">AZLE_INSTRUCTION_COUNT</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_num_runs">AZLE_PROPTEST_NUM_RUNS</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_path">AZLE_PROPTEST_PATH</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_quiet">AZLE_PROPTEST_QUIET</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_seed">AZLE_PROPTEST_SEED</a></li>
<li><a href="reference_http/environment_variables.html#azle_proptest_verbose">AZLE_PROPTEST_VERBOSE</a></li>
<li><a href="reference_http/environment_variables.html#azle_test_fetch">AZLE_TEST_FETCH</a></li>
<li><a href="reference_http/">AZLE_UPLOADER_IDENTITY_NAME</a></li>
<li><a href="reference_http/environment_variables.html#azle_verbose">AZLE_VERBOSE</a></li>
</ul>
<h2 id="azle_autoreload"><a class="header" href="#azle_autoreload">AZLE_AUTORELOAD</a></h2>
<p>Set this to <code>true</code> to enable autoreloading of your TypeScript/JavaScript code when making any changes to <code>.ts</code> or <code>.js</code> files in your project.</p>
<h2 id="azle_identity_storage_mode"><a class="header" href="#azle_identity_storage_mode">AZLE_IDENTITY_STORAGE_MODE</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_instruction_count"><a class="header" href="#azle_instruction_count">AZLE_INSTRUCTION_COUNT</a></h2>
<p>Set this to <code>true</code> to see rough instruction counts just before JavaScript execution completes for calls.</p>
<h2 id="azle_proptest_num_runs"><a class="header" href="#azle_proptest_num_runs">AZLE_PROPTEST_NUM_RUNS</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_path"><a class="header" href="#azle_proptest_path">AZLE_PROPTEST_PATH</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_quiet"><a class="header" href="#azle_proptest_quiet">AZLE_PROPTEST_QUIET</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_seed"><a class="header" href="#azle_proptest_seed">AZLE_PROPTEST_SEED</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_proptest_verbose"><a class="header" href="#azle_proptest_verbose">AZLE_PROPTEST_VERBOSE</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_test_fetch"><a class="header" href="#azle_test_fetch">AZLE_TEST_FETCH</a></h2>
<p>Used for automated testing.</p>
<h2 id="azle_uploader_identity_name"><a class="header" href="#azle_uploader_identity_name">AZLE_UPLOADER_IDENTITY_NAME</a></h2>
<p>Change the name of the <code>dfx</code> identity added as a controller for uploading large assets and autoreload.</p>
<h2 id="azle_verbose"><a class="header" href="#azle_verbose">AZLE_VERBOSE</a></h2>
<p>Set this to <code>true</code> to enable more logging output during <code>dfx deploy</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="old-candid-based-documentation"><a class="header" href="#old-candid-based-documentation">Old Candid-based Documentation</a></h1>
<blockquote>
<p>This entire section of the documentation may be out of date</p>
</blockquote>
<p>Azle is currently going through a transition to give higher priority to utilizing HTTP, REST, JSON, and other familiar web technologies. This is in contrast to having previously focused on ICP-specific technologies like <a href="./candid.html">Candid</a> and explicitly creating <code>Canister</code> objects with <a href="./query_methods.html">query</a> and <a href="./update_methods.html">update</a> methods.</p>
<p>We are calling these two paradigms HTTP-based and Candid-based. Many concepts from the <a href="./candid_based_documentation.html">Candid-based documentation</a> are still applicable in the HTTP-based paradigm. The HTTP-based paradigm simply focuses on changing the communication and serialization strategies to be more web-focused and less custom.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="azle-beta"><a class="header" href="#azle-beta">Azle (Beta)</a></h1>
<p>Azle is a <a href="https://www.typescriptlang.org/">TypeScript</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript</a> <a href="https://internetcomputer.org/docs/current/developer-docs/backend/choosing-language">Canister Development Kit</a> (CDK) for the <a href="https://internetcomputer.org/">Internet Computer</a> (IC). In other words, it's a TypeScript/JavaScript runtime for building applications (<a href="https://internetcomputer.org/docs/current/concepts/canisters-code">canisters</a>) on the IC.</p>
<ul>
<li><a href="https://www.npmjs.com/package/azle">npm package</a></li>
<li><a href="https://github.com/demergent-labs/azle">GitHub repo</a></li>
<li><a href="https://discord.gg/5Hb6rM2QUM">Discord channel</a></li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>Azle stable mode is continuously subjected to <a href="https://github.com/demergent-labs/azle/actions">intense scrutiny and testing</a>, however it does not yet have multiple independent security reviews/audits.</p>
<h2 id="stable-mode"><a class="header" href="#stable-mode">Stable Mode</a></h2>
<p>Azle runs in stable mode by default.</p>
<p>This mode is intended for production use after Azle's 1.0 release. Its focus is on API and runtime stability, security, performance, TypeScript and JavaScript language support, the ICP APIs, and Candid remote procedure calls (RPC). There is minimal support for the Node.js standard library, npm ecosystem, and HTTP server functionality.</p>
<h2 id="experimental-mode"><a class="header" href="#experimental-mode">Experimental Mode</a></h2>
<p>Azle runs in experimental mode through explicitly enabling a flag in <code>dfx.json</code> or certain CLI commands.</p>
<p>This mode is intended for developers who are willing to accept the risk of using an alpha or beta project. Its focus is on quickly enabling new features and functionality without requiring the time and other resources necessary to advance them to the stable mode. The Node.js standard libary, npm ecosystem, and HTTP server functionality are also major areas of focus.</p>
<blockquote>
<p>NOTE: Keep clearly in mind that the experimental mode fundamentally changes the Azle Wasm binary. It is not guaranteed to be secure or stable in API changes or runtime behavior. If you enable the experimental mode, even if you only use APIs from the stable mode, you are accepting a higher risk of bugs, errors, crashes, security exploits, breaking API changes, etc.</p>
</blockquote>
<h2 id="demergent-labs"><a class="header" href="#demergent-labs">Demergent Labs</a></h2>
<p>Azle is currently developed by <a href="https://github.com/demergent-labs">Demergent Labs</a>, a for-profit company with a <a href="https://dfinity.org/grants">grant</a> from <a href="https://dfinity.org/">DFINITY</a>.</p>
<p>Demergent Labs' <a href="https://github.com/demergent-labs/blog/blob/main/demergent-labs-grand-plan-part-1.md">vision</a> is to accelerate the adoption of Web3, the Internet Computer, and sustainable open source.</p>
<h2 id="benefits-and-drawbacks"><a class="header" href="#benefits-and-drawbacks">Benefits and drawbacks</a></h2>
<p>Azle and the IC provide unique benefits and drawbacks, and both are not currently suitable for all application use-cases.</p>
<p>The following information will help you to determine when Azle and the IC might be beneficial for your use-case.</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p>Azle intends to be a full TypeScript and JavaScript environment for the IC (a decentralized cloud platform), with support for all of the TypeScript and JavaScript language and as many relevant environment APIs as possible. These environment APIs will be similar to those available in the Node.js and web browser environments.</p>
<p>One of the core benefits of Azle is that it allows web developers to bring their TypeScript or JavaScript skills to the IC. For example, Azle allows the use of various npm packages and VS Code intellisense.</p>
<p>As for the IC, we believe its main benefits can be broken down into the following categories:</p>
<ul>
<li><a href="azle.html#ownership">Ownership</a></li>
<li><a href="azle.html#security">Security</a></li>
<li><a href="azle.html#developer-experience">Developer Experience</a></li>
</ul>
<p>Most of these benefits stem from the decentralized nature of the IC, though the IC is best thought of as a progressively decentralizing cloud platform. As opposed to traditional cloud platforms, its goal is to be owned and controlled by many independent entities.</p>
<h4 id="ownership"><a class="header" href="#ownership">Ownership</a></h4>
<ul>
<li><a href="azle.html#full-stack-group-ownership">Full-stack group ownership</a></li>
<li><a href="azle.html#autonomous-ownership">Autonomous ownership</a></li>
<li><a href="azle.html#permanent-apis">Permanent APIs</a></li>
<li><a href="azle.html#credible-neutrality">Credible neutrality</a></li>
<li><a href="azle.html#reduced-platform-risk">Reduced platform risk</a></li>
</ul>
<h5 id="full-stack-group-ownership"><a class="header" href="#full-stack-group-ownership">Full-stack group ownership</a></h5>
<p>The IC allows you to build applications that are controlled directly and only (with some caveats) by a group of people. This is in opposition to most cloud applications written today, which must be under the control of a very limited number of people and often a single legal entity that answers directly to a cloud provider, which itself is a single legal entity.</p>
<p>In the blockchain world, group-owned applications are known as <a href="https://en.wikipedia.org/wiki/Decentralized_autonomous_organization">DAOs</a>. As opposed to DAOs built on most blockchains, the IC allows full-stack applications to be controlled by groups. This means that the group fully controls the running instances of the frontend and the backend code.</p>
<h5 id="autonomous-ownership"><a class="header" href="#autonomous-ownership">Autonomous ownership</a></h5>
<p>In addition to allowing applications to be owned by groups of people, the IC also allows applications to be owned by no one. This essentially creates autonomous applications or everlasting processes that execute indefinitely. The IC will essentially allow such an application to run indefinitely, unless it depletes its balance of cycles, or the <a href="https://internetcomputer.org/nns">NNS</a> votes to shut it down, neither of which is inevitable.</p>
<h5 id="permanent-apis"><a class="header" href="#permanent-apis">Permanent APIs</a></h5>
<p>Because most web APIs are owned and operated by individual entities, their fate is tied to that of their owners. If their owners go out of business, then those APIs may cease to exist. If their owners decide that they do not like or agree with certain users, they may restrict their access. In the end, they may decide to shut down or restrict access for arbitrary reasons.</p>
<p>Because the IC allows for group and autonomous ownership of cloud software, the IC is able to produce potentially permanent web APIs. A decentralized group of independent entities will find it difficult to censor API consumers or shut down an API. An autonomous API would take those difficulties to the extreme, as it would continue operating as long as consumers were willing to pay for it.</p>
<h5 id="credible-neutrality"><a class="header" href="#credible-neutrality">Credible neutrality</a></h5>
<p>Group and autonomous ownership makes it possible to build neutral cloud software on the IC. This type of software would allow independent parties to coordinate with reduced trust in each other or a single third-party coordinator.</p>
<p>This removes the risk of the third-party coordinator acting in its own self-interest against the interests of the coordinating participants. The coordinating participants would also find it difficult to implement changes that would benefit themselves to the detriment of other participants.</p>
<p>Examples could include mobile app stores, ecommerce marketplaces, and podcast directories.</p>
<h5 id="reduced-platform-risk"><a class="header" href="#reduced-platform-risk">Reduced platform risk</a></h5>
<p>Because the IC is not owned or controlled by any one entity or individual, the risk of being deplatformed is reduced. This is in opposition to most cloud platforms, where the cloud provider itself generally has the power to arbitrarily remove users from its platform. While deplatforming can still occur on the IC, the only endogenous means of forcefully taking down an application is through an NNS vote.</p>
<h4 id="security"><a class="header" href="#security">Security</a></h4>
<ul>
<li><a href="azle.html#built-in-replication">Built-in replication</a></li>
<li><a href="azle.html#built-in-authentication">Built-in authentication</a></li>
<li><a href="azle.html#built-in-firewallport-management">Built-in firewall/port management</a></li>
<li><a href="azle.html#built-in-sandboxing">Built-in sandboxing</a></li>
<li><a href="azle.html#threshold-protocols">Threshold protocols</a></li>
<li><a href="azle.html#verifiable-source-code">Verifiable source code</a></li>
<li><a href="azle.html#blockchain-integration">Blockchain integration</a></li>
</ul>
<h5 id="built-in-replication"><a class="header" href="#built-in-replication">Built-in replication</a></h5>
<p>Replication has many benefits that stem from reducing various central points of failure.</p>
<p>The IC is at its core a <a href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine Fault Tolerant</a> replicated compute environment. Applications are deployed to subnets which are composed of nodes running replicas. Each replica is an independent replicated state machine that executes an application's state transitions (usually initiated with HTTP requests) and persists the results.</p>
<p>This replication provides a high level of security out-of-the-box. It is also the foundation of a number of protocols that provide threshold cryptographic operations to IC applications.</p>
<h5 id="built-in-authentication"><a class="header" href="#built-in-authentication">Built-in authentication</a></h5>
<p>IC client tooling makes it easy to sign and send messages to the IC, and <a href="https://internetcomputer.org/docs/current/tokenomics/identity-auth/what-is-ic-identity">Internet Identity</a> provides a novel approach to self-custody of private keys. The IC automatically authenticates messages with the public key of the signer, and provides a compact representation of that public key, called a principal, to the application. The principal can be used for authorization purposes. This removes many authentication concerns from the developer.</p>
<h5 id="built-in-firewallport-management"><a class="header" href="#built-in-firewallport-management">Built-in firewall/port management</a></h5>
<p>The concept of ports and various other low-level network infrastructure on the IC is abstracted away from the developer. This can greatly reduce application complexity thus minimizing the chance of introducing vulnerabilities through incorrect configurations. Canisters expose endpoints through various methods, usually query or update methods. Because authentication is also built-in, much of the remaining vulnerability surface area is minimized to implementing correct authorization rules in the canister method endpoints.</p>
<h5 id="built-in-sandboxing"><a class="header" href="#built-in-sandboxing">Built-in sandboxing</a></h5>
<p>Canisters have at least two layers of sandboxing to protect colocated canisters from each other. All canisters are at their core Wasm modules and thus inherit the built-in Wasm sandbox. In case there is any bug in the underlying implementation of the Wasm execution environment (or a vulnerability in the imported host functionality), there is also an OS-level sandbox. Developers need not do anything to take advantage of these sandboxes.</p>
<h5 id="threshold-protocols"><a class="header" href="#threshold-protocols">Threshold protocols</a></h5>
<p>The IC provides a number of threshold protocols that allow groups of independent nodes to perform cryptographic operations. These protocols remove central points of failure while providing familiar and useful cryptographic operations to developers. Included are <a href="https://internetcomputer.org/docs/current/developer-docs/integrations/t-ecdsa">ECDSA</a>, <a href="https://internetcomputer.org/how-it-works/response-certification/">BLS</a>, <a href="https://internetcomputer.org/how-it-works/chain-key-technology/">VRF-like</a>, and in the future <a href="https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560">threshold key derivation</a>.</p>
<h5 id="verifiable-source-code"><a class="header" href="#verifiable-source-code">Verifiable source code</a></h5>
<p>IC applications (canisters) are compiled into Wasm and deployed to the IC as Wasm modules. The IC hashes each canister's Wasm binary and stores it for public retrieval. The Wasm binary hash can be retrieved and compared with the hash of an independently compiled Wasm binary derived from available source code. If the hashes match, then one can know with a high degree of certainty that the application is executing the Wasm binary that was compiled from that source code.</p>
<h5 id="blockchain-integration"><a class="header" href="#blockchain-integration">Blockchain integration</a></h5>
<p>When compared with web APIs built for the same purpose, the IC provides a high degree of security when integrating with various other blockchains. It has a direct client integration with Bitcoin, allowing applications to query its state with BFT guarantees. A similar integration is coming for Ethereum.</p>
<p>In addition to these blockchain client integrations, a <a href="https://internetcomputer.org/docs/current/developer-docs/integrations/t-ecdsa/">threshold ECDSA protocol</a> (tECDSA) allows the IC to create keys and sign transactions on various <a href="http://ethanfast.com/top-crypto.html">ECDSA chains</a>. These chains include Bitcoin and Ethereum, and in the future the protocol may be extended to allow interaction with various <a href="http://ethanfast.com/top-crypto.html">EdDSA chains</a>. These direct integrations combined with tECDSA provide a much more secure way to provide blockchain functionality to end users than creating and storing their private keys on traditional cloud infrastructure.</p>
<h4 id="developer-experience"><a class="header" href="#developer-experience">Developer experience</a></h4>
<ul>
<li><a href="azle.html#built-in-devops">Built-in devops</a></li>
<li><a href="azle.html#orthogonal-persistence">Orthogonal persistence</a></li>
</ul>
<h5 id="built-in-devops"><a class="header" href="#built-in-devops">Built-in devops</a></h5>
<p>The IC provides many devops benefits automatically. Though currently limited in its scalability, the protocol attempts to remove the need for developers to concern themselves with concepts such as autoscaling, load balancing, uptime, sandboxing, and firewalls/port management.</p>
<p>Correctly constructed canisters have a simple deploy process and automatically inherit these devops capabilities up unto the current scaling limits of the IC. DFINITY engineers are constantly working to remove scalability bottlenecks.</p>
<h5 id="orthogonal-persistence"><a class="header" href="#orthogonal-persistence">Orthogonal persistence</a></h5>
<p>The IC automatically persists its heap. This creates an extremely convenient way for developers to store application state, by simply writing into global variables in their programming language of choice. This is a great way to get started.</p>
<p>If a canister upgrades its code, swapping out its Wasm binary, then the heap must be cleared. To overcome this limitation, there is a special area of memory called stable memory that persists across these canister upgrades. Special stable data structures provide a familiar API that allows writing into stable memory directly.</p>
<p>All of this together provides the foundation for a very simple persistence experience for the developer. The persistence tools now available and coming to the IC may be simpler than their equivalents on traditional cloud infrastructure.</p>
<h3 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h3>
<p>It's important to note that both Azle and the IC are early-stage projects. The IC officially launched in May of 2021, and Azle reached beta in April of 2022.</p>
<h4 id="azle"><a class="header" href="#azle">Azle</a></h4>
<p>Some of Azle's main drawbacks can be summarized as follows:</p>
<ul>
<li><a href="azle.html#beta">Beta</a></li>
<li><a href="azle.html#security-risks">Security risks</a></li>
<li><a href="azle.html#missing-apis">Missing APIs</a></li>
</ul>
<h5 id="beta"><a class="header" href="#beta">Beta</a></h5>
<p>Azle reached beta in April of 2022. It's an immature project that may have unforeseen bugs and other issues. We're working constantly to improve it. We hope to get to a production-ready 1.0 in 2024. The following are the major blockers to 1.0:</p>
<ul>
<li>Extensive automated property test coverage</li>
<li>Multiple independent security reviews/audits</li>
<li>Broad npm package support</li>
</ul>
<h5 id="security-risks"><a class="header" href="#security-risks">Security risks</a></h5>
<p>As discussed earlier, these are some things to keep in mind:</p>
<ul>
<li>Azle does not yet have extensive automated property tests</li>
<li>Azle does not yet have multiple independent security reviews/audits</li>
<li>Azle does not yet have many live, successful, continuously operating applications deployed to the IC</li>
</ul>
<h5 id="missing-apis"><a class="header" href="#missing-apis">Missing APIs</a></h5>
<p>Azle is not Node.js nor is it V8 running in a web browser. It is using a JavaScript interpreter running in a very new and very different environment. APIs from the Node.js and web browser ecosystems may not be present in Azle. Our goal is to support as many of these APIs as possible over time.</p>
<h4 id="ic"><a class="header" href="#ic">IC</a></h4>
<p>Some of the IC's main drawbacks can be summarized as follows:</p>
<ul>
<li><a href="azle.html#early">Early</a></li>
<li><a href="azle.html#high-latencies">High latencies</a></li>
<li><a href="azle.html#limited-and-expensive-compute-resources">Limited and expensive compute resources</a></li>
<li><a href="azle.html#limited-scalability">Limited scalability</a></li>
<li><a href="azle.html#lack-of-privacy">Lack of privacy</a></li>
<li><a href="azle.html#nns-risk">NNS risk</a></li>
</ul>
<h5 id="early"><a class="header" href="#early">Early</a></h5>
<p>The IC launched officially in May of 2021. As a relatively new project with an extremely ambitious vision, you can expect a small community, immature tooling, and an unproven track record. Much has been delivered, but many promises are yet to be fulfilled.</p>
<h5 id="high-latencies"><a class="header" href="#high-latencies">High latencies</a></h5>
<p>Any requests that change state on the IC must go through consensus, thus you can expect latencies of a few seconds for these types of requests. When canisters need to communicate with each other across subnets or under heavy load, these latencies can be even longer. Under these circumstances, in the worst case latencies will build up linearly. For example, if canister A calls canister B calls canister C, and these canisters are all on different subnets or under heavy load, then you might need to multiply the latency by the total number of calls.</p>
<h5 id="limited-and-expensive-compute-resources"><a class="header" href="#limited-and-expensive-compute-resources">Limited and expensive compute resources</a></h5>
<p>CPU usage, data storage, and network usage may be more expensive than the equivalent usage on traditional cloud platforms. Combining these costs with the high latencies explained above, it becomes readily apparent that the IC is currently not built for high-performance computing.</p>
<h5 id="limited-scalability"><a class="header" href="#limited-scalability">Limited scalability</a></h5>
<p>The IC might not be able to scale to the needs of your application. It is constantly seeking to improve scalability bottlenecks, but it will probably not be able to onboard millions of users to your traditional web application.</p>
<h5 id="lack-of-privacy"><a class="header" href="#lack-of-privacy">Lack of privacy</a></h5>
<p>You should assume that all of your application data (unless it is end-to-end encrypted) is accessible to multiple third-parties with no direct relationship and limited commitment to you. Currently all canister state sits unencrypted on node operator's machines. Application-layer access controls for data are possible, but motivated node operators will have an easy time getting access to your data.</p>
<h5 id="nns-risk"><a class="header" href="#nns-risk">NNS risk</a></h5>
<p>The NNS has the ability to uninstall any canister and can generally change anything about the IC protocol. The NNS uses a simple liquid democracy based on coin/token voting and follower relationships. At the time of this writing most of the voting power on the NNS follows DFINITY for protocol changes, effectively giving DFINITY write control to the protocol while those follower relationships remain in place. The NNS must mature and decentralize to provide practical and realistic protections to canisters and their users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internet-computer-overview"><a class="header" href="#internet-computer-overview">Internet Computer Overview</a></h1>
<p>The <a href="https://internetcomputer.org/">Internet Computer</a> (IC) is a decentralized cloud platform. Actually, it is better thought of as a progressively decentralizing cloud platform. Its full vision is yet to be fulfilled.</p>
<p>It aims to be owned and operated by many independent entities in many geographies and legal jurisdictions throughout the world. This is in opposition to most traditional cloud platforms today, which are generally owned and operated by one overarching legal entity.</p>
<p>The IC is composed of computer hardware nodes running the IC protocol software. Each running IC protocol software process is known as a replica.</p>
<p>Nodes are assigned into groups known as subnets. Each subnet attempts to maximize its decentralization of nodes according to factors such as data center location and node operator independence.</p>
<p>The subnets vary in size. Generally speaking the larger the size of the subnet the more secure it will be. Subnets currently range in size from 13 to 40 nodes, with most subnets having 13 nodes.</p>
<p>IC applications, known as canisters, are deployed to specific subnets. They are then accessible through Internet Protocol requests such as HTTP. Each subnet replicates all canisters across all of its replicas. A consensus protocol is run by the replicas to ensure <a href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine Fault Tolerance</a>.</p>
<p>View the <a href="https://dashboard.internetcomputer.org/subnets">IC Dashboard</a> to explore all data centers, subnets, node operators, and many other aspects of the IC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canisters-overview"><a class="header" href="#canisters-overview">Canisters Overview</a></h1>
<p>Canisters are <a href="https://internetcomputer.org/">Internet Computer</a> (IC) applications. They are the encapsulation of your code and state, and are essentially Wasm modules.</p>
<p>State can be stored on the 4 GiB heap or in a larger 96 GiB location called stable memory. You can store state on the heap using your language's native global variables. You can store state in stable memory using low-level APIs or special stable data structures that behave similarly to native language data structures.</p>
<p>State changes must go through a process called consensus. The consensus process ensures that state changes are <a href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine Fault Tolerant</a>. This process takes a few seconds to complete.</p>
<p>Operations on canister state are exposed to users through canister methods. These methods can be invoked through HTTP requests. Query methods allow state to be read and are low-latency. Update methods allow state to be changed and are higher-latency. Update methods take a few seconds to complete because of the consensus process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-2"><a class="header" href="#installation-2">Installation</a></h1>
<blockquote>
<p>Windows is only supported through a Linux virtual environment of some kind, such as <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a></p>
</blockquote>
<p>It's recommended to use nvm and Node.js 22:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>Restart your terminal and then run:</p>
<pre><code class="language-bash">nvm install 22
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">node --version
</code></pre>
<p>Install the dfx command line tools for managing ICP applications:</p>
<pre><code class="language-bash">DFX_VERSION=0.24.3 sh -ci &quot;$(curl -fsSL https://sdk.dfinity.org/install.sh)&quot;
</code></pre>
<p>Check that the installation went smoothly by looking for clean output from the following command:</p>
<pre><code class="language-bash">dfx --version
</code></pre>
<p>If after trying to run <code>dfx --version</code> you encounter an error such as <code>dfx: command not found</code>, you might need to add <code>$HOME/bin</code> to your path. Here's an example of doing this in your <code>.bashrc</code>:</p>
<pre><code class="language-bash">echo 'export PATH=&quot;$PATH:$HOME/bin&quot;' &gt;&gt; &quot;$HOME/.bashrc&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<ul>
<li><a href="hello_world.html#quick-start">Quick start</a></li>
<li><a href="hello_world.html#slow-start">Methodical start</a>
<ul>
<li><a href="hello_world.html#the-project-directory-and-file-structure">The project directory and file structure</a></li>
<li><a href="hello_world.html#indexts">index.ts</a></li>
<li><a href="hello_world.html#tsconfigjson">tsconfig.json</a></li>
<li><a href="hello_world.html#dfxjson">dfx.json</a></li>
<li><a href="hello_world.html#local-deployment">Local deployment</a></li>
<li><a href="hello_world.html#common-deployment-issues">Common deployment issues</a></li>
<li><a href="hello_world.html#interacting-with-your-canister-from-the-command-line">Interacting with your canister from the command line</a></li>
<li><a href="hello_world.html#interacting-with-your-canister-from-the-web-ui">Interacting with your canister from the web UI</a></li>
</ul>
</li>
</ul>
<p>Let's build your first application (canister) with Azle!</p>
<p>Before embarking please ensure you've followed all of <a href="./installation.html">the installation instructions</a>, especially noting <a href="./installation.html#build-dependencies">the build dependencies</a>.</p>
<p>We'll build a simple <code>Hello World</code> canister that shows the basics of importing Azle, exposing a query method, exposing an update method, and storing some state in a global variable. We'll then interact with it from the command line and from our web browser.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>We are going to use the Azle <code>new</code> command which creates a simple example project.</p>
<p>First use the <code>new</code> command to create a new project called <code>azle_hello_world</code>:</p>
<pre><code class="language-bash">npx azle new azle_hello_world
</code></pre>
<p>Now let's go inside of our project:</p>
<pre><code class="language-bash">cd azle_hello_world
</code></pre>
<p>We should install Azle and all of its dependencies:</p>
<pre><code class="language-bash">npm install
</code></pre>
<p>Start up your local replica:</p>
<pre><code class="language-bash">dfx start
</code></pre>
<p>In another terminal, deploy your canister:</p>
<pre><code class="language-bash">dfx deploy azle_hello_world
</code></pre>
<p>Call the <code>setMessage</code> method:</p>
<pre><code class="language-bash">dfx canister call azle_hello_world setMessage '(&quot;Hello world!&quot;)'
</code></pre>
<p>Call the <code>getMessage</code> method:</p>
<pre><code class="language-bash">dfx canister call azle_hello_world getMessage
</code></pre>
<p>If you run into an error during deployment, see <a href="./deployment.html#common-deployment-issues">the common deployment issues section</a>.</p>
<p>See the official <a href="https://github.com/demergent-labs/azle_hello_world">azle_hello_world</a> example for more information.</p>
<h2 id="methodical-start"><a class="header" href="#methodical-start">Methodical start</a></h2>
<h3 id="the-project-directory-and-file-structure"><a class="header" href="#the-project-directory-and-file-structure">The project directory and file structure</a></h3>
<p>Assuming you're starting completely from scratch, run these commands to setup your project's directory and file structure:</p>
<pre><code class="language-bash">mkdir azle_hello_world
cd azle_hello_world

mkdir src

touch src/index.ts
touch tsconfig.json
touch dfx.json
</code></pre>
<p>Now install Azle, which will create your <code>package.json</code> and <code>package-lock.json</code> files:</p>
<pre><code class="language-bash">npm install azle
</code></pre>
<p>Open up <code>azle_hello_world</code> in your text editor (we recommend <a href="https://code.visualstudio.com/">VS Code</a>).</p>
<h3 id="indexts"><a class="header" href="#indexts">index.ts</a></h3>
<p>Here's the main code of the project, which you should put in the <code>azle_hello_world/src/index.ts</code> file of your canister:</p>
<pre><code class="language-typescript">import { Canister, query, text, update, Void } from 'azle/experimental';

// This is a global variable that is stored on the heap
let message = '';

export default Canister({
    // Query calls complete quickly because they do not go through consensus
    getMessage: query([], text, () =&gt; {
        return message;
    }),
    // Update calls take a few seconds to complete
    // This is because they persist state changes and go through consensus
    setMessage: update([text], Void, (newMessage) =&gt; {
        message = newMessage; // This change will be persisted
    })
});
</code></pre>
<p>Let's discuss each section of the code.</p>
<pre><code class="language-typescript">import { Canister, query, text, update, Void } from 'azle/experimental';
</code></pre>
<p>The code starts off by importing <code>Canister</code>, <code>query</code>, <code>text</code>, <code>update</code> and <code>Void</code> from <code>azle</code>. The <code>azle</code> module provides most of the Internet Computer (IC) APIs for your canister.</p>
<pre><code class="language-typescript">// This is a global variable that is stored on the heap
let message = '';
</code></pre>
<p>We have created a global variable to store the state of our application. This variable is in scope to all of the functions defined in this module. We have set it equal to an empty string.</p>
<pre><code class="language-typescript">export default Canister({
    ...
});
</code></pre>
<p>The <code>Canister</code> function allows us to export our canister's definition to the Azle IC environment.</p>
<pre><code class="language-typescript">// Query calls complete quickly because they do not go through consensus
getMessage: query([], text, () =&gt; {
    return message;
}),
</code></pre>
<p>We are exposing a canister query method here. This method simply returns our global <code>message</code> variable. We use a <code>CandidType</code> object called <code>text</code> to instruct Azle to encode the return value as a Candid <code>text</code> value. When query methods are called they execute quickly because they do not have to go through consensus.</p>
<pre><code class="language-typescript">// Update calls take a few seconds to complete
// This is because they persist state changes and go through consensus
setMessage: update([text], Void, (newMessage) =&gt; {
    message = newMessage; // This change will be persisted
});
</code></pre>
<p>We are exposing an update method here. This method accepts a <code>string</code> from the caller and will store it in our global <code>message</code> variable. We use a <code>CandidType</code> object called <code>text</code> to instruct Azle to decode the <code>newMessage</code> parameter from a Candid <code>text</code> value to a JavaScript string value. Azle will infer the TypeScript type for <code>newMessage</code>. We use a <code>CandidType</code> object called <code>Void</code> to instruct Azle to encode the return value as the absence of a Candid value.</p>
<p>When update methods are called they take a few seconds to complete. This is because they persist changes and go through consensus. A majority of nodes in a subnet must agree on all state changes introduced in calls to update methods.</p>
<p>That's it! We've created a very simple getter/setter <code>Hello World</code> application. But no <code>Hello World</code> project is complete without actually yelling <code>Hello world</code>!</p>
<p>To do that, we'll need to setup the rest of our project.</p>
<h3 id="tsconfigjson"><a class="header" href="#tsconfigjson">tsconfig.json</a></h3>
<p>Create the following in <code>azle_hello_world/tsconfig.json</code>:</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;strict&quot;: true,
        &quot;target&quot;: &quot;ES2020&quot;,
        &quot;moduleResolution&quot;: &quot;node&quot;,
        &quot;allowJs&quot;: true,
        &quot;outDir&quot;: &quot;HACK_BECAUSE_OF_ALLOW_JS&quot;
    }
}
</code></pre>
<h3 id="dfxjson-1"><a class="header" href="#dfxjson-1">dfx.json</a></h3>
<p>Create the following in <code>azle_hello_world/dfx.json</code>:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;azle_hello_world&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;main&quot;: &quot;src/index.ts&quot;,
            &quot;candid&quot;: &quot;src/index.did&quot;,
            &quot;build&quot;: &quot;node_modules/.bin/azle compile azle_hello_world&quot;,
            &quot;wasm&quot;: &quot;.azle/azle_hello_world/azle_hello_world.wasm&quot;,
            &quot;gzip&quot;: true
        }
    }
}
</code></pre>
<h3 id="local-deployment"><a class="header" href="#local-deployment">Local deployment</a></h3>
<p>Let's deploy to our local replica.</p>
<p>First startup the replica:</p>
<pre><code class="language-bash">dfx start --background
</code></pre>
<p>Then deploy the canister:</p>
<pre><code class="language-bash">dfx deploy
</code></pre>
<h3 id="common-deployment-issues"><a class="header" href="#common-deployment-issues">Common deployment issues</a></h3>
<p>If you run into an error during deployment, see <a href="./deployment.html#common-deployment-issues">the common deployment issues section</a>.</p>
<h3 id="interacting-with-your-canister-from-the-command-line"><a class="header" href="#interacting-with-your-canister-from-the-command-line">Interacting with your canister from the command line</a></h3>
<p>Once we've deployed we can ask for our message:</p>
<pre><code class="language-bash">dfx canister call azle_hello_world getMessage
</code></pre>
<p>We should see <code>(&quot;&quot;)</code> representing an empty message.</p>
<p>Now let's yell <code>Hello World!</code>:</p>
<pre><code class="language-bash">dfx canister call azle_hello_world setMessage '(&quot;Hello World!&quot;)'
</code></pre>
<p>Retrieve the message:</p>
<pre><code class="language-bash">dfx canister call azle_hello_world getMessage
</code></pre>
<p>We should see <code>(&quot;Hello World!&quot;)</code>.</p>
<h3 id="interacting-with-your-canister-from-the-web-ui"><a class="header" href="#interacting-with-your-canister-from-the-web-ui">Interacting with your canister from the web UI</a></h3>
<p>After deploying your canister, you should see output similar to the following in your terminal:</p>
<pre><code class="language-bash">Deployed canisters.
URLs:
  Backend canister via Candid interface:
    azle_hello_world: http://127.0.0.1:8000/?canisterId=ryjl3-tyaaa-aaaaa-aaaba-cai&amp;id=rrkah-fqaaa-aaaaa-aaaaq-cai
</code></pre>
<p>Open up <a href="http://127.0.0.1:8000/?canisterId=ryjl3-tyaaa-aaaaa-aaaba-cai&amp;id=rrkah-fqaaa-aaaaa-aaaaq-cai">http://127.0.0.1:8000/?canisterId=ryjl3-tyaaa-aaaaa-aaaba-cai&amp;id=rrkah-fqaaa-aaaaa-aaaaq-cai</a> or the equivalent URL from your terminal to access the web UI and interact with your canister.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment-3"><a class="header" href="#deployment-3">Deployment</a></h1>
<ul>
<li><a href="deployment_candid_based.html#starting-the-local-replica">Starting the local replica</a></li>
<li><a href="deployment_candid_based.html#deploying-to-the-local-replica">Deploying to the local replica</a></li>
<li><a href="deployment_candid_based.html#interacting-with-your-canister">Interacting with your canister</a></li>
<li><a href="deployment_candid_based.html#deploying-to-mainnet">Deploying to mainnet</a></li>
<li><a href="deployment_candid_based.html#common-deployment-issues">Common deployment issues</a></li>
</ul>
<p>There are two main Internet Computer (IC) environments that you will generally interact with: the local replica and mainnet.</p>
<p>When developing on your local machine, our recommended flow is to start up a local replica in your project's root directoy and then deploy to it for local testing.</p>
<h2 id="starting-the-local-replica-1"><a class="header" href="#starting-the-local-replica-1">Starting the local replica</a></h2>
<p>Open a terminal and navigate to your project's root directory:</p>
<pre><code class="language-bash">dfx start
</code></pre>
<p>Alternatively you can start the local replica as a background process:</p>
<pre><code class="language-bash">dfx start --background
</code></pre>
<p>If you want to stop a local replica running in the background:</p>
<pre><code class="language-bash">dfx stop
</code></pre>
<p>If you ever see this error after <code>dfx stop</code>:</p>
<pre><code class="language-bash">Error: Failed to kill all processes.  Remaining: 627221 626923 627260
</code></pre>
<p>Then try this:</p>
<pre><code class="language-bash">sudo kill -9 627221
sudo kill -9 626923
sudo kill -9 627260
</code></pre>
<p>If your replica starts behaving strangely, we recommend starting the replica clean, which will clean the <code>dfx</code> state of your project:</p>
<pre><code class="language-bash">dfx start --clean
</code></pre>
<h2 id="deploying-to-the-local-replica-1"><a class="header" href="#deploying-to-the-local-replica-1">Deploying to the local replica</a></h2>
<p>To deploy all canisters defined in your <code>dfx.json</code>:</p>
<pre><code class="language-bash">dfx deploy
</code></pre>
<p>To deploy an individual canister:</p>
<pre><code class="language-bash">dfx deploy canister_name
</code></pre>
<h2 id="interacting-with-your-canister-1"><a class="header" href="#interacting-with-your-canister-1">Interacting with your canister</a></h2>
<p>As a developer you can generally interact with your canister in three ways:</p>
<ul>
<li><a href="deployment_candid_based.html#dfx-command-line">dfx command line</a></li>
<li><a href="deployment_candid_based.html#dfx-web-ui">dfx web UI</a></li>
<li><a href="deployment_candid_based.html#dfinityagent">@dfinity/agent</a></li>
</ul>
<h3 id="dfx-command-line"><a class="header" href="#dfx-command-line">dfx command line</a></h3>
<p>You can see a more complete reference <a href="https://internetcomputer.org/docs/current/references/cli-reference/">here</a>.</p>
<p>The commands you are likely to use most frequently are:</p>
<pre><code class="language-bash"># assume a canister named my_canister

# builds and deploys all canisters specified in dfx.json
dfx deploy

# builds all canisters specified in dfx.json
dfx build

# builds and deploys my_canister
dfx deploy my_canister

# builds my_canister
dfx build my_canister

# removes the Wasm binary and state of my_canister
dfx uninstall-code my_canister

# calls the methodName method on my_canister with a string argument
dfx canister call my_canister methodName '(&quot;This is a Candid string argument&quot;)'
</code></pre>
<h3 id="dfx-web-ui"><a class="header" href="#dfx-web-ui">dfx web UI</a></h3>
<p>After deploying your canister, you should see output similar to the following in your terminal:</p>
<pre><code class="language-bash">Deployed canisters.
URLs:
  Backend canister via Candid interface:
    my_canister: http://127.0.0.1:8000/?canisterId=ryjl3-tyaaa-aaaaa-aaaba-cai&amp;id=rrkah-fqaaa-aaaaa-aaaaq-cai
</code></pre>
<p>Open up <a href="http://127.0.0.1:8000/?canisterId=ryjl3-tyaaa-aaaaa-aaaba-cai&amp;id=rrkah-fqaaa-aaaaa-aaaaq-cai">http://127.0.0.1:8000/?canisterId=ryjl3-tyaaa-aaaaa-aaaba-cai&amp;id=rrkah-fqaaa-aaaaa-aaaaq-cai</a> to access the web UI.</p>
<h3 id="dfinityagent"><a class="header" href="#dfinityagent">@dfinity/agent</a></h3>
<p><a href="https://www.npmjs.com/package/@dfinity/agent">@dfinity/agent</a> is the TypeScript/JavaScript client library for interacting with canisters on the IC. If you are building a client web application, this is probably what you'll want to use.</p>
<p>There are other agents for other languages as well:</p>
<ul>
<li><a href="https://github.com/ic4j/ic4j-agent">Java</a></li>
<li><a href="https://github.com/rocklabs-io/ic-py">Python</a></li>
<li><a href="https://crates.io/crates/ic-agent">Rust</a></li>
</ul>
<h2 id="deploying-to-mainnet-1"><a class="header" href="#deploying-to-mainnet-1">Deploying to mainnet</a></h2>
<p>Assuming you are <a href="https://internetcomputer.org/docs/current/developer-docs/setup/cycles/">setup with cycles</a>, then you are ready to deploy to mainnet.</p>
<p>To deploy all canisters defined in your dfx.json:</p>
<pre><code class="language-bash">dfx deploy --network ic
</code></pre>
<p>To deploy an individual canister:</p>
<pre><code class="language-bash">dfx deploy --network ic canister_name
</code></pre>
<h2 id="common-deployment-issues-1"><a class="header" href="#common-deployment-issues-1">Common deployment issues</a></h2>
<p>If you run into an error during deployment, try the following:</p>
<ol>
<li>Ensure that you have followed the instructions correctly in <a href="./installation.html">the installation chapter</a>, especially noting <a href="./installation.html#build-dependencies">the build dependencies</a></li>
<li>Start the whole deployment process from scratch by running the following commands: <code>dfx stop</code> or simply terminate <code>dfx</code> in your terminal, <code>dfx start --clean</code>, <code>npx azle clean</code>, <code>dfx deploy</code></li>
<li>Look for more error output by adding the <code>AZLE_VERBOSE=true</code> environment variable into the same process that runs <code>dfx deploy</code></li>
<li>Look for errors in each of the files in <code>~/.config/azle/rust/[rust_version]/logs</code></li>
<li>Reach out in <a href="https://discord.gg/5Hb6rM2QUM">the Discord channel</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>
<p>Azle has many example projects showing nearly all Azle APIs. They can be found in the <a href="https://github.com/demergent-labs/azle/tree/main/examples">examples directory</a> of the <a href="https://github.com/demergent-labs/azle">Azle GitHub repository</a>.</p>
<p>We'll highlight a few of them and some others here:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/query">Query</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/update">Update</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/primitive_types">Primitive Types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable_structures">Stable Structures</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">Cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cross_canister_calls">Cross Canister Calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">Management Canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">Outgoing HTTP Requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">Incoming HTTP Requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/pre_and_post_upgrade">Pre and Post Upgrade</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">Timers</a></li>
<li><a href="https://github.com/demergent-labs/multisig_vault">Multisig Vault</a></li>
<li><a href="https://github.com/demergent-labs/ICRC-1">ICRC-1</a></li>
<li><a href="https://github.com/demergent-labs/ic_chainlink_data_feeds">IC Chainlink Data Feeds</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/basic_bitcoin">Bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ckbtc">ckBTC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-methods"><a class="header" href="#query-methods">Query Methods</a></h1>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<ul>
<li>Created with the <code>query</code> function</li>
<li>Read-only</li>
<li>Executed on a single node</li>
<li>No consensus</li>
<li>Latency on the order of ~100 milliseconds</li>
<li><a href="https://internetcomputer.org/docs/current/developer-docs/production/instruction-limits">5 billion Wasm instruction limit</a></li>
<li>4 GiB heap limit</li>
<li><a href="https://forum.dfinity.org/t/what-is-the-theroretical-number-for-txns-per-second-on-internet-computer-right-now/14039/6">~32k queries per second per canister</a></li>
</ul>
<p>The most basic way to expose your canister's functionality publicly is through a query method. Here's an example of a simple query method named <code>getString</code>:</p>
<pre><code class="language-typescript">import { Canister, query, text } from 'azle/experimental';

export default Canister({
    getString: query([], text, () =&gt; {
        return 'This is a query method!';
    })
});
</code></pre>
<p>Query methods are defined inside of a call to <code>Canister</code> using the <code>query</code> function.</p>
<p>The first parameter to <code>query</code> is an array of <code>CandidType</code> objects that will be used to decode the Candid bytes of the arguments sent from the client when calling your query method.</p>
<p>The second parameter to <code>query</code> is a <code>CandidType</code> object used to encode the return value of your function to Candid bytes to then be sent back to the client.</p>
<p>The third parameter to <code>query</code> is the function that receives the decoded arguments, performs some computation, and then returns a value to be encoded. The TypeScript signature of this function (parameter and return types) will be inferred from the <code>CandidType</code> arguments in the first and second parameters to <code>query</code>.</p>
<p><code>getString</code> can be called from the outside world through the IC's HTTP API. You'll usually invoke this API from the <a href="./deployment.html#interacting-with-your-canister"><code>dfx command line</code>, <code>dfx web UI</code>, or an agent</a>.</p>
<p>From the <code>dfx command line</code> you can call it like this:</p>
<pre><code class="language-bash">dfx canister call my_canister getString
</code></pre>
<p>Query methods are read-only. They do not persist any state changes. Take a look at the following example:</p>
<pre><code class="language-typescript">import { Canister, query, text, Void } from 'azle/experimental';

let db: {
    [key: string]: string;
} = {};

export default Canister({
    set: query([text, text], Void, (key, value) =&gt; {
        db[key] = value;
    })
});
</code></pre>
<p>Calling <code>set</code> will perform the operation of setting the <code>key</code> property on the <code>db</code> object to <code>value</code>, but after the call finishes that change will be discarded.</p>
<p>This is because query methods are executed on a single node machine and do not go through <a href="https://internetcomputer.org/how-it-works/consensus/">consensus</a>. This results in lower latencies, perhaps on the order of 100 milliseconds.</p>
<p>There is a limit to how much computation can be done in a single call to a query method. The current query call limit is <a href="https://internetcomputer.org/docs/current/developer-docs/production/instruction-limits">5 billion Wasm instructions</a>. Here's an example of a query method that runs the risk of reaching the limit:</p>
<pre><code class="language-typescript">import { Canister, nat32, query, text } from 'azle/experimental';

export default Canister({
    pyramid: query([nat32], text, (levels) =&gt; {
        return new Array(levels).fill(0).reduce((acc, _, index) =&gt; {
            const asterisks = new Array(index + 1).fill('*').join('');
            return `${acc}${asterisks}\n`;
        }, '');
    })
});
</code></pre>
<p>From the <code>dfx command line</code> you can call <code>pyramid</code> like this:</p>
<pre><code class="language-bash">dfx canister call my_canister pyramid '(1_000)'
</code></pre>
<p>With an argument of <code>1_000</code>, <code>pyramid</code> will fail with an error <code>...exceeded the instruction limit for single message execution</code>.</p>
<p>Keep in mind that each query method invocation has up to 4 GiB of heap available.</p>
<p>In terms of query scalability, an individual canister <a href="https://forum.dfinity.org/t/what-is-the-theroretical-number-for-txns-per-second-on-internet-computer-right-now/14039/6">likely has an upper bound of ~36k queries per second</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-methods"><a class="header" href="#update-methods">Update Methods</a></h1>
<h2 id="tldr-1"><a class="header" href="#tldr-1">TL;DR</a></h2>
<ul>
<li>Created with the <code>update</code> function</li>
<li>Read-write</li>
<li>Executed on many nodes</li>
<li>Consensus</li>
<li>Latency ~2-5 seconds</li>
<li><a href="https://internetcomputer.org/docs/current/developer-docs/production/instruction-limits">20 billion Wasm instruction limit</a></li>
<li>4 GiB heap limit</li>
<li>96 GiB stable memory limit</li>
<li><a href="https://forum.dfinity.org/t/what-is-the-theroretical-number-for-txns-per-second-on-internet-computer-right-now/14039/6">~900 updates per second per canister</a></li>
</ul>
<p>Update methods are similar to query methods, but state changes can be persisted. Here's an example of a simple update method:</p>
<pre><code class="language-typescript">import { Canister, nat64, update } from 'azle/experimental';

let counter = 0n;

export default Canister({
    increment: update([], nat64, () =&gt; {
        return counter++;
    })
});
</code></pre>
<p>Calling <code>increment</code> will return the current value of <code>counter</code> and then increase its value by 1. Because <code>counter</code> is a global variable, the change will be persisted to the heap, and subsequent query and update calls will have access to the new <code>counter</code> value.</p>
<p>Because the Internet Computer (IC) persists changes with certain fault tolerance guarantees, update calls are executed on many nodes and go through <a href="https://internetcomputer.org/how-it-works/consensus/">consensus</a>. This leads to latencies of ~2-5 seconds per update call.</p>
<p>Due to the latency and other expenses involved with update methods, it is best to use them only when necessary. Look at the following example:</p>
<pre><code class="language-typescript">import { Canister, query, text, update, Void } from 'azle/experimental';

let message = '';

export default Canister({
    getMessage: query([], text, () =&gt; {
        return message;
    }),
    setMessage: update([text], Void, (newMessage) =&gt; {
        message = newMessage;
    })
});
</code></pre>
<p>You'll notice that we use an update method, <code>setMessage</code>, only to perform the change to the global <code>message</code> variable. We use <code>getMessage</code>, a query method, to read the message.</p>
<p>Keep in mind that the heap is limited to 4 GiB, and thus there is an upper bound to global variable storage capacity. You can imagine how a simple database like the following would eventually run out of memory with too many entries:</p>
<pre><code class="language-typescript">import {
    Canister,
    None,
    Opt,
    query,
    Some,
    text,
    update,
    Void
} from 'azle/experimental';

type Db = {
    [key: string]: string;
};

let db: Db = {};

export default Canister({
    get: query([text], Opt(text), (key) =&gt; {
        const value = db[key];
        return value !== undefined ? Some(value) : None;
    }),
    set: update([text, text], Void, (key, value) =&gt; {
        db[key] = value;
    })
});
</code></pre>
<p>If you need more than 4 GiB of storage, consider taking advantage of the 96 GiB of stable memory. Stable structures like <code>StableBTreeMap</code> give you a nice API for interacting with stable memory. These data structures will be <a href="./stable_structures.html">covered in more detail later</a>. Here's a simple example:</p>
<pre><code class="language-typescript">import {
    Canister,
    Opt,
    query,
    StableBTreeMap,
    text,
    update,
    Void
} from 'azle/experimental';

let db = StableBTreeMap&lt;text, text&gt;(0);

export default Canister({
    get: query([text], Opt(text), (key) =&gt; {
        return db.get(key);
    }),
    set: update([text, text], Void, (key, value) =&gt; {
        db.insert(key, value);
    })
});
</code></pre>
<p>So far we have only seen how state changes can be persisted. State changes can also be discarded by implicit or explicit traps. A trap is an immediate stop to execution with the ability to provide a message to the execution environment.</p>
<p>Traps can be useful for ensuring that multiple operations are either all completed or all disregarded, or in other words atomic. Keep in mind that these guarantees do not hold once cross-canister calls are introduced, but that's a more advanced topic <a href="./cross_canister.html">covered later</a>.</p>
<p>Here's an example of how to trap and ensure atomic changes to your database:</p>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    Opt,
    query,
    Record,
    StableBTreeMap,
    text,
    update,
    Vec,
    Void
} from 'azle/experimental';

const Entry = Record({
    key: text,
    value: text
});

let db = StableBTreeMap&lt;text, text&gt;(0);

export default Canister({
    get: query([text], Opt(text), (key) =&gt; {
        return db.get(key);
    }),
    set: update([text, text], Void, (key, value) =&gt; {
        db.insert(key, value);
    }),
    setMany: update([Vec(Entry)], Void, (entries) =&gt; {
        entries.forEach((entry) =&gt; {
            if (entry.key === 'trap') {
                ic.trap('explicit trap');
            }

            db.insert(entry.key, entry.value);
        });
    })
});
</code></pre>
<p>In addition to <code>ic.trap</code>, an explicit JavaScript <code>throw</code> or any unhandled exception will also trap.</p>
<p>There is a limit to how much computation can be done in a single call to an update method. The current update call limit is <a href="https://internetcomputer.org/docs/current/developer-docs/production/instruction-limits">20 billion Wasm instructions</a>. If we modify our database example, we can introduce an update method that runs the risk of reaching the limit:</p>
<pre><code class="language-typescript">import {
    Canister,
    nat64,
    Opt,
    query,
    StableBTreeMap,
    text,
    update,
    Void
} from 'azle/experimental';

let db = StableBTreeMap&lt;text, text&gt;(0);

export default Canister({
    get: query([text], Opt(text), (key) =&gt; {
        return db.get(key);
    }),
    set: update([text, text], Void, (key, value) =&gt; {
        db.insert(key, value);
    }),
    setMany: update([nat64], Void, (numEntries) =&gt; {
        for (let i = 0; i &lt; numEntries; i++) {
            db.insert(i.toString(), i.toString());
        }
    })
});
</code></pre>
<p>From the <code>dfx command line</code> you can call <code>setMany</code> like this:</p>
<pre><code class="language-bash">dfx canister call my_canister setMany '(10_000)'
</code></pre>
<p>With an argument of <code>10_000</code>, <code>setMany</code> will fail with an error <code>...exceeded the instruction limit for single message execution</code>.</p>
<p>In terms of update scalability, an individual canister <a href="https://forum.dfinity.org/t/what-is-the-theroretical-number-for-txns-per-second-on-internet-computer-right-now/14039/6">likely has an upper bound of ~900 updates per second</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid"><a class="header" href="#candid">Candid</a></h1>
<ul>
<li><a href="./reference/candid/text.html">text</a></li>
<li><a href="./reference/candid/blob.html">blob</a></li>
<li><a href="./reference/candid/nat.html">nat</a></li>
<li><a href="./reference/candid/nat8.html">nat8</a></li>
<li><a href="./reference/candid/nat16.html">nat16</a></li>
<li><a href="./reference/candid/nat32.html">nat32</a></li>
<li><a href="./reference/candid/nat64.html">nat64</a></li>
<li><a href="./reference/candid/int.html">int</a></li>
<li><a href="./reference/candid/int8.html">int8</a></li>
<li><a href="./reference/candid/int16.html">int16</a></li>
<li><a href="./reference/candid/int32.html">int32</a></li>
<li><a href="./reference/candid/int64.html">int64</a></li>
<li><a href="./reference/candid/float32.html">float32</a></li>
<li><a href="./reference/candid/float64.html">float64</a></li>
<li><a href="./reference/candid/bool.html">bool</a></li>
<li><a href="./reference/candid/null.html">null</a></li>
<li><a href="./reference/candid/vec.html">vec</a></li>
<li><a href="./reference/candid/opt.html">opt</a></li>
<li><a href="./reference/candid/record.html">record</a></li>
<li><a href="./reference/candid/variant.html">variant</a></li>
<li><a href="./reference/candid/func.html">func</a></li>
<li><a href="./reference/candid/service.html">service</a></li>
<li><a href="./reference/candid/principal.html">principal</a></li>
<li><a href="./reference/candid/reserved.html">reserved</a></li>
<li><a href="./reference/candid/empty.html">empty</a></li>
</ul>
<p><a href="https://internetcomputer.org/docs/current/developer-docs/backend/candid/">Candid</a> is an interface description language created by <a href="https://dfinity.org/">DFINITY</a>. It can be used to define interfaces between services (canisters), allowing canisters and clients written in various languages to easily interact with each other. This interaction occurs through the serialization/encoding and deserialization/decoding of runtime values to and from Candid bytes.</p>
<p>Azle performs automatic encoding and decoding of JavaScript values to and from Candid bytes through the use of various <code>CandidType</code> objects. For example, <code>CandidType</code> objects are used when defining the parameter and return types of your query and update methods. They are also used to define the keys and values of a <code>StableBTreeMap</code>.</p>
<p>It's important to note that the <code>CandidType</code> objects decode Candid bytes into specific JavaScript runtime data structures that may differ in behavior from the description of the actual Candid type. For example, a <code>float32</code> Candid type is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a>, a <code>nat64</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">JavaScript BigInt</a>, and an <code>int</code> is also a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">JavaScript BigInt</a>.</p>
<p>Keep this in mind as it may result in unexpected behavior. Each <code>CandidType</code> object and its equivalent JavaScript runtime value is explained in more detail in <a href="./reference/candid/candid.html">The Azle Book Candid reference</a>.</p>
<p>A more canonical reference of all Candid types available on the Internet Computer (IC) can be found <a href="https://internetcomputer.org/docs/current/references/candid-ref">here</a>.</p>
<p>The following is a simple example showing how to import and use many of the <code>CandidType</code> objects available in Azle:</p>
<pre><code class="language-typescript">import {
    blob,
    bool,
    Canister,
    float32,
    float64,
    Func,
    int,
    int16,
    int32,
    int64,
    int8,
    nat,
    nat16,
    nat32,
    nat64,
    nat8,
    None,
    Null,
    Opt,
    Principal,
    query,
    Record,
    Recursive,
    text,
    update,
    Variant,
    Vec
} from 'azle/experimental';

const MyCanister = Canister({
    query: query([], bool),
    update: update([], text)
});

const Candid = Record({
    text: text,
    blob: blob,
    nat: nat,
    nat64: nat64,
    nat32: nat32,
    nat16: nat16,
    nat8: nat8,
    int: int,
    int64: int64,
    int32: int32,
    int16: int16,
    int8: int8,
    float64: float64,
    float32: float32,
    bool: bool,
    null: Null,
    vec: Vec(text),
    opt: Opt(nat),
    record: Record({
        firstName: text,
        lastName: text,
        age: nat8
    }),
    variant: Variant({
        Tag1: Null,
        Tag2: Null,
        Tag3: int
    }),
    func: Recursive(() =&gt; Func([], Candid, 'query')),
    canister: Canister({
        query: query([], bool),
        update: update([], text)
    }),
    principal: Principal
});

export default Canister({
    candidTypes: query([], Candid, () =&gt; {
        return {
            text: 'text',
            blob: Uint8Array.from([]),
            nat: 340_282_366_920_938_463_463_374_607_431_768_211_455n,
            nat64: 18_446_744_073_709_551_615n,
            nat32: 4_294_967_295,
            nat16: 65_535,
            nat8: 255,
            int: 170_141_183_460_469_231_731_687_303_715_884_105_727n,
            int64: 9_223_372_036_854_775_807n,
            int32: 2_147_483_647,
            int16: 32_767,
            int8: 127,
            float64: Math.E,
            float32: Math.PI,
            bool: true,
            null: null,
            vec: ['has one element'],
            opt: None,
            record: {
                firstName: 'John',
                lastName: 'Doe',
                age: 35
            },
            variant: {
                Tag1: null
            },
            func: [
                Principal.fromText('rrkah-fqaaa-aaaaa-aaaaq-cai'),
                'candidTypes'
            ],
            canister: MyCanister(Principal.fromText('aaaaa-aa')),
            principal: Principal.fromText('ryjl3-tyaaa-aaaaa-aaaba-cai')
        };
    })
});
</code></pre>
<p>Calling <code>candidTypes</code> with <code>dfx</code> will return:</p>
<pre><code>(
  record {
    func = func &quot;rrkah-fqaaa-aaaaa-aaaaq-cai&quot;.candidTypes;
    text = &quot;text&quot;;
    nat16 = 65_535 : nat16;
    nat32 = 4_294_967_295 : nat32;
    nat64 = 18_446_744_073_709_551_615 : nat64;
    record = record { age = 35 : nat8; lastName = &quot;Doe&quot;; firstName = &quot;John&quot; };
    int = 170_141_183_460_469_231_731_687_303_715_884_105_727 : int;
    nat = 340_282_366_920_938_463_463_374_607_431_768_211_455 : nat;
    opt = null;
    vec = vec { &quot;has one element&quot; };
    variant = variant { Tag1 };
    nat8 = 255 : nat8;
    canister = service &quot;aaaaa-aa&quot;;
    int16 = 32_767 : int16;
    int32 = 2_147_483_647 : int32;
    int64 = 9_223_372_036_854_775_807 : int64;
    null = null : null;
    blob = vec {};
    bool = true;
    principal = principal &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;;
    int8 = 127 : int8;
    float32 = 3.1415927 : float32;
    float64 = 2.718281828459045 : float64;
  },
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stable-structures"><a class="header" href="#stable-structures">Stable Structures</a></h1>
<h2 id="tldr-2"><a class="header" href="#tldr-2">TL;DR</a></h2>
<ul>
<li>96 GiB of stable memory</li>
<li>Persistent across upgrades</li>
<li>Familiar API</li>
<li>Must specify memory id</li>
<li>No migrations per memory id</li>
</ul>
<p>Stable structures are data structures with familiar APIs that allow write and read access to stable memory. Stable memory is a separate memory location from the heap that currently allows up to 96 GiB of binary storage. Stable memory persists automatically across upgrades.</p>
<p>Persistence on the Internet Computer (IC) is very important to understand. When a canister is upgraded (its code is changed after being initially deployed) its heap is wiped. This includes all global variables.</p>
<p>On the other hand, anything stored in stable memory will be preserved. Writing and reading to and from stable memory can be done with a <a href="./reference/stable_memory/stable_memory.html">low-level API</a>, but it is generally easier and preferable to use stable structures.</p>
<p>Azle currently provides one stable structure called <code>StableBTreeMap</code>. It's similar to a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">JavaScript Map</a> and has most of the common operations you'd expect such as reading, inserting, and removing values.</p>
<p>Here's how to define a simple <code>StableBTreeMap</code>:</p>
<pre><code class="language-typescript">import { nat8, StableBTreeMap, text } from 'azle/experimental';

let map = StableBTreeMap&lt;nat8, text&gt;(0);
</code></pre>
<p>This is a <code>StableBTreeMap</code> with a key of type <code>nat8</code> and a value of type <code>text</code>. Unless you want a default type of <code>any</code> for your <code>key</code> and <code>value</code>, then you must explicitly type your <code>StableBTreeMap</code> with type arguments.</p>
<p><code>StableBTreeMap</code> works by encoding and decoding values under-the-hood, storing and retrieving these values in bytes in stable memory. When writing to and reading from a <code>StableBTreeMap</code>, by default the <code>stableJson</code> <code>Serializable object</code> is used to encode JS values into bytes and to decode JS values from bytes. <code>stableJson</code> uses <code>JSON.stringify</code> and <code>JSON.parse</code> with a custom <code>replacer</code> and <code>reviver</code> to handle many <code>Candid</code> and other values that you will most likely use in your canisters.</p>
<p>You may use other <code>Serializable objects</code> besides <code>stableJson</code>, and you can even create your own. Simply pass in a <code>Serializable object</code> as the second and third parameters to your <code>StableBTreeMap</code>. The second parameter is the <code>key</code> <code>Serializable object</code> and the third parameter is the <code>value</code> <code>Serializable object</code>. For example, the following <code>StableBTreeMap</code> uses the <code>nat8</code> and <code>text</code> <code>CandidType objects</code> from Azle as <code>Serializable objects</code>. These <code>Serializable objects</code> will encode and decode to and from Candid bytes:</p>
<pre><code class="language-typescript">import { nat8, StableBTreeMap, text } from 'azle/experimental';

let map = StableBTreeMap&lt;nat8, text&gt;(0, nat8, text);
</code></pre>
<p>All <code>CandidType</code> objects imported from <code>azle</code> are <code>Serializable objects</code>.</p>
<p>A <code>Serializable object</code> simply has a <code>toBytes</code> method that takes a JS value and returns a <code>Uint8Array</code>, and a <code>fromBytes</code> method that takes a <code>Uint8Array</code> and returns a JS value.</p>
<p>Here's an example of how to create your own simple <code>JSON</code> <code>Serializable</code>:</p>
<pre><code class="language-typescript">export interface Serializable {
    toBytes: (data: any) =&gt; Uint8Array;
    fromBytes: (bytes: Uint8Array) =&gt; any;
}

export function StableSimpleJson(): Serializable {
    return {
        toBytes(data: any) {
            const result = JSON.stringify(data);
            return Uint8Array.from(Buffer.from(result));
        },
        fromBytes(bytes: Uint8Array) {
            return JSON.parse(Buffer.from(bytes).toString());
        }
    };
}
</code></pre>
<p>This <code>StableBTreeMap</code> also has a <code>memory id</code> of <code>0</code>. Each <code>StableBTreeMap</code> instance must have a unique <code>memory id</code> between <code>0</code> and <code>254</code>. Once a <code>memory id</code> is allocated, it cannot be used with a different <code>StableBTreeMap</code>. This means you can't create another <code>StableBTreeMap</code> using the same <code>memory id</code>, and you can't change the key or value types of an existing <code>StableBTreeMap</code>. <a href="https://github.com/demergent-labs/azle/issues/843">This problem will be addressed to some extent</a>.</p>
<p>Here's an example showing all of the basic <code>StableBTreeMap</code> operations:</p>
<pre><code class="language-typescript">import {
    bool,
    Canister,
    nat64,
    nat8,
    Opt,
    query,
    StableBTreeMap,
    text,
    Tuple,
    update,
    Vec
} from 'azle/experimental';

const Key = nat8;
type Key = typeof Key.tsType;

const Value = text;
type Value = typeof Value.tsType;

let map = StableBTreeMap&lt;Key, Value&gt;(0);

export default Canister({
    containsKey: query([Key], bool, (key) =&gt; {
        return map.containsKey(key);
    }),

    get: query([Key], Opt(Value), (key) =&gt; {
        return map.get(key);
    }),

    insert: update([Key, Value], Opt(Value), (key, value) =&gt; {
        return map.insert(key, value);
    }),

    isEmpty: query([], bool, () =&gt; {
        return map.isEmpty();
    }),

    items: query([], Vec(Tuple(Key, Value)), () =&gt; {
        return map.items();
    }),

    keys: query([], Vec(Key), () =&gt; {
        return Uint8Array.from(map.keys());
    }),

    len: query([], nat64, () =&gt; {
        return map.len();
    }),

    remove: update([Key], Opt(Value), (key) =&gt; {
        return map.remove(key);
    }),

    values: query([], Vec(Value), () =&gt; {
        return map.values();
    })
});
</code></pre>
<p>With these basic operations you can build more complex CRUD database applications:</p>
<pre><code class="language-typescript">import {
    blob,
    Canister,
    ic,
    Err,
    nat64,
    Ok,
    Opt,
    Principal,
    query,
    Record,
    Result,
    StableBTreeMap,
    text,
    update,
    Variant,
    Vec
} from 'azle/experimental';

const User = Record({
    id: Principal,
    createdAt: nat64,
    recordingIds: Vec(Principal),
    username: text
});
type User = typeof User.tsType;

const Recording = Record({
    id: Principal,
    audio: blob,
    createdAt: nat64,
    name: text,
    userId: Principal
});
type Recording = typeof Recording.tsType;

const AudioRecorderError = Variant({
    RecordingDoesNotExist: Principal,
    UserDoesNotExist: Principal
});
type AudioRecorderError = typeof AudioRecorderError.tsType;

let users = StableBTreeMap&lt;Principal, User&gt;(0);
let recordings = StableBTreeMap&lt;Principal, Recording&gt;(1);

export default Canister({
    createUser: update([text], User, (username) =&gt; {
        const id = generateId();
        const user: User = {
            id,
            createdAt: ic.time(),
            recordingIds: [],
            username
        };

        users.insert(user.id, user);

        return user;
    }),
    readUsers: query([], Vec(User), () =&gt; {
        return users.values();
    }),
    readUserById: query([Principal], Opt(User), (id) =&gt; {
        return users.get(id);
    }),
    deleteUser: update([Principal], Result(User, AudioRecorderError), (id) =&gt; {
        const userOpt = users.get(id);

        if ('None' in userOpt) {
            return Err({
                UserDoesNotExist: id
            });
        }

        const user = userOpt.Some;

        user.recordingIds.forEach((recordingId) =&gt; {
            recordings.remove(recordingId);
        });

        users.remove(user.id);

        return Ok(user);
    }),
    createRecording: update(
        [blob, text, Principal],
        Result(Recording, AudioRecorderError),
        (audio, name, userId) =&gt; {
            const userOpt = users.get(userId);

            if ('None' in userOpt) {
                return Err({
                    UserDoesNotExist: userId
                });
            }

            const user = userOpt.Some;

            const id = generateId();
            const recording: Recording = {
                id,
                audio,
                createdAt: ic.time(),
                name,
                userId
            };

            recordings.insert(recording.id, recording);

            const updatedUser: User = {
                ...user,
                recordingIds: [...user.recordingIds, recording.id]
            };

            users.insert(updatedUser.id, updatedUser);

            return Ok(recording);
        }
    ),
    readRecordings: query([], Vec(Recording), () =&gt; {
        return recordings.values();
    }),
    readRecordingById: query([Principal], Opt(Recording), (id) =&gt; {
        return recordings.get(id);
    }),
    deleteRecording: update(
        [Principal],
        Result(Recording, AudioRecorderError),
        (id) =&gt; {
            const recordingOpt = recordings.get(id);

            if ('None' in recordingOpt) {
                return Err({ RecordingDoesNotExist: id });
            }

            const recording = recordingOpt.Some;

            const userOpt = users.get(recording.userId);

            if ('None' in userOpt) {
                return Err({
                    UserDoesNotExist: recording.userId
                });
            }

            const user = userOpt.Some;

            const updatedUser: User = {
                ...user,
                recordingIds: user.recordingIds.filter(
                    (recordingId) =&gt;
                        recordingId.toText() !== recording.id.toText()
                )
            };

            users.insert(updatedUser.id, updatedUser);

            recordings.remove(id);

            return Ok(recording);
        }
    )
});

function generateId(): Principal {
    const randomBytes = new Array(29)
        .fill(0)
        .map((_) =&gt; Math.floor(Math.random() * 256));

    return Principal.fromUint8Array(Uint8Array.from(randomBytes));
}
</code></pre>
<p>The example above shows a very basic audio recording backend application. There are two types of entities that need to be stored, <code>User</code> and <code>Recording</code>. These are represented as <code>Candid</code> records.</p>
<p>Each entity gets its own <code>StableBTreeMap</code>:</p>
<pre><code class="language-typescript">import {
    blob,
    Canister,
    ic,
    Err,
    nat64,
    Ok,
    Opt,
    Principal,
    query,
    Record,
    Result,
    StableBTreeMap,
    text,
    update,
    Variant,
    Vec
} from 'azle/experimental';

const User = Record({
    id: Principal,
    createdAt: nat64,
    recordingIds: Vec(Principal),
    username: text
});
type User = typeof User.tsType;

const Recording = Record({
    id: Principal,
    audio: blob,
    createdAt: nat64,
    name: text,
    userId: Principal
});
type Recording = typeof Recording.tsType;

const AudioRecorderError = Variant({
    RecordingDoesNotExist: Principal,
    UserDoesNotExist: Principal
});
type AudioRecorderError = typeof AudioRecorderError.tsType;

let users = StableBTreeMap&lt;Principal, User&gt;(0);
let recordings = StableBTreeMap&lt;Principal, Recording&gt;(1);
</code></pre>
<p>Notice that each <code>StableBTreeMap</code> has a unique <code>memory id</code>. You can begin to create basic database CRUD functionality by creating one <code>StableBTreeMap</code> per entity. It's up to you to create functionality for querying, filtering, and relations. <code>StableBTreeMap</code> is not a full-featured database solution, but a fundamental building block that may enable you to achieve more advanced database functionality.</p>
<p>Demergent Labs plans to deeply explore database solutions on the IC in the future.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<h3 id="float64-values"><a class="header" href="#float64-values">float64 values</a></h3>
<p>It seems to be only some <code>float64</code> values cannot be successfully stored and retrieved with a <code>StableBTreeMap</code> using <code>stableJson</code> because of this bug with <code>JSON.parse</code>: https://github.com/bellard/quickjs/issues/206</p>
<h3 id="candidtype-performance"><a class="header" href="#candidtype-performance">CandidType Performance</a></h3>
<p>Azle's Candid encoding/decoding implementation is currently not well optimized, and Candid may not be the most optimal encoding format overall, so you may experience heavy instruction usage when performing many <code>StableBTreeMap</code> operations in succession. A rough idea of the overhead from our preliminary testing is probably 1-2 million instructions for a full Candid encoding and decoding of values per <code>StableBTreeMap</code> operation.</p>
<p>For these reasons we recommend using the <code>stableJson</code> <code>Serializable object</code> (the default) instead of <code>CandidType</code> <code>Serializable objects</code>.</p>
<h3 id="migrations"><a class="header" href="#migrations">Migrations</a></h3>
<p>Migrations must be performed manually by reading the values out of one <code>StableBTreeMap</code> and writing them into another. Once a <code>StableBTreeMap</code> is initialized to a specific <code>memory id</code>, that <code>memory id</code> cannot be changed unless the canister is completely wiped and initialized again.</p>
<h3 id="canister"><a class="header" href="#canister">Canister</a></h3>
<p><code>Canister</code> values do not currently work with the default <code>stableJson</code> implementation. If you must persist <code>Canister</code>s, consider using the <code>Canister</code> <code>CandidType object</code> as your <code>Serializable object</code> in your <code>StableBTreeMap</code>, or create a custom <code>replacer</code> or <code>reviver</code> for <code>stableJson</code> that handles <code>Canister</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-canister"><a class="header" href="#cross-canister">Cross-canister</a></h1>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/async_await">async_await</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/composite_queries">composite_queries</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cross_canister_calls">cross_canister_calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/func_types">func_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/heartbeat">heartbeat</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/inline_types">inline_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ledger_canister">ledger_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/rejections">rejections</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">timers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/tuple_types">tuple_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/whoami">whoami</a></li>
</ul>
<p>Canisters are generally able to call the query or update methods of other canisters in any subnet. We refer to these types of calls as cross-canister calls.</p>
<p>A cross-canister call begins with a definition of the canister to be called.</p>
<p>Imagine a simple canister called <code>token_canister</code>:</p>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    nat64,
    Opt,
    Principal,
    StableBTreeMap,
    update
} from 'azle/experimental';

let accounts = StableBTreeMap&lt;Principal, nat64&gt;(0);

export default Canister({
    transfer: update([Principal, nat64], nat64, (to, amount) =&gt; {
        const from = ic.caller();

        const fromBalance = getBalance(accounts.get(from));
        const toBalance = getBalance(accounts.get(to));

        accounts.insert(from, fromBalance - amount);
        accounts.insert(to, toBalance + amount);

        return amount;
    })
});

function getBalance(accountOpt: Opt&lt;nat64&gt;): nat64 {
    if ('None' in accountOpt) {
        return 0n;
    } else {
        return accountOpt.Some;
    }
}
</code></pre>
<p>Now that you have the canister definition, you can import and instantiate it in another canister:</p>
<pre><code class="language-typescript">import { Canister, ic, nat64, Principal, update } from 'azle/experimental';
import TokenCanister from './token_canister';

const tokenCanister = TokenCanister(
    Principal.fromText('r7inp-6aaaa-aaaaa-aaabq-cai')
);

export default Canister({
    payout: update([Principal, nat64], nat64, async (to, amount) =&gt; {
        return await ic.call(tokenCanister.transfer, {
            args: [to, amount]
        });
    })
});
</code></pre>
<p>If you don't have the actual definition of the token canister with the canister method implementations, you can always create your own canister definition without method implementations:</p>
<pre><code class="language-typescript">import { Canister, ic, nat64, Principal, update } from 'azle/experimental';

const TokenCanister = Canister({
    transfer: update([Principal, nat64], nat64)
});

const tokenCanister = TokenCanister(
    Principal.fromText('r7inp-6aaaa-aaaaa-aaabq-cai')
);

export default Canister({
    payout: update([Principal, nat64], nat64, async (to, amount) =&gt; {
        return await ic.call(tokenCanister.transfer, {
            args: [to, amount]
        });
    })
});
</code></pre>
<p>The IC guarantees that cross-canister calls will return. This means that, generally speaking, you will always receive a response from <code>ic.call</code>. If there are errors during the call, <code>ic.call</code> will throw. Wrapping your cross-canister call in a <code>try...catch</code> allows you to handle these errors.</p>
<p>Let's add to our example code and explore adding some practical error-handling to stop people from stealing tokens.</p>
<p><code>token_canister</code>:</p>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    nat64,
    Opt,
    Principal,
    StableBTreeMap,
    update
} from 'azle/experimental';

let accounts = StableBTreeMap&lt;Principal, nat64&gt;(0);

export default Canister({
    transfer: update([Principal, nat64], nat64, (to, amount) =&gt; {
        const from = ic.caller();

        const fromBalance = getBalance(accounts.get(from));

        if (amount &gt; fromBalance) {
            throw new Error(`${from} has an insufficient balance`);
        }

        const toBalance = getBalance(accounts.get(to));

        accounts.insert(from, fromBalance - amount);
        accounts.insert(to, toBalance + amount);

        return amount;
    })
});

function getBalance(accountOpt: Opt&lt;nat64&gt;): nat64 {
    if ('None' in accountOpt) {
        return 0n;
    } else {
        return accountOpt.Some;
    }
}
</code></pre>
<p><code>payout_canister</code>:</p>
<pre><code class="language-typescript">import { Canister, ic, nat64, Principal, update } from 'azle/experimental';
import TokenCanister from './index';

const tokenCanister = TokenCanister(
    Principal.fromText('bkyz2-fmaaa-aaaaa-qaaaq-cai')
);

export default Canister({
    payout: update([Principal, nat64], nat64, async (to, amount) =&gt; {
        try {
            return await ic.call(tokenCanister.transfer, {
                args: [to, amount]
            });
        } catch (error) {
            console.log(error);
        }

        return 0n;
    })
});
</code></pre>
<p>Throwing will allow you to express error conditions and halt execution, but you may find embracing the <code>Result</code> variant as a better solution for error handling because of its composability and predictability.</p>
<p>So far we have only shown a cross-canister call from an update method. Update methods can call other update methods or query methods (but not composite query methods as discussed below). If an update method calls a query method, that query method will be called in replicated mode. Replicated mode engages the consensus process, but for queries the state will still be discarded.</p>
<p>Cross-canister calls can also be initiated from query methods. These are known as composite queries, and in Azle they are simply <code>async</code> query methods. Composite queries can call other composite query methods and regular query methods. Composite queries cannot call update methods.</p>
<p>Here's an example of a composite query method:</p>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, query } from 'azle/experimental';

const SomeCanister = Canister({
    queryForBoolean: query([], bool)
});

const someCanister = SomeCanister(
    Principal.fromText('ryjl3-tyaaa-aaaaa-aaaba-cai')
);

export default Canister({
    querySomeCanister: query([], bool, async () =&gt; {
        return await ic.call(someCanister.queryForBoolean);
    })
});
</code></pre>
<p>You can expect cross-canister calls within the same subnet to take up to a few seconds to complete, and cross-canister calls across subnets <a href="https://forum.dfinity.org/t/can-i-run-multiple-inter-canister-update-calls-in-parallel/13115/6">take about double that time</a>. Composite queries should be much faster, similar to query calls in latency.</p>
<p>If you don't need to wait for your cross-canister call to return, you can use <code>notify</code>:</p>
<pre><code class="language-typescript">import { Canister, ic, Principal, update, Void } from 'azle/experimental';

const SomeCanister = Canister({
    receiveNotification: update([], Void)
});

const someCanister = SomeCanister(
    Principal.fromText('ryjl3-tyaaa-aaaaa-aaaba-cai')
);

export default Canister({
    sendNotification: update([], Void, () =&gt; {
        return ic.notify(someCanister.receiveNotification);
    })
});
</code></pre>
<p>If you need to send cycles with your cross-canister call, you can add <code>cycles</code> to the <code>config</code> object of <code>ic.notify</code>:</p>
<pre><code class="language-typescript">import { Canister, ic, Principal, update, Void } from 'azle/experimental';

const SomeCanister = Canister({
    receiveNotification: update([], Void)
});

const someCanister = SomeCanister(
    Principal.fromText('ryjl3-tyaaa-aaaaa-aaaba-cai')
);

export default Canister({
    sendNotification: update([], Void, () =&gt; {
        return ic.notify(someCanister.receiveNotification, {
            cycles: 1_000_000n
        });
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http"><a class="header" href="#http">HTTP</a></h1>
<p>This chapter is a work in progress.</p>
<h2 id="incoming-http-requests"><a class="header" href="#incoming-http-requests">Incoming HTTP requests</a></h2>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">http_counter</a></li>
</ul>
<pre><code class="language-typescript">import {
    blob,
    bool,
    Canister,
    Func,
    nat16,
    None,
    Opt,
    query,
    Record,
    text,
    Tuple,
    Variant,
    Vec
} from 'azle/experimental';

const Token = Record({
    // add whatever fields you'd like
    arbitrary_data: text
});

const StreamingCallbackHttpResponse = Record({
    body: blob,
    token: Opt(Token)
});

export const Callback = Func([text], StreamingCallbackHttpResponse, 'query');

const CallbackStrategy = Record({
    callback: Callback,
    token: Token
});

const StreamingStrategy = Variant({
    Callback: CallbackStrategy
});

type HeaderField = [text, text];
const HeaderField = Tuple(text, text);

const HttpResponse = Record({
    status_code: nat16,
    headers: Vec(HeaderField),
    body: blob,
    streaming_strategy: Opt(StreamingStrategy),
    upgrade: Opt(bool)
});

const HttpRequest = Record({
    method: text,
    url: text,
    headers: Vec(HeaderField),
    body: blob,
    certificate_version: Opt(nat16)
});

export default Canister({
    http_request: query([HttpRequest], HttpResponse, (req) =&gt; {
        return {
            status_code: 200,
            headers: [],
            body: Buffer.from('hello'),
            streaming_strategy: None,
            upgrade: None
        };
    })
});
</code></pre>
<h2 id="outgoing-http-requests"><a class="header" href="#outgoing-http-requests">Outgoing HTTP requests</a></h2>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    init,
    nat32,
    Principal,
    query,
    Some,
    StableBTreeMap,
    text,
    update
} from 'azle/experimental';
import {
    HttpResponse,
    HttpTransformArgs,
    managementCanister
} from 'azle/canisters/management';

let stableStorage = StableBTreeMap&lt;text, text&gt;(0);

export default Canister({
    init: init([text], (ethereumUrl) =&gt; {
        stableStorage.insert('ethereumUrl', ethereumUrl);
    }),
    ethGetBalance: update([text], text, async (ethereumAddress) =&gt; {
        const urlOpt = stableStorage.get('ethereumUrl');

        if ('None' in urlOpt) {
            throw new Error('ethereumUrl is not defined');
        }

        const url = urlOpt.Some;

        const httpResponse = await ic.call(managementCanister.http_request, {
            args: [
                {
                    url,
                    max_response_bytes: Some(2_000n),
                    method: {
                        post: null
                    },
                    headers: [],
                    body: Some(
                        Buffer.from(
                            JSON.stringify({
                                jsonrpc: '2.0',
                                method: 'eth_getBalance',
                                params: [ethereumAddress, 'earliest'],
                                id: 1
                            }),
                            'utf-8'
                        )
                    ),
                    transform: Some({
                        function: [ic.id(), 'ethTransform'] as [
                            Principal,
                            string
                        ],
                        context: Uint8Array.from([])
                    })
                }
            ],
            cycles: 50_000_000n
        });

        return Buffer.from(httpResponse.body.buffer).toString('utf-8');
    }),
    ethGetBlockByNumber: update([nat32], text, async (number) =&gt; {
        const urlOpt = stableStorage.get('ethereumUrl');

        if ('None' in urlOpt) {
            throw new Error('ethereumUrl is not defined');
        }

        const url = urlOpt.Some;

        const httpResponse = await ic.call(managementCanister.http_request, {
            args: [
                {
                    url,
                    max_response_bytes: Some(2_000n),
                    method: {
                        post: null
                    },
                    headers: [],
                    body: Some(
                        Buffer.from(
                            JSON.stringify({
                                jsonrpc: '2.0',
                                method: 'eth_getBlockByNumber',
                                params: [`0x${number.toString(16)}`, false],
                                id: 1
                            }),
                            'utf-8'
                        )
                    ),
                    transform: Some({
                        function: [ic.id(), 'ethTransform'] as [
                            Principal,
                            string
                        ],
                        context: Uint8Array.from([])
                    })
                }
            ],
            cycles: 50_000_000n
        });

        return Buffer.from(httpResponse.body.buffer).toString('utf-8');
    }),
    ethTransform: query([HttpTransformArgs], HttpResponse, (args) =&gt; {
        return {
            ...args.response,
            headers: []
        };
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="management-canister-1"><a class="header" href="#management-canister-1">Management Canister</a></h1>
<p>This chapter is a work in progress.</p>
<p>You can access the management canister like this:</p>
<pre><code class="language-typescript">import { blob, Canister, ic, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    randomBytes: update([], blob, async () =&gt; {
        return await ic.call(managementCanister.raw_rand);
    })
});
</code></pre>
<p>See the <a href="./reference/management_canister/management_canister.html">management canister reference section</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-lifecycle"><a class="header" href="#canister-lifecycle">Canister Lifecycle</a></h1>
<p>This chapter is a work in progress.</p>
<pre><code class="language-typescript">import { Canister, init, postUpgrade, preUpgrade } from 'azle/experimental';

export default Canister({
    init: init([], () =&gt; {
        console.log('runs on first canister install');
    }),
    preUpgrade: preUpgrade(() =&gt; {
        console.log('runs before canister upgrade');
    }),
    postUpgrade: postUpgrade([], () =&gt; {
        console.log('runs after canister upgrade');
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>This chapter is a work in progress.</p>
<pre><code class="language-typescript">import {
    blob,
    bool,
    Canister,
    Duration,
    ic,
    int8,
    query,
    Record,
    text,
    TimerId,
    update,
    Void
} from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

const StatusReport = Record({
    single: bool,
    inline: int8,
    capture: text,
    repeat: int8,
    singleCrossCanister: blob,
    repeatCrossCanister: blob
});

const TimerIds = Record({
    single: TimerId,
    inline: TimerId,
    capture: TimerId,
    repeat: TimerId,
    singleCrossCanister: TimerId,
    repeatCrossCanister: TimerId
});

let statusReport: typeof StatusReport = {
    single: false,
    inline: 0,
    capture: '',
    repeat: 0,
    singleCrossCanister: Uint8Array.from([]),
    repeatCrossCanister: Uint8Array.from([])
};

export default Canister({
    clearTimer: update([TimerId], Void, (timerId) =&gt; {
        ic.clearTimer(timerId);
        console.log(`timer ${timerId} cancelled`);
    }),
    setTimers: update([Duration, Duration], TimerIds, (delay, interval) =&gt; {
        const capturedValue = '🚩';

        const singleId = ic.setTimer(delay, oneTimeTimerCallback);

        const inlineId = ic.setTimer(delay, () =&gt; {
            statusReport.inline = 1;
            console.log('Inline timer called');
        });

        const captureId = ic.setTimer(delay, () =&gt; {
            statusReport.capture = capturedValue;
            console.log(`Timer captured value ${capturedValue}`);
        });

        const repeatId = ic.setTimerInterval(interval, () =&gt; {
            statusReport.repeat++;
            console.log(`Repeating timer. Call ${statusReport.repeat}`);
        });

        const singleCrossCanisterId = ic.setTimer(
            delay,
            singleCrossCanisterTimerCallback
        );

        const repeatCrossCanisterId = ic.setTimerInterval(
            interval,
            repeatCrossCanisterTimerCallback
        );

        return {
            single: singleId,
            inline: inlineId,
            capture: captureId,
            repeat: repeatId,
            singleCrossCanister: singleCrossCanisterId,
            repeatCrossCanister: repeatCrossCanisterId
        };
    }),
    statusReport: query([], StatusReport, () =&gt; {
        return statusReport;
    })
});

function oneTimeTimerCallback() {
    statusReport.single = true;
    console.log('oneTimeTimerCallback called');
}

async function singleCrossCanisterTimerCallback() {
    console.log('singleCrossCanisterTimerCallback');

    statusReport.singleCrossCanister = await ic.call(
        managementCanister.raw_rand
    );
}

async function repeatCrossCanisterTimerCallback() {
    console.log('repeatCrossCanisterTimerCallback');

    statusReport.repeatCrossCanister = Uint8Array.from([
        ...statusReport.repeatCrossCanister,
        ...(await ic.call(managementCanister.raw_rand))
    ]);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cycles"><a class="header" href="#cycles">Cycles</a></h1>
<p>This chapter is a work in progress.</p>
<p>Cycles are essentially units of computational resources such as bandwidth, memory, and CPU instructions. Costs are generally metered on the Internet Computer (IC) by cycles. You can see <a href="https://internetcomputer.org/docs/current/developer-docs/production/computation-and-storage-costs">a breakdown of all cycle costs here</a>.</p>
<p>Currently queries do not have any cycle costs.</p>
<p>Most important to you will probably be update costs.</p>
<p>TODO break down some cycle scenarios maybe? Perhaps we should show some of our analyses for different types of applications. Maybe show how to send and receive cycles, exactly how to do it.</p>
<p>Show all of the APIs for sending or receiving cycles?</p>
<p>Perhaps we don't need to do that here, since each API will show this information.</p>
<p>Maybe here we just show the basic concept of cycles, link to the main cycles cost page, and show a few examples of how to break down these costs or estimate these costs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caveats-1"><a class="header" href="#caveats-1">Caveats</a></h1>
<h2 id="npm-packages"><a class="header" href="#npm-packages">npm packages</a></h2>
<p>Some npm packages will work and some will not work. It is our long-term goal to support as many npm packages as possible. There are various reasons why an npm package may not currently work, including the small Wasm binary limit of the IC and unimplemented web or Node.js APIs. Feel free to open issues if your npm package does not work in Azle.</p>
<h2 id="javascript-environment-apis"><a class="header" href="#javascript-environment-apis">JavaScript environment APIs</a></h2>
<p>You may encounter various missing JavaScript environment APIs, such as those you would expect in the web or Node.js environments.</p>
<h2 id="high-candid-encodingdecoding-costs"><a class="header" href="#high-candid-encodingdecoding-costs">High Candid encoding/decoding costs</a></h2>
<p>Candid encoding/decoding is currently very unoptimized. This will most likely lead to a ~1-2 million extra fixed instruction cost for all calls. Be careful using <code>CandidType</code> <code>Serializable objects</code> with <code>StableBTreeMap</code>, or using any other API or data structure that engages in Candid encoding/decoding.</p>
<h2 id="promises"><a class="header" href="#promises">Promises</a></h2>
<p>Though promises are implemented, the underlying queue that handles asynchronous operations is very simple. This queue will not behave exactly as queues from the major JS engines.</p>
<h2 id="jsonparse-and-stablebtreemap-float64-values"><a class="header" href="#jsonparse-and-stablebtreemap-float64-values">JSON.parse and StableBTreeMap float64 values</a></h2>
<p>It seems to be only some <code>float64</code> values cannot be successfully stored and retrieved with a <code>StableBTreeMap</code> using <code>stableJson</code> because of this bug with JSON.parse: https://github.com/bellard/quickjs/issues/206</p>
<p>This will also affect stand-alone usage of <code>JSON.parse</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-1"><a class="header" href="#reference-1">Reference</a></h1>
<ul>
<li><a href="reference/./bitcoin.html">Bitcoin</a></li>
<li><a href="reference/./call_apis/call_apis.html">Call APIs</a></li>
<li><a href="reference/./candid/candid.html">Candid</a></li>
<li><a href="reference/./canister_apis/canister_apis.html">Canister APIs</a></li>
<li><a href="reference/./canister_methods/canister_methods.html">Canister Methods</a></li>
<li><a href="reference/./environment_variables.html">Environment Variables</a></li>
<li><a href="reference/./management_canister/management_canister.html">Management Canister</a></li>
<li><a href="reference/./plugins.html">Plugins</a></li>
<li><a href="reference/./stable_memory/stable_memory.html">Stable Memory</a></li>
<li><a href="reference/./timers/timers.html">Timers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-1"><a class="header" href="#bitcoin-1">Bitcoin</a></h1>
<p>The Internet Computer (IC) interacts with the Bitcoin blockchain through the use of <code>tECDSA</code>, the <code>Bitcoin integration</code>, and a ledger canister called <code>ckBTC</code>.</p>
<h2 id="tecdsa"><a class="header" href="#tecdsa">tECDSA</a></h2>
<p><code>tECDSA</code> on the IC allows canisters to request access to threshold ECDSA keypairs on the <code>tECDSA</code> subnet. This functionality is exposed through two management canister methods:</p>
<ul>
<li><a href="reference/./management_canister/ecdsa_public_key.html">ecdsa_public_key</a></li>
<li><a href="reference/./management_canister/sign_with_ecdsa.html">sign_with_ecdsa</a></li>
</ul>
<p>The following are examples using <code>tECDSA</code>:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/basic_bitcoin">basic_bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
</ul>
<h2 id="bitcoin-integration"><a class="header" href="#bitcoin-integration">Bitcoin integration</a></h2>
<p>The <code>Bitcoin integration</code> allows canisters on the IC to interact directly with the Bitcoin network. This functionality is exposed through the following management canister methods:</p>
<ul>
<li><a href="reference/./management_canister/bitcoin_get_balance.html">bitcoin_get_balance</a></li>
<li><a href="reference/./management_canister/bitcoin_get_current_fee_percentiles.html">bitcoin_get_current_fee_percentiles</a></li>
<li><a href="reference/./management_canister/bitcoin_get_utxos.html">bitcoin_get_utxos</a></li>
<li><a href="reference/./management_canister/bitcoin_send_transaction.html">bitcoin_send_transaction</a></li>
</ul>
<p>The following are examples using the <code>Bitcoin integration</code>:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/basic_bitcoin">basic_bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
</ul>
<h2 id="ckbtc-1"><a class="header" href="#ckbtc-1">ckBTC</a></h2>
<p><code>ckBTC</code> is a ledger canister deployed to the IC. It follows the <code>ICRC</code> standard, and can be accessed easily from an Azle canister using <code>azle/canisters/ICRC</code> if you only need the <code>ICRC</code> methods. For access to the full ledger methods you will need to create your own <a href="reference/../cross_canister.html">Service</a> for now.</p>
<p>The following are examples using <code>ckBTC</code>:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ckbtc">ckBTC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-apis"><a class="header" href="#call-apis">Call APIs</a></h1>
<ul>
<li><a href="reference/call_apis/./accept_message.html">accept message</a></li>
<li><a href="reference/call_apis/./arg_data_raw.html">arg data raw</a></li>
<li><a href="reference/call_apis/./call.html">call</a></li>
<li><a href="reference/call_apis/./call_raw.html">call raw</a></li>
<li><a href="reference/call_apis/./call_raw128.html">call raw 128</a></li>
<li><a href="reference/call_apis/./call_with_payment.html">call with payment</a></li>
<li><a href="reference/call_apis/./call_with_payment128.html">call with payment 128</a></li>
<li><a href="reference/call_apis/./caller.html">caller</a></li>
<li><a href="reference/call_apis/./method_name.html">method name</a></li>
<li><a href="reference/call_apis/./msg_cycles_accept.html">msg cycles accept</a></li>
<li><a href="reference/call_apis/./msg_cycles_accept128.html">msg cycles accept 128</a></li>
<li><a href="reference/call_apis/./msg_cycles_available.html">msg cycles available</a></li>
<li><a href="reference/call_apis/./msg_cycles_available128.html">msg cycles available 128</a></li>
<li><a href="reference/call_apis/./msg_cycles_refunded.html">msg cycles refunded</a></li>
<li><a href="reference/call_apis/./msg_cycles_refunded128.html">msg cycles refunded 128</a></li>
<li><a href="reference/call_apis/./notify.html">notify</a></li>
<li><a href="reference/call_apis/./notify_raw.html">notify raw</a></li>
<li><a href="reference/call_apis/./notify_with_payment_128.html">notify with payment 128</a></li>
<li><a href="reference/call_apis/./reject.html">reject</a></li>
<li><a href="reference/call_apis/./reject_code.html">reject code</a></li>
<li><a href="reference/call_apis/./reject_message.html">reject message</a></li>
<li><a href="reference/call_apis/./reply.html">reply</a></li>
<li><a href="reference/call_apis/./reply_raw.html">reply raw</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accept-message"><a class="header" href="#accept-message">accept message</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/blob/main/examples/inspect_message/src/inspect_message.ts">inspect_message</a></li>
<li><a href="https://github.com/demergent-labs/azle/blob/main/examples/run_time_errors/src/index.ts">run_time_errors</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, inspectMessage } from 'azle/experimental';

export default Canister({
    inspectMessage: inspectMessage(() =&gt; {
        ic.acceptMessage();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arg-data-raw"><a class="header" href="#arg-data-raw">arg data raw</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/blob/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { blob, bool, Canister, ic, int8, query, text } from 'azle/experimental';

export default Canister({
    // returns the argument data as bytes.
    argDataRaw: query(
        [blob, int8, bool, text],
        blob,
        (arg1, arg2, arg3, arg4) =&gt; {
            return ic.argDataRaw();
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call"><a class="header" href="#call">call</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/async_await">async_await</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/composite_queries">composite_queries</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cross_canister_calls">cross_canister_calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/func_types">func_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/heartbeat">heartbeat</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/inline_types">inline_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ledger_canister">ledger_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/rejections">rejections</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">timers</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/tuple_types">tuple_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/whoami">whoami</a></li>
</ul>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    init,
    nat64,
    Principal,
    update
} from 'azle/experimental';

const TokenCanister = Canister({
    transfer: update([Principal, nat64], nat64)
});

let tokenCanister: typeof TokenCanister;

export default Canister({
    init: init([], setup),
    postDeploy: init([], setup),
    payout: update([Principal, nat64], nat64, async (to, amount) =&gt; {
        return await ic.call(tokenCanister.transfer, {
            args: [to, amount]
        });
    })
});

function setup() {
    tokenCanister = TokenCanister(
        Principal.fromText('r7inp-6aaaa-aaaaa-aaabq-cai')
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-raw"><a class="header" href="#call-raw">call raw</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/call_raw">call_raw</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    nat64,
    Principal,
    text,
    update
} from 'azle/experimental';

export default Canister({
    executeCallRaw: update(
        [Principal, text, text, nat64],
        text,
        async (canisterId, method, candidArgs, payment) =&gt; {
            const candidBytes = await ic.callRaw(
                canisterId,
                method,
                ic.candidEncode(candidArgs),
                payment
            );

            return ic.candidDecode(candidBytes);
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-raw-128"><a class="header" href="#call-raw-128">call raw 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/call_raw">call_raw</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat, Principal, text, update } from 'azle/experimental';

export default Canister({
    executeCallRaw128: update(
        [Principal, text, text, nat],
        text,
        async (canisterId, method, candidArgs, payment) =&gt; {
            const candidBytes = await ic.callRaw128(
                canisterId,
                method,
                ic.candidEncode(candidArgs),
                payment
            );

            return ic.candidDecode(candidBytes);
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-with-payment"><a class="header" href="#call-with-payment">call with payment</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, Principal, update, Void } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeInstallCode: update(
        [Principal, blob],
        Void,
        async (canisterId, wasmModule) =&gt; {
            return await ic.call(managementCanister.install_code, {
                args: [
                    {
                        mode: { install: null },
                        canister_id: canisterId,
                        wasm_module: wasmModule,
                        arg: Uint8Array.from([])
                    }
                ],
                cycles: 100_000_000_000n
            });
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-with-payment-128"><a class="header" href="#call-with-payment-128">call with payment 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, Principal, update, Void } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeInstallCode: update(
        [Principal, blob],
        Void,
        async (canisterId, wasmModule) =&gt; {
            return await ic.call128(managementCanister.install_code, {
                args: [
                    {
                        mode: { install: null },
                        canister_id: canisterId,
                        wasm_module: wasmModule,
                        arg: Uint8Array.from([])
                    }
                ],
                cycles: 100_000_000_000n
            });
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caller"><a class="header" href="#caller">caller</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/whoami">whoami</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, Principal, update } from 'azle/experimental';

export default Canister({
    // returns the principal of the identity that called this function
    caller: update([], Principal, () =&gt; {
        return ic.caller();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-name"><a class="header" href="#method-name">method name</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/inspect_message">inspect_message</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/run_time_errors">run_time_errors</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, inspectMessage, update } from 'azle/experimental';

export default Canister({
    inspectMessage: inspectMessage(() =&gt; {
        console.log('inspectMessage called');

        if (ic.methodName() === 'accessible') {
            ic.acceptMessage();
            return;
        }

        if (ic.methodName() === 'inaccessible') {
            return;
        }

        throw `Method &quot;${ic.methodName()}&quot; not allowed`;
    }),
    accessible: update([], bool, () =&gt; {
        return true;
    }),
    inaccessible: update([], bool, () =&gt; {
        return false;
    }),
    alsoInaccessible: update([], bool, () =&gt; {
        return false;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msg-cycles-accept"><a class="header" href="#msg-cycles-accept">msg cycles accept</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, update } from 'azle/experimental';

export default Canister({
    // Moves all transferred cycles to the canister
    receiveCycles: update([], nat64, () =&gt; {
        return ic.msgCyclesAccept(ic.msgCyclesAvailable() / 2n);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msg-cycles-accept-128"><a class="header" href="#msg-cycles-accept-128">msg cycles accept 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, update } from 'azle/experimental';

export default Canister({
    // Moves all transferred cycles to the canister
    receiveCycles128: update([], nat64, () =&gt; {
        return ic.msgCyclesAccept128(ic.msgCyclesAvailable128() / 2n);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msg-cycles-available"><a class="header" href="#msg-cycles-available">msg cycles available</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, update } from 'azle/experimental';

export default Canister({
    // Moves all transferred cycles to the canister
    receiveCycles: update([], nat64, () =&gt; {
        return ic.msgCyclesAccept(ic.msgCyclesAvailable() / 2n);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msg-cycles-available-128"><a class="header" href="#msg-cycles-available-128">msg cycles available 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, update } from 'azle/experimental';

export default Canister({
    // Moves all transferred cycles to the canister
    receiveCycles128: update([], nat64, () =&gt; {
        return ic.msgCyclesAccept128(ic.msgCyclesAvailable128() / 2n);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msg-cycles-refunded"><a class="header" href="#msg-cycles-refunded">msg cycles refunded</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, update } from 'azle/experimental';
import { otherCanister } from './other_canister';

export default Canister({
    // Reports the number of cycles returned from the Cycles canister
    sendCycles: update([], nat64, async () =&gt; {
        await ic.call(otherCanister.receiveCycles, {
            cycles: 1_000_000n
        });

        return ic.msgCyclesRefunded();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msg-cycles-refunded-128"><a class="header" href="#msg-cycles-refunded-128">msg cycles refunded 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, update } from 'azle/experimental';
import { otherCanister } from './other_canister';

export default Canister({
    // Reports the number of cycles returned from the Cycles canister
    sendCycles128: update([], nat64, async () =&gt; {
        await ic.call128(otherCanister.receiveCycles128, {
            cycles: 1_000_000n
        });

        return ic.msgCyclesRefunded128();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notify"><a class="header" href="#notify">notify</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cross_canister_calls">cross_canister_calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, update, Void } from 'azle/experimental';
import { otherCanister } from './otherCanister';

export default Canister({
    sendNotification: update([], Void, () =&gt; {
        return ic.notify(otherCanister.receiveNotification, {
            args: ['This is the notification']
        });
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notify-raw"><a class="header" href="#notify-raw">notify raw</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/notify_raw">notify_raw</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, Principal, update, Void } from 'azle/experimental';

export default Canister({
    sendNotification: update([], Void, () =&gt; {
        return ic.notifyRaw(
            Principal.fromText('ryjl3-tyaaa-aaaaa-aaaba-cai'),
            'receiveNotification',
            Uint8Array.from(ic.candidEncode('()')),
            0n
        );
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notify-with-payment-128"><a class="header" href="#notify-with-payment-128">notify with payment 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, update, Void } from 'azle/experimental';
import { otherCanister } from './otherCanister';

export default Canister({
    sendCycles128Notify: update([], Void, () =&gt; {
        return ic.notify(otherCanister.receiveCycles128, {
            cycles: 1_000_000n
        });
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reject"><a class="header" href="#reject">reject</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/manual_reply">manual_reply</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/rejections">rejections</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, empty, ic, Manual, query, text } from 'azle/experimental';

export default Canister({
    reject: query(
        [text],
        Manual(empty),
        (message) =&gt; {
            ic.reject(message);
        },
        { manual: true }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reject-code"><a class="header" href="#reject-code">reject code</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/rejections">rejections</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, RejectionCode, update } from 'azle/experimental';
import { otherCanister } from './other_canister';

export default Canister({
    getRejectionCodeDestinationInvalid: update([], RejectionCode, async () =&gt; {
        await ic.call(otherCanister.method);
        return ic.rejectCode();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reject-message"><a class="header" href="#reject-message">reject message</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/rejections">rejections</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, text, update } from 'azle/experimental';
import { otherCanister } from './other_canister';

export default Canister({
    getRejectionMessage: update([], text, async () =&gt; {
        await ic.call(otherCanister.method);
        return ic.rejectMessage();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reply"><a class="header" href="#reply">reply</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/composite_queries">composite_queries</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/manual_reply">manual_reply</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, Manual, update } from 'azle/experimental';

export default Canister({
    updateBlob: update(
        [],
        Manual(blob),
        () =&gt; {
            ic.reply(
                new Uint8Array([83, 117, 114, 112, 114, 105, 115, 101, 33]),
                blob
            );
        },
        { manual: true }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reply-raw"><a class="header" href="#reply-raw">reply raw</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/manual_reply">manual_reply</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<pre><code class="language-typescript">import {
    blob,
    bool,
    Canister,
    ic,
    int,
    Manual,
    Null,
    Record,
    text,
    update,
    Variant
} from 'azle/experimental';

const Options = Variant({
    High: Null,
    Medium: Null,
    Low: Null
});

export default Canister({
    replyRaw: update(
        [],
        Manual(
            Record({
                int: int,
                text: text,
                bool: bool,
                blob: blob,
                variant: Options
            })
        ),
        () =&gt; {
            ic.replyRaw(
                ic.candidEncode(
                    '(record { &quot;int&quot; = 42; &quot;text&quot; = &quot;text&quot;; &quot;bool&quot; = true; &quot;blob&quot; = blob &quot;Surprise!&quot;; &quot;variant&quot; = variant { Medium } })'
                )
            );
        },
        { manual: true }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-1"><a class="header" href="#candid-1">Candid</a></h1>
<ul>
<li><a href="reference/candid/./blob.html">blob</a></li>
<li><a href="reference/candid/./bool.html">bool</a></li>
<li><a href="reference/candid/./empty.html">empty</a></li>
<li><a href="reference/candid/./float32.html">float32</a></li>
<li><a href="reference/candid/./float64.html">float64</a></li>
<li><a href="reference/candid/./func.html">func</a></li>
<li><a href="reference/candid/./int.html">int</a></li>
<li><a href="reference/candid/./int8.html">int8</a></li>
<li><a href="reference/candid/./int16.html">int16</a></li>
<li><a href="reference/candid/./int32.html">int32</a></li>
<li><a href="reference/candid/./int64.html">int64</a></li>
<li><a href="reference/candid/./nat.html">nat</a></li>
<li><a href="reference/candid/./nat8.html">nat8</a></li>
<li><a href="reference/candid/./nat16.html">nat16</a></li>
<li><a href="reference/candid/./nat32.html">nat32</a></li>
<li><a href="reference/candid/./nat64.html">nat64</a></li>
<li><a href="reference/candid/./null.html">null</a></li>
<li><a href="reference/candid/./opt.html">opt</a></li>
<li><a href="reference/candid/./principal.html">principal</a></li>
<li><a href="reference/candid/./record.html">record</a></li>
<li><a href="reference/candid/./reserved.html">reserved</a></li>
<li><a href="reference/candid/./service.html">service</a></li>
<li><a href="reference/candid/./text.html">text</a></li>
<li><a href="reference/candid/./variant.html">variant</a></li>
<li><a href="reference/candid/./vec.html">vec</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blob"><a class="header" href="#blob">blob</a></h1>
<p>The <code>CandidType</code> object <code>blob</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-blob">Candid type blob</a>, is inferred to be a TypeScript <code>Uint8Array</code> and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array">JavaScript Uint8Array</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { blob, Canister, query } from 'azle/experimental';

export default Canister({
    getBlob: query([], blob, () =&gt; {
        return Uint8Array.from([68, 73, 68, 76, 0, 0]);
    }),
    printBlob: query([blob], blob, (blob) =&gt; {
        console.log(typeof blob);
        return blob;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getBlob : () -&gt; (vec nat8) query;
    printBlob : (vec nat8) -&gt; (vec nat8) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printBlob '(vec { 68; 73; 68; 76; 0; 0; })'
(blob &quot;DIDL\00\00&quot;)

dfx canister call candid_canister printBlob '(blob &quot;DIDL\00\00&quot;)'
(blob &quot;DIDL\00\00&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">bool</a></h1>
<p>The <code>CandidType</code> object <code>bool</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-bool">Candid type bool</a>, is inferred to be a TypeScript <code>boolean</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">JavaScript Boolean</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { bool, Canister, query } from 'azle/experimental';

export default Canister({
    getBool: query([], bool, () =&gt; {
        return true;
    }),
    printBool: query([bool], bool, (bool) =&gt; {
        console.log(typeof bool);
        return bool;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getBool : () -&gt; (bool) query;
    printBool : (bool) -&gt; (bool) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printBool '(true)'
(true)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empty"><a class="header" href="#empty">empty</a></h1>
<p>The <code>CandidType</code> object <code>empty</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-empty">Candid type empty</a>, is inferred to be a TypeScript <code>never</code>, and has no JavaScript value at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, empty, query } from 'azle/experimental';

export default Canister({
    getEmpty: query([], empty, () =&gt; {
        throw 'Anything you want';
    }),
    // Note: It is impossible to call this function because it requires an argument
    // but there is no way to pass an &quot;empty&quot; value as an argument.
    printEmpty: query([empty], empty, (empty) =&gt; {
        console.log(typeof empty);
        throw 'Anything you want';
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getEmpty : () -&gt; (empty) query;
    printEmpty : (empty) -&gt; (empty) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printEmpty '(&quot;You can put anything here&quot;)'
Error: Failed to create argument blob.
Caused by: Failed to create argument blob.
  Invalid data: Unable to serialize Candid values: type mismatch: &quot;You can put anything here&quot; cannot be of type empty
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float32"><a class="header" href="#float32">float32</a></h1>
<p>The <code>CandidType</code> object <code>float32</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-float32-and-float64">Candid type float32</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, float32, query } from 'azle/experimental';

export default Canister({
    getFloat32: query([], float32, () =&gt; {
        return Math.PI;
    }),
    printFloat32: query([float32], float32, (float32) =&gt; {
        console.log(typeof float32);
        return float32;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getFloat32 : () -&gt; (float32) query;
    printFloat32 : (float32) -&gt; (float32) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printFloat32 '(3.1415927 : float32)'
(3.1415927 : float32)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float64"><a class="header" href="#float64">float64</a></h1>
<p>The <code>CandidType</code> object <code>float64</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-float32-and-float64">Candid type float64</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, float64, query } from 'azle/experimental';

export default Canister({
    getFloat64: query([], float64, () =&gt; {
        return Math.E;
    }),
    printFloat64: query([float64], float64, (float64) =&gt; {
        console.log(typeof float64);
        return float64;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getFloat64 : () -&gt; (float64) query;
    printFloat64 : (float64) -&gt; (float64) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printFloat64 '(2.718281828459045 : float64)'
(2.718281828459045 : float64)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func"><a class="header" href="#func">func</a></h1>
<p>Values created by the <code>CandidType</code> function <code>Func</code> correspond to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-func---">Candid type func</a>, are inferred to be TypeScript <code>[Principal, string]</code> tuples, and will be decoded into <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">JavaScript array</a> with two elements at runtime.</p>
<p>The first element is an <a href="https://www.npmjs.com/package/@dfinity/principal">@dfinity/principal</a> and the second is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">JavaScript string</a>. The <code>@dfinity/principal</code> represents the <code>principal</code> of the canister/service where the function exists, and the <code>string</code> represents the function's name.</p>
<p>A <code>func</code> acts as a callback, allowing the <code>func</code> receiver to know which canister instance and method must be used to call back.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, Func, Principal, query, text } from 'azle/experimental';

const BasicFunc = Func([text], text, 'query');

export default Canister({
    getBasicFunc: query([], BasicFunc, () =&gt; {
        return [
            Principal.fromText('rrkah-fqaaa-aaaaa-aaaaq-cai'),
            'getBasicFunc'
        ];
    }),
    printBasicFunc: query([BasicFunc], BasicFunc, (basicFunc) =&gt; {
        console.log(typeof basicFunc);
        return basicFunc;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getBasicFunc : () -&gt; (func (text) -&gt; (text) query) query;
    printBasicFunc : (func (text) -&gt; (text) query) -&gt; (
        func (text) -&gt; (text) query,
      ) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printBasicFunc '(func &quot;r7inp-6aaaa-aaaaa-aaabq-cai&quot;.getBasicFunc)'
(func &quot;r7inp-6aaaa-aaaaa-aaabq-cai&quot;.getBasicFunc)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int"><a class="header" href="#int">int</a></h1>
<p>The <code>CandidType</code> object <code>int</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-int">Candid type int</a>, is inferred to be a TypeScript <code>bigint</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">JavaScript BigInt</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, int, query } from 'azle/experimental';

export default Canister({
    getInt: query([], int, () =&gt; {
        return 170_141_183_460_469_231_731_687_303_715_884_105_727n;
    }),
    printInt: query([int], int, (int) =&gt; {
        console.log(typeof int);
        return int;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getInt : () -&gt; (int) query;
    printInt : (int) -&gt; (int) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printInt '(170_141_183_460_469_231_731_687_303_715_884_105_727 : int)'
(170_141_183_460_469_231_731_687_303_715_884_105_727 : int)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int8"><a class="header" href="#int8">int8</a></h1>
<p>The <code>CandidType</code> object <code>int8</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type int8</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, int8, query } from 'azle/experimental';

export default Canister({
    getInt8: query([], int8, () =&gt; {
        return 127;
    }),
    printInt8: query([int8], int8, (int8) =&gt; {
        console.log(typeof int8);
        return int8;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getInt8 : () -&gt; (int8) query;
    printInt8 : (int8) -&gt; (int8) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printInt8 '(127 : int8)'
(127 : int8)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int16"><a class="header" href="#int16">int16</a></h1>
<p>The <code>CandidType</code> object <code>int16</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type int16</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, int16, query } from 'azle/experimental';

export default Canister({
    getInt16: query([], int16, () =&gt; {
        return 32_767;
    }),
    printInt16: query([int16], int16, (int16) =&gt; {
        console.log(typeof int16);
        return int16;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getInt16 : () -&gt; (int16) query;
    printInt16 : (int16) -&gt; (int16) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printInt16 '(32_767 : int16)'
(32_767 : int16)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int32"><a class="header" href="#int32">int32</a></h1>
<p>The <code>CandidType</code> object <code>int32</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type int32</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, int32, query } from 'azle/experimental';

export default Canister({
    getInt32: query([], int32, () =&gt; {
        return 2_147_483_647;
    }),
    printInt32: query([int32], int32, (int32) =&gt; {
        console.log(typeof int32);
        return int32;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getInt32 : () -&gt; (int32) query;
    printInt32 : (int32) -&gt; (int32) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printInt32 '(2_147_483_647 : int32)'
(2_147_483_647 : int32)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int64"><a class="header" href="#int64">int64</a></h1>
<p>The <code>CandidType</code> object <code>int64</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type int64</a>, is inferred to be a TypeScript <code>bigint</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">JavaScript BigInt</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, int64, query } from 'azle/experimental';

export default Canister({
    getInt64: query([], int64, () =&gt; {
        return 9_223_372_036_854_775_807n;
    }),
    printInt64: query([int64], int64, (int64) =&gt; {
        console.log(typeof int64);
        return int64;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getInt64 : () -&gt; (int64) query;
    printInt64 : (int64) -&gt; (int64) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printInt64 '(9_223_372_036_854_775_807 : int64)'
(9_223_372_036_854_775_807 : int64)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nat"><a class="header" href="#nat">nat</a></h1>
<p>The <code>CandidType</code> object <code>nat</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-nat">Candid type nat</a>, is inferred to be a TypeScript <code>bigint</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">JavaScript BigInt</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, nat, query } from 'azle/experimental';

export default Canister({
    getNat: query([], nat, () =&gt; {
        return 340_282_366_920_938_463_463_374_607_431_768_211_455n;
    }),
    printNat: query([nat], nat, (nat) =&gt; {
        console.log(typeof nat);
        return nat;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNat : () -&gt; (nat) query;
    printNat : (nat) -&gt; (nat) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNat '(340_282_366_920_938_463_463_374_607_431_768_211_455 : nat)'
(340_282_366_920_938_463_463_374_607_431_768_211_455 : nat)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nat8"><a class="header" href="#nat8">nat8</a></h1>
<p>The <code>CandidType</code> object <code>nat8</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type nat8</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, nat8, query } from 'azle/experimental';

export default Canister({
    getNat8: query([], nat8, () =&gt; {
        return 255;
    }),
    printNat8: query([nat8], nat8, (nat8) =&gt; {
        console.log(typeof nat8);
        return nat8;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNat8 : () -&gt; (nat8) query;
    printNat8 : (nat8) -&gt; (nat8) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNat8 '(255 : nat8)'
(255 : nat8)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nat16"><a class="header" href="#nat16">nat16</a></h1>
<p>The <code>CandidType</code> object <code>nat16</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type nat16</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, nat16, query } from 'azle/experimental';

export default Canister({
    getNat16: query([], nat16, () =&gt; {
        return 65_535;
    }),
    printNat16: query([nat16], nat16, (nat16) =&gt; {
        console.log(typeof nat16);
        return nat16;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNat16 : () -&gt; (nat16) query;
    printNat16 : (nat16) -&gt; (nat16) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNat16 '(65_535 : nat16)'
(65_535 : nat16)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nat32"><a class="header" href="#nat32">nat32</a></h1>
<p>The <code>CandidType</code> object <code>nat32</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type nat32</a>, is inferred to be a TypeScript <code>number</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">JavaScript Number</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, nat32, query } from 'azle/experimental';

export default Canister({
    getNat32: query([], nat32, () =&gt; {
        return 4_294_967_295;
    }),
    printNat32: query([nat32], nat32, (nat32) =&gt; {
        console.log(typeof nat32);
        return nat32;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNat32 : () -&gt; (nat32) query;
    printNat32 : (nat32) -&gt; (nat32) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNat32 '(4_294_967_295 : nat32)'
(4_294_967_295 : nat32)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nat64"><a class="header" href="#nat64">nat64</a></h1>
<p>The <code>CandidType</code> object <code>nat64</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-natn-and-intn">Candid type nat64</a>, is inferred to be a TypeScript <code>bigint</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">JavaScript BigInt</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, nat64, query } from 'azle/experimental';

export default Canister({
    getNat64: query([], nat64, () =&gt; {
        return 18_446_744_073_709_551_615n;
    }),
    printNat64: query([nat64], nat64, (nat64) =&gt; {
        console.log(typeof nat64);
        return nat64;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNat64 : () -&gt; (nat64) query;
    printNat64 : (nat64) -&gt; (nat64) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNat64 '(18_446_744_073_709_551_615 : nat64)'
(18_446_744_073_709_551_615 : nat64)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null"><a class="header" href="#null">null</a></h1>
<p>The <code>CandidType</code> object <code>null</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-null">Candid type null</a>, is inferred to be a TypeScript <code>null</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null">JavaScript null</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, Null, query } from 'azle/experimental';

export default Canister({
    getNull: query([], Null, () =&gt; {
        return null;
    }),
    printNull: query([Null], Null, (null_) =&gt; {
        console.log(typeof null_);
        return null_;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNull : () -&gt; (null) query;
    printNull : (null) -&gt; (null) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNull '(null)'
(null : null)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opt"><a class="header" href="#opt">opt</a></h1>
<p>The <code>CandidType</code> object <code>Opt</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-opt-t">Candid type opt</a>, is inferred to be a TypeScript <code>Opt&lt;T&gt;</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">JavaScript Object</a> at runtime.</p>
<p>It is a <a href="reference/candid/opt.html#variant">variant</a> with <code>Some</code> and <code>None</code> cases. At runtime if the value of the variant is <code>Some</code>, the <code>Some</code> property of the variant object will have a value of the enclosed <code>Opt</code> type at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { bool, Canister, None, Opt, query, Some } from 'azle/experimental';

export default Canister({
    getOptSome: query([], Opt(bool), () =&gt; {
        return Some(true); // equivalent to { Some: true }
    }),
    getOptNone: query([], Opt(bool), () =&gt; {
        return None; //equivalent to { None: null}
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getOptNone : () -&gt; (opt bool) query;
    getOptSome : () -&gt; (opt bool) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister getOptSome
(opt true)

dfx canister call candid_canister getOptNone
(null)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="principal"><a class="header" href="#principal">principal</a></h1>
<p>The <code>CandidType</code> object <code>Principal</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-principal">Candid type principal</a>, is inferred to be a TypeScript <a href="https://www.npmjs.com/package/@dfinity/principal">@dfinity/principal</a> <code>Principal</code>, and will be decoded into an <a href="https://www.npmjs.com/package/@dfinity/principal">@dfinity/principal Principal</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, Principal, query } from 'azle/experimental';

export default Canister({
    getPrincipal: query([], Principal, () =&gt; {
        return Principal.fromText('rrkah-fqaaa-aaaaa-aaaaq-cai');
    }),
    printPrincipal: query([Principal], Principal, (principal) =&gt; {
        console.log(typeof principal);
        return principal;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getPrincipal : () -&gt; (principal) query;
    printPrincipal : (principal) -&gt; (principal) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printPrincipal '(principal &quot;rrkah-fqaaa-aaaaa-aaaaq-cai&quot;)'
(principal &quot;rrkah-fqaaa-aaaaa-aaaaq-cai&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="record"><a class="header" href="#record">record</a></h1>
<p>Objects created by the <code>CandidType</code> function <code>Record</code> correspond to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-record--n--t--">Candid record type</a>, are inferred to be TypeScript <code>Object</code>s, and will be decoded into <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">JavaScript Objects</a> at runtime.</p>
<p>The shape of the object will match the object literal passed to the <code>Record</code> function.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, Principal, query, Record, text } from 'azle/experimental';

const User = Record({
    id: Principal,
    username: text
});

export default Canister({
    getUser: query([], User, () =&gt; {
        return {
            id: Principal.fromUint8Array(Uint8Array.from([0])),
            username: 'lastmjs'
        };
    }),
    printUser: query([User], User, (user) =&gt; {
        console.log(typeof user);
        return user;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>type User = record { id : principal; username : text };
service : () -&gt; {
    getUser : () -&gt; (User) query;
    printUser : (User) -&gt; (User) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printUser '(record { id = principal &quot;2ibo7-dia&quot;; username = &quot;lastmjs&quot; })'
(record { id = principal &quot;2ibo7-dia&quot;; username = &quot;lastmjs&quot; })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reserved"><a class="header" href="#reserved">reserved</a></h1>
<p>The <code>CandidType</code> object <code>reserved</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-reserved">Candid type reserved</a>, is inferred to be a TypeScript <code>any</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null">JavaScript null</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, query, reserved } from 'azle/experimental';

export default Canister({
    getReserved: query([], reserved, () =&gt; {
        return 'anything';
    }),
    printReserved: query([reserved], reserved, (reserved) =&gt; {
        console.log(typeof reserved);
        return reserved;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getReserved : () -&gt; (reserved) query;
    printReserved : (reserved) -&gt; (reserved) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printReserved '(null)'
(null : reserved)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service"><a class="header" href="#service">service</a></h1>
<p>Values created by the <code>CandidType</code> function <code>Canister</code> correspond to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-service-">Candid service type</a>, are inferred to be TypeScript <code>Object</code>s, and will be decoded into <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">JavaScript Objects</a> at runtime.</p>
<p>The properties of this object that match the keys of the service's <code>query</code> and <code>update</code> methods can be passed into <code>ic.call</code> and <code>ic.notify</code> to perform cross-canister calls.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import {
    bool,
    Canister,
    ic,
    Principal,
    query,
    text,
    update
} from 'azle/experimental';

const SomeCanister = Canister({
    query1: query([], bool),
    update1: update([], text)
});

export default Canister({
    getService: query([], SomeCanister, () =&gt; {
        return SomeCanister(Principal.fromText('aaaaa-aa'));
    }),
    callService: update([SomeCanister], text, (service) =&gt; {
        return ic.call(service.update1);
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>type ManualReply = variant { Ok : text; Err : text };
service : () -&gt; {
  callService : (
      service { query1 : () -&gt; (bool) query; update1 : () -&gt; (text) },
    ) -&gt; (ManualReply);
  getService : () -&gt; (
      service { query1 : () -&gt; (bool) query; update1 : () -&gt; (text) },
    ) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister getService
(service &quot;aaaaa-aa&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">text</a></h1>
<p>The <code>CandidType</code> object <code>text</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-text">Candid type text</a>, is inferred to be a TypeScript <code>string</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">JavaScript String</a> at runtime.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, query, text } from 'azle/experimental';

export default Canister({
    getString: query([], text, () =&gt; {
        return 'Hello world!';
    }),
    printString: query([text], text, (string) =&gt; {
        console.log(typeof string);
        return string;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getString : () -&gt; (text) query;
    printString : (text) -&gt; (text) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printString '(&quot;Hello world!&quot;)'
(&quot;Hello world!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variant"><a class="header" href="#variant">variant</a></h1>
<p>Objects created by the <code>CandidType</code> function <code>Variant</code> correspond to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-variant--n--t--">Candid variant type</a>, are inferred to be TypeScript <code>Object</code>s, and will be decoded into <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">JavaScript Objects</a> at runtime.</p>
<p>The shape of the object will match the object literal passed to the <code>Variant</code> function, however it will contain only one of the enumerated properties.</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, Null, query, Variant } from 'azle/experimental';

const Emotion = Variant({
    Happy: Null,
    Indifferent: Null,
    Sad: Null
});

const Reaction = Variant({
    Fire: Null,
    ThumbsUp: Null,
    Emotion: Emotion
});

export default Canister({
    getReaction: query([], Reaction, () =&gt; {
        return {
            Fire: null
        };
    }),
    printReaction: query([Reaction], Reaction, (reaction) =&gt; {
        console.log(typeof reaction);
        return reaction;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>type Emotion = variant { Sad; Indifferent; Happy };
type Reaction = variant { Emotion : Emotion; Fire; ThumbsUp };
service : () -&gt; {
    getReaction : () -&gt; (Reaction) query;
    printReaction : (Reaction) -&gt; (Reaction) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printReaction '(variant { Fire })'
(variant { Fire })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec">vec</a></h1>
<p>The <code>CandidType</code> object <code>Vec</code> corresponds to the <a href="https://internetcomputer.org/docs/current/references/candid-ref#type-vec-t">Candid type vec</a>, is inferred to be a TypeScript <code>T[]</code>, and will be decoded into a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">JavaScript array</a> of the specified type at runtime (except for <code>Vec&lt;nat8&gt;</code> which will become a <code>Uint8Array</code>, thus it is recommended to use the <code>blob</code> type instead of <code>Vec&lt;nat8&gt;</code>).</p>
<p>TypeScript or JavaScript:</p>
<pre><code class="language-typescript">import { Canister, int32, Vec, query } from 'azle/experimental';

export default Canister({
    getNumbers: query([], Vec(int32), () =&gt; {
        return [0, 1, 2, 3];
    }),
    printNumbers: query([Vec(int32)], Vec(int32), (numbers) =&gt; {
        console.log(typeof numbers);
        return numbers;
    })
});
</code></pre>
<p>Candid:</p>
<pre><code>service : () -&gt; {
    getNumbers : () -&gt; (vec int32) query;
    printNumbers : (vec int32) -&gt; (vec int32) query;
}
</code></pre>
<p>dfx:</p>
<pre><code class="language-bash">dfx canister call candid_canister printNumbers '(vec { 0 : int32; 1 : int32; 2 : int32; 3 : int32 })'
(vec { 0 : int32; 1 : int32; 2 : int32; 3 : int32 })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-apis"><a class="header" href="#canister-apis">Canister APIs</a></h1>
<ul>
<li><a href="reference/canister_apis/./candid_decode.html">candid decode</a></li>
<li><a href="reference/canister_apis/./candid_encode.html">candid encode</a></li>
<li><a href="reference/canister_apis/./canister_balance.html">canister balance</a></li>
<li><a href="reference/canister_apis/./canister_balance128.html">canister balance 128</a></li>
<li><a href="reference/canister_apis/./canister_version.html">canister version</a></li>
<li><a href="reference/canister_apis/./canister_id.html">canister id</a></li>
<li><a href="reference/canister_apis/./data_certificate.html">data certificate</a></li>
<li><a href="reference/canister_apis/./instruction_counter.html">instruction counter</a></li>
<li><a href="reference/canister_apis/./is_controller.html">is controller</a></li>
<li><a href="reference/canister_apis/./performance_counter.html">performance counter</a></li>
<li><a href="reference/canister_apis/./print.html">print</a></li>
<li><a href="reference/canister_apis/./set_certified_data.html">set certified data</a></li>
<li><a href="reference/canister_apis/./time.html">time</a></li>
<li><a href="reference/canister_apis/./trap.html">trap</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-decode"><a class="header" href="#candid-decode">candid decode</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/call_raw">call_raw</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/candid_encoding">candid_encoding</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, query, text } from 'azle/experimental';

export default Canister({
    // decodes Candid bytes to a Candid string
    candidDecode: query([blob], text, (candidEncoded) =&gt; {
        return ic.candidDecode(candidEncoded);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="candid-encode"><a class="header" href="#candid-encode">candid encode</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/call_raw">call_raw</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/candid_encoding">candid_encoding</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/manual_reply">manual_reply</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/notify_raw">notify_raw</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, query, text } from 'azle/experimental';

export default Canister({
    // encodes a Candid string to Candid bytes
    candidEncode: query([text], blob, (candidString) =&gt; {
        return ic.candidEncode(candidString);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-balance"><a class="header" href="#canister-balance">canister balance</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, query } from 'azle/experimental';

export default Canister({
    // returns the amount of cycles available in the canister
    canisterBalance: query([], nat64, () =&gt; {
        return ic.canisterBalance();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-balance-128"><a class="header" href="#canister-balance-128">canister balance 128</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cycles">cycles</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat, query } from 'azle/experimental';

export default Canister({
    // returns the amount of cycles available in the canister
    canisterBalance128: query([], nat, () =&gt; {
        return ic.canisterBalance128();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-version"><a class="header" href="#canister-version">canister version</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, query } from 'azle/experimental';

export default Canister({
    // returns the canister's version number
    canisterVersion: query([], nat64, () =&gt; {
        return ic.canisterVersion();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-id"><a class="header" href="#canister-id">canister id</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">http_counter</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/whoami">whoami</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, Principal, query } from 'azle/experimental';

export default Canister({
    // returns this canister's id
    id: query([], Principal, () =&gt; {
        return ic.id();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-certificate"><a class="header" href="#data-certificate">data certificate</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, Opt, query } from 'azle/experimental';

export default Canister({
    // When called from a query call, returns the data certificate
    // authenticating certified_data set by this canister. Returns None if not
    // called from a query call.
    dataCertificate: query([], Opt(blob), () =&gt; {
        return ic.dataCertificate();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instruction-counter"><a class="header" href="#instruction-counter">instruction counter</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, query } from 'azle/experimental';

export default Canister({
    // Returns the number of instructions that the canister executed since the
    // last entry point.
    instructionCounter: query([], nat64, () =&gt; {
        return ic.instructionCounter();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is-controller"><a class="header" href="#is-controller">is controller</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, query } from 'azle/experimental';

export default Canister({
    // determines whether the given principal is a controller of the canister
    isController: query([Principal], bool, (principal) =&gt; {
        return ic.isController(principal);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-counter"><a class="header" href="#performance-counter">performance counter</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, query } from 'azle/experimental';

export default Canister({
    performanceCounter: query([], nat64, () =&gt; {
        return ic.performanceCounter(0);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print"><a class="header" href="#print">print</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/null_example">null_example</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, query, text } from 'azle/experimental';

export default Canister({
    // prints a message through the local replica's output
    print: query([text], bool, (message) =&gt; {
        ic.print(message);

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-certified-data"><a class="header" href="#set-certified-data">set certified data</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, update, Void } from 'azle/experimental';

export default Canister({
    // sets up to 32 bytes of certified data
    setCertifiedData: update([blob], Void, (data) =&gt; {
        ic.setCertifiedData(data);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">time</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/audio_recorder">audio_recorder</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, nat64, query } from 'azle/experimental';

export default Canister({
    // returns the current timestamp
    time: query([], nat64, () =&gt; {
        return ic.time();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trap"><a class="header" href="#trap">trap</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/cross_canister_calls">cross_canister_calls</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">http_counter</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ic_api">ic_api</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, query, text } from 'azle/experimental';

export default Canister({
    // traps with a message, stopping execution and discarding all state within the call
    trap: query([text], bool, (message) =&gt; {
        ic.trap(message);

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister-methods"><a class="header" href="#canister-methods">Canister Methods</a></h1>
<ul>
<li><a href="reference/canister_methods/./heartbeat.html">heartbeat</a></li>
<li><a href="reference/canister_methods/./http_request.html">http_request</a></li>
<li><a href="reference/canister_methods/./http_request_update.html">http_request_update</a></li>
<li><a href="reference/canister_methods/./init.html">init</a></li>
<li><a href="reference/canister_methods/./inspect_message.html">inspect message</a></li>
<li><a href="reference/canister_methods/./post_upgrade.html">post upgrade</a></li>
<li><a href="reference/canister_methods/./pre_upgrade.html">pre upgrade</a></li>
<li><a href="reference/canister_methods/./query.html">query</a></li>
<li><a href="reference/canister_methods/./update.html">update</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heartbeat-1"><a class="header" href="#heartbeat-1">heartbeat</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/heartbeat">heartbeat</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/run_time_errors">run_time_errors</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, heartbeat } from 'azle/experimental';

export default Canister({
    heartbeat: heartbeat(() =&gt; {
        console.log('this runs ~1 time per second');
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http_request"><a class="header" href="#http_request">http_request</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">http_counter</a></li>
</ul>
<pre><code class="language-typescript">import {
    blob,
    bool,
    Canister,
    Func,
    nat16,
    None,
    Opt,
    query,
    Record,
    text,
    Tuple,
    Variant,
    Vec
} from 'azle/experimental';

const Token = Record({
    // add whatever fields you'd like
    arbitrary_data: text
});

const StreamingCallbackHttpResponse = Record({
    body: blob,
    token: Opt(Token)
});

export const Callback = Func([text], StreamingCallbackHttpResponse, 'query');

const CallbackStrategy = Record({
    callback: Callback,
    token: Token
});

const StreamingStrategy = Variant({
    Callback: CallbackStrategy
});

type HeaderField = [text, text];
const HeaderField = Tuple(text, text);

const HttpResponse = Record({
    status_code: nat16,
    headers: Vec(HeaderField),
    body: blob,
    streaming_strategy: Opt(StreamingStrategy),
    upgrade: Opt(bool)
});

const HttpRequest = Record({
    method: text,
    url: text,
    headers: Vec(HeaderField),
    body: blob,
    certificate_version: Opt(nat16)
});

export default Canister({
    http_request: query([HttpRequest], HttpResponse, (req) =&gt; {
        return {
            status_code: 200,
            headers: [],
            body: Buffer.from('hello'),
            streaming_strategy: None,
            upgrade: None
        };
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http_request-1"><a class="header" href="#http_request-1">http_request</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">http_counter</a></li>
</ul>
<pre><code class="language-typescript">import {
    blob,
    bool,
    Canister,
    Func,
    nat16,
    None,
    Opt,
    Record,
    text,
    Tuple,
    update,
    Variant,
    Vec
} from 'azle/experimental';

const Token = Record({
    // add whatever fields you'd like
    arbitrary_data: text
});

const StreamingCallbackHttpResponse = Record({
    body: blob,
    token: Opt(Token)
});

export const Callback = Func([text], StreamingCallbackHttpResponse, 'query');

const CallbackStrategy = Record({
    callback: Callback,
    token: Token
});

const StreamingStrategy = Variant({
    Callback: CallbackStrategy
});

type HeaderField = [text, text];
const HeaderField = Tuple(text, text);

const HttpResponse = Record({
    status_code: nat16,
    headers: Vec(HeaderField),
    body: blob,
    streaming_strategy: Opt(StreamingStrategy),
    upgrade: Opt(bool)
});

const HttpRequest = Record({
    method: text,
    url: text,
    headers: Vec(HeaderField),
    body: blob,
    certificate_version: Opt(nat16)
});

export default Canister({
    http_request_update: update([HttpRequest], HttpResponse, (req) =&gt; {
        return {
            status_code: 200,
            headers: [],
            body: Buffer.from('hello'),
            streaming_strategy: None,
            upgrade: None
        };
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init-1"><a class="header" href="#init-1">init</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/func_types">func_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/init">init</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/persistent-storage">persistent-storage</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/pre_and_post_upgrade">pre_and_post_upgrade</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/whoami">whoami</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, init } from 'azle/experimental';

export default Canister({
    init: init([], () =&gt; {
        console.log('This runs once when the canister is first initialized');
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspect-message"><a class="header" href="#inspect-message">inspect message</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/inspect_message">inspect_message</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/run_time_errors">run_time_errors</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, inspectMessage, update } from 'azle/experimental';

export default Canister({
    inspectMessage: inspectMessage(() =&gt; {
        console.log('inspectMessage called');

        if (ic.methodName() === 'accessible') {
            ic.acceptMessage();
            return;
        }

        if (ic.methodName() === 'inaccessible') {
            return;
        }

        throw `Method &quot;${ic.methodName()}&quot; not allowed`;
    }),
    accessible: update([], bool, () =&gt; {
        return true;
    }),
    inaccessible: update([], bool, () =&gt; {
        return false;
    }),
    alsoInaccessible: update([], bool, () =&gt; {
        return false;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="post-upgrade"><a class="header" href="#post-upgrade">post upgrade</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/pre_and_post_upgrade">pre_and_post_upgrade</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/whoami">whoami</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, postUpgrade } from 'azle/experimental';

export default Canister({
    postUpgrade: postUpgrade([], () =&gt; {
        console.log('This runs after every canister upgrade');
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-upgrade"><a class="header" href="#pre-upgrade">pre upgrade</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/pre_and_post_upgrade">pre_and_post_upgrade</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, preUpgrade } from 'azle/experimental';

export default Canister({
    preUpgrade: preUpgrade(() =&gt; {
        console.log('This runs before every canister upgrade');
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-1"><a class="header" href="#query-1">query</a></h1>
<p>This section is a work in progress.</p>
<pre><code class="language-typescript">import { Canister, query, text } from 'azle/experimental';

export default Canister({
    simpleQuery: query([], text, () =&gt; {
        return 'This is a query method';
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-1"><a class="header" href="#update-1">update</a></h1>
<p>This section is a work in progress.</p>
<pre><code class="language-typescript">import { Canister, query, text, update, Void } from 'azle/experimental';

let message = '';

export default Canister({
    getMessage: query([], text, () =&gt; {
        return message;
    }),
    setMessage: update([text], Void, (newMessage) =&gt; {
        message = newMessage;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables-2"><a class="header" href="#environment-variables-2">Environment Variables</a></h1>
<p>You can provide environment variables to Azle canisters by specifying their names in your <code>dfx.json</code> file and then using the <code>process.env</code> object in Azle. Be aware that the environment variables that you specify in your <code>dfx.json</code> file will be included in plain text in your canister's Wasm binary.</p>
<h2 id="dfxjson-2"><a class="header" href="#dfxjson-2">dfx.json</a></h2>
<p>Modify your <code>dfx.json</code> file with the <code>env</code> property to specify which environment variables you would like included in your Azle canister's binary. In this case, <code>CANISTER1_PRINCIPAL</code> and <code>CANISTER2_PRINCIPAL</code> will be included:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;canister1&quot;: {
            &quot;type&quot;: &quot;azle&quot;,
            &quot;main&quot;: &quot;src/canister1/index.ts&quot;,
            &quot;declarations&quot;: {
                &quot;output&quot;: &quot;test/dfx_generated/canister1&quot;,
                &quot;node_compatibility&quot;: true
            },
            &quot;custom&quot;: {
                &quot;experimental&quot;: true,
                &quot;candid_gen&quot;: &quot;http&quot;,
                &quot;env&quot;: [&quot;CANISTER1_PRINCIPAL&quot;, &quot;CANISTER2_PRINCIPAL&quot;]
            }
        }
    }
}
</code></pre>
<h2 id="processenv"><a class="header" href="#processenv">process.env</a></h2>
<p>You can access the specified environment variables in Azle like so:</p>
<pre><code class="language-typescript">import { Canister, query, text } from 'azle/experimental';

export default Canister({
    canister1PrincipalEnvVar: query([], text, () =&gt; {
        return (
            process.env.CANISTER1_PRINCIPAL ??
            'process.env.CANISTER1_PRINCIPAL is undefined'
        );
    }),
    canister2PrincipalEnvVar: query([], text, () =&gt; {
        return (
            process.env.CANISTER2_PRINCIPAL ??
            'process.env.CANISTER2_PRINCIPAL is undefined'
        );
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="management-canister-2"><a class="header" href="#management-canister-2">Management Canister</a></h1>
<ul>
<li><a href="reference/management_canister/./bitcoin_get_balance.html">bitcoin_get_balance</a></li>
<li><a href="reference/management_canister/./bitcoin_get_current_fee_percentiles.html">bitcoin_get_current_fee_percentiles</a></li>
<li><a href="reference/management_canister/./bitcoin_get_utxos.html">bitcoin_get_utxos</a></li>
<li><a href="reference/management_canister/./bitcoin_send_transaction.html">bitcoin_send_transaction</a></li>
<li><a href="reference/management_canister/./canister_info.html">canister_info</a></li>
<li><a href="reference/management_canister/./canister_status.html">canister_status</a></li>
<li><a href="reference/management_canister/./create_canister.html">create_canister</a></li>
<li><a href="reference/management_canister/./delete_canister.html">delete_canister</a></li>
<li><a href="reference/management_canister/./deposit_cycles.html">deposit_cycles</a></li>
<li><a href="reference/management_canister/./ecdsa_public_key.html">ecdsa_public_key</a></li>
<li><a href="reference/management_canister/./http_request.html">http_request</a></li>
<li><a href="reference/management_canister/./install_code.html">install_code</a></li>
<li><a href="reference/management_canister/./provisional_create_canister_with_cycles.html">provisional_create_canister_with_cycles</a></li>
<li><a href="reference/management_canister/./provisional_top_up_canister.html">provisional_top_up_canister</a></li>
<li><a href="reference/management_canister/./raw_rand.html">raw_rand</a></li>
<li><a href="reference/management_canister/./sign_with_ecdsa.html">sign_with_ecdsa</a></li>
<li><a href="reference/management_canister/./start_canister.html">start_canister</a></li>
<li><a href="reference/management_canister/./stop_canister.html">stop_canister</a></li>
<li><a href="reference/management_canister/./uninstall_code.html">uninstall_code</a></li>
<li><a href="reference/management_canister/./update_settings.html">update_settings</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin_get_balance"><a class="header" href="#bitcoin_get_balance">bitcoin_get_balance</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, None, text, update } from 'azle/experimental';
import { managementCanister, Satoshi } from 'azle/canisters/management';

const BITCOIN_API_CYCLE_COST = 100_000_000n;

export default Canister({
    getBalance: update([text], Satoshi, async (address) =&gt; {
        return await ic.call(managementCanister.bitcoin_get_balance, {
            args: [
                {
                    address,
                    min_confirmations: None,
                    network: { Regtest: null }
                }
            ],
            cycles: BITCOIN_API_CYCLE_COST
        });
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin_get_current_fee_percentiles"><a class="header" href="#bitcoin_get_current_fee_percentiles">bitcoin_get_current_fee_percentiles</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, update, Vec } from 'azle/experimental';
import {
    managementCanister,
    MillisatoshiPerByte
} from 'azle/canisters/management';

const BITCOIN_API_CYCLE_COST = 100_000_000n;

export default Canister({
    getCurrentFeePercentiles: update([], Vec(MillisatoshiPerByte), async () =&gt; {
        return await ic.call(
            managementCanister.bitcoin_get_current_fee_percentiles,
            {
                args: [
                    {
                        network: { Regtest: null }
                    }
                ],
                cycles: BITCOIN_API_CYCLE_COST
            }
        );
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin_get_utxos"><a class="header" href="#bitcoin_get_utxos">bitcoin_get_utxos</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/bitcoin">bitcoin</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, None, text, update } from 'azle/experimental';
import { GetUtxosResult, managementCanister } from 'azle/canisters/management';

const BITCOIN_API_CYCLE_COST = 100_000_000n;

export default Canister({
    getUtxos: update([text], GetUtxosResult, async (address) =&gt; {
        return await ic.call(managementCanister.bitcoin_get_utxos, {
            args: [
                {
                    address,
                    filter: None,
                    network: { Regtest: null }
                }
            ],
            cycles: BITCOIN_API_CYCLE_COST
        });
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin_send_transaction"><a class="header" href="#bitcoin_send_transaction">bitcoin_send_transaction</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<pre><code class="language-typescript">import { blob, bool, Canister, ic, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

const BITCOIN_BASE_TRANSACTION_COST = 5_000_000_000n;
const BITCOIN_CYCLE_COST_PER_TRANSACTION_BYTE = 20_000_000n;

export default Canister({
    sendTransaction: update([blob], bool, async (transaction) =&gt; {
        const transactionFee =
            BITCOIN_BASE_TRANSACTION_COST +
            BigInt(transaction.length) *
                BITCOIN_CYCLE_COST_PER_TRANSACTION_BYTE;

        await ic.call(managementCanister.bitcoin_send_transaction, {
            args: [
                {
                    transaction,
                    network: { Regtest: null }
                }
            ],
            cycles: transactionFee
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canister_status"><a class="header" href="#canister_status">canister_status</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, update } from 'azle/experimental';
import {
    CanisterStatusArgs,
    CanisterStatusResult,
    managementCanister
} from 'azle/canisters/management';

export default Canister({
    getCanisterStatus: update(
        [CanisterStatusArgs],
        CanisterStatusResult,
        async (args) =&gt; {
            return await ic.call(managementCanister.canister_status, {
                args: [args]
            });
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create_canister"><a class="header" href="#create_canister">create_canister</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, None, update } from 'azle/experimental';
import {
    CreateCanisterResult,
    managementCanister
} from 'azle/canisters/management';

export default Canister({
    executeCreateCanister: update([], CreateCanisterResult, async () =&gt; {
        return await ic.call(managementCanister.create_canister, {
            args: [{ settings: None }],
            cycles: 50_000_000_000_000n
        });
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete_canister"><a class="header" href="#delete_canister">delete_canister</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeDeleteCanister: update([Principal], bool, async (canisterId) =&gt; {
        await ic.call(managementCanister.delete_canister, {
            args: [
                {
                    canister_id: canisterId
                }
            ]
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposit_cycles"><a class="header" href="#deposit_cycles">deposit_cycles</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeDepositCycles: update([Principal], bool, async (canisterId) =&gt; {
        await ic.call(managementCanister.deposit_cycles, {
            args: [
                {
                    canister_id: canisterId
                }
            ],
            cycles: 10_000_000n
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecdsa_public_key"><a class="header" href="#ecdsa_public_key">ecdsa_public_key</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, None, Record, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

const PublicKey = Record({
    publicKey: blob
});

export default Canister({
    publicKey: update([], PublicKey, async () =&gt; {
        const caller = ic.caller().toUint8Array();

        const publicKeyResult = await ic.call(
            managementCanister.ecdsa_public_key,
            {
                args: [
                    {
                        canister_id: None,
                        derivation_path: [caller],
                        key_id: {
                            curve: { secp256k1: null },
                            name: 'dfx_test_key'
                        }
                    }
                ]
            }
        );

        return {
            publicKey: publicKeyResult.public_key
        };
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http_request-2"><a class="header" href="#http_request-2">http_request</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/outgoing_http_requests">outgoing_http_requests</a></li>
</ul>
<pre><code class="language-typescript">import {
    Canister,
    ic,
    None,
    Principal,
    query,
    Some,
    update
} from 'azle/experimental';
import {
    HttpResponse,
    HttpTransformArgs,
    managementCanister
} from 'azle/canisters/management';

export default Canister({
    xkcd: update([], HttpResponse, async () =&gt; {
        return await ic.call(managementCanister.http_request, {
            args: [
                {
                    url: `https://xkcd.com/642/info.0.json`,
                    max_response_bytes: Some(2_000n),
                    method: {
                        get: null
                    },
                    headers: [],
                    body: None,
                    transform: Some({
                        function: [ic.id(), 'xkcdTransform'] as [
                            Principal,
                            string
                        ],
                        context: Uint8Array.from([])
                    })
                }
            ],
            cycles: 50_000_000n
        });
    }),
    xkcdTransform: query([HttpTransformArgs], HttpResponse, (args) =&gt; {
        return {
            ...args.response,
            headers: []
        };
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install_code"><a class="header" href="#install_code">install_code</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { blob, bool, Canister, ic, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeInstallCode: update(
        [Principal, blob],
        bool,
        async (canisterId, wasmModule) =&gt; {
            await ic.call(managementCanister.install_code, {
                args: [
                    {
                        mode: {
                            install: null
                        },
                        canister_id: canisterId,
                        wasm_module: wasmModule,
                        arg: Uint8Array.from([])
                    }
                ],
                cycles: 100_000_000_000n
            });

            return true;
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="provisional_create_canister_with_cycles"><a class="header" href="#provisional_create_canister_with_cycles">provisional_create_canister_with_cycles</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, None, update } from 'azle/experimental';
import {
    managementCanister,
    ProvisionalCreateCanisterWithCyclesResult
} from 'azle/canisters/management';

export default Canister({
    provisionalCreateCanisterWithCycles: update(
        [],
        ProvisionalCreateCanisterWithCyclesResult,
        async () =&gt; {
            return await ic.call(
                managementCanister.provisional_create_canister_with_cycles,
                {
                    args: [
                        {
                            amount: None,
                            settings: None
                        }
                    ]
                }
            );
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="provisional_top_up_canister"><a class="header" href="#provisional_top_up_canister">provisional_top_up_canister</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, nat, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    provisionalTopUpCanister: update(
        [Principal, nat],
        bool,
        async (canisterId, amount) =&gt; {
            await ic.call(managementCanister.provisional_top_up_canister, {
                args: [
                    {
                        canister_id: canisterId,
                        amount
                    }
                ]
            });

            return true;
        }
    )
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw_rand"><a class="header" href="#raw_rand">raw_rand</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/async_await">async/await</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/heartbeat">heartbeat</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">timers</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    getRawRand: update([], blob, async () =&gt; {
        return await ic.call(managementCanister.raw_rand);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sign_with_ecdsa"><a class="header" href="#sign_with_ecdsa">sign_with_ecdsa</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/threshold_ecdsa">threshold_ecdsa</a></li>
</ul>
<pre><code class="language-typescript">import { blob, Canister, ic, Record, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

const Signature = Record({
    signature: blob
});

export default Canister({
    sign: update([blob], Signature, async (messageHash) =&gt; {
        if (messageHash.length !== 32) {
            ic.trap('messageHash must be 32 bytes');
        }

        const caller = ic.caller().toUint8Array();

        const signatureResult = await ic.call(
            managementCanister.sign_with_ecdsa,
            {
                args: [
                    {
                        message_hash: messageHash,
                        derivation_path: [caller],
                        key_id: {
                            curve: { secp256k1: null },
                            name: 'dfx_test_key'
                        }
                    }
                ],
                cycles: 10_000_000_000n
            }
        );

        return {
            signature: signatureResult.signature
        };
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start_canister"><a class="header" href="#start_canister">start_canister</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeStartCanister: update([Principal], bool, async (canisterId) =&gt; {
        await ic.call(managementCanister.start_canister, {
            args: [
                {
                    canister_id: canisterId
                }
            ]
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stop_canister"><a class="header" href="#stop_canister">stop_canister</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeStopCanister: update([Principal], bool, async (canisterId) =&gt; {
        await ic.call(managementCanister.stop_canister, {
            args: [
                {
                    canister_id: canisterId
                }
            ]
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uninstall_code"><a class="header" href="#uninstall_code">uninstall_code</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import { bool, Canister, ic, Principal, update } from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeUninstallCode: update([Principal], bool, async (canisterId) =&gt; {
        await ic.call(managementCanister.uninstall_code, {
            args: [
                {
                    canister_id: canisterId
                }
            ]
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update_settings"><a class="header" href="#update_settings">update_settings</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/management_canister">management_canister</a></li>
</ul>
<pre><code class="language-typescript">import {
    bool,
    Canister,
    ic,
    None,
    Principal,
    Some,
    update
} from 'azle/experimental';
import { managementCanister } from 'azle/canisters/management';

export default Canister({
    executeUpdateSettings: update([Principal], bool, async (canisterId) =&gt; {
        await ic.call(managementCanister.update_settings, {
            args: [
                {
                    canister_id: canisterId,
                    settings: {
                        controllers: None,
                        compute_allocation: Some(1n),
                        memory_allocation: Some(3_000_000n),
                        freezing_threshold: Some(2_000_000n)
                    }
                }
            ]
        });

        return true;
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Azle plugins allow developers to wrap Rust code in TypeScript/JavaScript APIs that can then be exposed to Azle canisters, providing a clean and simple developer experience with the underlying Rust code.</p>
<p>Plugins are in a very early alpha state. You can create and use them now, but be aware that the API will be changing significantly in the near future.</p>
<p>You can use the following example plugins as you create your own plugins:</p>
<h2 id="local-plugin"><a class="header" href="#local-plugin">Local plugin</a></h2>
<p>If you just want to create a plugin in the same repo as your project, see <a href="https://github.com/demergent-labs/azle/tree/main/examples/plugins">the plugins example</a>.</p>
<h2 id="npm-plugin"><a class="header" href="#npm-plugin">npm plugin</a></h2>
<p>If you want to create a plugin that can be published and/or used with npm, see <a href="https://github.com/demergent-labs/ic-sqlite-plugin">the ic-sqlite-plugin example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stable-memory"><a class="header" href="#stable-memory">Stable Memory</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stable-structures-1"><a class="header" href="#stable-structures-1">stable structures</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/audio_recorder">audio_recorder</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/ethereum_json_rpc">ethereum_json_rpc</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/func_types">func_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/http_counter">http_counter</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/inline_types">inline_types</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/motoko_examples/persistent-storage">persistent-storage</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/pre_and_post_upgrade">pre_and_post_upgrade</a></li>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/stable_structures">stable_structures</a></li>
</ul>
<pre><code class="language-typescript">import {
    bool,
    Canister,
    nat64,
    nat8,
    Opt,
    query,
    StableBTreeMap,
    text,
    Tuple,
    update,
    Vec
} from 'azle/experimental';

const Key = nat8;
type Key = typeof Key.tsType;

const Value = text;
type Value = typeof Value.tsType;

let map = StableBTreeMap&lt;Key, Value&gt;(0);

export default Canister({
    containsKey: query([Key], bool, (key) =&gt; {
        return map.containsKey(key);
    }),

    get: query([Key], Opt(Value), (key) =&gt; {
        return map.get(key);
    }),

    insert: update([Key, Value], Opt(Value), (key, value) =&gt; {
        return map.insert(key, value);
    }),

    isEmpty: query([], bool, () =&gt; {
        return map.isEmpty();
    }),

    items: query([], Vec(Tuple(Key, Value)), () =&gt; {
        return map.items();
    }),

    keys: query([], Vec(Key), () =&gt; {
        return Uint8Array.from(map.keys());
    }),

    len: query([], nat64, () =&gt; {
        return map.len();
    }),

    remove: update([Key], Opt(Value), (key) =&gt; {
        return map.remove(key);
    }),

    values: query([], Vec(Value), () =&gt; {
        return map.values();
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-1"><a class="header" href="#timers-1">Timers</a></h1>
<ul>
<li><a href="reference/timers/./clear_timer.html">clear timer</a></li>
<li><a href="reference/timers/./set_timer.html">set timer</a></li>
<li><a href="reference/timers/./set_timer_interval.html">set timer interval</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clear-timer"><a class="header" href="#clear-timer">clear timer</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">timers</a></li>
</ul>
<pre><code class="language-typescript">import { Canister, ic, TimerId, update, Void } from 'azle/experimental';

export default Canister({
    clearTimer: update([TimerId], Void, (timerId) =&gt; {
        ic.clearTimer(timerId);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-timer"><a class="header" href="#set-timer">set timer</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">timers</a></li>
</ul>
<pre><code class="language-typescript">import {
    Canister,
    Duration,
    ic,
    TimerId,
    Tuple,
    update
} from 'azle/experimental';

export default Canister({
    setTimers: update([Duration], Tuple(TimerId, TimerId), (delay) =&gt; {
        const functionTimerId = ic.setTimer(delay, callback);

        const capturedValue = '🚩';

        const closureTimerId = ic.setTimer(delay, () =&gt; {
            console.log(`closure called and captured value ${capturedValue}`);
        });

        return [functionTimerId, closureTimerId];
    })
});

function callback() {
    console.log('callback called');
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-timer-interval"><a class="header" href="#set-timer-interval">set timer interval</a></h1>
<p>This section is a work in progress.</p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/demergent-labs/azle/tree/main/examples/timers">timers</a></li>
</ul>
<pre><code class="language-typescript">import {
    Canister,
    Duration,
    ic,
    TimerId,
    Tuple,
    update
} from 'azle/experimental';

export default Canister({
    setTimerIntervals: update(
        [Duration],
        Tuple(TimerId, TimerId),
        (interval) =&gt; {
            const functionTimerId = ic.setTimerInterval(interval, callback);

            const capturedValue = '🚩';

            const closureTimerId = ic.setTimerInterval(interval, () =&gt; {
                console.log(
                    `closure called and captured value ${capturedValue}`
                );
            });

            return [functionTimerId, closureTimerId];
        }
    )
});

function callback() {
    console.log('callback called');
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
